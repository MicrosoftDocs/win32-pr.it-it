---
title: Rasterizzazione conservativa Direct3D 12
description: La rasterizzazione conservativa aggiunge una certa certezza al rendering in pixel, che risulta utile in particolare per gli algoritmi di rilevamento dei conflitti.
ms.assetid: 081199AD-1702-4EC8-95AD-B1148C676199
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4e4fae3489d54ab7b6b7abfda56f54dd8d970962
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548899"
---
# <a name="direct3d-12-conservative-rasterization"></a><span data-ttu-id="6abfd-103">Rasterizzazione conservativa Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="6abfd-103">Direct3D 12 Conservative Rasterization</span></span>

<span data-ttu-id="6abfd-104">La rasterizzazione conservativa aggiunge una certa certezza al rendering in pixel, che risulta utile in particolare per gli algoritmi di rilevamento dei conflitti.</span><span class="sxs-lookup"><span data-stu-id="6abfd-104">Conservative Rasterization adds some certainty to pixel rendering, which is helpful in particular to collision detection algorithms.</span></span>

-   [<span data-ttu-id="6abfd-105">Overview</span><span class="sxs-lookup"><span data-stu-id="6abfd-105">Overview</span></span>](#overview)
-   [<span data-ttu-id="6abfd-106">Interazioni con la pipeline</span><span class="sxs-lookup"><span data-stu-id="6abfd-106">Interactions with the pipeline</span></span>](#interactions-with-the-pipeline)
    -   [<span data-ttu-id="6abfd-107">Interazione tra regole di rasterizzazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-107">Rasterization Rules interaction</span></span>](#rasterization-rules-interaction)
    -   [<span data-ttu-id="6abfd-108">Interazione multicampionamento</span><span class="sxs-lookup"><span data-stu-id="6abfd-108">Multisampling interaction</span></span>](#multisampling-interaction)
    -   [<span data-ttu-id="6abfd-109">Interazione SampleMask</span><span class="sxs-lookup"><span data-stu-id="6abfd-109">SampleMask interaction</span></span>](#samplemask-interaction)
    -   [<span data-ttu-id="6abfd-110">Interazione test profondità/stencil</span><span class="sxs-lookup"><span data-stu-id="6abfd-110">Depth/Stencil Test interaction</span></span>](#depthstencil-test-interaction)
    -   [<span data-ttu-id="6abfd-111">Interazione con i pixel Helper</span><span class="sxs-lookup"><span data-stu-id="6abfd-111">Helper Pixel interaction</span></span>](#helper-pixel-interaction)
    -   [<span data-ttu-id="6abfd-112">Interazione di code coverage output</span><span class="sxs-lookup"><span data-stu-id="6abfd-112">Output Coverage interaction</span></span>](#output-coverage-interaction)
    -   [<span data-ttu-id="6abfd-113">Interazione InputCoverage</span><span class="sxs-lookup"><span data-stu-id="6abfd-113">InputCoverage interaction</span></span>](#inputcoverage-interaction)
    -   [<span data-ttu-id="6abfd-114">Interazione InnerCoverage</span><span class="sxs-lookup"><span data-stu-id="6abfd-114">InnerCoverage interaction</span></span>](#innercoverage-interaction)
    -   [<span data-ttu-id="6abfd-115">Interazione con l'interpolazione degli attributi</span><span class="sxs-lookup"><span data-stu-id="6abfd-115">Attribute Interpolation interaction</span></span>](#attribute-interpolation-interaction)
    -   [<span data-ttu-id="6abfd-116">Interazione di ritaglio</span><span class="sxs-lookup"><span data-stu-id="6abfd-116">Clipping interaction</span></span>](#clipping-interaction)
    -   [<span data-ttu-id="6abfd-117">Interazione della distanza tra clip</span><span class="sxs-lookup"><span data-stu-id="6abfd-117">Clip Distance interaction</span></span>](#clip-distance-interaction)
    -   [<span data-ttu-id="6abfd-118">Interazione di rasterizzazione indipendente di destinazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-118">Target Independent Rasterization interaction</span></span>](#target-independent-rasterization-interaction)
    -   [<span data-ttu-id="6abfd-119">Interazione della topologia primitiva IA</span><span class="sxs-lookup"><span data-stu-id="6abfd-119">IA Primitive Topology interaction</span></span>](#ia-primitive-topology-interaction)
    -   [<span data-ttu-id="6abfd-120">Interazione tra query</span><span class="sxs-lookup"><span data-stu-id="6abfd-120">Query interaction</span></span>](#query-interaction)
    -   [<span data-ttu-id="6abfd-121">Interazione stato di eliminazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-121">Cull State interaction</span></span>](#cull-state-interaction)
    -   [<span data-ttu-id="6abfd-122">Interazione IsFrontFace</span><span class="sxs-lookup"><span data-stu-id="6abfd-122">IsFrontFace interaction</span></span>](#isfrontface-interaction)
    -   [<span data-ttu-id="6abfd-123">Interazione modalità di riempimento</span><span class="sxs-lookup"><span data-stu-id="6abfd-123">Fill Modes interaction</span></span>](#fill-modes-interaction)
-   [<span data-ttu-id="6abfd-124">Dettagli di implementazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-124">Implementation details</span></span>](#implementation-details)
-   [<span data-ttu-id="6abfd-125">Riepilogo API</span><span class="sxs-lookup"><span data-stu-id="6abfd-125">API summary</span></span>](#api-summary)
-   [<span data-ttu-id="6abfd-126">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="6abfd-126">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="6abfd-127">Panoramica</span><span class="sxs-lookup"><span data-stu-id="6abfd-127">Overview</span></span>

<span data-ttu-id="6abfd-128">La rasterizzazione conservativa indica che tutti i pixel almeno parzialmente coperti da una primitiva sottoposta a rendering vengono rasterizzati, il che significa che il pixel shader viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-128">Conservative Rasterization means that all pixels that are at least partially covered by a rendered primitive are rasterized, which means that the pixel shader is invoked.</span></span> <span data-ttu-id="6abfd-129">Il comportamento normale è il campionamento, che non viene usato se è abilitata la rasterizzazione conservativa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-129">Normal behavior is sampling, which is not used if Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="6abfd-130">La rasterizzazione conservativa è utile in diverse situazioni, tra cui la certezza del rilevamento dei conflitti, l'abbattimento dell'occlusione e il rendering affiancato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-130">Conservative Rasterization is useful in a number of situations, including for certainty in collision detection, occlusion culling, and tiled rendering.</span></span>

<span data-ttu-id="6abfd-131">Ad esempio, la figura seguente mostra un triangolo verde sottoposto a rendering usando la rasterizzazione conservativa, così come verrebbe visualizzato nel rasterizzatore (ovvero usando le coordinate del vertice a virgola fissa 16,8).</span><span class="sxs-lookup"><span data-stu-id="6abfd-131">For example, the following figure shows a green triangle rendered using Conservative Rasterization, as it would appear in the rasterizer (that is, using 16.8 fixed point vertex coordinates).</span></span> <span data-ttu-id="6abfd-132">L'area marrone è nota come "area di incertezza", un'area concettuale che rappresenta i limiti estesi del triangolo, necessari per garantire che la primitiva nell'rasterizzatore sia conservativa rispetto alle coordinate iniziali del vertice a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="6abfd-132">The brown area is known as an "uncertainty region" - a conceptual region that represents the extended bounds of the triangle, required to ensure the primitive in the rasterizer is conservative with respect to the original floating point vertex coordinates.</span></span> <span data-ttu-id="6abfd-133">I quadratini rossi in ogni vertice mostrano come viene calcolata l'area di incertezza: come un quadrato con sweep.</span><span class="sxs-lookup"><span data-stu-id="6abfd-133">The red squares at each vertex shows how the uncertainty region is calculated: as a swept square.</span></span>

<span data-ttu-id="6abfd-134">I quadrati grigi di grandi dimensioni mostrano i pixel di cui verrà eseguito il rendering.</span><span class="sxs-lookup"><span data-stu-id="6abfd-134">The large gray squares show the pixels that will be rendered.</span></span> <span data-ttu-id="6abfd-135">I quadrati rosa mostrano i pixel sottoposti a rendering usando la regola in alto a sinistra, che entra in gioco quando il bordo del triangolo supera il bordo dei pixel.</span><span class="sxs-lookup"><span data-stu-id="6abfd-135">The pink squares show pixels rendered using the "Top-Left Rule", which comes into play as the edge of the triangle crosses the edge of the pixels.</span></span> <span data-ttu-id="6abfd-136">È possibile che siano presenti falsi positivi (pixel impostati che non dovrebbero essere stati), che verranno normalmente rimosse dal sistema, ma non sempre.</span><span class="sxs-lookup"><span data-stu-id="6abfd-136">There can be false positives (pixels set that should not have been) which the system will normally but not always cull.</span></span>

![regola in alto a sinistra](images/conservative-rasterization-0.png)

## <a name="interactions-with-the-pipeline"></a><span data-ttu-id="6abfd-138">Interazioni con la pipeline</span><span class="sxs-lookup"><span data-stu-id="6abfd-138">Interactions with the pipeline</span></span>

### <a name="rasterization-rules-interaction"></a><span data-ttu-id="6abfd-139">Interazione tra regole di rasterizzazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-139">Rasterization Rules interaction</span></span>

<span data-ttu-id="6abfd-140">In modalità di rasterizzazione conservativa, le regole di rasterizzazione si applicano allo stesso modo di quando la modalità di rasterizzazione conservativa non è abilitata con le eccezioni per la regola di Top-Left, descritta sopra e la copertura dei pixel.</span><span class="sxs-lookup"><span data-stu-id="6abfd-140">In Conservative Rasterization mode, Rasterization Rules apply the same way as when Conservative Rasterization mode is not enabled with exceptions for the Top-Left Rule, described above, and Pixel Coverage.</span></span> <span data-ttu-id="6abfd-141">16,8 Fixed-Point è necessario utilizzare la precisione del rasterizzatore.</span><span class="sxs-lookup"><span data-stu-id="6abfd-141">16.8 Fixed-Point Rasterizer precision must be used.</span></span>

<span data-ttu-id="6abfd-142">Pixel che non verrebbero analizzati se l'hardware utilizzava le coordinate dei vertici a virgola mobile complete può essere incluso solo se si trovano all'interno di un'area di incertezza non superiore a metà di un pixel nel dominio a virgola fissa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-142">Pixels that would not be covered if hardware was using full floating point vertex coordinates may only be included if they are within an uncertainty region no larger half a pixel in the fixed point domain.</span></span> <span data-ttu-id="6abfd-143">Si prevede che l'hardware futuro raggiunga l'area di incertezza ristretta specificata nel livello 2.</span><span class="sxs-lookup"><span data-stu-id="6abfd-143">Future hardware is expected to reach the tightened uncertainty region specified in Tier 2.</span></span> <span data-ttu-id="6abfd-144">Si noti che questo requisito impedisce che i triangoli dei nastri si estendano ulteriormente rispetto al necessario.</span><span class="sxs-lookup"><span data-stu-id="6abfd-144">Note that this requirement prevents sliver triangles from extending further than necessary.</span></span>

<span data-ttu-id="6abfd-145">Si applica anche un'area di incertezza valida simile `InnerCoverage` , ma è più stretta perché nessuna implementazione richiede un'area di incertezza maggiore per questo caso.</span><span class="sxs-lookup"><span data-stu-id="6abfd-145">A similar valid uncertainty region applies to `InnerCoverage` as well, but it is tighter since no implementations require a larger uncertainty region for this case.</span></span> <span data-ttu-id="6abfd-146">Per altri dettagli, vedere [interazione con InnerCoverage](#innercoverage-interaction) .</span><span class="sxs-lookup"><span data-stu-id="6abfd-146">See [InnerCoverage interaction](#innercoverage-interaction) for more detail.</span></span>

<span data-ttu-id="6abfd-147">Le aree di incertezza interna ed esterna devono essere maggiori o uguali alla metà della griglia dei sottopixel, ovvero 1/512 di un pixel, nel dominio a virgola fissa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-147">Inner and outer uncertainty regions must be greater than or equal to the size of half the sub-pixel grid, or 1/512 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="6abfd-148">Questa è l'area minima di incertezza valida.</span><span class="sxs-lookup"><span data-stu-id="6abfd-148">This is the minimum valid uncertainty region.</span></span> <span data-ttu-id="6abfd-149">1/512 deriva dalla rappresentazione della coordinata di rasterizzazione dei punti fissi 16,8 e dalla regola round-to-più vicina che si applica quando si convertono le coordinate dei vertici a virgola mobile in 16,8 Coordinate di punti fisse</span><span class="sxs-lookup"><span data-stu-id="6abfd-149">1/512 comes from the 16.8 fixed point Rasterizer coordinate representation and the round-to-nearest rule that applies when converting floating point vertex coordinates to 16.8 fixed point coordinates.</span></span> <span data-ttu-id="6abfd-150">1/512 può cambiare se la precisione del rasterizzatore viene modificata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-150">1/512 can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="6abfd-151">Se un'implementazione implementa questa area minima di incertezza, devono seguire la regola Top-Left quando un bordo o un angolo dell'area di incertezza cade lungo il bordo o l'angolo di un pixel.</span><span class="sxs-lookup"><span data-stu-id="6abfd-151">If an implementation implements this minimum uncertainty region, then they must follow the Top-Left Rule when an edge or corner of the uncertainty region falls along the edge or corner of a pixel.</span></span> <span data-ttu-id="6abfd-152">I bordi ritagliati dell'area di incertezza devono essere considerati come il vertice più vicino, vale a dire che vengono conteggiati come due bordi, ovvero i due che si uniscono al vertice associato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-152">The clipped edges of the uncertainty region should be treated as the closest vertex, meaning that it counts as two edges: the two that join at the associated vertex.</span></span> <span data-ttu-id="6abfd-153">Top-Left regola è obbligatoria quando viene utilizzata l'area di incertezza minima. in caso contrario, un'implementazione di rasterizzazione conservativa non riuscirà a rasterizzare i pixel che potrebbero essere coperti quando la modalità di rasterizzazione conservativa è disabilitata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-153">Top-Left Rule is required when the minimum uncertainty region is used because if it is not, then a Conservative Rasterization implementation would fail to rasterize pixels that could be covered when Conservative Rasterization mode is disabled.</span></span>

<span data-ttu-id="6abfd-154">Il diagramma seguente illustra un'area di incertezza esterna valida prodotta dalla sweep di un quadrato intorno ai bordi della primitiva nel dominio a virgola fissa, ovvero i vertici sono stati quantizzati dalla rappresentazione a virgola fissa 16,8.</span><span class="sxs-lookup"><span data-stu-id="6abfd-154">The following diagram illustrates a valid outer uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="6abfd-155">Le dimensioni di questo quadrato sono basate sulle dimensioni della regione di incertezza esterna valide: per 1/2 di un pixel, il quadrato è di 1 pixel in larghezza e altezza, per 1/512 di un pixel, il quadrato è 1/256 di un pixel in larghezza e altezza.</span><span class="sxs-lookup"><span data-stu-id="6abfd-155">The dimensions of this square are based on the valid outer uncertainty region size: for the 1/2 of a pixel, the square is 1 pixel in width and height, for 1/512 of a pixel, the square is 1/256 of a pixel in width and height.</span></span> <span data-ttu-id="6abfd-156">Il triangolo verde rappresenta una determinata primitiva, la linea rossa tratteggiata rappresenta il limite di rasterizzazione conservativa sovrastimata, i quadrati neri solidi rappresentano il quadrato che viene trascinato lungo i bordi primitivi e l'area a scacchi blu è l'area di incertezza esterna:</span><span class="sxs-lookup"><span data-stu-id="6abfd-156">The green triangle represents a given primitive, the red dotted line represents the bound on Overestimated Conservative Rasterization, the solid black squares represent the square that is swept along the primitive edges, and the blue checkered area is the outer uncertainty region:</span></span>

![area di incertezza esterna.](images/outercoverage.jpg)

### <a name="multisampling-interaction"></a><span data-ttu-id="6abfd-158">Interazione multicampionamento</span><span class="sxs-lookup"><span data-stu-id="6abfd-158">Multisampling interaction</span></span>

<span data-ttu-id="6abfd-159">Indipendentemente dal numero di campioni nelle superfici **renderTarget** / **DepthStencil** (o se *ForcedSampleCount* viene usato o meno), tutti gli esempi vengono analizzati per i pixel rasterizzati dalla rasterizzazione conservativa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-159">Regardless of the number of samples in **RenderTarget**/**DepthStencil** surfaces (or whether *ForcedSampleCount* is being used or not), all samples are covered for pixels rasterized by Conservative Rasterization.</span></span> <span data-ttu-id="6abfd-160">I singoli percorsi di esempio non vengono verificati se rientrano nella primitiva o meno.</span><span class="sxs-lookup"><span data-stu-id="6abfd-160">Individual sample locations are not tested for whether they fall in the primitive or not.</span></span>

### <a name="samplemask-interaction"></a><span data-ttu-id="6abfd-161">Interazione SampleMask</span><span class="sxs-lookup"><span data-stu-id="6abfd-161">SampleMask interaction</span></span>

<span data-ttu-id="6abfd-162">Lo stato di rasterizzazione *SampleMask* viene applicato allo stesso modo di quando la rasterizzazione conservativa non è abilitata per `InputCoverage` , ma non ha alcun effetto, `InnerCoverage` ovvero non è unire con and in un input dichiarato con `InnerCoverage` .</span><span class="sxs-lookup"><span data-stu-id="6abfd-162">The *SampleMask* Rasterizer State applies the same way as when Conservative Rasterization is not enabled for `InputCoverage`, but does not affect `InnerCoverage` (i.e. it is not AND’ed into an input declared with `InnerCoverage`).</span></span> <span data-ttu-id="6abfd-163">Ciò è dovuto `InnerCoverage` al fatto che non è correlato al fatto che gli esempi MSAA siano mascherati: 0 `InnerCoverage` significa solo che non è garantito che il pixel sia completamente coperto, non che nessun campione verrà aggiornato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-163">This is because `InnerCoverage` is unrelated to whether MSAA samples are masked out: 0 `InnerCoverage` only means that the pixel is not guaranteed to be fully covered, not that no samples will be updated.</span></span>

### <a name="depthstencil-test-interaction"></a><span data-ttu-id="6abfd-164">Interazione test profondità/stencil</span><span class="sxs-lookup"><span data-stu-id="6abfd-164">Depth/Stencil Test interaction</span></span>

<span data-ttu-id="6abfd-165">I test depth/stencil procedono per un pixel con rasterizzazione conservativa nello stesso modo in cui vengono analizzati tutti i campioni quando la rasterizzazione conservativa non è abilitata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-165">Depth/Stencil Testing proceeds for a conservatively rasterized pixel the same way as if all samples are covered when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="6abfd-166">L'esecuzione di tutti gli esempi analizzati può causare un'estrapolazione della profondità, che è valida e deve essere fissata al viewport come specificato quando la rasterizzazione conservativa non è abilitata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-166">Proceeding with all samples covered can cause Depth Extrapolation, which is valid and must be clamped to the viewport as specified when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="6abfd-167">Questa operazione è simile a quando si utilizzano le modalità di interpolazione con frequenza pixel in un **renderTarget** con numero campione maggiore di 1, anche se nel caso della rasterizzazione conservativa, si tratta del valore di profondità nel test di profondità della funzione fisso che può essere estrapolato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-167">This is similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1, although in the case of Conservative Rasterization, it is the depth value going into the fixed function depth test that can be extrapolated.</span></span>

<span data-ttu-id="6abfd-168">Il comportamento di eliminazione anticipata con l'estrapolazione della profondità non è definito.</span><span class="sxs-lookup"><span data-stu-id="6abfd-168">Early Depth culling behavior with Depth Extrapolation is undefined.</span></span> <span data-ttu-id="6abfd-169">Questo è dovuto al fatto che alcuni componenti iniziali di abbandono di profondità non supportano correttamente i valori di profondità estrapolati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-169">This is because some Early Depth culling hardware cannot properly support extrapolated depth values.</span></span> <span data-ttu-id="6abfd-170">Tuttavia, il comportamento di eliminazione anticipata della profondità in presenza di un'estrapolazione approfondita è problematico anche con l'hardware che può supportare i valori di profondità estrapolati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-170">However, Early Depth culling behavior in the presence of Depth Extrapolation is problematic even with hardware that can support extrapolated depth values.</span></span> <span data-ttu-id="6abfd-171">Per risolvere il problema, è possibile bloccare la profondità di input del pixel shader sui valori di profondità minima e massima della primitiva da rasterizzare e scrivere tale valore `oDepth` (il registro di profondità dell'output pixel shader).</span><span class="sxs-lookup"><span data-stu-id="6abfd-171">This issue can be worked around by clamping the Pixel Shader input depth to the min and max depth values of the primitive being rasterized and writing that value to `oDepth` (the pixel shader output depth register).</span></span> <span data-ttu-id="6abfd-172">Le implementazioni sono necessarie per disabilitare l'eliminazione anticipata della profondità in questo caso, a causa della `oDepth` scrittura.</span><span class="sxs-lookup"><span data-stu-id="6abfd-172">Implementations are required to disable Early Depth culling in this case, due to the `oDepth` write.</span></span>

### <a name="helper-pixel-interaction"></a><span data-ttu-id="6abfd-173">Interazione con i pixel Helper</span><span class="sxs-lookup"><span data-stu-id="6abfd-173">Helper Pixel interaction</span></span>

<span data-ttu-id="6abfd-174">Le regole dei pixel Helper si applicano allo stesso modo di quando la rasterizzazione conservativa non è abilitata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-174">Helper Pixel rules apply the same way as when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="6abfd-175">Come parte di questa operazione, tutti i pixel, inclusi i pixel helper, devono essere segnalati `InputCoverage` in modo accurato come specificato nella `InputCoverage` sezione interazione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-175">As part of this, all pixels including Helper Pixels must report `InputCoverage` accurately as specified in the `InputCoverage` interaction section.</span></span> <span data-ttu-id="6abfd-176">Il code coverage 0 del report di pixel è completamente non coperto.</span><span class="sxs-lookup"><span data-stu-id="6abfd-176">So fully non-covered pixels report 0 coverage.</span></span>

### <a name="output-coverage-interaction"></a><span data-ttu-id="6abfd-177">Interazione di code coverage output</span><span class="sxs-lookup"><span data-stu-id="6abfd-177">Output Coverage interaction</span></span>

<span data-ttu-id="6abfd-178">Il code coverage di output ( `oMask` ) si comporta per un pixel con rasterizzazione conservata, come avviene quando la rasterizzazione conservativa non è abilitata con tutti gli esempi analizzati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-178">Output Coverage (`oMask`) behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

### <a name="inputcoverage-interaction"></a><span data-ttu-id="6abfd-179">Interazione InputCoverage</span><span class="sxs-lookup"><span data-stu-id="6abfd-179">InputCoverage interaction</span></span>

<span data-ttu-id="6abfd-180">In modalità di rasterizzazione conservativa, questo registro di input viene popolato come se tutti i campioni venissero analizzati quando la rasterizzazione conservativa non è abilitata per un determinato pixel rasterizzato in modo conservativo.</span><span class="sxs-lookup"><span data-stu-id="6abfd-180">In Conservative Rasterization mode, this input register is populated as if all samples are covered when Conservative Rasterization is not enabled for a given conservatively rasterized pixel.</span></span> <span data-ttu-id="6abfd-181">Ovvero, vengono applicate tutte le interazioni esistenti (ad esempio, *SampleMask* ) e i primi n bit in `InputCoverage` da LSB vengono impostati su 1 per un pixel rasterizzato in modo conservativo, dato un campione n per pixel **renderTarget** e/o un buffer **DepthStencil** associato alla fusione di **output** oppure un *ForcedSampleCount* n di esempio.</span><span class="sxs-lookup"><span data-stu-id="6abfd-181">That is to say, all existing interactions apply (e.g. *SampleMask* is applied), and the first n bits in `InputCoverage` from the LSB are set to 1 for a conservatively rasterized pixel, given an n sample per pixel **RenderTarget** and/or **DepthStencil** buffer bound at the **Output Merger**, or an n sample *ForcedSampleCount*.</span></span> <span data-ttu-id="6abfd-182">Il resto dei bit è 0.</span><span class="sxs-lookup"><span data-stu-id="6abfd-182">The rest of the bits are 0.</span></span>

<span data-ttu-id="6abfd-183">Questo input è disponibile in uno shader indipendentemente dall'uso della rasterizzazione conservativa, sebbene la rasterizzazione conservativa modifichi il comportamento in modo da visualizzare solo tutti gli esempi analizzati (o nessuno per i pixel Helper).</span><span class="sxs-lookup"><span data-stu-id="6abfd-183">This input is available in a shader regardless of the use of Conservative Rasterization, though Conservative Rasterization changes its behavior to only show all samples covered (or none for Helper Pixels).</span></span>

### <a name="innercoverage-interaction"></a><span data-ttu-id="6abfd-184">Interazione InnerCoverage</span><span class="sxs-lookup"><span data-stu-id="6abfd-184">InnerCoverage interaction</span></span>

<span data-ttu-id="6abfd-185">Questa funzionalità è richiesta da e disponibile solo in, livello 3.</span><span class="sxs-lookup"><span data-stu-id="6abfd-185">This feature is required by, and only available in, Tier 3.</span></span> <span data-ttu-id="6abfd-186">Il runtime non riuscirà a creare shader per gli shader che usano questa modalità quando un'implementazione supporta un livello inferiore al livello 3.</span><span class="sxs-lookup"><span data-stu-id="6abfd-186">The runtime will fail shader creation for shaders that use this mode when an implementation supports a Tier less than Tier 3.</span></span>

<span data-ttu-id="6abfd-187">Il pixel shader ha un valore scalare Integer a 32 bit per generare un valore disponibile: `InnerCoverage` .</span><span class="sxs-lookup"><span data-stu-id="6abfd-187">The Pixel Shader has a 32-bit scalar integer System Generate Value available: `InnerCoverage`.</span></span> <span data-ttu-id="6abfd-188">Si tratta di un campo di bit con bit 0 da LSB impostato su 1 per un determinato pixel rasterizzato in modo conservativo, solo quando tale pixel è garantito interamente all'interno della primitiva corrente.</span><span class="sxs-lookup"><span data-stu-id="6abfd-188">This is a bit-field that has bit 0 from the LSB set to 1 for a given conservatively rasterized pixel, only when that pixel is guaranteed to be entirely inside the current primitive.</span></span> <span data-ttu-id="6abfd-189">Tutti gli altri bit del registro di input devono essere impostati su 0 quando il bit 0 non è impostato, ma non definiti quando il bit 0 è impostato su 1 (essenzialmente, questo campo di bit rappresenta un valore booleano dove false deve essere esattamente 0, ma true può essere qualsiasi valore diverso da zero (ad esempio, set di bit 0).</span><span class="sxs-lookup"><span data-stu-id="6abfd-189">All other input register bits must be set to 0 when bit 0 is not set, but are undefined when bit 0 is set to 1 (essentially, this bit-field represents a Boolean value where false must be exactly 0, but true can be any odd (i.e. bit 0 set) non-zero value).</span></span> <span data-ttu-id="6abfd-190">Questo input viene usato per le informazioni di rasterizzazione conservative sottostimate.</span><span class="sxs-lookup"><span data-stu-id="6abfd-190">This input is used for underestimated Conservative Rasterization information.</span></span> <span data-ttu-id="6abfd-191">Informa il pixel shader se il pixel corrente è completamente all'interno della geometria.</span><span class="sxs-lookup"><span data-stu-id="6abfd-191">It informs the Pixel Shader whether the current pixel lies completely inside the geometry.</span></span>

<span data-ttu-id="6abfd-192">Questo deve tenere conto dell'errore di blocco alle risoluzioni maggiori o uguali alla risoluzione in cui il progetto corrente sta operando.</span><span class="sxs-lookup"><span data-stu-id="6abfd-192">This must account for snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating.</span></span> <span data-ttu-id="6abfd-193">Non devono essere presenti falsi positivi (impostazione `InnerCoverage` bits quando il pixel non è completamente coperto per eventuali errori di blocco a risoluzione maggiori o uguali alla risoluzione in cui è in esecuzione il progetto corrente), ma sono consentiti falsi negativi.</span><span class="sxs-lookup"><span data-stu-id="6abfd-193">There must not be false positives (setting `InnerCoverage` bits when the pixel is not fully covered for any snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating), but false negatives are allowed.</span></span> <span data-ttu-id="6abfd-194">In breve, l'implementazione non deve identificare erroneamente i pixel come completamente analizzati e non con coordinate del vertice a virgola mobile complete nel rasterizzatore.</span><span class="sxs-lookup"><span data-stu-id="6abfd-194">In summary, the implementation must not incorrectly identify pixels as fully covered that would not be with full floating point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="6abfd-195">Pixel che verrebbero completamente analizzati se l'hardware utilizzava coordinate del vertice a virgola mobile complete può essere omesso solo se intersecano l'area di incertezza interna, che non deve essere maggiore della dimensione della griglia dei sottopixel, o 1/256 di un pixel, nel dominio a virgola fissa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-195">Pixels that would be fully covered if hardware was using full floating point vertex coordinates may only be omitted if they intersect the inner uncertainty region, which must be no larger than the size of the sub-pixel grid, or 1/256 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="6abfd-196">Detto un altro modo, i pixel interamente all'interno del limite interno dell'area di incertezza interna devono essere contrassegnati come completamente analizzati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-196">Said another way, pixels entirely within the inner boundary of the inner uncertainty region must be marked as fully covered.</span></span> <span data-ttu-id="6abfd-197">Il limite interno dell'area di incertezza è illustrato nel diagramma seguente dalla linea di colore nero in grassetto.</span><span class="sxs-lookup"><span data-stu-id="6abfd-197">The inner boundary of the uncertainty region is illustrated in the diagram below by the bold black dotted line.</span></span> <span data-ttu-id="6abfd-198">1/256 deriva dalla rappresentazione della coordinata del rasterizzatore dei punti fissi 16,8, che può cambiare se la precisione del rasterizzatore viene modificata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-198">1/256 comes from the 16.8 fixed point Rasterizer coordinate representation, which can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="6abfd-199">Questa area di incertezza è sufficiente per tenere conto dell'errore di blocco causato dalla conversione delle coordinate dei vertici a virgola mobile in coordinate del vertice a virgola fissa nel rasterizzatore.</span><span class="sxs-lookup"><span data-stu-id="6abfd-199">This uncertainty region is enough to account for snapping error caused by the conversion of floating point vertex coordinates to fixed point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="6abfd-200">Gli stessi requisiti di area minima di incertezza 1/512 definiti nell'interazione delle regole di rasterizzazione si applicano anche qui.</span><span class="sxs-lookup"><span data-stu-id="6abfd-200">The same 1/512 minimum uncertainty region requirements defined in Rasterization Rules interaction apply here as well.</span></span>

<span data-ttu-id="6abfd-201">Il diagramma seguente illustra un'area di incertezza interna valida prodotta dalla sweep di un quadrato intorno ai bordi della primitiva nel dominio a virgola fissa, ovvero i vertici sono stati quantizzati dalla rappresentazione a virgola fissa 16,8.</span><span class="sxs-lookup"><span data-stu-id="6abfd-201">The following diagram illustrates a valid inner uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="6abfd-202">Le dimensioni di questo quadrato sono basate sulle dimensioni della regione di incertezza interna valide: per 1/256 di un pixel, il quadrato è 1/128 di un pixel in larghezza e altezza.</span><span class="sxs-lookup"><span data-stu-id="6abfd-202">The dimensions of this square are based on the valid inner uncertainty region size: for 1/256 of a pixel, the square is 1/128 of a pixel in width and height.</span></span> <span data-ttu-id="6abfd-203">Il triangolo verde rappresenta una primitiva, la linea punteggiata nera rappresenta il limite dell'area di incertezza interna, i quadrati neri a tinta unita rappresentano il quadrato che viene trascinato lungo i bordi primitivi e l'area a scacchi arancione è l'area di incertezza interna:</span><span class="sxs-lookup"><span data-stu-id="6abfd-203">The green triangle represents a given primitive, the bold black dotted line represents the boundary of the inner uncertainty region, the solid black squares represent the square that is swept along the primitive edges, and the orange checkered area is the inner uncertainty region:</span></span>

![reqion di incertezza interna.](images/innercoverage.jpg)

<span data-ttu-id="6abfd-205">L'uso di `InnerCoverage` non influisce sul fatto che un pixel venga rasterizzato in modo prudenziale, ovvero l'uso di una di queste `InputCoverage` modalità non influisce sui pixel che vengono rasterizzati quando è abilitata la modalità di rasterizzazione conservativa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-205">The use of `InnerCoverage` does not affect whether a pixel is conservatively rasterized, i.e. using one of these `InputCoverage` modes does not affect which pixels are rasterized when Conservative Rasterization mode is enabled.</span></span> <span data-ttu-id="6abfd-206">Pertanto, quando `InnerCoverage` si usa e il pixel shader sta elaborando un pixel che non è completamente coperto dalla geometria, il valore sarà 0, ma la chiamata al pixel shader avrà esempi aggiornati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-206">Therefore, when `InnerCoverage` is used and the Pixel Shader is processing a pixel that is not completely covered by the geometry its value will be 0, but the Pixel Shader invocation will have samples updated.</span></span> <span data-ttu-id="6abfd-207">Si tratta di un valore diverso da quando `InputCoverage` è 0, pertanto non verrà aggiornato alcun campione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-207">This is different from when `InputCoverage` is 0, meaning that no samples will be updated.</span></span>

<span data-ttu-id="6abfd-208">Questo input si escludono a vicenda `InputCoverage` : non è possibile usare entrambi.</span><span class="sxs-lookup"><span data-stu-id="6abfd-208">This input is mutually exclusive with `InputCoverage` : both cannot be used.</span></span>

<span data-ttu-id="6abfd-209">Per accedere a `InnerCoverage` , è necessario dichiararlo come un singolo componente da uno dei registri di input del pixel shader.</span><span class="sxs-lookup"><span data-stu-id="6abfd-209">To access `InnerCoverage`, it must be declared as a single component out of one of the Pixel Shader input registers.</span></span> <span data-ttu-id="6abfd-210">La modalità di interpolazione nella dichiarazione deve essere costante (l'interpolazione non è applicabile).</span><span class="sxs-lookup"><span data-stu-id="6abfd-210">The interpolation mode on the declaration must be constant (interpolation does not apply).</span></span>

<span data-ttu-id="6abfd-211">Il `InnerCoverage` campo di bit non è influenzato da test depth/stencil, né individuato con lo stato di rasterizzazione *SampleMask* .</span><span class="sxs-lookup"><span data-stu-id="6abfd-211">The `InnerCoverage` bit-field is not affected by depth/stencil tests, nor is it ANDed with the *SampleMask* Rasterizer state.</span></span>

<span data-ttu-id="6abfd-212">Questo input è valido solo in modalità di rasterizzazione conservativa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-212">This input is only valid in Conservative Rasterization mode.</span></span> <span data-ttu-id="6abfd-213">Quando la rasterizzazione conservativa non è abilitata, `InnerCoverage` produce un valore non definito.</span><span class="sxs-lookup"><span data-stu-id="6abfd-213">When Conservative Rasterization is not enabled, `InnerCoverage` produces an undefined value.</span></span>

<span data-ttu-id="6abfd-214">Le chiamate del pixel shader causate dalla necessità di pixel helper, ma in caso contrario non coperte dalla primitiva, devono avere il `InnerCoverage` registro impostato su 0.</span><span class="sxs-lookup"><span data-stu-id="6abfd-214">Pixel Shader invocations caused by the need for Helper Pixels, but otherwise not covered by the primitive, must have the `InnerCoverage` register set to 0.</span></span>

### <a name="attribute-interpolation-interaction"></a><span data-ttu-id="6abfd-215">Interazione con l'interpolazione degli attributi</span><span class="sxs-lookup"><span data-stu-id="6abfd-215">Attribute Interpolation interaction</span></span>

<span data-ttu-id="6abfd-216">Le modalità di interpolazione degli attributi non sono state modificate ed è possibile procedere nello stesso modo in cui la rasterizzazione conservativa non è abilitata, in cui vengono usati i vertici con scalabilità del viewport e con conversione a virgola fissa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-216">Attribute interpolation modes are unchanged and proceed the same way as when Conservative Rasterization is not enabled, where the viewport-scaled and fixed-point-converted vertices are used.</span></span> <span data-ttu-id="6abfd-217">Poiché tutti gli esempi in un pixel rasterizzato in modo conservativo sono considerati analizzati, sono validi per i valori da estrapolare, in modo analogo a quando si utilizzano le modalità di interpolazione con frequenza pixel in un **renderTarget** con numero campione maggiore di 1.</span><span class="sxs-lookup"><span data-stu-id="6abfd-217">Because all samples in a conservatively rasterized pixel are considered covered, it is valid for values to be extrapolated, similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1.</span></span> <span data-ttu-id="6abfd-218">Le modalità di interpolazione del baricentro producono risultati identici alla modalità di interpolazione non centrale corrispondente. il concetto di centro non è significativo in questo scenario, in cui il code coverage di esempio è pieno o 0.</span><span class="sxs-lookup"><span data-stu-id="6abfd-218">Centroid interpolation modes produce results identical to the corresponding non-centroid interpolation mode; the notion of centroid is meaningless in this scenario – where sample coverage is only either full or 0.</span></span>

<span data-ttu-id="6abfd-219">La rasterizzazione conservativa consente la degenerazione dei triangoli per produrre chiamate pixel shader, pertanto, i triangoli degenerati devono usare i valori assegnati al vertice 0 per tutti i valori interpolati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-219">Conservative Rasterization allows for degenerate triangles to produce Pixel Shader invocations, therefore, degenerate triangles must use the values assigned to Vertex 0 for all interpolated values.</span></span>

### <a name="clipping-interaction"></a><span data-ttu-id="6abfd-220">Interazione di ritaglio</span><span class="sxs-lookup"><span data-stu-id="6abfd-220">Clipping interaction</span></span>

<span data-ttu-id="6abfd-221">Quando è abilitata la modalità di rasterizzazione conservativa e la clip di profondità è disabilitata (quando lo stato di rasterizzazione *DepthClipEnable* è impostato su false), potrebbero esistere variazioni nell'interpolazione degli attributi per i segmenti di una primitiva che non rientrano nell'intervallo 0 <= z <= w, a seconda dell'implementazione: i valori costanti vengono utilizzati da un punto in cui la primitiva interseca il piano pertinente (quasi o lontano) oppure l'interpolazione degli attributi si comporta come se fosse disabilitata la modalità di rasterizzazione conservativa</span><span class="sxs-lookup"><span data-stu-id="6abfd-221">When Conservative Rasterization mode is enabled and depth clip is disabled (when the *DepthClipEnable* Rasterizer State is set to FALSE), there may be variances in attribute interpolation for segments of a primitive that fall outside the 0 <= z <= w range, depending on implementation: either constant values are used from a point where the primitive intersects the relevant plane (near or far), or attribute interpolation behaves as when Conservative Rasterization mode is disabled.</span></span> <span data-ttu-id="6abfd-222">Tuttavia, il comportamento del valore di profondità è lo stesso indipendentemente dalla modalità di rasterizzazione conservativa, ovvero le primitive che non rientrano nell'intervallo di profondità devono comunque avere il valore del limite più vicino all'intervallo di profondità del viewport.</span><span class="sxs-lookup"><span data-stu-id="6abfd-222">However, the depth value behavior is the same regardless of Conservative Rasterization mode, i.e. primitives that fall outside of the depth range must still be given the value of the nearest limit of the viewport depth range.</span></span> <span data-ttu-id="6abfd-223">Il comportamento di interpolazione degli attributi all'interno dell'intervallo 0 <= z <= w deve rimanere invariato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-223">Attribute interpolation behavior inside the 0 <= z <= w range must remain unchanged.</span></span>

### <a name="clip-distance-interaction"></a><span data-ttu-id="6abfd-224">Interazione della distanza tra clip</span><span class="sxs-lookup"><span data-stu-id="6abfd-224">Clip Distance interaction</span></span>

<span data-ttu-id="6abfd-225">La distanza tra clip è valida quando è abilitata la modalità di rasterizzazione conservativa e si comporta per un pixel con rasterizzazione conservativa, come avviene quando la rasterizzazione conservativa non è abilitata con tutti gli esempi analizzati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-225">Clip Distance is valid when Conservative Rasterization mode is enabled, and behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

<span data-ttu-id="6abfd-226">Si noti che la rasterizzazione conservativa può causare l'estrapolazione della coordinata del vertice W, che può causare W <= 0.</span><span class="sxs-lookup"><span data-stu-id="6abfd-226">Note that Conservative Rasterization can cause extrapolation of the W vertex coordinate, which may cause W <= 0.</span></span> <span data-ttu-id="6abfd-227">Ciò può causare l'esecuzione di implementazioni di distanza di ritaglio per pixel in una distanza di clip che è stata divisa da un valore W non valido.</span><span class="sxs-lookup"><span data-stu-id="6abfd-227">This could cause per-pixel Clip Distance implementations to operate on a Clip Distance that has been Perspective Divided by an invalid W value.</span></span> <span data-ttu-id="6abfd-228">Le implementazioni della distanza tra clip devono essere protette dalla richiamata della rasterizzazione per i pixel in cui la coordinata del vertice W <= 0 (ad esempio, a causa dell'estrapolazione in modalità di rasterizzazione conservativa)</span><span class="sxs-lookup"><span data-stu-id="6abfd-228">Clip Distance implementations must guard against invoking rasterization for pixels where vertex coordinate W <= 0 (e.g. due to extrapolation when in Conservative Rasterization mode).</span></span>

### <a name="target-independent-rasterization-interaction"></a><span data-ttu-id="6abfd-229">Interazione di rasterizzazione indipendente di destinazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-229">Target Independent Rasterization interaction</span></span>

<span data-ttu-id="6abfd-230">La modalità di rasterizzazione conservativa è compatibile con la rasterizzazione indipendente di destinazione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-230">Conservative Rasterization mode is compatible with Target Independent Rasterization (TIR).</span></span> <span data-ttu-id="6abfd-231">Si applicano le regole e le restrizioni TIR, comportando un pixel con rasterizzazione conservata come se fossero analizzati tutti i campioni.</span><span class="sxs-lookup"><span data-stu-id="6abfd-231">TIR rules and restrictions apply, behaving for a conservatively rasterized pixel as if all samples are covered.</span></span>

### <a name="ia-primitive-topology-interaction"></a><span data-ttu-id="6abfd-232">Interazione della topologia primitiva IA</span><span class="sxs-lookup"><span data-stu-id="6abfd-232">IA Primitive Topology interaction</span></span>

<span data-ttu-id="6abfd-233">La rasterizzazione conservativa non è definita per le primitive linea o punto.</span><span class="sxs-lookup"><span data-stu-id="6abfd-233">Conservative Rasterization is not defined for line or point primitives.</span></span> <span data-ttu-id="6abfd-234">Pertanto, le topologie primitive che specificano punti o linee producono un comportamento non definito se vengono alimentate all'unità di rasterizzazione quando è abilitata la rasterizzazione conservativa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-234">Therefore, Primitive Topologies that specify points or lines produce undefined behavior if they are fed to the rasterizer unit when Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="6abfd-235">La convalida dei livelli di debug verifica che le applicazioni non usino queste topologie primitive.</span><span class="sxs-lookup"><span data-stu-id="6abfd-235">The debug layer validation verifies applications do not use these Primitive Topologies.</span></span>

### <a name="query-interaction"></a><span data-ttu-id="6abfd-236">Interazione tra query</span><span class="sxs-lookup"><span data-stu-id="6abfd-236">Query interaction</span></span>

<span data-ttu-id="6abfd-237">Per un pixel rasterizzato in modo conservativo, le query si comportano come se la rasterizzazione conservativa non venisse abilitata quando vengono analizzati tutti i campioni.</span><span class="sxs-lookup"><span data-stu-id="6abfd-237">For a conservatively rasterized pixel, queries behave as they do when Conservative Rasterization is not enabled when all samples are covered.</span></span> <span data-ttu-id="6abfd-238">Ad esempio, per un pixel rasterizzato in modo conservativo \_ , \_ \_ le statistiche della pipeline del tipo di query D3D12 e delle \_ \_ \_ \_ statistiche della pipeline del tipo di query D3D12 (dal [**\_ \_ tipo di query D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) devono comportarsi come se la rasterizzazione conservativa non venisse abilitata quando vengono analizzati tutti gli esempi</span><span class="sxs-lookup"><span data-stu-id="6abfd-238">For example, for a conservatively rasterized pixel, D3D12\_QUERY\_TYPE\_OCCLUSION and D3D12\_QUERY\_TYPE\_PIPELINE\_STATISTICS (from [**D3D12\_QUERY\_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) must behave as they would when Conservative Rasterization is not enabled when all samples are covered.</span></span>

<span data-ttu-id="6abfd-239">Le chiamate del pixel shader devono essere incrementate per ogni pixel con rasterizzazione conservativa in modalità di rasterizzazione conservativa.</span><span class="sxs-lookup"><span data-stu-id="6abfd-239">Pixel Shader invocations should increment for every conservatively rasterized pixel in Conservative Rasterization mode.</span></span>

### <a name="cull-state-interaction"></a><span data-ttu-id="6abfd-240">Interazione stato di eliminazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-240">Cull State interaction</span></span>

<span data-ttu-id="6abfd-241">Tutti gli Stati di eliminazione sono validi in modalità di rasterizzazione conservativa e seguono le stesse regole di quando la rasterizzazione conservativa non è abilitata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-241">All Cull States are valid in Conservative Rasterization mode and follow the same rules as when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="6abfd-242">Quando si confronta la rasterizzazione conservativa tra le risoluzioni a se stessa o senza la rasterizzazione conservativa abilitata, esiste la possibilità che alcune primitive possano avere una faccia non corrispondente (ad esempio, una riattivazione, l'altra anteriore).</span><span class="sxs-lookup"><span data-stu-id="6abfd-242">When comparing Conservative Rasterization across resolutions to itself or without Conservative Rasterization enabled, there is the possibility that some primitives may have mismatched facedness (i.e. one back facing, the other front facing).</span></span> <span data-ttu-id="6abfd-243">Le applicazioni possono evitare questa incertezza usando \_ la modalità di abbattimento D3D12 \_ \_ None (dalla [**\_ \_ modalità di eliminazione D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) e non usando il `IsFrontFace` valore generato dal sistema.</span><span class="sxs-lookup"><span data-stu-id="6abfd-243">Applications can avoid this uncertainty by using D3D12\_CULL\_MODE\_NONE (from [**D3D12\_CULL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) and not using the `IsFrontFace` System Generated Value.</span></span>

### <a name="isfrontface-interaction"></a><span data-ttu-id="6abfd-244">Interazione IsFrontFace</span><span class="sxs-lookup"><span data-stu-id="6abfd-244">IsFrontFace interaction</span></span>

<span data-ttu-id="6abfd-245">Il `IsFrontFace` valore generato dal sistema è valido per l'utilizzo in modalità di rasterizzazione conservativa e segue il comportamento definito quando la rasterizzazione conservativa non è abilitata.</span><span class="sxs-lookup"><span data-stu-id="6abfd-245">The `IsFrontFace` System Generated Value is valid to use in Conservative Rasterization mode, and follows the behavior defined when Conservative Rasterization is not enabled.</span></span>

### <a name="fill-modes-interaction"></a><span data-ttu-id="6abfd-246">Interazione modalità di riempimento</span><span class="sxs-lookup"><span data-stu-id="6abfd-246">Fill Modes interaction</span></span>

<span data-ttu-id="6abfd-247">L'unica [**modalità di \_ riempimento \_ D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) valida per la rasterizzazione conservativa è D3D12 \_ Fill \_ Solid, qualsiasi altra modalità di riempimento è un parametro non valido per lo stato di rasterizzazione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-247">The only valid [**D3D12\_FILL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) for Conservative Rasterization is D3D12\_FILL\_SOLID, any other fill mode is an invalid parameter for the Rasterizer State.</span></span>

<span data-ttu-id="6abfd-248">Ciò è dovuto al fatto che la specifica funzionale D3D12 specifica che la modalità di riempimento wireframe deve convertire i bordi del triangolo in linee e seguire le regole di rasterizzazione delle righe e il comportamento di rasterizzazione della linea conservativa non è stato definito</span><span class="sxs-lookup"><span data-stu-id="6abfd-248">This is because D3D12 functional specification specifies that wireframe fill mode should convert triangle edges to lines and follow the line rasterization rules and conservative line rasterization behavior has not been defined.</span></span>

## <a name="implementation-details"></a><span data-ttu-id="6abfd-249">Dettagli dell'implementazione</span><span class="sxs-lookup"><span data-stu-id="6abfd-249">Implementation details</span></span>

<span data-ttu-id="6abfd-250">Il tipo di rasterizzazione supportato in Direct3D 12 viene talvolta definito "rasterizzazione conservativa sovrastimata".</span><span class="sxs-lookup"><span data-stu-id="6abfd-250">The type of rasterization supported in Direct3D 12 is sometimes referred to as "Overestimated Conservative Rasterization".</span></span> <span data-ttu-id="6abfd-251">Esiste anche il concetto di "rasterizzazione conservativa sottostimata", il che significa che vengono rasterizzati solo i pixel completamente coperti da una primitiva sottoposta a rendering.</span><span class="sxs-lookup"><span data-stu-id="6abfd-251">There is also the concept of "Underestimated Conservative Rasterization", which means that only pixels that are fully covered by a rendered primitive are rasterized.</span></span> <span data-ttu-id="6abfd-252">Le informazioni di rasterizzazione conservative sottostimate sono disponibili tramite il pixel shader tramite l'utilizzo di dati di code coverage di input e solo la rasterizzazione conservativa sovrastimata è disponibile come modalità di rasterizzazione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-252">Underestimated Conservative Rasterization information is available through the pixel shader through the use of input coverage data, and only overestimated Conservative Rasterization is available as a rasterizing mode.</span></span>

<span data-ttu-id="6abfd-253">Se una parte di una primitiva si sovrappone a un pixel, il pixel viene considerato analizzato ed è quindi rasterizzato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-253">If any part of a primitive overlaps a pixel, then that pixel is considered covered and is then rasterized.</span></span> <span data-ttu-id="6abfd-254">Quando un bordo o un angolo di una primitiva cade lungo il bordo o l'angolo di un pixel, l'applicazione della "regola superiore sinistra" è specifica dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-254">When an edge or corner of a primitive falls along the edge or corner of a pixel, the application of the "top-left rule" is implementation-specific.</span></span> <span data-ttu-id="6abfd-255">Tuttavia, per le implementazioni che supportano triangoli degenerati, un triangolo degenerato lungo un bordo o un angolo deve coprire almeno un pixel.</span><span class="sxs-lookup"><span data-stu-id="6abfd-255">However, for implementations that support degenerate triangles, a degenerate triangle along an edge or corner must cover at least one pixel.</span></span>

<span data-ttu-id="6abfd-256">Le implementazioni di rasterizzazione conservative possono variare in componenti hardware diversi e generare falsi positivi, vale a dire che possono decidere erroneamente che i pixel sono coperti.</span><span class="sxs-lookup"><span data-stu-id="6abfd-256">Conservative Rasterization implementations can vary on different hardware, and do produce false positives, meaning that they can incorrectly decide that pixels are covered.</span></span> <span data-ttu-id="6abfd-257">Questo problema può verificarsi a causa di dettagli specifici dell'implementazione, ad esempio gli errori di espansione o di blocco primitivi inerenti alle coordinate dei vertici a virgola fissa utilizzate per la rasterizzazione.</span><span class="sxs-lookup"><span data-stu-id="6abfd-257">This can occur because of implementation-specific details like primitive growing or snapping errors inherent in the fixed-point vertex coordinates used in rasterization.</span></span> <span data-ttu-id="6abfd-258">Il motivo per cui i falsi positivi (rispetto alle coordinate dei vertici dei punti fissi) sono validi perché una certa quantità di falsi positivi è necessaria per consentire a un'implementazione di eseguire la valutazione del code coverage rispetto ai vertici post-bloccati (ad esempio coordinate dei vertici convertite da virgola mobile a 16,8 a virgola fissa utilizzati nell'rasterizzatore), ma che rispettano il code coverage prodotto dalle coordinate originali del vertice a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="6abfd-258">The reason false positives (with respect to fixed point vertex coordinates) are valid is because some amount of false positives are needed to allow an implementation to do coverage evaluation against post-snapped vertices (i.e. vertex coordinates that have been converted from floating point to the 16.8 fixed-point used in the rasterizer), but honor the coverage produced by the original floating point vertex coordinates.</span></span>

<span data-ttu-id="6abfd-259">Le implementazioni di rasterizzazione conservative non producono falsi negativi rispetto alle coordinate dei vertici a virgola mobile per le primitive post-snap non degenerate: se una parte di una primitiva si sovrappone a qualsiasi parte di un pixel, il pixel verrà rasterizzato.</span><span class="sxs-lookup"><span data-stu-id="6abfd-259">Conservative Rasterization implementations do not produce false negatives with respect to the floating-point vertex coordinates for non-degenerate post-snap primitives: if any part of a primitive overlaps any part of a pixel, then that pixel is rasterized.</span></span>

<span data-ttu-id="6abfd-260">I triangoli degenerati (indici duplicati in un buffer di indice o collineano in 3D) o diventano degenerati dopo la conversione a virgola fissa (vertici collineari nell'rasterizzatore), possono o non essere raccolti; entrambi sono comportamenti validi.</span><span class="sxs-lookup"><span data-stu-id="6abfd-260">Triangles that are degenerate (duplicate indices in an index buffer or collinear in 3D), or become degenerate after fixed-point conversion (collinear vertices in the rasterizer), may or may not be culled; both are valid behaviors.</span></span> <span data-ttu-id="6abfd-261">I triangoli degenerati devono essere considerati rivolti. Pertanto, se un comportamento specifico è richiesto da un'applicazione, può utilizzare l'abbattimento o il test di back-face per il front-end.</span><span class="sxs-lookup"><span data-stu-id="6abfd-261">Degenerate triangles must be considered back facing, so if a specific behavior is required by an application, it can use back-face culling or test for front facing.</span></span> <span data-ttu-id="6abfd-262">I triangoli degenerati utilizzano i valori assegnati al vertice 0 per tutti i valori interpolati.</span><span class="sxs-lookup"><span data-stu-id="6abfd-262">Degenerate triangles use the values assigned to Vertex 0 for all interpolated values.</span></span>

<span data-ttu-id="6abfd-263">Sono disponibili tre livelli di supporto hardware, oltre alla possibilità che l'hardware non supporti questa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="6abfd-263">There are three tiers of hardware support, in addition to the possibility that the hardware does not support this feature.</span></span>

-   <span data-ttu-id="6abfd-264">Il livello 1 impone un'area di incertezza massima di 1/2 pixel e non supporta le degenerazioni post-snap.</span><span class="sxs-lookup"><span data-stu-id="6abfd-264">Tier 1 enforces a maximum 1/2 pixel uncertainty region and does not support post-snap degenerates.</span></span> <span data-ttu-id="6abfd-265">Si tratta di una soluzione ideale per il rendering affiancato, un Atlante di trama, la generazione di una mappa chiara e mappe shadow dei pixel secondari.</span><span class="sxs-lookup"><span data-stu-id="6abfd-265">This is good for tiled rendering, a texture atlas, light map generation and sub-pixel shadow maps.</span></span>
-   <span data-ttu-id="6abfd-266">Il livello 2 riduce l'area di incertezza massima a 1/256 e richiede che le degenerazioni post-snap non vengano abbattuti.</span><span class="sxs-lookup"><span data-stu-id="6abfd-266">Tier 2 reduces the maximum uncertainty region to 1/256 and requires post-snap degenerates not be culled.</span></span> <span data-ttu-id="6abfd-267">Questo livello è utile per l'accelerazione dell'algoritmo basato su CPU (ad esempio voxelization).</span><span class="sxs-lookup"><span data-stu-id="6abfd-267">This tier is helpful for CPU-based algorithm acceleration (such as voxelization).</span></span>
-   <span data-ttu-id="6abfd-268">Il livello 3 mantiene un'area di incertezza massima di 1/256 e aggiunge il supporto per la copertura interna degli input.</span><span class="sxs-lookup"><span data-stu-id="6abfd-268">Tier 3 maintains a maximum 1/256 uncertainty region and adds support for inner input coverage.</span></span> <span data-ttu-id="6abfd-269">Il code coverage dell'input interno aggiunge il nuovo valore `SV_InnerCoverage` a HLSL (High Level Shading Language).</span><span class="sxs-lookup"><span data-stu-id="6abfd-269">Inner input coverage adds the new value `SV_InnerCoverage` to High Level Shading Language (HLSL).</span></span> <span data-ttu-id="6abfd-270">Si tratta di un intero scalare a 32 bit che può essere specificato nell'input di un pixel shader e rappresenta le informazioni di rasterizzazione conservative sottostimate, ovvero se un pixel è garantito per essere completamente coperto.</span><span class="sxs-lookup"><span data-stu-id="6abfd-270">This is a 32-bit scalar integer that can be specified on input to a pixel shader, and represents the underestimated Conservative Rasterization information (that is, whether a pixel is guaranteed-to-be-fully covered).</span></span> <span data-ttu-id="6abfd-271">Questo livello è utile per l'eliminazione delle occlusioni.</span><span class="sxs-lookup"><span data-stu-id="6abfd-271">This tier is helpful for occlusion culling.</span></span>

## <a name="api-summary"></a><span data-ttu-id="6abfd-272">Riepilogo dell'API</span><span class="sxs-lookup"><span data-stu-id="6abfd-272">API summary</span></span>

<span data-ttu-id="6abfd-273">I metodi, le strutture, le enumerazioni e le classi helper seguenti fanno riferimento a una rasterizzazione conservativa:</span><span class="sxs-lookup"><span data-stu-id="6abfd-273">The following methods, structures, enums, and helper classes reference Conservative Rasterization:</span></span>

-   <span data-ttu-id="6abfd-274">[**D3D12 \_ RASTERIZZAtore \_ desc**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : struttura che contiene la descrizione del rasterizzatore.</span><span class="sxs-lookup"><span data-stu-id="6abfd-274">[**D3D12\_RASTERIZER\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : structure holding the rasterizer description.</span></span>
-   <span data-ttu-id="6abfd-275">[**D3D12 \_ \_ \_ Modalità di RASTERIZZAzione conservativa**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : valori enum per la modalità (on o off).</span><span class="sxs-lookup"><span data-stu-id="6abfd-275">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : enum values for the mode (on or off).</span></span>
-   <span data-ttu-id="6abfd-276">[**D3D12 \_ \_Opzioni di \_ D3D12 \_ dati delle funzionalità**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : struttura che mantiene il livello di supporto.</span><span class="sxs-lookup"><span data-stu-id="6abfd-276">[**D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : structure holding the tier of support.</span></span>
-   <span data-ttu-id="6abfd-277">[**D3D12 \_ \_ \_ Livello di RASTERIZZAzione conservativa**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : valori enum per ogni livello di supporto dell'hardware.</span><span class="sxs-lookup"><span data-stu-id="6abfd-277">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : enum values for each tier of support by the hardware.</span></span>
-   <span data-ttu-id="6abfd-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : metodo per accedere alle funzionalità supportate.</span><span class="sxs-lookup"><span data-stu-id="6abfd-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : method to access the supported features.</span></span>
-   <span data-ttu-id="6abfd-279">[**CD3DX12 \_ RASTERIZZAtore \_ desc**](cd3dx12-rasterizer-desc.md) : classe helper per la creazione di descrizioni del rasterizzatore.</span><span class="sxs-lookup"><span data-stu-id="6abfd-279">[**CD3DX12\_RASTERIZER\_DESC**](cd3dx12-rasterizer-desc.md) : helper class for creating rasterizer descriptions.</span></span>

## <a name="related-topics"></a><span data-ttu-id="6abfd-280">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="6abfd-280">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6abfd-281">Esercitazioni video su DirectX Advanced Learning: rasterizzazione conservativa</span><span class="sxs-lookup"><span data-stu-id="6abfd-281">DirectX advanced learning video tutorials : Conservative Rasterization</span></span>](https://www.youtube.com/watch?v=zL0oSY_YmDY)
</dt> <dt>

[<span data-ttu-id="6abfd-282">Visualizzazioni ordinate del rasterizzatore</span><span class="sxs-lookup"><span data-stu-id="6abfd-282">Rasterizer Ordered Views</span></span>](rasterizer-order-views.md)
</dt> <dt>

[<span data-ttu-id="6abfd-283">Rendering</span><span class="sxs-lookup"><span data-stu-id="6abfd-283">Rendering</span></span>](rendering.md)
</dt> </dl>

 

 




