---
title: Differenze nel modello di associazione da Direct3D 11
description: Una delle principali decisioni di progettazione alla base dell'associazione DirectX12 consiste nel separarla da altre attività di gestione. Questa operazione impone alcuni requisiti nell'app per gestire determinati rischi potenziali.
ms.assetid: 3EE7E9AE-203D-40D4-9F12-4313ED179035
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 43b2785da6497fd4e775d9f88847928e7c4c08e8
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104068"
---
# <a name="differences-in-the-binding-model-from-direct3d-11"></a><span data-ttu-id="95857-104">Differenze nel modello di associazione da Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="95857-104">Differences in the Binding Model from Direct3D 11</span></span>

<span data-ttu-id="95857-105">Una delle principali decisioni di progettazione alla base dell'associazione DirectX12 consiste nel separarla da altre attività di gestione.</span><span class="sxs-lookup"><span data-stu-id="95857-105">One of the main design decisions behind DirectX12 binding is to separate it from other management tasks.</span></span> <span data-ttu-id="95857-106">Questa operazione impone alcuni requisiti nell'app per gestire determinati rischi potenziali.</span><span class="sxs-lookup"><span data-stu-id="95857-106">This places some requirements on the app to manage certain potential hazards.</span></span>

<span data-ttu-id="95857-107">Il vantaggio principale del modello di associazione D3D12 è che consente alle app di modificare spesso le associazioni di trame, senza costi elevati in termini di prestazioni della CPU.</span><span class="sxs-lookup"><span data-stu-id="95857-107">The main advantage of the D3D12 Binding Model is that it enables apps to change texture bindings frequently, without a huge CPU performance cost.</span></span> <span data-ttu-id="95857-108">Altri vantaggi sono che gli shader hanno accesso a un numero molto elevato di risorse. gli shader non devono essere in grado di stabilire in anticipo quante risorse saranno associate e che è possibile usare un modello di associazione di risorse unificato indipendentemente dall'hardware o dal flusso di contenuto delle app.</span><span class="sxs-lookup"><span data-stu-id="95857-108">Other benefits are that shaders have access to a very large number of resources, shaders need not know in advance how many resources will be bound, and that a unified resource binding model can be used regardless of hardware or the apps content flow.</span></span>

<span data-ttu-id="95857-109">Per migliorare le prestazioni, il modello di associazione non richiede al sistema di tenere traccia dei binding che un'app ha richiesto alla GPU per l'uso ed è disponibile un'integrazione pulita tra gli elenchi di comandi di binding e multithread.</span><span class="sxs-lookup"><span data-stu-id="95857-109">To improve performance, the binding model does not require the system to keep track of what bindings an app has requested the GPU to use, and there is a clean integration between binding and multi-threaded command lists.</span></span>

<span data-ttu-id="95857-110">Le sezioni seguenti elencano alcune delle modifiche apportate al modello di associazione delle risorse a partire da D3D11.</span><span class="sxs-lookup"><span data-stu-id="95857-110">The following sections list some of the changes to the resource binding model since D3D11.</span></span>

-   [<span data-ttu-id="95857-111">Gestione della residenza di memoria separata dall'associazione</span><span class="sxs-lookup"><span data-stu-id="95857-111">Memory Residency Management Separated From Binding</span></span>](#memory-residency-management-separated-from-binding)
-   [<span data-ttu-id="95857-112">Gestione della durata degli oggetti separata dall'associazione</span><span class="sxs-lookup"><span data-stu-id="95857-112">Object Lifetime Management Separated From Binding</span></span>](#object-lifetime-management-separated-from-binding)
-   [<span data-ttu-id="95857-113">Rilevamento dello stato delle risorse del driver separato dal binding</span><span class="sxs-lookup"><span data-stu-id="95857-113">Driver Resource State Tracking Separated From Binding</span></span>](#driver-resource-state-tracking-separated-from-binding)
-   [<span data-ttu-id="95857-114">Sincronizzazione della memoria mappata GPU CPU separata dal binding</span><span class="sxs-lookup"><span data-stu-id="95857-114">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>](#cpu-gpu-mapped-memory-synchronization-separated-from-binding)
-   [<span data-ttu-id="95857-115">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="95857-115">Related topics</span></span>](#related-topics)

## <a name="memory-residency-management-separated-from-binding"></a><span data-ttu-id="95857-116">Gestione della residenza di memoria separata dall'associazione</span><span class="sxs-lookup"><span data-stu-id="95857-116">Memory Residency Management Separated From Binding</span></span>

<span data-ttu-id="95857-117">Le applicazioni hanno il controllo esplicito sulle superfici che devono essere disponibili per la GPU da usare direttamente (chiamato "residente").</span><span class="sxs-lookup"><span data-stu-id="95857-117">Applications have explicit control over which surfaces they need to be available for the GPU to use directly (called being "resident").</span></span> <span data-ttu-id="95857-118">Viceversa, possono applicare altri Stati alle risorse, ad esempio renderli esplicitamente non residenti o consentire al sistema operativo di scegliere alcune classi di applicazioni che richiedono un footprint di memoria minimo.</span><span class="sxs-lookup"><span data-stu-id="95857-118">Conversely, they can apply other states on resources such as explicitly making them not resident, or letting the OS choose for certain classes of applications that require a minimal memory footprint.</span></span> <span data-ttu-id="95857-119">Il punto importante è che la gestione dell'applicazione di ciò che è residente è completamente separata dal modo in cui fornisce l'accesso alle risorse agli shader.</span><span class="sxs-lookup"><span data-stu-id="95857-119">The important point here is that the application's management of what is resident is completely decoupled from how it gives access to resources to shaders.</span></span>

<span data-ttu-id="95857-120">Il disaccoppiamento della gestione della residenza dal meccanismo per concedere agli shader l'accesso alle risorse riduce il costo del sistema o dell'hardware per il rendering poiché il sistema operativo non deve esaminare costantemente lo stato dell'associazione locale per sapere cosa fare.</span><span class="sxs-lookup"><span data-stu-id="95857-120">The decoupling of residency management from the mechanism for giving shaders access to resources reduces the system/hardware cost for rendering since the OS doesn't have to constantly inspect the local binding state to know what to make resident.</span></span> <span data-ttu-id="95857-121">Inoltre, non è più necessario che gli shader conoscano le superfici esatte a cui possono fare riferimento, purché l'intero set di risorse eventualmente accessibili sia stato reso residente in anticipo.</span><span class="sxs-lookup"><span data-stu-id="95857-121">Furthermore, shaders no longer have to know which exact surfaces they may need to reference, as long as the entire set of possibly accessible resources has been made resident ahead of time.</span></span>

## <a name="object-lifetime-management-separated-from-binding"></a><span data-ttu-id="95857-122">Gestione della durata degli oggetti separata dall'associazione</span><span class="sxs-lookup"><span data-stu-id="95857-122">Object Lifetime Management Separated From Binding</span></span>

<span data-ttu-id="95857-123">Diversamente dalle API precedenti, il sistema non tiene più traccia delle associazioni di risorse alla pipeline.</span><span class="sxs-lookup"><span data-stu-id="95857-123">Unlike previous APIs, the system no longer tracks bindings of resources to the pipeline.</span></span> <span data-ttu-id="95857-124">Questa operazione consente al sistema di mantenere le risorse attive rilasciate dall'applicazione, perché ancora fanno riferimento a un lavoro GPU in attesa.</span><span class="sxs-lookup"><span data-stu-id="95857-124">This used to enable the system to keep alive resources that the application has released because they are still referenced by outstanding GPU work.</span></span>

<span data-ttu-id="95857-125">Prima di liberare qualsiasi risorsa, ad esempio una trama, le applicazioni devono ora verificare che la GPU abbia completato il riferimento.</span><span class="sxs-lookup"><span data-stu-id="95857-125">Before freeing any resource, such as a texture, applications now must make sure the GPU has completed referencing it.</span></span> <span data-ttu-id="95857-126">Questo significa che prima che un'applicazione possa liberare in modo sicuro una risorsa, la GPU deve avere completato l'esecuzione dell'elenco dei comandi che fa riferimento alla risorsa.</span><span class="sxs-lookup"><span data-stu-id="95857-126">This means before an application can safely free a resource the GPU must have completed execution of the command list referencing the resource.</span></span>

## <a name="driver-resource-state-tracking-separated-from-binding"></a><span data-ttu-id="95857-127">Rilevamento dello stato delle risorse del driver separato dal binding</span><span class="sxs-lookup"><span data-stu-id="95857-127">Driver Resource State Tracking Separated From Binding</span></span>

<span data-ttu-id="95857-128">Il sistema non controlla più le associazioni di risorse per capire quando si sono verificate le transizioni di risorse che richiedono un driver o un lavoro GPU aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="95857-128">The system no longer inspects resource bindings to understand when resource transitions have occurred which require additional driver or GPU work.</span></span> <span data-ttu-id="95857-129">Un esempio comune per molte GPU e driver è che è necessario rilevare quando una superficie passa dall'uso come visualizzazione di destinazione di rendering (RTV) a Shader Resource View (SRV).</span><span class="sxs-lookup"><span data-stu-id="95857-129">A common example for many GPUs and drivers is having to know when a surface transitions from being used as a Render Target View (RTV) to Shader Resource View (SRV).</span></span> <span data-ttu-id="95857-130">Le applicazioni devono ora identificare quando si verificano transizioni di risorse che il sistema potrebbe preoccuparsi di eseguire tramite API dedicate.</span><span class="sxs-lookup"><span data-stu-id="95857-130">Applications themselves must now identify when any resource transitions that the system might care about are happening via dedicated APIs.</span></span>

## <a name="cpu-gpu-mapped-memory-synchronization-separated-from-binding"></a><span data-ttu-id="95857-131">Sincronizzazione della memoria mappata GPU CPU separata dal binding</span><span class="sxs-lookup"><span data-stu-id="95857-131">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>

<span data-ttu-id="95857-132">Il sistema non controlla più le associazioni di risorse per capire se è necessario ritardare il rendering perché dipende da una risorsa di cui è stato eseguito il mapping per l'accesso alla CPU, ma non ne è ancora stato eseguito il mapping.</span><span class="sxs-lookup"><span data-stu-id="95857-132">The system no longer inspects resource bindings to understand if rendering needs to be delayed because it depends on a resource that has been mapped for CPU access but has not been unmapped yet.</span></span> <span data-ttu-id="95857-133">Le applicazioni ora hanno la responsabilità di sincronizzare gli accessi alla memoria CPU e GPU.</span><span class="sxs-lookup"><span data-stu-id="95857-133">Applications now have the responsibility to synchronize CPU and GPU memory accesses.</span></span> <span data-ttu-id="95857-134">Per semplificare questa operazione, il sistema fornisce meccanismi che consentono all'applicazione di richiedere la sospensione di un thread della CPU fino al completamento del lavoro.</span><span class="sxs-lookup"><span data-stu-id="95857-134">To help with this, the system provides mechanisms for the application to request the sleeping of a CPU thread until work completes.</span></span> <span data-ttu-id="95857-135">Il polling può essere eseguito anche se è meno efficiente.</span><span class="sxs-lookup"><span data-stu-id="95857-135">Polling could also be done, but can be less efficient.</span></span>

## <a name="related-topics"></a><span data-ttu-id="95857-136">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="95857-136">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="95857-137">Associazione di risorse</span><span class="sxs-lookup"><span data-stu-id="95857-137">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




