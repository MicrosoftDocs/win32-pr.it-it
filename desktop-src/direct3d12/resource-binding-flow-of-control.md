---
title: Panoramica dell'associazione di risorse
description: La chiave per l'associazione di risorse in DirectX 12 è costituita dai concetti di un descrittore, tabelle di descrittore, heap di descrittori e una firma radice.
ms.assetid: 92E100CA-822D-46B1-BD37-FF57C3FB703D
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2bc7e78255c123777716eddb43d9443e19113b34
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104647"
---
# <a name="resource-binding-overview"></a><span data-ttu-id="af169-103">Panoramica dell'associazione di risorse</span><span class="sxs-lookup"><span data-stu-id="af169-103">Resource Binding Overview</span></span>

<span data-ttu-id="af169-104">La chiave per l'associazione di risorse in DirectX 12 è costituita dai concetti di un *descrittore*, *tabelle di descrittore*, *heap di descrittori* e una *firma radice*.</span><span class="sxs-lookup"><span data-stu-id="af169-104">The key to resource binding in DirectX 12 are the concepts of a *descriptor*, *descriptor tables*, *descriptor heaps*, and a *root signature*.</span></span>

-   [<span data-ttu-id="af169-105">Risorse e pipeline grafica</span><span class="sxs-lookup"><span data-stu-id="af169-105">Resources and the Graphics Pipeline</span></span>](#resources-and-the-graphics-pipeline)
-   [<span data-ttu-id="af169-106">Tipi di risorse e viste</span><span class="sxs-lookup"><span data-stu-id="af169-106">Resource types and views</span></span>](#resource-types-and-views)
-   [<span data-ttu-id="af169-107">Flusso di associazione di risorse del controllo</span><span class="sxs-lookup"><span data-stu-id="af169-107">Resource Binding Flow of Control</span></span>](#resource-binding-overview)
-   [<span data-ttu-id="af169-108">Sottoallocazione</span><span class="sxs-lookup"><span data-stu-id="af169-108">Suballocation</span></span>](#suballocation)
-   [<span data-ttu-id="af169-109">Liberare risorse</span><span class="sxs-lookup"><span data-stu-id="af169-109">Freeing Resources</span></span>](#freeing-resources)
-   [<span data-ttu-id="af169-110">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="af169-110">Related topics</span></span>](#related-topics)

## <a name="resources-and-the-graphics-pipeline"></a><span data-ttu-id="af169-111">Risorse e pipeline grafica</span><span class="sxs-lookup"><span data-stu-id="af169-111">Resources and the Graphics Pipeline</span></span>

<span data-ttu-id="af169-112">Le risorse dello shader, ad esempio le trame, le tabelle costanti, le immagini, i buffer e così via, non sono associate direttamente alla pipeline dello shader. al contrario, viene fatto riferimento tramite un *descrittore*.</span><span class="sxs-lookup"><span data-stu-id="af169-112">Shader resources (such as textures, constant tables, images, buffers and so on) are not bound directly to the shader pipeline; instead, they are referenced through a *descriptor*.</span></span> <span data-ttu-id="af169-113">Un descrittore è un piccolo oggetto che contiene informazioni su una risorsa.</span><span class="sxs-lookup"><span data-stu-id="af169-113">A descriptor is a small object that contains information about one resource.</span></span>

<span data-ttu-id="af169-114">I descrittori sono raggruppati in *tabelle di descrittori* di form.</span><span class="sxs-lookup"><span data-stu-id="af169-114">Descriptors are grouped together to form *descriptor tables*.</span></span> <span data-ttu-id="af169-115">Ogni tabella descrittore archivia informazioni su un intervallo di tipi di risorse.</span><span class="sxs-lookup"><span data-stu-id="af169-115">Each descriptor table stores information about one range of types of resource.</span></span> <span data-ttu-id="af169-116">Sono disponibili molti tipi diversi di risorse.</span><span class="sxs-lookup"><span data-stu-id="af169-116">There are many different types of resources.</span></span> <span data-ttu-id="af169-117">Le risorse più comuni sono:</span><span class="sxs-lookup"><span data-stu-id="af169-117">The most common resources are:</span></span>

-   <span data-ttu-id="af169-118">Viste del buffer costante (CBVs)</span><span class="sxs-lookup"><span data-stu-id="af169-118">Constant buffer views (CBVs)</span></span>
-   <span data-ttu-id="af169-119">Viste di accesso non ordinate (UAV)</span><span class="sxs-lookup"><span data-stu-id="af169-119">Unordered access views (UAVs)</span></span>
-   <span data-ttu-id="af169-120">Viste risorse shader (SRVs)</span><span class="sxs-lookup"><span data-stu-id="af169-120">Shader resource views (SRVs)</span></span>
-   <span data-ttu-id="af169-121">Campionatori</span><span class="sxs-lookup"><span data-stu-id="af169-121">Samplers</span></span>

<span data-ttu-id="af169-122">I descrittori SRV, UAV e CBVs possono essere combinati nella stessa tabella descrittore.</span><span class="sxs-lookup"><span data-stu-id="af169-122">SRV, UAV, and CBVs descriptors can be combined into the same descriptor table.</span></span>

<span data-ttu-id="af169-123">Le pipeline di calcolo e di grafica ottengono l'accesso alle risorse facendo riferimento alle tabelle del descrittore in base all'indice.</span><span class="sxs-lookup"><span data-stu-id="af169-123">The graphics and compute pipelines gain access to resources by referencing into descriptor tables by index.</span></span>

<span data-ttu-id="af169-124">Le tabelle descrittore vengono archiviate in un *heap del descrittore*.</span><span class="sxs-lookup"><span data-stu-id="af169-124">Descriptor tables are stored in a *descriptor heap*.</span></span> <span data-ttu-id="af169-125">Gli heap descrittore conterranno idealmente tutti i descrittori (nelle tabelle dei descrittori) per uno o più frame di cui eseguire il rendering.</span><span class="sxs-lookup"><span data-stu-id="af169-125">Descriptor heaps will ideally contain all the descriptors (in descriptor tables) for one or more frames to be rendered.</span></span> <span data-ttu-id="af169-126">Tutte le risorse verranno archiviate in heap in modalità utente.</span><span class="sxs-lookup"><span data-stu-id="af169-126">All the resources will be stored in user mode heaps.</span></span>

<span data-ttu-id="af169-127">Un altro concetto è quello di una *firma radice*.</span><span class="sxs-lookup"><span data-stu-id="af169-127">Another concept is that of a *root signature*.</span></span> <span data-ttu-id="af169-128">La firma radice è una convenzione di associazione, definita dall'applicazione, che viene utilizzata dagli shader per individuare le risorse a cui è necessario accedere.</span><span class="sxs-lookup"><span data-stu-id="af169-128">The root signature is a binding convention, defined by the application, that is used by shaders to locate the resources that they need access to.</span></span> <span data-ttu-id="af169-129">La firma radice può archiviare:</span><span class="sxs-lookup"><span data-stu-id="af169-129">The root signature can store:</span></span>

-   <span data-ttu-id="af169-130">Indici per le tabelle dei descrittori in un heap del descrittore, in cui il layout della tabella descrittore è già stato definito.</span><span class="sxs-lookup"><span data-stu-id="af169-130">Indexes to descriptor tables in a descriptor heap, where the layout of the descriptor table has been pre-defined.</span></span>
-   <span data-ttu-id="af169-131">Le costanti, in modo che le app possano associare le costanti definite dall'utente (note come *costanti radice*) direttamente agli shader senza dover passare attraverso i descrittori e le tabelle dei descrittori.</span><span class="sxs-lookup"><span data-stu-id="af169-131">Constants, so apps can bind user-defined constants (known as *root constants*) directly to shaders without having to go through descriptors and descriptor tables.</span></span>
-   <span data-ttu-id="af169-132">Numero molto ridotto di descrittori direttamente all'interno della firma radice, ad esempio una visualizzazione del buffer costante (CBV) che cambia per ogni estrazione, evitando così che l'applicazione debba inserire i descrittori in un heap dei descrittori.</span><span class="sxs-lookup"><span data-stu-id="af169-132">A very small number of descriptors directly inside the root signature, such as a constant buffer view (CBV) that changes per draw, thereby saving the application from needing to put those descriptors in a descriptor heap.</span></span>

<span data-ttu-id="af169-133">In altre parole, la firma radice fornisce le ottimizzazioni delle prestazioni appropriate per piccole quantità di dati che cambiano per ogni progetto.</span><span class="sxs-lookup"><span data-stu-id="af169-133">In other words, the root signature provides performance optimizations suitable for small amounts of data that change per draw.</span></span>

<span data-ttu-id="af169-134">Il progetto Direct3D 12 per l'associazione lo separa da altre attività, ad esempio la gestione della memoria, la gestione della durata degli oggetti, il rilevamento dello stato e la sincronizzazione della memoria (vedere [le differenze nel modello di associazione da Direct3D 11](binding-model.md)).</span><span class="sxs-lookup"><span data-stu-id="af169-134">The Direct3D 12 design for binding separates it from other tasks, such as memory management, object lifetime management, state tracking, and memory synchronization (refer to [Differences in the Binding Model from Direct3D 11](binding-model.md)).</span></span> <span data-ttu-id="af169-135">Il binding Direct3D 12 è progettato per un sovraccarico ridotto e ottimizzato per le chiamate API eseguite con maggiore frequenza.</span><span class="sxs-lookup"><span data-stu-id="af169-135">Direct3D 12 binding is designed to be low overhead and optimized for the API calls that are made most frequently.</span></span> <span data-ttu-id="af169-136">Inoltre, è scalabile per l'hardware di fascia bassa fino a un livello superiore e scalabile dalle versioni precedenti (la pipeline Direct3D 11 più lineare) agli approcci più recenti (più paralleli) alla programmazione del motore di grafica.</span><span class="sxs-lookup"><span data-stu-id="af169-136">It is also scalable across low end to high end hardware, and scalable from older (the more linear Direct3D 11 pipeline) to the newer (more parallel) approaches to graphics engine programming.</span></span>

## <a name="resource-types-and-views"></a><span data-ttu-id="af169-137">Tipi di risorse e viste</span><span class="sxs-lookup"><span data-stu-id="af169-137">Resource types and views</span></span>

<span data-ttu-id="af169-138">I tipi di risorsa corrispondono a Direct3D 11, ovvero:</span><span class="sxs-lookup"><span data-stu-id="af169-138">Resource types are the same as Direct3D 11, namely:</span></span>

-   <span data-ttu-id="af169-139">Texture1D e Texture1DArray</span><span class="sxs-lookup"><span data-stu-id="af169-139">Texture1D, and Texture1DArray</span></span>
-   <span data-ttu-id="af169-140">Texture2D, Texture2DArray, Texture2DMS, Texture2DMSArray</span><span class="sxs-lookup"><span data-stu-id="af169-140">Texture2D, and Texture2DArray, Texture2DMS, Texture2DMSArray</span></span>
-   <span data-ttu-id="af169-141">Texture3D</span><span class="sxs-lookup"><span data-stu-id="af169-141">Texture3D</span></span>
-   <span data-ttu-id="af169-142">Buffer (tipizzati, strutturati e non elaborati)</span><span class="sxs-lookup"><span data-stu-id="af169-142">Buffers (typed, structured and raw)</span></span>

<span data-ttu-id="af169-143">Le visualizzazioni delle risorse sono simili, ma leggermente diverse dalle visualizzazioni Direct3D 11, vertex e index buffer sono state aggiunte.</span><span class="sxs-lookup"><span data-stu-id="af169-143">Resource views are similar but slightly different from Direct3D 11, vertex and index buffer views have been added.</span></span>

-   <span data-ttu-id="af169-144">Constant Buffer View (CBV)</span><span class="sxs-lookup"><span data-stu-id="af169-144">Constant buffer view (CBV)</span></span>
-   <span data-ttu-id="af169-145">Visualizzazione accessi non ordinati (UAV)</span><span class="sxs-lookup"><span data-stu-id="af169-145">Unordered access view (UAV)</span></span>
-   <span data-ttu-id="af169-146">Visualizzazione risorse shader (SRV)</span><span class="sxs-lookup"><span data-stu-id="af169-146">Shader resource view (SRV)</span></span>
-   <span data-ttu-id="af169-147">Campionatori</span><span class="sxs-lookup"><span data-stu-id="af169-147">Samplers</span></span>
-   <span data-ttu-id="af169-148">Visualizzazione destinazione rendering (RTV)</span><span class="sxs-lookup"><span data-stu-id="af169-148">Render Target View (RTV)</span></span>
-   <span data-ttu-id="af169-149">Visualizzazione stencil profondità (DSV)</span><span class="sxs-lookup"><span data-stu-id="af169-149">Depth Stencil View (DSV)</span></span>
-   <span data-ttu-id="af169-150">Visualizzazione buffer indice (IBV)</span><span class="sxs-lookup"><span data-stu-id="af169-150">Index Buffer View (IBV)</span></span>
-   <span data-ttu-id="af169-151">Visualizzazione buffer dei vertici (VBV)</span><span class="sxs-lookup"><span data-stu-id="af169-151">Vertex Buffer View (VBV)</span></span>
-   <span data-ttu-id="af169-152">Visualizzazione output flusso (SOV)</span><span class="sxs-lookup"><span data-stu-id="af169-152">Stream Output View (SOV)</span></span>

<span data-ttu-id="af169-153">Solo le prime quattro visualizzazioni sono effettivamente visibili agli shader, fanno riferimento a heap del [descrittore visibile dello shader](shader-visible-descriptor-heaps.md) e [heap dei descrittori non shader visibili](non-shader-visible-descriptor-heaps.md).</span><span class="sxs-lookup"><span data-stu-id="af169-153">Only the first four of these views are actually visible to shaders, refer to [Shader Visible Descriptor Heaps](shader-visible-descriptor-heaps.md) and [Non Shader Visible Descriptor Heaps](non-shader-visible-descriptor-heaps.md).</span></span>

## <a name="resource-binding-flow-of-control"></a><span data-ttu-id="af169-154">Flusso di associazione di risorse del controllo</span><span class="sxs-lookup"><span data-stu-id="af169-154">Resource Binding Flow of Control</span></span>

<span data-ttu-id="af169-155">Concentrandosi solo sulle firme radice, i descrittori radice, le costanti radice, le tabelle dei descrittori e gli heap dei descrittori, il flusso della logica di rendering per un'app dovrebbe essere simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="af169-155">Focusing just on root signatures, root descriptors, root constants, descriptor tables, and descriptor heaps, the flow of rendering logic for an app should be similar to the following:</span></span>

-   <span data-ttu-id="af169-156">Creare uno o più oggetti firma radice, uno per ogni diversa configurazione di binding necessaria per un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="af169-156">Create one or more root signature objects – one for every different binding configuration an application needs.</span></span>
-   <span data-ttu-id="af169-157">Creare shader e lo stato della pipeline con gli oggetti firma radice con cui verranno utilizzati.</span><span class="sxs-lookup"><span data-stu-id="af169-157">Create shaders and pipeline state with the root signature objects they will be used with.</span></span>
-   <span data-ttu-id="af169-158">Crearne uno (o, se necessario, più) heap dei descrittori che conterranno tutti i descrittori SRV, UAV e CBV per ogni frame di rendering.</span><span class="sxs-lookup"><span data-stu-id="af169-158">Create one (or, if necessary, more) descriptor heaps that will contain all the SRV, UAV, and CBV descriptors for each frame of rendering.</span></span>
-   <span data-ttu-id="af169-159">Inizializzare gli heap dei descrittori con i descrittori laddove possibile per i set di descrittori che verranno riutilizzati in molti frame.</span><span class="sxs-lookup"><span data-stu-id="af169-159">Initialize the descriptor heap(s) with descriptors where possible for sets of descriptors that will be reused across many frames.</span></span>
-   <span data-ttu-id="af169-160">Per ogni fotogramma di cui eseguire il rendering:</span><span class="sxs-lookup"><span data-stu-id="af169-160">For each frame to be rendered:</span></span>
    -   <span data-ttu-id="af169-161">Per ogni elenco di comandi:</span><span class="sxs-lookup"><span data-stu-id="af169-161">For each command list:</span></span>
        -   <span data-ttu-id="af169-162">Impostare la firma radice corrente da usare e modificare se necessario durante il rendering, che è raramente necessario.</span><span class="sxs-lookup"><span data-stu-id="af169-162">Set the current root signature to use (and change if needed during rendering – which is rarely required).</span></span>
        -   <span data-ttu-id="af169-163">Aggiornare le costanti della firma radice e/o i descrittori di firma radice per la nuova vista, ad esempio le proiezioni del mondo/visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="af169-163">Update some root signature’s constants and/or root signature descriptors for the new view (such as world/view projections).</span></span>
        -   <span data-ttu-id="af169-164">Per ogni elemento da creare:</span><span class="sxs-lookup"><span data-stu-id="af169-164">For each item to draw:</span></span>
            -   <span data-ttu-id="af169-165">Definire tutti i nuovi descrittori negli heap del descrittore in base alle esigenze per il rendering per oggetto.</span><span class="sxs-lookup"><span data-stu-id="af169-165">Define any new descriptors in descriptor heaps as needed for per-object rendering.</span></span> <span data-ttu-id="af169-166">Per gli heap dei descrittori visibili allo shader, l'app deve assicurarsi di usare lo spazio dell'heap dei descrittori a cui non è già stato fatto riferimento mediante il rendering che potrebbe essere in corso, ad esempio l'allocazione lineare dello spazio attraverso l'heap del descrittore durante il rendering.</span><span class="sxs-lookup"><span data-stu-id="af169-166">For shader-visible descriptor heaps, the app must make sure to use descriptor heap space that isn’t already being referenced by rendering that could be in flight – for example, linearly allocating space through the descriptor heap during rendering.</span></span>
            -   <span data-ttu-id="af169-167">Aggiornare la firma radice con i puntatori alle aree richieste degli heap del descrittore.</span><span class="sxs-lookup"><span data-stu-id="af169-167">Update the root signature with pointers to the required regions of the descriptor heaps.</span></span> <span data-ttu-id="af169-168">Una tabella dei descrittori, ad esempio, può puntare ad alcuni descrittori statici (non modificabili) inizializzati in precedenza, mentre un'altra tabella descrittore può puntare ad alcuni descrittori dinamici configurati per il rendering corrente.</span><span class="sxs-lookup"><span data-stu-id="af169-168">For example, one descriptor table might point to some static (unchanging) descriptors initialized earlier, while another descriptor table might point to some dynamic descriptors configured for the current rendering.</span></span>
            -   <span data-ttu-id="af169-169">Aggiornare alcune costanti della firma radice e/o descrittori di firma radice per il rendering per singolo elemento.</span><span class="sxs-lookup"><span data-stu-id="af169-169">Update some root signature’s constants and/or root signature descriptors for per-item rendering.</span></span>
            -   <span data-ttu-id="af169-170">Impostare lo stato della pipeline per l'elemento da creare (solo se è necessario modificare), compatibile con la firma radice attualmente associata.</span><span class="sxs-lookup"><span data-stu-id="af169-170">Set the pipeline state for the item to draw (only if change needed), compatible with the currently bound root signature.</span></span>
            -   <span data-ttu-id="af169-171">Disegna</span><span class="sxs-lookup"><span data-stu-id="af169-171">Draw</span></span>
        -   <span data-ttu-id="af169-172">Repeat (elemento successivo)</span><span class="sxs-lookup"><span data-stu-id="af169-172">Repeat (next item)</span></span>
    -   <span data-ttu-id="af169-173">Repeat (elenco dei comandi successivi)</span><span class="sxs-lookup"><span data-stu-id="af169-173">Repeat (next command list)</span></span>
    -   <span data-ttu-id="af169-174">In modo rigoroso al termine della GPU con la memoria che non verrà più usata, è possibile rilasciarla.</span><span class="sxs-lookup"><span data-stu-id="af169-174">Strictly when the GPU has finished with any memory that will no longer be used, it can be released.</span></span> <span data-ttu-id="af169-175">I riferimenti ai descrittori non devono essere eliminati se il rendering aggiuntivo che usa tali descrittori non viene inviato.</span><span class="sxs-lookup"><span data-stu-id="af169-175">Descriptors' references to it do not need to be deleted if additional rendering that uses those descriptors is not submitted.</span></span> <span data-ttu-id="af169-176">Il rendering successivo può quindi puntare ad altre aree negli heap del descrittore oppure è possibile sovrascrivere i descrittori non aggiornati con descrittori validi per riutilizzare lo spazio dell'heap del descrittore.</span><span class="sxs-lookup"><span data-stu-id="af169-176">So, subsequent rendering can point to other areas in descriptor heaps, or stale descriptors can be overwritten with valid descriptors to reuse the descriptor heap space.</span></span>
-   <span data-ttu-id="af169-177">Ripeti (fotogramma successivo)</span><span class="sxs-lookup"><span data-stu-id="af169-177">Repeat (next frame)</span></span>

<span data-ttu-id="af169-178">Si noti che altri tipi di descrittori, visualizzazioni di destinazione di rendering (RTVs), viste depth stencil (DSV), viste buffer index (IBVs), viste buffer vertex (VBVs) e visualizzazioni di oggetti shader (SOV) vengono gestiti in modo diverso.</span><span class="sxs-lookup"><span data-stu-id="af169-178">Note that other descriptor types, render target views (RTVs), depth stencil views (DSV), index buffer views (IBVs), vertex buffer views (VBVs), and shader object views (SOV), are managed differently.</span></span> <span data-ttu-id="af169-179">Il driver gestisce il controllo delle versioni del set di descrittori associato per ogni progetto durante la registrazione dell'elenco dei comandi (in modo analogo a come le associazioni della firma radice vengono sottoposte a controllo delle versioni dal driver o dall'hardware).</span><span class="sxs-lookup"><span data-stu-id="af169-179">The driver handles the versioning of the set of descriptors bound for each draw during recording of the command list (similar to how the root signature bindings are versioned by the hardware/driver).</span></span> <span data-ttu-id="af169-180">Questa operazione è diversa dal contenuto degli heap dei descrittori visibili dello shader, per i quali l'applicazione deve essere allocata manualmente attraverso l'heap, perché fa riferimento a descrittori diversi tra le estrazioni.</span><span class="sxs-lookup"><span data-stu-id="af169-180">This is different from the contents of shader-visible descriptor heaps, for which the application must manually allocate through the heap as it references different descriptors between draws.</span></span> <span data-ttu-id="af169-181">Il controllo delle versioni del contenuto dell'heap che è visibile allo shader viene lasciato all'applicazione perché consente alle applicazioni di eseguire operazioni come il riutilizzo dei descrittori che non cambiano. in alternativa, usare set statici di grandi dimensioni di descrittori e usare l'indicizzazione dello shader, ad esempio l'ID del materiale, per selezionare i descrittori da usare dall'heap del descrittore o usare combinazioni di tecniche per diversi set di descrittori.</span><span class="sxs-lookup"><span data-stu-id="af169-181">Versioning of heap content that is shader-visible is left to the application because it allows applications to do things like reuse descriptors that don’t change, or use large static sets of descriptors and use shader indexing (such as by material ID) to select descriptors to use from the descriptor heap, or use combinations of techniques for different sets of descriptors.</span></span> <span data-ttu-id="af169-182">L'hardware non è equipaggiato per gestire questo tipo di flessibilità per gli altri tipi di descrittori (RTV, DSV, IBV, VBV, SOV).</span><span class="sxs-lookup"><span data-stu-id="af169-182">The hardware isn’t equipped to handle this type of flexibility for the other descriptor types (RTV, DSV, IBV, VBV, SOV).</span></span>

## <a name="suballocation"></a><span data-ttu-id="af169-183">Sottoallocazione</span><span class="sxs-lookup"><span data-stu-id="af169-183">Suballocation</span></span>

<span data-ttu-id="af169-184">In Direct3D 12, l'app dispone di un controllo di basso livello sulla gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="af169-184">In Direct3D 12, the app has low-level control over memory management.</span></span> <span data-ttu-id="af169-185">Nelle versioni precedenti di Direct3D, incluso Direct3D 11, esiste un'allocazione per ogni risorsa.</span><span class="sxs-lookup"><span data-stu-id="af169-185">In earlier versions of Direct3D, including Direct3D 11, there would be one allocation per resource.</span></span> <span data-ttu-id="af169-186">In Direct3D 12, l'app può usare l'API per allocare un blocco di memoria di grandi dimensioni, più grande di qualsiasi singolo oggetto necessario.</span><span class="sxs-lookup"><span data-stu-id="af169-186">In Direct3D 12, the app can use the API to allocate a large block of memory, larger than any single object would need.</span></span> <span data-ttu-id="af169-187">Al termine dell'operazione, l'app può creare descrittori per puntare a sezioni del blocco di memoria di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="af169-187">After this is done, the app can create descriptors to point to sections of that large memory block.</span></span> <span data-ttu-id="af169-188">Questo processo di decidere cosa inserire dove (blocchi più piccoli all'interno del blocco di grandi dimensioni) è noto come *allocazione*.</span><span class="sxs-lookup"><span data-stu-id="af169-188">This process of deciding what to put where (smaller blocks inside the large block) is known as *suballocation*.</span></span> <span data-ttu-id="af169-189">Per consentire all'app di eseguire questa operazione, è possibile ottenere miglioramenti in termini di utilizzo efficiente di calcolo e memoria.</span><span class="sxs-lookup"><span data-stu-id="af169-189">Enabling the app to do this can yield gains in efficient use of computation and memory.</span></span> <span data-ttu-id="af169-190">Ad esempio, la ridenominazione delle risorse viene resa obsoleta.</span><span class="sxs-lookup"><span data-stu-id="af169-190">For example, resource renaming is rendered obsolete.</span></span> <span data-ttu-id="af169-191">Al posto di questo, le app possono usare le recinzioni per determinare quando viene usata una determinata risorsa e quando non si esegue la schermatura nelle esecuzioni dell'elenco di comandi in cui l'elenco dei comandi richiede l'uso di quella particolare risorsa.</span><span class="sxs-lookup"><span data-stu-id="af169-191">In place of this, apps can use fences to determine when a particular resource is being used and when it's not by fencing on command list executions where the command list requires the use of that particular resource.</span></span>

## <a name="freeing-resources"></a><span data-ttu-id="af169-192">Liberare risorse</span><span class="sxs-lookup"><span data-stu-id="af169-192">Freeing Resources</span></span>

<span data-ttu-id="af169-193">Prima di poter liberare la memoria associata alla pipeline, è necessario che la GPU sia terminata.</span><span class="sxs-lookup"><span data-stu-id="af169-193">Before any memory that has been bound to the pipeline can be freed, the GPU must be finished with it.</span></span>

<span data-ttu-id="af169-194">L'attesa del rendering del frame è probabilmente il modo più grossolano per assicurarsi che la GPU sia stata completata.</span><span class="sxs-lookup"><span data-stu-id="af169-194">Waiting for frame rendering is probably the coarsest way to be certain that the GPU has finished.</span></span> <span data-ttu-id="af169-195">A un livello più preciso, è possibile usare di nuovo le schermate, quando un comando viene registrato in un elenco di comandi di cui si vuole tenere traccia del completamento, inserire un limite immediatamente dopo.</span><span class="sxs-lookup"><span data-stu-id="af169-195">At a finer grain, you can again use fences—when a command is recorded into a command list that you want to track the completion of, insert a fence immediately after it.</span></span> <span data-ttu-id="af169-196">Quindi, è possibile eseguire diverse operazioni di sincronizzazione con la barriera.</span><span class="sxs-lookup"><span data-stu-id="af169-196">Then, you can do various synchronization operations with the fence.</span></span> <span data-ttu-id="af169-197">Si invia un nuovo lavoro (elenchi di comandi) che attende fino a quando non viene passato un limite specificato sulla GPU, che indica il completamento di tutti gli elementi prima che siano completati, oppure è possibile richiedere che venga generato un evento della CPU quando il limite viene superato (che l'app può attendere con un thread in sospensione).</span><span class="sxs-lookup"><span data-stu-id="af169-197">You submit new work (command lists) that waits until a specified fence has passed on the GPU, which indicates that everything before it is complete, or you can request that a CPU event be raised when the fence has passed (which the app can be waiting on with a sleeping thread).</span></span> <span data-ttu-id="af169-198">In Direct3D 11, era `EnqueueSetEvent` ().</span><span class="sxs-lookup"><span data-stu-id="af169-198">In Direct3D 11, this was `EnqueueSetEvent`().</span></span>

## <a name="related-topics"></a><span data-ttu-id="af169-199">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="af169-199">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="af169-200">Associazione di risorse</span><span class="sxs-lookup"><span data-stu-id="af169-200">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




