---
title: Modifiche importanti da Direct3D 11 a Direct3D 12
description: Direct3D 12 rappresenta una partenza significativa dal modello di programmazione Direct3D 11. Direct3D 12 consente alle app di avvicinarsi a hardware che mai.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548794"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="bc9e3-104">Modifiche importanti da Direct3D 11 a Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="bc9e3-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="bc9e3-105">Direct3D 12 rappresenta una partenza significativa dal modello di programmazione Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="bc9e3-106">Direct3D 12 consente alle app di avvicinarsi a hardware che mai.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="bc9e3-107">Grazie alla vicinanza all'hardware, Direct3D 12 è più veloce ed efficiente.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="bc9e3-108">Tuttavia, il compromesso dell'app con una maggiore velocità ed efficienza con Direct3D 12 è che si è responsabili di più attività rispetto a Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="bc9e3-109">Sincronizzazione esplicita</span><span class="sxs-lookup"><span data-stu-id="bc9e3-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="bc9e3-110">Gestione della residenza di memoria fisica</span><span class="sxs-lookup"><span data-stu-id="bc9e3-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="bc9e3-111">Oggetti stato della pipeline</span><span class="sxs-lookup"><span data-stu-id="bc9e3-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="bc9e3-112">Elenchi di comandi e bundle</span><span class="sxs-lookup"><span data-stu-id="bc9e3-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="bc9e3-113">Heap e tabelle descrittore</span><span class="sxs-lookup"><span data-stu-id="bc9e3-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="bc9e3-114">Porting da Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="bc9e3-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="bc9e3-115">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="bc9e3-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="bc9e3-116">Direct3D 12 è un ritorno alla programmazione di basso livello. offre un maggiore controllo sugli elementi grafici dei giochi e delle app introducendo queste nuove funzionalità: gli oggetti per rappresentare lo stato complessivo della pipeline, gli elenchi di comandi e le aggregazioni per l'invio del lavoro e gli heap e le tabelle dei descrittori per l'accesso alle risorse.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="bc9e3-117">L'app ha aumentato la velocità e l'efficienza con Direct3D 12, ma è responsabile di più attività rispetto a Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="bc9e3-118">Sincronizzazione esplicita</span><span class="sxs-lookup"><span data-stu-id="bc9e3-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="bc9e3-119">In Direct3D 12 la sincronizzazione della GPU CPU è ora la responsabilità esplicita dell'app e non viene più eseguita in modo implicito dal runtime, così come si trova in Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="bc9e3-120">Questo fatto significa anche che nessun controllo automatico dei rischi per la pipeline viene eseguito da Direct3D 12, di conseguenza si tratta della responsabilità delle app.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="bc9e3-121">In Direct3D 12, le app sono responsabili del pipelining degli aggiornamenti dei dati.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="bc9e3-122">Ovvero il modello "map/Lock-scarto" in Direct3D 11 deve essere eseguito manualmente in Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="bc9e3-123">In Direct3D 11, se la GPU usa ancora il buffer quando si chiama [**sul ID3D11DeviceContext:: Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) con lo [**\_ scarto di \_ scrittura \_ della mappa d3d11**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), il runtime restituisce un puntatore a una nuova area di memoria anziché ai dati del buffer obsoleti.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="bc9e3-124">Questo consente alla GPU di continuare a usare i dati obsoleti mentre l'app inserisce i dati nel nuovo buffer.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="bc9e3-125">Nell'app non è necessaria alcuna gestione della memoria aggiuntiva. il buffer precedente viene riutilizzato o eliminato automaticamente al termine della GPU.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="bc9e3-126">In Direct3D 12 tutti gli aggiornamenti dinamici, inclusi i buffer costanti, i buffer dei vertici dinamici, le trame dinamiche e così via, sono controllati in modo esplicito dall'app.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="bc9e3-127">Questi aggiornamenti dinamici includono eventuali barriere GPU o buffering necessari.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="bc9e3-128">L'app è responsabile della disponibilità della memoria fino a quando non è più necessaria.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="bc9e3-129">Direct3D 12 USA il conteggio dei riferimenti di tipo COM solo per la durata delle interfacce, usando il modello di riferimento debole di Direct3D associato alla durata del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="bc9e3-130">Tutte le durate della memoria della risorsa e della descrizione sono l'unica responsabilità dell'app di mantenere la durata appropriata e non vengono conteggiati i riferimenti.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="bc9e3-131">Direct3D 11 utilizza il conteggio dei riferimenti per gestire anche la durata delle dipendenze di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="bc9e3-132">Gestione della residenza di memoria fisica</span><span class="sxs-lookup"><span data-stu-id="bc9e3-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="bc9e3-133">Un'applicazione Direct3D 12 deve impedire race condition tra più code, più adapter e i thread della CPU.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="bc9e3-134">D3D12 non Sincronizza più la CPU e la GPU, né supporta meccanismi pratici per la ridenominazione delle risorse o il multibuffering.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="bc9e3-135">È necessario usare i limiti per evitare che più unità di elaborazione sovrascrivano la memoria prima che un'altra unità di elaborazione lo usi.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="bc9e3-136">L'applicazione Direct3D 12 deve garantire che i dati siano residenti in memoria mentre vengono letti dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="bc9e3-137">La memoria utilizzata da ogni oggetto viene resa residente durante la creazione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="bc9e3-138">Le applicazioni che chiamano questi metodi devono usare le schermate per assicurarsi che la GPU non acceda a oggetti rimossi.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="bc9e3-139">Le barriere delle risorse sono un altro tipo di sincronizzazione necessario, usato per sincronizzare le transizioni di risorse e risorse a un livello estremamente granulare.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="bc9e3-140">Vedere [gestione della memoria in Direct3D 12](memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="bc9e3-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="bc9e3-141">Oggetti stato della pipeline</span><span class="sxs-lookup"><span data-stu-id="bc9e3-141">Pipeline state objects</span></span>

<span data-ttu-id="bc9e3-142">Direct3D 11 consente la manipolazione dello stato della pipeline tramite un ampio set di oggetti indipendenti.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="bc9e3-143">Ad esempio, lo stato dell'assembler di input, lo stato pixel shader, lo stato di rasterizzazione e lo stato di Unione di output possono essere tutti modificati in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="bc9e3-144">Questa progettazione offre una rappresentazione comoda e relativamente generale della pipeline grafica, ma non usa le funzionalità dell'hardware moderno, principalmente perché i vari Stati sono spesso interdipendenti.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="bc9e3-145">Molte GPU, ad esempio, combinano pixel shader e lo stato di Unione dell'output in una singola rappresentazione hardware.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="bc9e3-146">Tuttavia, poiché l'API Direct3D 11 consente di impostare le fasi della pipeline separatamente, il driver di visualizzazione non riesce a risolvere i problemi di stato della pipeline fino a quando lo stato non viene finalizzato, che non è fino al momento dell'estrazione.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="bc9e3-147">Questo schema ritarda la configurazione dello stato dell'hardware, ovvero un sovraccarico aggiuntivo e un minor numero massimo di chiamate di disegno per fotogramma.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="bc9e3-148">Direct3D 12 risolve questo schema unificando la maggior parte dello stato della pipeline in oggetti di stato della pipeline non modificabili (PSO), che vengono finalizzati al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="bc9e3-149">L'hardware e i driver possono quindi convertire immediatamente il PSO in tutte le istruzioni native hardware e lo stato necessario per eseguire il lavoro della GPU.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="bc9e3-150">È comunque possibile modificare in modo dinamico quale PSO è in uso, ma a tale scopo, l'hardware deve solo copiare la quantità minima di stato pre-calcolato direttamente nei registri hardware, anziché calcolare lo stato dell'hardware in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="bc9e3-151">Usando PSO, il sovraccarico delle chiamate di progetto viene ridotto in modo significativo e molte altre chiamate di progetto possono verificarsi per ogni fotogramma.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="bc9e3-152">Per altre informazioni su PSO, vedere [gestione dello stato della pipeline grafica in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="bc9e3-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="bc9e3-153">Elenchi di comandi e bundle</span><span class="sxs-lookup"><span data-stu-id="bc9e3-153">Command lists and bundles</span></span>

<span data-ttu-id="bc9e3-154">In Direct3D 11 tutti gli invii di lavoro vengono eseguiti tramite il [contesto immediato](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), che rappresenta un singolo flusso di comandi che passano alla GPU.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="bc9e3-155">Per ottenere il ridimensionamento multithreading, i giochi hanno anche [contesti posticipati](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) disponibili.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="bc9e3-156">I contesti posticipati in Direct3D 11 non vengono mappati perfettamente all'hardware, quindi è possibile eseguire un lavoro relativamente ridotto.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="bc9e3-157">Direct3D 12 introduce un nuovo modello per l'invio di lavoro in base agli elenchi di comandi che contengono tutte le informazioni necessarie per eseguire un determinato carico di lavoro sulla GPU.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="bc9e3-158">Ogni nuovo elenco di comandi contiene informazioni quali il PSO da usare, le risorse di trama e buffer necessarie e gli argomenti per tutte le chiamate di creazione.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="bc9e3-159">Poiché ogni elenco di comandi è autonomo e non eredita alcuno stato, il driver è in grado di pre-calcolare tutti i comandi GPU necessari in primo piano e in modalità a thread libero.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="bc9e3-160">L'unico processo seriale necessario è l'invio finale degli elenchi di comandi alla GPU tramite la coda dei comandi.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="bc9e3-161">Oltre agli elenchi di comandi, Direct3D 12 introduce anche un secondo livello di pre-calcolo del lavoro: *bundle*.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="bc9e3-162">A differenza degli elenchi di comandi, che sono completamente autonomi e vengono in genere costruiti, inviati una sola volta ed eliminati, i bundle forniscono una forma di ereditarietà dello stato che consente il riutilizzo.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="bc9e3-163">Se, ad esempio, un gioco vuole creare due modelli di caratteri con diverse trame, un approccio consiste nel registrare un elenco di comandi con due set di chiamate di traccia identiche.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="bc9e3-164">Un altro approccio consiste nel "registrare" un bundle che disegna un singolo modello di caratteri, quindi "riprodurre" il bundle due volte nell'elenco dei comandi usando risorse diverse.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="bc9e3-165">Nel secondo caso, il driver di visualizzazione deve solo calcolare le istruzioni appropriate una sola volta e la creazione dell'elenco di comandi essenzialmente equivale a due chiamate di funzione a basso costo.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="bc9e3-166">Per altre informazioni sugli elenchi di comandi e sui bundle, vedere [lavoro di invio in Direct3D 12](command-queues-and-command-lists.md).</span><span class="sxs-lookup"><span data-stu-id="bc9e3-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="bc9e3-167">Heap e tabelle descrittore</span><span class="sxs-lookup"><span data-stu-id="bc9e3-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="bc9e3-168">Il binding di risorse in Direct3D 11 è altamente astratto e pratico, ma lascia molte funzionalità hardware moderne sottoutilizzate.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="bc9e3-169">In Direct3D 11 i giochi creano oggetti *visualizzazione* delle risorse, quindi associano tali viste a diversi *slot* in varie fasi dello shader della pipeline.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="bc9e3-170">Gli shader, a loro volta, leggono i dati da tali slot di binding espliciti, che vengono corretti in fase di estrazione.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="bc9e3-171">Questo modello significa che ogni volta che un gioco viene disegnato usando risorse diverse, deve riassociare diverse visualizzazioni a slot diversi e chiamare di nuovo il metodo di creazione.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="bc9e3-172">Questo caso rappresenta anche un sovraccarico che può essere eliminato usando completamente le funzionalità hardware moderne.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="bc9e3-173">Direct3D 12 modifica il modello di binding in modo che corrisponda all'hardware moderno e migliora significativamente le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="bc9e3-174">Anziché richiedere visualizzazioni di risorse autonome e mapping esplicito agli slot, Direct3D 12 fornisce un heap dei descrittori in cui i giochi creano le varie visualizzazioni di risorse.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="bc9e3-175">Questo schema fornisce un meccanismo che consente alla GPU di scrivere direttamente la descrizione della risorsa nativa hardware (descrittore) in memoria in primo piano.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="bc9e3-176">Per dichiarare quali risorse devono essere usate dalla pipeline per una determinata chiamata di progetto, i giochi specificano una o più tabelle descrittore che rappresentano intervalli secondari dell'heap completo del descrittore.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="bc9e3-177">Poiché l'heap del descrittore è già stato popolato con i dati appropriati del descrittore specifico dell'hardware, la modifica delle tabelle dei descrittori è un'operazione estremamente a basso costo.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="bc9e3-178">Oltre alle prestazioni migliorate offerte dagli heap e dalle tabelle dei descrittori, Direct3D 12 consente anche di indicizzare dinamicamente le risorse in shader, che offrono una flessibilità senza precedenti e sbloccano nuove tecniche di rendering.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="bc9e3-179">Ad esempio, i motori di rendering posticipati moderni in genere codificano un identificatore di materiale o di oggetto di qualche tipo nel buffer g intermedio.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="bc9e3-180">In Direct3D 11, questi motori devono prestare attenzione a evitare di usare troppi materiali, in quanto l'inclusione di troppi in un g-buffer può rallentare significativamente il passaggio di rendering finale.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="bc9e3-181">Con le risorse indicizzabili in modo dinamico, una scena con migliaia di materiali può essere finalizzata con la stessa rapidità di una con soli dieci.</span><span class="sxs-lookup"><span data-stu-id="bc9e3-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="bc9e3-182">Per ulteriori informazioni sugli heap e le tabelle dei descrittori, vedere [associazione di risorse](resource-binding.md)e [differenze nel modello di associazione da Direct3D 11](binding-model.md).</span><span class="sxs-lookup"><span data-stu-id="bc9e3-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="bc9e3-183">Porting da Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="bc9e3-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="bc9e3-184">Il porting da Direct3D 11 è un processo necessario, descritto in [porting da Direct3D 11 a Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="bc9e3-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="bc9e3-185">Vedere anche l'intervallo di opzioni disponibili in [utilizzo di Direct3D 11, Direct3D 10 e Direct2D](direct3d-12-interop.md).</span><span class="sxs-lookup"><span data-stu-id="bc9e3-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="bc9e3-186">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="bc9e3-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="bc9e3-187">Informazioni su Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="bc9e3-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 