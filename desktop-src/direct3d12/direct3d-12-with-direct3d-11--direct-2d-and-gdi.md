---
title: Interoperabilità di Direct3D 12
description: D3D12 può essere usato per scrivere applicazioni con componenti.
ms.assetid: 51F7E715-82B6-48D8-A06A-CBBEDF6968F5
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3b5fcfe2adf756c12f034031675d0c3ac5571b44
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548892"
---
# <a name="direct3d-12-interop"></a><span data-ttu-id="30184-103">Interoperabilità di Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="30184-103">Direct3D 12 interop</span></span>

<span data-ttu-id="30184-104">D3D12 può essere usato per scrivere applicazioni con componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-104">D3D12 can be used to write componentized applications.</span></span>

-   [<span data-ttu-id="30184-105">Panoramica dell'interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-105">Interop overview</span></span>](#interop-overview)
-   [<span data-ttu-id="30184-106">Motivi per l'utilizzo dell'interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-106">Reasons for using interop</span></span>](#reasons-for-using-interop)
    -   [<span data-ttu-id="30184-107">Condivisione di un elenco di comandi</span><span class="sxs-lookup"><span data-stu-id="30184-107">Sharing a command list</span></span>](#sharing-a-command-list)
    -   [<span data-ttu-id="30184-108">Condivisione di una coda di comandi</span><span class="sxs-lookup"><span data-stu-id="30184-108">Sharing a command queue</span></span>](#sharing-a-command-queue)
    -   [<span data-ttu-id="30184-109">Condivisione delle primitive di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="30184-109">Sharing sync primitives</span></span>](#sharing-sync-primitives)
    -   [<span data-ttu-id="30184-110">Condivisione di risorse</span><span class="sxs-lookup"><span data-stu-id="30184-110">Sharing resources</span></span>](#sharing-resources)
    -   [<span data-ttu-id="30184-111">Scelta di un modello di interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-111">Choosing an interop model</span></span>](#choosing-an-interop-model)
-   [<span data-ttu-id="30184-112">API di interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-112">Interop APIs</span></span>](#interop-apis)
-   [<span data-ttu-id="30184-113">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="30184-113">Related topics</span></span>](#related-topics)

## <a name="interop-overview"></a><span data-ttu-id="30184-114">Panoramica dell'interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-114">Interop overview</span></span>

<span data-ttu-id="30184-115">D3D12 può essere molto potente e consentire alle applicazioni di scrivere codice grafico con efficienza simile a console, ma non tutte le applicazioni devono riinventare la ruota e scrivere completamente il motore di rendering da zero.</span><span class="sxs-lookup"><span data-stu-id="30184-115">D3D12 can be very powerful, and allow applications to write graphics code with console-like efficiency, but not every application needs to reinvent the wheel and write the entirety of their rendering engine from scratch.</span></span> <span data-ttu-id="30184-116">In alcuni casi, un altro componente o libreria ha già eseguito una soluzione migliore o, in altri casi, le prestazioni di una parte di codice non sono cruciali come la correttezza e la leggibilità.</span><span class="sxs-lookup"><span data-stu-id="30184-116">In some cases, another component or library has already done it better, or in other cases, the performance of a portion of code is not as critical as its correctness and readability.</span></span>

<span data-ttu-id="30184-117">In questa sezione vengono descritte le tecniche di interoperabilità seguenti:</span><span class="sxs-lookup"><span data-stu-id="30184-117">This section covers the following interop techniques:</span></span>

-   <span data-ttu-id="30184-118">D3D12 e D3D12 nello stesso dispositivo</span><span class="sxs-lookup"><span data-stu-id="30184-118">D3D12 and D3D12, on the same device</span></span>
-   <span data-ttu-id="30184-119">D3D12 e D3D12 in dispositivi diversi</span><span class="sxs-lookup"><span data-stu-id="30184-119">D3D12 and D3D12, on different devices</span></span>
-   <span data-ttu-id="30184-120">D3D12 e qualsiasi combinazione di D3D11, D3D10 o D2D nello stesso dispositivo</span><span class="sxs-lookup"><span data-stu-id="30184-120">D3D12 and any combination of D3D11, D3D10, or D2D, on the same device</span></span>
-   <span data-ttu-id="30184-121">D3D12 e qualsiasi combinazione di D3D11, D3D10 o D2D in dispositivi diversi</span><span class="sxs-lookup"><span data-stu-id="30184-121">D3D12 and any combination of D3D11, D3D10, or D2D, on different devices</span></span>
-   <span data-ttu-id="30184-122">D3D12 e GDI oppure D3D12 e D3D11 e GDI</span><span class="sxs-lookup"><span data-stu-id="30184-122">D3D12 and GDI, or D3D12 and D3D11 and GDI</span></span>

## <a name="reasons-for-using-interop"></a><span data-ttu-id="30184-123">Motivi per l'utilizzo dell'interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-123">Reasons for using interop</span></span>

<span data-ttu-id="30184-124">Ci sono diversi motivi per cui un'applicazione potrebbe volere D3D12 l'interoperabilità con altre API.</span><span class="sxs-lookup"><span data-stu-id="30184-124">There are several reasons an application would want D3D12 interop with other APIs.</span></span> <span data-ttu-id="30184-125">Di seguito alcuni esempi:</span><span class="sxs-lookup"><span data-stu-id="30184-125">Some examples:</span></span>

-   <span data-ttu-id="30184-126">Porting incrementale: si desidera trasferire un'intera applicazione da D3D10 o da D3D11 a D3D12, pur avendola funzionale a fasi intermedie del processo di porting (per abilitare il test e il debug).</span><span class="sxs-lookup"><span data-stu-id="30184-126">Incremental porting: wanting to port an entire application from D3D10 or D3D11 to D3D12, while having it functional at intermediate stages of the porting process (to enable testing and debugging).</span></span>
-   <span data-ttu-id="30184-127">Codice della casella nera: se si vuole lasciare una parte specifica di un'applicazione così com'è, durante il porting del resto del codice.</span><span class="sxs-lookup"><span data-stu-id="30184-127">Black box code: wanting to leave a particular portion of an application as-is while porting the rest of the code.</span></span> <span data-ttu-id="30184-128">Ad esempio, potrebbe non essere necessario trasferire gli elementi dell'interfaccia utente di un gioco.</span><span class="sxs-lookup"><span data-stu-id="30184-128">For example, there might be no need to port UI elements of a game.</span></span>
-   <span data-ttu-id="30184-129">Componenti non modificabili: è necessario usare i componenti che non sono di proprietà dell'applicazione, che non vengono scritti nei D3D12 di destinazione.</span><span class="sxs-lookup"><span data-stu-id="30184-129">Unchangeable components: needing to use components which are not owned by the application, which are not written to target D3D12.</span></span>
-   <span data-ttu-id="30184-130">Un nuovo componente: se non si vuole trasferire l'intera applicazione, ma si vuole usare un nuovo componente scritto con D3D12.</span><span class="sxs-lookup"><span data-stu-id="30184-130">A new component: not wanting to port the entire application, but wanting to use a new component which is written using D3D12.</span></span>

<span data-ttu-id="30184-131">Sono disponibili quattro tecniche principali per l'interoperabilità in D3D12:</span><span class="sxs-lookup"><span data-stu-id="30184-131">There are four main techniques for interop in D3D12:</span></span>

-   <span data-ttu-id="30184-132">Un'app può scegliere di fornire un elenco di comandi aperti a un componente, che registra alcuni comandi di rendering aggiuntivi in una destinazione di rendering già associata.</span><span class="sxs-lookup"><span data-stu-id="30184-132">An app can choose to provide an open command list to a component, which records some additional rendering commands to an already-bound render target.</span></span> <span data-ttu-id="30184-133">Questa operazione equivale a fornire un contesto di dispositivo preparato a un altro componente in D3D11 ed è ideale per elementi come l'aggiunta di interfaccia utente/testo a un buffer nascosto già associato.</span><span class="sxs-lookup"><span data-stu-id="30184-133">This is equivalent to providing a prepared device context to another component in D3D11, and is great for things like adding UI/text to an already bound back buffer.</span></span>
-   <span data-ttu-id="30184-134">Un'app può scegliere di fornire una coda di comandi a un componente, insieme a una risorsa di destinazione desiderata.</span><span class="sxs-lookup"><span data-stu-id="30184-134">An app can choose to provide a command queue to a component, along with a desired destination resource.</span></span> <span data-ttu-id="30184-135">Questa operazione equivale a usare le API [**ClearState**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) o [**DeviceContextState**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) in D3D11 per fornire un contesto di dispositivo pulito a un altro componente.</span><span class="sxs-lookup"><span data-stu-id="30184-135">This is equivalent to using [**ClearState**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) or [**DeviceContextState**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) APIs in D3D11 to provide a clean device context to another component.</span></span> <span data-ttu-id="30184-136">Questo è il funzionamento dei componenti come D2D.</span><span class="sxs-lookup"><span data-stu-id="30184-136">This is how components like D2D operate.</span></span>
-   <span data-ttu-id="30184-137">Un componente può optare per un modello in cui produce un elenco di comandi, potenzialmente in parallelo, che l'app è responsabile dell'invio in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="30184-137">A component may opt for a model where it produces a command list, potentially in parallel, which the app is responsible for submission at a later time.</span></span> <span data-ttu-id="30184-138">È necessario fornire almeno una risorsa tra i limiti dei componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-138">At least one resource must be provided across component boundaries.</span></span> <span data-ttu-id="30184-139">Questa stessa tecnica è disponibile in D3D11 usando contesti posticipati, sebbene le prestazioni in D3D12 siano più desiderate.</span><span class="sxs-lookup"><span data-stu-id="30184-139">This same technique is available in D3D11 using deferred contexts, though the performance in D3D12 is more desirable.</span></span>
-   <span data-ttu-id="30184-140">Ogni componente ha le proprie code e/o i dispositivi e l'app e i componenti devono condividere le risorse e le informazioni di sincronizzazione tra i limiti dei componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-140">Each component has its own queue(s) and/or device(s), and the app and components need to share resources and synchronization information across component boundaries.</span></span> <span data-ttu-id="30184-141">Si tratta di un aspetto simile a quello legacy `ISurfaceQueue` e alla [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex)più moderna.</span><span class="sxs-lookup"><span data-stu-id="30184-141">This is similar to the legacy `ISurfaceQueue`, and the more modern [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex).</span></span>

<span data-ttu-id="30184-142">Le differenze tra questi scenari sono esattamente condivise tra i limiti dei componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-142">The differences between these scenarios is what exactly is shared between the component boundaries.</span></span> <span data-ttu-id="30184-143">Si presuppone che il dispositivo sia condiviso, ma poiché è fondamentalmente senza stato, non è rilevante.</span><span class="sxs-lookup"><span data-stu-id="30184-143">The device is assumed to be shared, but since it is basically stateless, it is not really relevant.</span></span> <span data-ttu-id="30184-144">Gli oggetti chiave sono l'elenco dei comandi, la coda dei comandi, gli oggetti di sincronizzazione e le risorse.</span><span class="sxs-lookup"><span data-stu-id="30184-144">The key objects are the command list, the command queue, the sync objects, and the resources.</span></span> <span data-ttu-id="30184-145">Ognuna di queste presenta complicazioni durante la condivisione.</span><span class="sxs-lookup"><span data-stu-id="30184-145">Each of these have their own complications when sharing them.</span></span>

### <a name="sharing-a-command-list"></a><span data-ttu-id="30184-146">Condivisione di un elenco di comandi</span><span class="sxs-lookup"><span data-stu-id="30184-146">Sharing a command list</span></span>

<span data-ttu-id="30184-147">Per il metodo di interoperabilità più semplice è necessario condividere solo un elenco di comandi con una parte del motore.</span><span class="sxs-lookup"><span data-stu-id="30184-147">The simplest method of interop requires sharing only a command list with a portion of the engine.</span></span> <span data-ttu-id="30184-148">Una volta completate le operazioni di rendering, la proprietà dell'elenco dei comandi torna al chiamante.</span><span class="sxs-lookup"><span data-stu-id="30184-148">Once the rendering operations have completed, the command list ownership goes back to the caller.</span></span> <span data-ttu-id="30184-149">La proprietà dell'elenco di comandi può essere tracciata attraverso lo stack.</span><span class="sxs-lookup"><span data-stu-id="30184-149">The ownership of the command list can be traced through the stack.</span></span> <span data-ttu-id="30184-150">Poiché gli elenchi di comandi sono a thread singolo, un'app non è in grado di eseguire un'operazione univoca o innovativa utilizzando questa tecnica.</span><span class="sxs-lookup"><span data-stu-id="30184-150">Since command lists are single threaded, there’s no way for an app to do something unique or innovative using this technique.</span></span>

### <a name="sharing-a-command-queue"></a><span data-ttu-id="30184-151">Condivisione di una coda di comandi</span><span class="sxs-lookup"><span data-stu-id="30184-151">Sharing a command queue</span></span>

<span data-ttu-id="30184-152">Probabilmente la tecnica più comune per più componenti che condividono un dispositivo nello stesso processo.</span><span class="sxs-lookup"><span data-stu-id="30184-152">Probably the most common technique for multiple components sharing a device in the same process.</span></span>

<span data-ttu-id="30184-153">Quando la coda dei comandi è l'unità di condivisione, è necessario effettuare una chiamata al componente per informare che tutti gli elenchi di comandi in attesa devono essere inviati immediatamente alla coda dei comandi (ed è necessario sincronizzare tutte le code dei comandi interni).</span><span class="sxs-lookup"><span data-stu-id="30184-153">When the command queue is the unit of sharing, there needs to be a call to the component to let it know that all outstanding command lists need to be submitted to the command queue immediately (and any internal command queues need to be synchronized).</span></span> <span data-ttu-id="30184-154">Questa operazione equivale all'API di [**scaricamento**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) d3d11 ed è l'unico modo in cui l'applicazione può inviare i propri elenchi di comandi o le primitive di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="30184-154">This is equivalent to the D3D11 [**Flush**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) API, and is the only way that the application can submit its own command lists or sync primitives.</span></span>

### <a name="sharing-sync-primitives"></a><span data-ttu-id="30184-155">Condivisione delle primitive di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="30184-155">Sharing sync primitives</span></span>

<span data-ttu-id="30184-156">Il modello previsto per un componente che opera nei propri dispositivi e/o nelle code dei comandi consiste nell'accettare un handle condiviso o [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) e la coppia UInt64 al momento dell'inizio del lavoro, il quale rimarrà in attesa e quindi un secondo handle ID3D12Fence o Shared e la coppia UInt64 che segnalerà al termine di tutto il lavoro.</span><span class="sxs-lookup"><span data-stu-id="30184-156">The expected pattern for a component which operates on its own devices and/or command queues will be to accept an [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) or shared handle, and UINT64 pair upon beginning its work, which it will wait on, and then a second ID3D12Fence or shared handle, and UINT64 pair which it will signal when all work is complete.</span></span> <span data-ttu-id="30184-157">Questo modello corrisponde all'implementazione corrente di [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) e della progettazione della sincronizzazione del modello di sincronizzazione di DWM/dxgi.</span><span class="sxs-lookup"><span data-stu-id="30184-157">This pattern matches the current implementation of both [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) and the DWM/DXGI flip model synchronization design.</span></span>

### <a name="sharing-resources"></a><span data-ttu-id="30184-158">Condivisione di risorse</span><span class="sxs-lookup"><span data-stu-id="30184-158">Sharing resources</span></span>

<span data-ttu-id="30184-159">La parte più complessa della scrittura di un'app D3D12 che sfrutta più componenti è la modalità di gestione delle risorse condivise tra i limiti dei componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-159">By far the most complicated part of writing a D3D12 app which leverages multiple components is how to deal with the resources which are shared across component boundaries.</span></span> <span data-ttu-id="30184-160">Ciò è dovuto principalmente al concetto di stato delle risorse.</span><span class="sxs-lookup"><span data-stu-id="30184-160">This is mostly due to the concept of resource states.</span></span> <span data-ttu-id="30184-161">Sebbene alcuni aspetti della progettazione dello stato delle risorse siano progettati per gestire la sincronizzazione all'interno dell'elenco dei comandi, altri hanno un impatto tra gli elenchi di comandi, influiscono sul layout delle risorse e sui set di operazioni validi o sulle caratteristiche delle prestazioni di accesso ai dati della risorsa.</span><span class="sxs-lookup"><span data-stu-id="30184-161">While some aspects of the resource state design are meant to deal with intra-command-list synchronization, others do have impact between command lists, affecting resource layout and either valid sets of operations or performance characteristics of accessing the resource data.</span></span>

<span data-ttu-id="30184-162">Esistono due modelli di gestione di questa complicazione, che coinvolgono essenzialmente un contratto tra i componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-162">There are two patterns of dealing with this complication, both of which involve essentially a contract between components.</span></span>

-   <span data-ttu-id="30184-163">Il contratto può essere definito dallo sviluppatore del componente e documentato.</span><span class="sxs-lookup"><span data-stu-id="30184-163">The contract can be defined by the component developer and documented.</span></span> <span data-ttu-id="30184-164">Questa operazione può essere semplice quanto "la risorsa deve essere nello stato predefinito quando il lavoro viene avviato e verrà rimessa nello stato predefinito quando il lavoro viene eseguito" o potrebbe avere regole più complesse per consentire elementi come la condivisione di un buffer di profondità senza forzare la risoluzione della profondità intermedia.</span><span class="sxs-lookup"><span data-stu-id="30184-164">This could be as simple as “the resource must be in the default state when work is started, and will be put back in the default state when work is done” or could have more complicated rules to allow things like sharing a depth buffer without forcing intermediate depth resolves.</span></span>
-   <span data-ttu-id="30184-165">Il contratto può essere definito dall'applicazione in fase di esecuzione, nel momento in cui la risorsa viene condivisa tra i limiti dei componenti.</span><span class="sxs-lookup"><span data-stu-id="30184-165">The contract can be defined by the application at runtime, at the time when the resource is shared across component boundaries.</span></span> <span data-ttu-id="30184-166">È costituito dalle stesse due informazioni: lo stato in cui si troverà la risorsa quando il componente inizia a utilizzarlo e lo stato in cui il componente deve lasciarlo al termine dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="30184-166">It consists of the same two pieces of information – the state the resource will be in when the component starts using it, and the state the component should leave it in when it finishes.</span></span>

### <a name="choosing-an-interop-model"></a><span data-ttu-id="30184-167">Scelta di un modello di interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-167">Choosing an interop model</span></span>

<span data-ttu-id="30184-168">Per la maggior parte delle applicazioni D3D12, la condivisione di una coda di comandi è probabilmente il modello ideale.</span><span class="sxs-lookup"><span data-stu-id="30184-168">For most D3D12 applications, sharing a command queue is probably the ideal model.</span></span> <span data-ttu-id="30184-169">Consente di completare la proprietà della creazione e dell'invio del lavoro, senza l'overhead aggiuntivo della memoria dovuto alla presenza di code ridondanti e senza l'impatto sulle prestazioni delle primitive di sincronizzazione della GPU.</span><span class="sxs-lookup"><span data-stu-id="30184-169">It allows complete ownership of work creation and submission, without the additional memory overhead from having redundant queues, and without the perf impact of dealing with the GPU sync primitives.</span></span>

<span data-ttu-id="30184-170">La condivisione delle primitive di sincronizzazione è necessaria quando i componenti devono gestire diverse proprietà della coda, ad esempio il tipo o la priorità, oppure quando la condivisione deve estendere i limiti del processo.</span><span class="sxs-lookup"><span data-stu-id="30184-170">Sharing sync primitives is required once the components need to deal with different queue properties, such as type or priority, or once the sharing needs to span process boundaries.</span></span>

<span data-ttu-id="30184-171">La condivisione o la produzione di elenchi di comandi non è ampiamente usata esternamente da componenti di terze parti, ma può essere ampiamente usata nei componenti interni a un motore di gioco.</span><span class="sxs-lookup"><span data-stu-id="30184-171">Sharing or producing command lists are not widely used externally by third party components, but might be widely used in components which are internal to a game engine.</span></span>

## <a name="interop-apis"></a><span data-ttu-id="30184-172">API di interoperabilità</span><span class="sxs-lookup"><span data-stu-id="30184-172">Interop APIs</span></span>

<span data-ttu-id="30184-173">Nell'argomento [Direct3D 11 su 12](./direct3d-11-on-12.md) viene illustrato l'utilizzo di gran parte della superficie dell'API correlata ai tipi di interoperabilità descritti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="30184-173">The [Direct3D 11 on 12](./direct3d-11-on-12.md) topic walks you through the usage of much of the API surface related to the kinds of interoperation described in this topic.</span></span>

<span data-ttu-id="30184-174">Vedere anche il metodo [ID3D12Device:: CreateSharedHandle](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) , che è possibile usare per condividere le superfici tra le API grafiche di Windows.</span><span class="sxs-lookup"><span data-stu-id="30184-174">Also see the [ID3D12Device::CreateSharedHandle](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) method, which you can use to share surfaces between Windows graphics APIs.</span></span>

## <a name="related-topics"></a><span data-ttu-id="30184-175">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="30184-175">Related topics</span></span>

* [<span data-ttu-id="30184-176">Informazioni su Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="30184-176">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
* [<span data-ttu-id="30184-177">Uso di Direct3D 11, Direct3D 10 e Direct2D</span><span class="sxs-lookup"><span data-stu-id="30184-177">Working with Direct3D 11, Direct3D 10 and Direct2D</span></span>](direct3d-12-interop.md)
* [<span data-ttu-id="30184-178">D3D11On12</span><span class="sxs-lookup"><span data-stu-id="30184-178">Direct3D 11 on 12</span></span>](./direct3d-11-on-12.md)