---
title: Binding in DirectML
description: In DirectML, l'associazione si riferisce all'allegato di risorse alla pipeline per la GPU da usare durante l'inizializzazione e l'esecuzione degli operatori di machine learning.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/18/2020
ms.locfileid: "104548830"
---
# <a name="binding-in-directml"></a><span data-ttu-id="eb441-103">Binding in DirectML</span><span class="sxs-lookup"><span data-stu-id="eb441-103">Binding in DirectML</span></span>

<span data-ttu-id="eb441-104">In DirectML, l' *associazione* si riferisce all'allegato di risorse alla pipeline per la GPU da usare durante l'inizializzazione e l'esecuzione degli operatori di machine learning.</span><span class="sxs-lookup"><span data-stu-id="eb441-104">In DirectML, *binding* refers to the attachment of resources to the pipeline for the GPU to use during the initialization and execution of your machine learning operators.</span></span> <span data-ttu-id="eb441-105">Queste risorse possono essere i tensori di input e di output, ad esempio, nonché le risorse temporanee o persistenti necessarie per l'operatore.</span><span class="sxs-lookup"><span data-stu-id="eb441-105">These resources can be input and output tensors, for example, as well as any temporary or persistent resources that the operator needs.</span></span>

<span data-ttu-id="eb441-106">In questo argomento vengono illustrati i dettagli concettuali e procedurali dell'associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-106">This topic addresses the conceptual and procedural details of binding.</span></span> <span data-ttu-id="eb441-107">Si consiglia anche di leggere completamente la documentazione per le API chiamate, inclusi i parametri e le osservazioni.</span><span class="sxs-lookup"><span data-stu-id="eb441-107">We recommend that you also fully read the documentation for the APIs that you call, including parameters and Remarks.</span></span>

## <a name="important-ideas-in-binding"></a><span data-ttu-id="eb441-108">Idee importanti nell'associazione</span><span class="sxs-lookup"><span data-stu-id="eb441-108">Important ideas in binding</span></span>

<span data-ttu-id="eb441-109">L'elenco dei passaggi seguenti contiene una descrizione di alto livello delle attività correlate all'associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-109">The list of steps below contain a high-level description of binding-related tasks.</span></span> <span data-ttu-id="eb441-110">È necessario seguire questa procedura ogni volta che si esegue un oggetto [inviabile](/windows/desktop/api/directml/nn-directml-idmldispatchable) &mdash; un dispatcher è un inizializzatore di operatore o un operatore compilato.</span><span class="sxs-lookup"><span data-stu-id="eb441-110">You need to follow these steps each time you execute a [dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)&mdash;a dispatchable is either an operator initializer or a compiled operator.</span></span> <span data-ttu-id="eb441-111">Questa procedura introduce le idee, le strutture e i metodi importanti necessari per l'associazione DirectML.</span><span class="sxs-lookup"><span data-stu-id="eb441-111">These steps introduce the important ideas, structures, and methods involved in DirectML binding.</span></span>

<span data-ttu-id="eb441-112">Le sezioni successive di questo argomento approfondiscono e spiegano in modo più dettagliato queste attività di associazione, con frammenti di codice illustrativi ricavati dall'esempio di codice [dell'applicazione DirectML minimo](dml-min-app.md) .</span><span class="sxs-lookup"><span data-stu-id="eb441-112">Subsequent sections in this topic dig deeper and explain these binding tasks in more detail, with illustrative code snippets taken from the [minimal DirectML application](dml-min-app.md) code example.</span></span>

- <span data-ttu-id="eb441-113">Chiamare [**IDMLDispatchable:: GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) sul dispatcher per determinare il numero di descrittori necessari e anche le proprie esigenze di risorse temporanee/permanenti.</span><span class="sxs-lookup"><span data-stu-id="eb441-113">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) on the dispatchable to determine how many descriptors it needs, and also its temporary/persistent resource needs.</span></span>
- <span data-ttu-id="eb441-114">Creare un heap del descrittore Direct3D 12 sufficientemente grande per i descrittori e associarlo alla pipeline.</span><span class="sxs-lookup"><span data-stu-id="eb441-114">Create a Direct3D 12 descriptor heap large enough for the descriptors, and bind it to the pipeline.</span></span>
- <span data-ttu-id="eb441-115">Chiamare [**IDMLDevice:: CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) per creare una tabella di associazione DirectML per rappresentare le risorse vincolate alla pipeline.</span><span class="sxs-lookup"><span data-stu-id="eb441-115">Call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create a DirectML binding table to represent the resources bound to the pipeline.</span></span> <span data-ttu-id="eb441-116">Utilizzare la struttura [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) per descrivere la tabella di associazione, incluso il subset dei descrittori a cui punta nell'heap del descrittore.</span><span class="sxs-lookup"><span data-stu-id="eb441-116">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the subset of the descriptors that it points to in the descriptor heap.</span></span>
- <span data-ttu-id="eb441-117">Creare risorse temporanee/permanenti come risorse buffer Direct3D 12, descriverle con [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) e [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) strutture e aggiungerle alla tabella di binding.</span><span class="sxs-lookup"><span data-stu-id="eb441-117">Create temporary/persistent resources as Direct3D 12 buffer resources, describe them with [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) and [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structures, and add them to the binding table.</span></span>
- <span data-ttu-id="eb441-118">Se l'oggetto inviabile è un operatore compilato, creare un buffer di elementi tensore come risorsa buffer Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="eb441-118">If the dispatchable is a compiled operator, then create a buffer of tensor elements as a Direct3D 12 buffer resource.</span></span> <span data-ttu-id="eb441-119">Popolarlo o caricarlo, definirlo con **DML_BUFFER_BINDING** e **DML_BINDING_DESC** strutture e aggiungerlo alla tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-119">Populate/upload it, describe it with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and add it to the binding table.</span></span>
- <span data-ttu-id="eb441-120">Passare la tabella di associazione come parametro quando si chiama [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="eb441-120">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a><span data-ttu-id="eb441-121">Recuperare le proprietà di binding di un oggetto inviabile</span><span class="sxs-lookup"><span data-stu-id="eb441-121">Retrieve the binding properties of a dispatchable</span></span>

<span data-ttu-id="eb441-122">La struttura [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) descrive le esigenze di binding di un operatore inviabile (inizializzatore operatore o operatore compilato).</span><span class="sxs-lookup"><span data-stu-id="eb441-122">The [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) structure describes the binding needs of a dispatchable (operator initializer or compiled operator).</span></span> <span data-ttu-id="eb441-123">Queste proprietà correlate all'associazione includono il numero di descrittori che è necessario associare al dispatcher, nonché le dimensioni in byte di qualsiasi risorsa temporanea e/o persistente di cui necessita.</span><span class="sxs-lookup"><span data-stu-id="eb441-123">These binding-related properties include the number of descriptors that you should bind to the dispatchable, as well as the size in bytes of any temporary and/or persistent resource that it needs.</span></span>

> [!NOTE]
> <span data-ttu-id="eb441-124">Anche per più operatori dello stesso tipo, non fare supposizioni su di essi con gli stessi requisiti di binding.</span><span class="sxs-lookup"><span data-stu-id="eb441-124">Even for multiple operators of the same type, don't make assumptions about them having the same binding requirements.</span></span> <span data-ttu-id="eb441-125">Eseguire una query sulle proprietà di binding per ogni inizializzatore e operatore creato.</span><span class="sxs-lookup"><span data-stu-id="eb441-125">Query the binding properties for every initializer and operator that you create.</span></span>

<span data-ttu-id="eb441-126">Chiamare [**IDMLDispatchable:: GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) per recuperare un **DML_BINDING_PROPERTIES**.</span><span class="sxs-lookup"><span data-stu-id="eb441-126">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) to retrieve a **DML_BINDING_PROPERTIES**.</span></span>

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

<span data-ttu-id="eb441-127">Il `descriptorCount` valore recuperato qui determina la dimensione (minima) dell'heap del descrittore e della tabella di associazione creata nei due passaggi successivi.</span><span class="sxs-lookup"><span data-stu-id="eb441-127">The `descriptorCount` value that you retrieve here determines the (minimum) size of the descriptor heap and of the binding table that you create in the next two steps.</span></span>

<span data-ttu-id="eb441-128">**DML_BINDING_PROPERTIES** contiene anche un `TemporaryResourceSize` membro, ovvero la dimensione minima, in byte, della risorsa temporanea che deve essere associata alla tabella di binding per questo oggetto inviabile.</span><span class="sxs-lookup"><span data-stu-id="eb441-128">**DML_BINDING_PROPERTIES** also contains a `TemporaryResourceSize` member, which is the minimum size in bytes of the temporary resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="eb441-129">Un valore pari a zero indica che non è necessaria una risorsa temporanea.</span><span class="sxs-lookup"><span data-stu-id="eb441-129">A value of zero means that a temporary resource is not required.</span></span>

<span data-ttu-id="eb441-130">E un `PersistentResourceSize` membro, ovvero la dimensione minima, in byte, della risorsa persistente che deve essere associata alla tabella di associazione per questo oggetto inviabile.</span><span class="sxs-lookup"><span data-stu-id="eb441-130">And a `PersistentResourceSize` member, which is the minimum size in bytes of the persistent resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="eb441-131">Un valore pari a zero indica che non è necessaria una risorsa permanente.</span><span class="sxs-lookup"><span data-stu-id="eb441-131">A value of zero means that a persistent resource is not required.</span></span> <span data-ttu-id="eb441-132">Una risorsa persistente, se necessaria, deve essere fornita durante l'inizializzazione di un operatore compilato (dove è associato come output dell'inizializzatore di operatore) e durante l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="eb441-132">A persistent resource, if one is needed, must be supplied during initialization of a compiled operator (where it is bound as an output of the operator initializer) as well as during execution.</span></span> <span data-ttu-id="eb441-133">Altre informazioni su questo argomento sono disponibili più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="eb441-133">There's more about this later in this topic.</span></span> <span data-ttu-id="eb441-134">Solo gli operatori compilati hanno risorse persistenti: gli inizializzatori di operatore restituiscono sempre un valore pari a 0 per il membro.</span><span class="sxs-lookup"><span data-stu-id="eb441-134">Only compiled operators have persistent resources—operator initializers always return a value of 0 for this member.</span></span>

<span data-ttu-id="eb441-135">Se si chiama **IDMLDispatchable:: GetBindingProperties** in un inizializzatore di operatore sia prima che dopo una chiamata a [**IDMLOperatorInitializer:: Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), i due set di proprietà di associazione recuperati non sono necessariamente identici.</span><span class="sxs-lookup"><span data-stu-id="eb441-135">If you call **IDMLDispatchable::GetBindingProperties** on an operator initializer both before and after a call to [**IDMLOperatorInitializer::Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), then the two sets of binding properties retrieved are not guaranteed to be identical.</span></span>

## <a name="describe-create-and-bind-a-descriptor-heap"></a><span data-ttu-id="eb441-136">Descrivere, creare e associare un heap del descrittore</span><span class="sxs-lookup"><span data-stu-id="eb441-136">Describe, create, and bind a descriptor heap</span></span>

<span data-ttu-id="eb441-137">In termini di descrittori, la responsabilità inizia e termina con l'heap del descrittore.</span><span class="sxs-lookup"><span data-stu-id="eb441-137">In terms of descriptors, your responsibility begins and ends with the descriptor heap itself.</span></span> <span data-ttu-id="eb441-138">DirectML stesso si occupa della creazione e della gestione dei descrittori all'interno dell'heap fornito.</span><span class="sxs-lookup"><span data-stu-id="eb441-138">DirectML itself takes care of creating and managing the descriptors inside of the heap that you provide.</span></span>

<span data-ttu-id="eb441-139">Quindi, usare una struttura di [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) per descrivere un heap sufficientemente grande per il numero di descrittori necessari per l'invio.</span><span class="sxs-lookup"><span data-stu-id="eb441-139">So, use a [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) structure to describe a heap large enough for the number of descriptors that the dispatchable needs.</span></span> <span data-ttu-id="eb441-140">Quindi crearlo con [**ID3D12Device:: CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span><span class="sxs-lookup"><span data-stu-id="eb441-140">Then create it with [**ID3D12Device::CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span></span> <span data-ttu-id="eb441-141">Infine, chiamare [**ID3D12GraphicsCommandList:: SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) per associare l'heap del descrittore alla pipeline.</span><span class="sxs-lookup"><span data-stu-id="eb441-141">And, lastly, call [**ID3D12GraphicsCommandList::SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) to bind your descriptor heap to the pipeline.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a><span data-ttu-id="eb441-142">Descrivere e creare una tabella di associazione</span><span class="sxs-lookup"><span data-stu-id="eb441-142">Describe and create a binding table</span></span>

<span data-ttu-id="eb441-143">Una tabella di binding DirectML rappresenta le risorse che si associano alla pipeline per un oggetto inviabile da usare.</span><span class="sxs-lookup"><span data-stu-id="eb441-143">A DirectML binding table represents the resources that you bind to the pipeline for a dispatchable to use.</span></span> <span data-ttu-id="eb441-144">Tali risorse possono essere i tensori di input e di output (o altri parametri) per un operatore oppure possono essere diverse risorse permanenti e temporanee con cui può essere distribuito un oggetto inviabile.</span><span class="sxs-lookup"><span data-stu-id="eb441-144">Those resources could be input and output tensors (or other parameters) for an operator, or they could be various persistent and temporary resources that a dispatchable works with.</span></span>

<span data-ttu-id="eb441-145">Utilizzare la struttura [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) per descrivere la tabella di associazione, incluso il dispatcher per il quale la tabella di associazione rappresenterà le associazioni e l'intervallo di descrittori (dall'heap descrittore appena creato) a cui si desidera che la tabella di associazione faccia riferimento (e in cui DirectML può scrivere descrittori).</span><span class="sxs-lookup"><span data-stu-id="eb441-145">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the dispatchable for which the binding table will represent the bindings, and the range of descriptors (from the descriptor heap that you just created) that you wish the binding table to refer to (and into which DirectML may write descriptors).</span></span> <span data-ttu-id="eb441-146">Il `descriptorCount` valore (una delle proprietà di associazione recuperate nel primo passaggio) indica le dimensioni minime, nei descrittori, della tabella di associazione necessaria per l'oggetto inviabile.</span><span class="sxs-lookup"><span data-stu-id="eb441-146">The `descriptorCount` value (one of the binding properties that we retrieved in the first step) tells us what minimum size is, in descriptors, of the binding table required for the dispatchable object.</span></span> <span data-ttu-id="eb441-147">Questo valore viene usato per indicare il numero massimo di descrittori che DirectML è autorizzato a scrivere nell'heap, dall'inizio degli handle di descrittore della CPU e della GPU forniti.</span><span class="sxs-lookup"><span data-stu-id="eb441-147">Here, we use that value to indicate the maximum number of descriptors that DirectML is permitted to write into our heap, from the start of both the supplied CPU and GPU descriptor handles.</span></span>

<span data-ttu-id="eb441-148">Chiamare quindi [**IDMLDevice:: CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) per creare la tabella di associazione DirectML.</span><span class="sxs-lookup"><span data-stu-id="eb441-148">Then call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create the DirectML binding table.</span></span> <span data-ttu-id="eb441-149">Nei passaggi successivi, dopo aver creato ulteriori risorse per il dispatcher, le risorse verranno aggiunte alla tabella di binding.</span><span class="sxs-lookup"><span data-stu-id="eb441-149">In later steps, after we've created further resources for the dispatchable, we'll add those resources to the binding table.</span></span>

<span data-ttu-id="eb441-150">Anziché passare un **DML_BINDING_TABLE_DESC** a questa chiamata, è possibile passare `nullptr` , che indica una tabella di binding vuota.</span><span class="sxs-lookup"><span data-stu-id="eb441-150">Instead of passing a **DML_BINDING_TABLE_DESC** to this call, you can pass `nullptr`, indicating an empty binding table.</span></span>

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

<span data-ttu-id="eb441-151">L'ordine in cui DirectML scrive i descrittori nell'heap non è specificato, pertanto l'applicazione deve prestare attenzione a non sovrascrivere i descrittori inclusi nella tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-151">The order in which DirectML writes descriptors into the heap is unspecified, so your application must take care not to overwrite the descriptors wrapped by the binding table.</span></span> <span data-ttu-id="eb441-152">Gli handle di descrittore CPU e GPU forniti possono provenire da heap diversi, tuttavia è responsabilità dell'applicazione garantire che l'intero intervallo di descrittori a cui fa riferimento l'handle del descrittore della CPU venga copiato nell'intervallo a cui fa riferimento l'handle del descrittore della GPU prima dell'esecuzione utilizzando questa tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-152">The supplied CPU and GPU descriptor handles may come from different heaps, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span> <span data-ttu-id="eb441-153">L'heap del descrittore da cui vengono forniti gli handle deve avere il tipo **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span><span class="sxs-lookup"><span data-stu-id="eb441-153">The descriptor heap from which the handles are supplied must have type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span></span> <span data-ttu-id="eb441-154">Inoltre, l'heap a cui fa riferimento `GPUDescriptorHandle` deve essere un heap del descrittore visibile allo shader.</span><span class="sxs-lookup"><span data-stu-id="eb441-154">Additionally, the heap referred to by the `GPUDescriptorHandle` must be a shader-visible descriptor heap.</span></span>

<span data-ttu-id="eb441-155">È possibile reimpostare una tabella di binding per rimuovere tutte le risorse aggiunte, modificando allo stesso tempo qualsiasi proprietà impostata sul **DML_BINDING_TABLE_DESC** iniziale (per eseguire il wrapping di un nuovo intervallo di descrittori o per riutilizzarlo per un altro Dispatcher).</span><span class="sxs-lookup"><span data-stu-id="eb441-155">You can reset a binding table to remove any resources that you've added to it, while at the same time changing any property that you set on its initial **DML_BINDING_TABLE_DESC** (to wrap a new range of descriptors, or to re-use it for a different dispatchable).</span></span> <span data-ttu-id="eb441-156">È sufficiente apportare le modifiche alla struttura di descrizione e chiamare [**IDMLBindingTable:: Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span><span class="sxs-lookup"><span data-stu-id="eb441-156">Just make the changes to the description structure, and call [**IDMLBindingTable::Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span></span>

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a><span data-ttu-id="eb441-157">Descrivere e associare eventuali risorse temporanee/permanenti</span><span class="sxs-lookup"><span data-stu-id="eb441-157">Describe and bind any temporary/persistent resources</span></span>

<span data-ttu-id="eb441-158">La struttura di **DML_BINDING_PROPERTIES** popolata quando [sono state recuperate le proprietà di binding](#retrieve-the-binding-properties-of-a-dispatchable) dell'oggetto inviabile contiene la dimensione in byte di qualsiasi risorsa temporanea e/o persistente richiesta dal dispatcher.</span><span class="sxs-lookup"><span data-stu-id="eb441-158">The **DML_BINDING_PROPERTIES** structure that we populated when we [retrieved the binding properties](#retrieve-the-binding-properties-of-a-dispatchable) of our dispatchable contains the size in bytes of any temporary and/or persistent resource that the dispatchable needs.</span></span> <span data-ttu-id="eb441-159">Se una di queste dimensioni è diversa da zero, creare una risorsa buffer Direct3D 12 e aggiungerla alla tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-159">If either of these sizes is non-zero, then create a Direct3D 12 buffer resource and add it to the binding table.</span></span>

<span data-ttu-id="eb441-160">Nell'esempio di codice riportato di seguito viene creata una risorsa temporanea, ovvero `temporaryResourceSize` byte, per l'oggetto inviabile.</span><span class="sxs-lookup"><span data-stu-id="eb441-160">In the code example below, we create a temporary resource (`temporaryResourceSize` bytes in size) for the dispatchable.</span></span> <span data-ttu-id="eb441-161">Viene descritto come si vuole associare la risorsa e quindi si aggiunge tale associazione alla tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-161">We describe how we wish to bind the resource, and then we add that binding to the binding table.</span></span>

<span data-ttu-id="eb441-162">Poiché si sta associando una risorsa di buffer singola, viene descritta l'associazione con una struttura [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) .</span><span class="sxs-lookup"><span data-stu-id="eb441-162">Since we're binding a single buffer resource, we describe our binding with a [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) structure.</span></span> <span data-ttu-id="eb441-163">In tale struttura viene specificata la risorsa buffer Direct3D 12 (la risorsa deve avere [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)di dimensione), nonché un offset e dimensioni nel buffer.</span><span class="sxs-lookup"><span data-stu-id="eb441-163">In that structure, we specify the Direct3D 12 buffer resource (the resource must have dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), as well as an offset-and-size into the buffer.</span></span> <span data-ttu-id="eb441-164">È anche possibile descrivere un'associazione per una matrice di buffer (anziché per un singolo buffer) e la struttura [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) esiste a tale scopo.</span><span class="sxs-lookup"><span data-stu-id="eb441-164">It's also possible to describe a binding for an array of buffers (rather than for a single buffer), and the [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) structure exists for that purpose.</span></span>

<span data-ttu-id="eb441-165">Per astrarre la distinzione tra un'associazione di buffer e un'associazione di matrici di buffer, viene usata la struttura  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) .</span><span class="sxs-lookup"><span data-stu-id="eb441-165">To abstract away the distinction between a buffer binding and a buffer array binding, we use the  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structure.</span></span> <span data-ttu-id="eb441-166">È possibile impostare il `Type` membro del **DML_BINDING_DESC** su [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) o **DML_BINDING_TYPE_BUFFER_ARRAY**.</span><span class="sxs-lookup"><span data-stu-id="eb441-166">You can set the `Type` member of the **DML_BINDING_DESC** to either [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) or **DML_BINDING_TYPE_BUFFER_ARRAY**.</span></span> <span data-ttu-id="eb441-167">È quindi possibile impostare il `Desc` membro in modo che punti a un **DML_BUFFER_BINDING** o a un **DML_BUFFER_ARRAY_BINDING**, a seconda di `Type` .</span><span class="sxs-lookup"><span data-stu-id="eb441-167">And you can then set the `Desc` member to point to either a **DML_BUFFER_BINDING** or to a **DML_BUFFER_ARRAY_BINDING**, depending on `Type`.</span></span>

<span data-ttu-id="eb441-168">In questo esempio si sta trattando della risorsa temporanea, quindi la si aggiunge alla tabella di binding con una chiamata a [**IDMLBindingTable:: BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span><span class="sxs-lookup"><span data-stu-id="eb441-168">We're dealing with the temporary resource in this example, so we add it to the binding table with a call to [**IDMLBindingTable::BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span></span>

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

<span data-ttu-id="eb441-169">Una risorsa temporanea, se necessaria, è una memoria Scratch utilizzata internamente durante l'esecuzione dell'operatore, pertanto non è necessario preoccuparsi del suo contenuto.</span><span class="sxs-lookup"><span data-stu-id="eb441-169">A temporary resource (if one is needed) is scratch memory that's used internally during the execution of the operator, so you don't need to be concerned with its contents.</span></span> <span data-ttu-id="eb441-170">Non è quindi necessario mantenerla dopo che la chiamata a [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) è stata completata sulla GPU.</span><span class="sxs-lookup"><span data-stu-id="eb441-170">Nor do you need to keep it around after your call to [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) has completed on the GPU.</span></span> <span data-ttu-id="eb441-171">Ciò significa che l'applicazione può rilasciare o sovrascrivere la risorsa temporanea tra gli invii dell'operatore compilato.</span><span class="sxs-lookup"><span data-stu-id="eb441-171">This means that your application may release or overwrite the temporary resource in between dispatches of the compiled operator.</span></span> <span data-ttu-id="eb441-172">L'intervallo di buffer specificato da associare come risorsa temporanea deve avere l'offset iniziale allineato a [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="eb441-172">The supplied buffer range to be bound as the temporary resource must have its start offset aligned to [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="eb441-173">Il tipo dell'heap sottostante al buffer deve essere **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="eb441-173">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

<span data-ttu-id="eb441-174">Se l'oggetto inviabile segnala una dimensione diversa da zero per la risorsa persistente più longeva, tuttavia, la procedura è leggermente diversa.</span><span class="sxs-lookup"><span data-stu-id="eb441-174">If the dispatchable reports a non-zero size for its more long-lived persistent resource, though, then the procedure is a little different.</span></span> <span data-ttu-id="eb441-175">È necessario creare un buffer e descrivere un'associazione che segue lo stesso modello illustrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="eb441-175">You should create a buffer and describe a binding following the same pattern as shown above.</span></span> <span data-ttu-id="eb441-176">Ma aggiungerlo alla tabella di associazione dell'inizializzatore di operatore con una chiamata a [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), perché è il processo dell'inizializzatore di operatore a inizializzare la risorsa persistente.</span><span class="sxs-lookup"><span data-stu-id="eb441-176">But add it to your operator initializer's binding table with a call to [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), because it's the operator initializer's job to initialize the persistent resource.</span></span> <span data-ttu-id="eb441-177">Quindi aggiungerlo alla tabella di binding dell'operatore compilato con una chiamata a [**IDMLBindingTable:: BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span><span class="sxs-lookup"><span data-stu-id="eb441-177">Then add it to your compiled operator's binding table with a call to [**IDMLBindingTable::BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span></span> <span data-ttu-id="eb441-178">Vedere l'esempio di codice [dell'applicazione DirectML minimo](dml-min-app.md) per vedere il flusso di lavoro in azione.</span><span class="sxs-lookup"><span data-stu-id="eb441-178">See the [minimal DirectML application](dml-min-app.md) code example to see this workflow in action.</span></span> <span data-ttu-id="eb441-179">Il contenuto e la durata della risorsa persistente devono essere mantenuti fino a quando l'operatore compilato lo esegue.</span><span class="sxs-lookup"><span data-stu-id="eb441-179">The persistent resource's contents and lifetime must persist as long as the compiled operator does.</span></span> <span data-ttu-id="eb441-180">Ovvero, se un operatore richiede una risorsa persistente, l'applicazione deve fornirla durante l'inizializzazione e successivamente fornirla anche a tutte le esecuzioni future dell'operatore senza modificarne il contenuto.</span><span class="sxs-lookup"><span data-stu-id="eb441-180">That is, if an operator requires a persistent resource, then your application must supply it during initialization and subsequently also supply it to all future executes of the operator without modifying its contents.</span></span> <span data-ttu-id="eb441-181">La risorsa persistente viene in genere utilizzata da DirectML per archiviare le tabelle di ricerca o altri dati di lunga durata calcolati durante l'inizializzazione di un operatore e riutilizzati nelle esecuzioni future dell'operatore.</span><span class="sxs-lookup"><span data-stu-id="eb441-181">The persistent resource is typically used by DirectML to store lookup tables or other long-lived data that is computed during initialization of an operator and reused on future executions of that operator.</span></span> <span data-ttu-id="eb441-182">L'intervallo di buffer specificato da associare come buffer permanente deve avere l'offset iniziale allineato a [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="eb441-182">The supplied buffer range to be bound as the persistent buffer must have its start offset aligned to [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="eb441-183">Il tipo dell'heap sottostante al buffer deve essere **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="eb441-183">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

## <a name="describe-and-bind-any-tensors"></a><span data-ttu-id="eb441-184">Descrivere e associare tutti i tensori</span><span class="sxs-lookup"><span data-stu-id="eb441-184">Describe and bind any tensors</span></span>

<span data-ttu-id="eb441-185">Se si ha a che fare con un operatore compilato, anziché con un inizializzatore di operatore, è necessario associare le risorse di input e di output (per i tasti di scelta e altri parametri) alla tabella di binding dell'operatore.</span><span class="sxs-lookup"><span data-stu-id="eb441-185">If you're dealing with a compiled operator (rather than with an operator initializer), then you need to bind input and output resources (for tensors and other parameters) to the operator's binding table.</span></span> <span data-ttu-id="eb441-186">Il numero di binding deve corrispondere esattamente al numero di input dell'operatore, inclusi i Tenser facoltativi.</span><span class="sxs-lookup"><span data-stu-id="eb441-186">The number of bindings must exactly match the number of inputs of the operator, including optional tensors.</span></span> <span data-ttu-id="eb441-187">I specifici tensori di input e di output e altri parametri accettati da un operatore sono documentati nell'argomento relativo a tale operatore (ad esempio, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span><span class="sxs-lookup"><span data-stu-id="eb441-187">The particular input and output tensors and other parameters that an operator takes are documented in the topic for that operator (for example, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span></span>

<span data-ttu-id="eb441-188">Una risorsa tensore è un buffer che contiene i singoli valori degli elementi del tensore.</span><span class="sxs-lookup"><span data-stu-id="eb441-188">A tensor resource is a buffer that contains the individual element values of the tensor.</span></span> <span data-ttu-id="eb441-189">È possibile caricare e leggere tale buffer da e verso la GPU usando le normali tecniche di Direct3D 12 ([caricare le risorse](/windows/desktop/direct3d12/uploading-resources) e [leggere i dati tramite un buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span><span class="sxs-lookup"><span data-stu-id="eb441-189">You upload and read back such a buffer to/from the GPU using the regular Direct3D 12 techniques ([Upload resources](/windows/desktop/direct3d12/uploading-resources) and [Read back data via a buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span></span> <span data-ttu-id="eb441-190">Vedere l'esempio di codice [dell'applicazione DirectML minimo](dml-min-app.md) per vedere le tecniche in azione.</span><span class="sxs-lookup"><span data-stu-id="eb441-190">See the [minimal DirectML application](dml-min-app.md) code example to see these techniques in action.</span></span>

<span data-ttu-id="eb441-191">Infine, descrivere le associazioni di risorse di input e output con le strutture **DML_BUFFER_BINDING** e **DML_BINDING_DESC** , quindi aggiungerle alla tabella di binding dell'operatore compilato con le chiamate a [**IDMLBindingTable:: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) e [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="eb441-191">Lastly, describe your input and output resource bindings with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and then add them to the compiled operator's binding table with calls to [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span> <span data-ttu-id="eb441-192">Quando si chiama un metodo \**IDMLBindingTable:: \* Bind* _, DirectML scrive uno o più descrittori nell'intervallo di descrittori della CPU.</span><span class="sxs-lookup"><span data-stu-id="eb441-192">When you call an \**IDMLBindingTable::Bind\** _ method, DirectML writes one or more descriptors into the range of CPU descriptors.</span></span>

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

<span data-ttu-id="eb441-193">Uno dei passaggi per la creazione di un operatore DirectML (vedere [_ *IDMLDevice:: CreateOperator* \*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) consiste nel dichiarare una o più strutture [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) per descrivere i buffer di dati del tensore che l'operatore accetta e restituisce.</span><span class="sxs-lookup"><span data-stu-id="eb441-193">One of the steps in creating a DirectML operator (see [_ *IDMLDevice::CreateOperator*\*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) is to declare one or more [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) structures to describe the tensor data buffers that the operator takes and returns.</span></span> <span data-ttu-id="eb441-194">Nonché il tipo e le dimensioni del buffer di tensore, è possibile specificare facoltativamente il flag di [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) .</span><span class="sxs-lookup"><span data-stu-id="eb441-194">As well as the tensor buffer's type and size, you can optionally specify the [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) flag.</span></span>

<span data-ttu-id="eb441-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indica che i dati del tensore devono essere di proprietà e gestiti da DirectML.</span><span class="sxs-lookup"><span data-stu-id="eb441-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indicates that the tensor data should be owned and managed by DirectML.</span></span> <span data-ttu-id="eb441-196">DirectML crea una copia dei dati di tensore durante l'inizializzazione dell'operatore e la archivia nella risorsa persistente.</span><span class="sxs-lookup"><span data-stu-id="eb441-196">DirectML makes a copy of the tensor data during initialization of the operator, and stores it in the persistent resource.</span></span> <span data-ttu-id="eb441-197">Questo consente a DirectML di eseguire la riformattazione dei dati del tensore in altri moduli più efficienti.</span><span class="sxs-lookup"><span data-stu-id="eb441-197">This allows DirectML to perform reformatting of the tensor data into other, more efficient forms.</span></span> <span data-ttu-id="eb441-198">L'impostazione di questo flag può migliorare le prestazioni, ma è in genere utile solo per i tensori i cui dati non cambiano per la durata dell'operatore (ad esempio, i tensori di peso).</span><span class="sxs-lookup"><span data-stu-id="eb441-198">Setting this flag may increase performance, but it's typically only useful for tensors whose data doesn't change for the lifetime of the operator (for example, weight tensors).</span></span> <span data-ttu-id="eb441-199">E il flag può essere usato solo nei tensori di input.</span><span class="sxs-lookup"><span data-stu-id="eb441-199">And the flag may only be used on input tensors.</span></span> <span data-ttu-id="eb441-200">Quando il flag viene impostato su una particolare descrizione del tensore, il tensore corrispondente deve essere associato alla tabella di associazione durante l'inizializzazione dell'operatore e non durante l'esecuzione (che comporterà un errore).</span><span class="sxs-lookup"><span data-stu-id="eb441-200">When the flag is set on a particular tensor description, the corresponding tensor must be bound to the binding table during operator initialization, and not during execution (which will result in an error).</span></span> <span data-ttu-id="eb441-201">Si tratta dell'opposto del comportamento predefinito (il comportamento senza il flag di DML_TENSOR_FLAG_OWNED_BY_DML), in cui il tensore dovrebbe essere associato durante l'esecuzione e non durante l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-201">That's the opposite of the default behavior (the behavior without the DML_TENSOR_FLAG_OWNED_BY_DML flag), where the tensor is expected to be bound during execution, and not during initialization.</span></span> <span data-ttu-id="eb441-202">Quando si forniscono i dati del tensore a un inizializzatore di operatore, è lecito associare un caricamento anziché un heap predefinito, perché DirectML esegue una copia dei dati.</span><span class="sxs-lookup"><span data-stu-id="eb441-202">When you supply the tensor data to an operator initializer, it's legal to bind an UPLOAD rather than a DEFAULT heap, because DirectML makes a copy of the data.</span></span> <span data-ttu-id="eb441-203">In tutti gli altri casi, tutte le risorse vincolate a DirectML devono essere risorse heap predefinite.</span><span class="sxs-lookup"><span data-stu-id="eb441-203">In all other cases, all resources bound to DirectML must be DEFAULT heap resources.</span></span>

<span data-ttu-id="eb441-204">Per altre informazioni, vedere [**IDMLBindingTable:: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) e [**IDMLBindingTable:: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="eb441-204">For more info, see [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span>

## <a name="execute-the-dispatchable"></a><span data-ttu-id="eb441-205">Eseguire il dispatcher</span><span class="sxs-lookup"><span data-stu-id="eb441-205">Execute the dispatchable</span></span>

<span data-ttu-id="eb441-206">Passare la tabella di associazione come parametro quando si chiama [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="eb441-206">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

<span data-ttu-id="eb441-207">Quando si utilizza la tabella di associazione durante una chiamata a **IDMLCommandRecorder:: RecordDispatch**, DirectML associa i descrittori GPU corrispondenti alla pipeline.</span><span class="sxs-lookup"><span data-stu-id="eb441-207">When you use the binding table during a call to **IDMLCommandRecorder::RecordDispatch**, DirectML binds the corresponding GPU descriptors to the pipeline.</span></span> <span data-ttu-id="eb441-208">Gli handle descrittore della CPU e della GPU non devono puntare alle stesse voci in un heap dei descrittori, tuttavia è responsabilità dell'applicazione garantire che l'intero intervallo di descrittori a cui fa riferimento l'handle del descrittore della CPU venga copiato nell'intervallo a cui fa riferimento l'handle del descrittore della GPU prima dell'esecuzione utilizzando questa tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-208">The CPU and GPU descriptor handles aren't required to point to the same entries in a descriptor heap, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

<span data-ttu-id="eb441-209">Infine, chiudere l'elenco di comandi Direct3D 12 e inviarlo per l'esecuzione come qualsiasi altro elenco di comandi.</span><span class="sxs-lookup"><span data-stu-id="eb441-209">Finally, close your Direct3D 12 command list, and submit it for execution as you would any other command list.</span></span>

<span data-ttu-id="eb441-210">Prima dell'esecuzione di **RecordDispatch** sulla GPU, è necessario eseguire la transizione di tutte le risorse limitate allo stato **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** o a uno stato promuovibile in modo implicito a **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, ad esempio **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="eb441-210">Prior to execution of **RecordDispatch** on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="eb441-211">Al termine della chiamata, le risorse rimangono nello stato **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="eb441-211">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="eb441-212">L'unica eccezione è rappresentata dagli heap di caricamento associati durante l'esecuzione di un inizializzatore di operatore e mentre uno o più tensori hanno il flag di **DML_TENSOR_FLAG_OWNED_BY_DML** impostato.</span><span class="sxs-lookup"><span data-stu-id="eb441-212">The only exception to this is for upload heaps bound when executing an operator initializer and while one or more tensors has the **DML_TENSOR_FLAG_OWNED_BY_DML** flag set.</span></span> <span data-ttu-id="eb441-213">In tal caso, gli heap di caricamento associati per l'input devono trovarsi nello stato **D3D12_RESOURCE_STATE_GENERIC_READ** e rimarranno in tale stato, come richiesto da tutti gli heap di caricamento.</span><span class="sxs-lookup"><span data-stu-id="eb441-213">In that case, any upload heaps bound for input must be in the **D3D12_RESOURCE_STATE_GENERIC_READ** state and will remain in that state, as required by all upload heaps.</span></span> <span data-ttu-id="eb441-214">Se **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** non è stato impostato durante la compilazione dell'operatore, è necessario impostare tutte le associazioni nella tabella di binding prima della chiamata a **RecordDispatch** . in caso contrario, il comportamento non è definito.</span><span class="sxs-lookup"><span data-stu-id="eb441-214">If **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** was not set when compiling the operator, then all bindings must be set on the binding table before **RecordDispatch** is called, otherwise the behavior is undefined.</span></span> <span data-ttu-id="eb441-215">In caso contrario, se un operatore supporta l' [associazione tardiva](#optionally-specify-late-bound-operator-bindings), l'associazione delle risorse può essere rinviata fino a quando l'elenco di comandi Direct3D 12 non viene inviato alla coda dei comandi per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="eb441-215">Otherwise, if an operator supports [late binding](#optionally-specify-late-bound-operator-bindings), then binding of resources may be deferred until the Direct3D 12 command list is submitted to the command queue for execution.</span></span>

<span data-ttu-id="eb441-216">**RecordDispatch** agisce logicamente come una chiamata a [**ID3D12GraphicsCommandList::D la patch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span><span class="sxs-lookup"><span data-stu-id="eb441-216">**RecordDispatch** acts logically like a call to [**ID3D12GraphicsCommandList::Dispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span></span> <span data-ttu-id="eb441-217">Di conseguenza, le barriere per la visualizzazione di accesso non ordinato (UAV) sono necessarie per garantire l'ordinamento corretto in caso di dipendenze dei dati tra le invii.</span><span class="sxs-lookup"><span data-stu-id="eb441-217">As such, unordered access view (UAV) barriers are necessary to ensure correct ordering if there are data dependencies between dispatches.</span></span> <span data-ttu-id="eb441-218">Questo metodo non inserisce le barriere UAV sulle risorse di input e di output.</span><span class="sxs-lookup"><span data-stu-id="eb441-218">This method does not insert UAV barriers on input nor output resources.</span></span> <span data-ttu-id="eb441-219">L'applicazione deve assicurarsi che vengano eseguite le barriere UAV corrette su tutti gli input se il contenuto dipende da un dispatch upstream e da eventuali output se sono presenti invii a valle che dipendono da tali output.</span><span class="sxs-lookup"><span data-stu-id="eb441-219">Your application must ensure that the correct UAV barriers are performed on any inputs if their contents depend on an upstream dispatch, and on any outputs if there are downstream dispatches that depend on those outputs.</span></span>

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a><span data-ttu-id="eb441-220">Durata e sincronizzazione dei descrittori e della tabella di associazione</span><span class="sxs-lookup"><span data-stu-id="eb441-220">Lifetime and synchronization of descriptors and binding table</span></span>

<span data-ttu-id="eb441-221">Un modello mentale efficace di associazione in DirectML è che dietro le quinte la tabella di binding DirectML sta creando e gestendo descrittori UAV (unordered Access View) nell'heap del descrittore fornito.</span><span class="sxs-lookup"><span data-stu-id="eb441-221">A good mental model of binding in DirectML is that behind the scenes the DirectML binding table itself is creating and managing unordered access view (UAV) descriptors inside the descriptor heap that you provide.</span></span> <span data-ttu-id="eb441-222">Quindi, tutte le normali regole Direct3D 12 riguardano la sincronizzazione dell'accesso a tale heap e ai relativi descrittori.</span><span class="sxs-lookup"><span data-stu-id="eb441-222">So, all of the usual Direct3D 12 rules apply around synchronizing access to that heap and to its descriptors.</span></span> <span data-ttu-id="eb441-223">È responsabilità dell'applicazione eseguire una sincronizzazione corretta tra il lavoro di CPU e GPU che usa una tabella di associazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-223">It's your application's responsibility to perform correct synchronization between the CPU and GPU work that uses a binding table.</span></span>

<span data-ttu-id="eb441-224">Una tabella di associazione non può sovrascrivere un descrittore mentre il descrittore è in uso (ad esempio, da un frame precedente).</span><span class="sxs-lookup"><span data-stu-id="eb441-224">A binding table can't overwrite a descriptor while the descriptor is in use (by a prior frame, for example).</span></span> <span data-ttu-id="eb441-225">Se quindi si vuole riusare un heap del descrittore già associato, ad esempio richiamando Bind \* su una tabella di associazione che vi fa riferimento oppure sovrascrivendo manualmente l'heap del descrittore, è necessario attendere che il dispatcher stia usando l'heap del descrittore per completare l'esecuzione nella GPU.</span><span class="sxs-lookup"><span data-stu-id="eb441-225">So, if you want to reuse an already-bound descriptor heap (for example, by calling Bind\* again on a binding table that points to it, or by overwriting the descriptor heap manually), then you should wait for the dispatchable that's currently using the descriptor heap to finish executing on the GPU.</span></span> <span data-ttu-id="eb441-226">Una tabella di associazione non mantiene un riferimento sicuro nell'heap del descrittore in cui viene scritto, quindi non è necessario rilasciare l'heap del descrittore visibile dello shader, fino a quando tutto il lavoro che utilizza tale tabella di associazione non ha completato l'esecuzione nella GPU.</span><span class="sxs-lookup"><span data-stu-id="eb441-226">A binding table doesn't maintain a strong reference on the descriptor heap that it writes into, so you mustn't release the backing shader-visible descriptor heap until all work using that binding table has completed execution on the GPU.</span></span>

<span data-ttu-id="eb441-227">D'altra parte, mentre una tabella di associazione specifica e gestisce un heap del descrittore, la tabella non *contiene* alcuna memoria.</span><span class="sxs-lookup"><span data-stu-id="eb441-227">On the other hand, while a binding table does specify and manage a descriptor heap, the table doesn't itself *contain* any of that memory.</span></span> <span data-ttu-id="eb441-228">È quindi possibile rilasciare o reimpostare una tabella di associazione in qualsiasi momento dopo aver chiamato [**IDMLCommandRecorder:: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) (non è necessario attendere il completamento di tale chiamata sulla GPU, purché i descrittori sottostanti rimangano validi).</span><span class="sxs-lookup"><span data-stu-id="eb441-228">So, you may release or reset a binding table any time after you've called [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) with it (you don't need to wait for that call to complete on the GPU, so long as the underlying descriptors remain valid).</span></span>

<span data-ttu-id="eb441-229">La tabella di associazione non mantiene i riferimenti sicuri su tutte le risorse associate con esso &mdash; . l'applicazione deve assicurarsi che le risorse non vengano eliminate mentre sono ancora in uso dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="eb441-229">The binding table doesn't keep strong references on any resources bound using it&mdash;your application must ensure that resources are not deleted while still in use by the GPU.</span></span> <span data-ttu-id="eb441-230">Inoltre, una tabella di binding non è thread-safe &mdash; . l'applicazione non deve chiamare metodi su una tabella di associazione simultaneamente da thread diversi senza sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="eb441-230">Also, a binding table isn't thread safe&mdash;your application must not call methods on a binding table simultaneously from different threads without synchronization.</span></span>

<span data-ttu-id="eb441-231">Si tenga presente che, in ogni caso, la riassociazione è necessaria solo quando si modificano le risorse associate.</span><span class="sxs-lookup"><span data-stu-id="eb441-231">And consider that in any case rebinding is necessary only when you change which resources are bound.</span></span> <span data-ttu-id="eb441-232">Se non è necessario modificare le risorse associate, è possibile eseguire il binding una volta all'avvio e passare la stessa tabella di associazione ogni volta che si chiama **RecordDispatch**.</span><span class="sxs-lookup"><span data-stu-id="eb441-232">If you don't need to change the bound resources, then you can bind once at startup, and pass the same binding table each time you call **RecordDispatch**.</span></span>

<span data-ttu-id="eb441-233">Per l'interfoliazione dei carichi di lavoro di machine learning e di rendering, è sufficiente assicurarsi che le tabelle di binding di ogni frame puntino agli intervalli dell'heap del descrittore che non sono già in uso nella GPU.</span><span class="sxs-lookup"><span data-stu-id="eb441-233">For interleaving machine learning and rendering workloads, just ensure that each frame's binding tables points to ranges of the descriptor heap that are not already in use on the GPU.</span></span>

## <a name="optionally-specify-late-bound-operator-bindings"></a><span data-ttu-id="eb441-234">Facoltativamente, specificare associazioni di operatori ad associazione tardiva</span><span class="sxs-lookup"><span data-stu-id="eb441-234">Optionally specify late-bound operator bindings</span></span>

<span data-ttu-id="eb441-235">Se si ha a che fare con un operatore compilato (anziché con un inizializzatore di operatore), è possibile specificare l'associazione tardiva per l'operatore.</span><span class="sxs-lookup"><span data-stu-id="eb441-235">If you're dealing with a compiled operator (rather than with an operator initializer), then you have the option to specify late binding for the operator.</span></span> <span data-ttu-id="eb441-236">Senza associazione tardiva, è necessario impostare tutte le associazioni nella tabella di binding prima di registrare un operatore in un elenco di comandi.</span><span class="sxs-lookup"><span data-stu-id="eb441-236">Without late binding, you must set all bindings on the binding table before you record an operator into a command list.</span></span> <span data-ttu-id="eb441-237">Con l'associazione tardiva, è possibile impostare o modificare le associazioni sugli operatori già registrati in un elenco di comandi, prima di essere inviati alla coda dei comandi.</span><span class="sxs-lookup"><span data-stu-id="eb441-237">With late binding, you can set (or change) bindings on operators that you've already recorded into a command list, before it has been submitted to the command queue.</span></span>

<span data-ttu-id="eb441-238">Per specificare l'associazione tardiva, chiamare [**IDMLDevice:: CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) con un `flags` argomento di [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span><span class="sxs-lookup"><span data-stu-id="eb441-238">To specify late binding, call [**IDMLDevice::CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) with a `flags` argument of [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span></span>