---
title: programmazione a 64 bit per sviluppatori di giochi
description: Questo articolo illustra i problemi di compatibilità e di portabilità e consente agli sviluppatori di semplificare la transizione a piattaforme a 64 bit.
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b12e57ea1b3cc3272ca40465df31a04244d99e68
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104047065"
---
# <a name="64-bit-programming-for-game-developers"></a><span data-ttu-id="db043-103">programmazione a 64 bit per sviluppatori di giochi</span><span class="sxs-lookup"><span data-stu-id="db043-103">64-bit programming for Game Developers</span></span>

<span data-ttu-id="db043-104">I produttori di processori sono in esclusiva spedizione di processori a 64 bit nei propri computer desktop e anche i chipset della maggior parte dei computer portatili supportano la tecnologia x64.</span><span class="sxs-lookup"><span data-stu-id="db043-104">Processor manufacturers are exclusively shipping 64-bit processors in their desktop computers, and even the chipsets of most laptop computers support x64 technology.</span></span> <span data-ttu-id="db043-105">È importante per gli sviluppatori di giochi sfruttare i miglioramenti offerti dai processori a 64 bit con le nuove applicazioni e garantire che le applicazioni precedenti vengano eseguite correttamente sui nuovi processori e sulle edizioni a 64 bit di Windows Vista e Windows 7.</span><span class="sxs-lookup"><span data-stu-id="db043-105">It is important for game developers to take advantage of the improvements that 64-bit processors offer with their new applications and to ensure that their earlier applications run correctly on the new processors and the 64-bit editions of Windows Vista and Windows 7.</span></span> <span data-ttu-id="db043-106">Questo articolo illustra i problemi di compatibilità e di portabilità e consente agli sviluppatori di semplificare la transizione a piattaforme a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-106">This article addresses compatibility and porting issues and helps developers ease their transition to 64-bit platforms.</span></span>

<span data-ttu-id="db043-107">Microsoft dispone attualmente dei seguenti sistemi operativi a 64 bit:</span><span class="sxs-lookup"><span data-stu-id="db043-107">Microsoft currently has the following 64-bit operating systems:</span></span>

-   <span data-ttu-id="db043-108">Windows Server 2003 Service Pack 1</span><span class="sxs-lookup"><span data-stu-id="db043-108">Windows Server 2003 Service Pack 1</span></span>
-   <span data-ttu-id="db043-109">Windows XP Professional x64 Edition (disponibile per gli OEM e per gli sviluppatori tramite MSDN)</span><span class="sxs-lookup"><span data-stu-id="db043-109">Windows XP Professional x64 Edition (available to OEMs and to developers through MSDN)</span></span>
-   <span data-ttu-id="db043-110">Windows Vista</span><span class="sxs-lookup"><span data-stu-id="db043-110">Windows Vista</span></span>
-   <span data-ttu-id="db043-111">Windows Server 2008</span><span class="sxs-lookup"><span data-stu-id="db043-111">Windows Server 2008</span></span>
-   <span data-ttu-id="db043-112">Windows 7</span><span class="sxs-lookup"><span data-stu-id="db043-112">Windows 7</span></span>
-   <span data-ttu-id="db043-113">Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="db043-113">Windows Server 2008 R2</span></span>

> [!Note]  
> <span data-ttu-id="db043-114">Windows Server 2008 R2 è disponibile solo come edizione a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-114">Windows Server 2008 R2 is only available as a 64-bit edition.</span></span>

 

-   [<span data-ttu-id="db043-115">Differenze nella memoria indirizzabile</span><span class="sxs-lookup"><span data-stu-id="db043-115">Differences in Addressable Memory</span></span>](#differences-in-addressable-memory)
-   [<span data-ttu-id="db043-116">Specifica di indirizzi di grandi dimensioni quando si compila</span><span class="sxs-lookup"><span data-stu-id="db043-116">Specifying Large-Address-Aware When Building</span></span>](#specifying-large-address-aware-when-building)
-   [<span data-ttu-id="db043-117">Compatibilità delle applicazioni a 32 bit su piattaforme a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-117">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [<span data-ttu-id="db043-118">Potenziali problemi di compatibilità</span><span class="sxs-lookup"><span data-stu-id="db043-118">Potential Compatibility Pitfalls</span></span>](#potential-compatibility-pitfalls)
-   [<span data-ttu-id="db043-119">Porting di applicazioni a piattaforme a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-119">Porting Applications to 64-Bit Platforms</span></span>](#porting-applications-to-64-bit-platforms)
-   [<span data-ttu-id="db043-120">Profilatura e ottimizzazione di applicazioni con porting</span><span class="sxs-lookup"><span data-stu-id="db043-120">Profiling and Optimization of Ported Applications</span></span>](#profiling-and-optimization-of-ported-applications)
-   [<span data-ttu-id="db043-121">Codice gestito in un sistema operativo a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-121">Managed Code on a 64-bit Operating System</span></span>](#managed-code-on-a-64-bit-operating-system)
-   [<span data-ttu-id="db043-122">Implicazioni sulle prestazioni dell'esecuzione di un sistema operativo a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-122">Performance Implications of Running a 64-bit Operating System</span></span>](#performance-implications-of-running-a-64-bit-operating-system)
-   [<span data-ttu-id="db043-123">Summary</span><span class="sxs-lookup"><span data-stu-id="db043-123">Summary</span></span>](#summary)

## <a name="differences-in-addressable-memory"></a><span data-ttu-id="db043-124">Differenze nella memoria indirizzabile</span><span class="sxs-lookup"><span data-stu-id="db043-124">Differences in Addressable Memory</span></span>

<span data-ttu-id="db043-125">La prima cosa che la maggior parte degli sviluppatori si nota è che i processori a 64 bit forniscono un notevole passo avanti nella quantità di memoria fisica e virtuale che può essere risolta.</span><span class="sxs-lookup"><span data-stu-id="db043-125">The first thing most developers notice is that 64-bit processors provide a huge leap in the amount of physical and virtual memory that can be addressed.</span></span>

-   <span data-ttu-id="db043-126">le applicazioni a 32 bit su piattaforme a 32 bit possono indirizzare fino a 2 GB.</span><span class="sxs-lookup"><span data-stu-id="db043-126">32-bit applications on 32-bit platforms can address up to 2 GB.</span></span>
-   <span data-ttu-id="db043-127">le applicazioni a 32 bit compilate con il flag del linker/LARGEADDRESSAWARE: Sì su Windows XP o Windows Server 2003 a 32 bit con l'opzione di avvio speciale/3GB possono essere indirizzate a un massimo di 3 GB.</span><span class="sxs-lookup"><span data-stu-id="db043-127">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on 32-bit Windows XP or Windows Server 2003 with the special /3gb boot option can address up to 3 GB.</span></span> <span data-ttu-id="db043-128">Questa operazione vincola il kernel solo a 1 GB, che può causare un errore di alcuni driver e/o servizi.</span><span class="sxs-lookup"><span data-stu-id="db043-128">This constrains the kernel to only 1 GB which may cause some drivers and/or services to fail.</span></span>
-   <span data-ttu-id="db043-129">le applicazioni a 32 bit compilate con il flag del linker/LARGEADDRESSAWARE: Sì nelle edizioni a 32 bit di Windows Vista, Windows Server 2008 e Windows 7 possono indirizzare la memoria fino al numero specificato dall'elemento IncreaseUserVa dei dati di configurazione di avvio (BCD).</span><span class="sxs-lookup"><span data-stu-id="db043-129">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on the 32-bit editions of Windows Vista, Windows Server 2008, and Windows 7 can address memory up to the number specified by the boot configuration data (BCD) element IncreaseUserVa.</span></span> <span data-ttu-id="db043-130">Il valore predefinito di IncreaseUserVa può essere compreso tra 2048 e 3072 (che corrisponde alla quantità di memoria configurata dall'opzione di avvio/3GB in Windows XP).</span><span class="sxs-lookup"><span data-stu-id="db043-130">IncreaseUserVa can have a value ranging from 2048, the default, to 3072 (which matches the amount of memory configured by the /3gb boot option on Windows XP).</span></span> <span data-ttu-id="db043-131">Il resto di 4 GB viene allocato al kernel e può causare la mancata configurazione di driver e servizi.</span><span class="sxs-lookup"><span data-stu-id="db043-131">The remainder of 4 GB is allocated to the kernel and can result in failing driver and service configurations.</span></span>

    <span data-ttu-id="db043-132">Per ulteriori informazioni su BCD, vedere [dati configurazione di avvio](https://msdn.microsoft.com/library/aa362692.aspx) su MSDN.</span><span class="sxs-lookup"><span data-stu-id="db043-132">For more information about BCD, see [Boot Configuration Data](https://msdn.microsoft.com/library/aa362692.aspx) on MSDN.</span></span>

-   <span data-ttu-id="db043-133">le applicazioni a 32 bit su piattaforme a 64 bit possono indirizzare fino a 2 GB o fino a 4 GB con il flag del linker/LARGEADDRESSAWARE: Sì.</span><span class="sxs-lookup"><span data-stu-id="db043-133">32-bit applications on 64-bit platforms can address up to 2 GB, or up to 4 GB with the /LARGEADDRESSAWARE:YES linker flag.</span></span>
-   <span data-ttu-id="db043-134">le applicazioni a 64 bit utilizzano 43 bit per l'indirizzamento, che fornisce 8 TB di indirizzo virtuale per le applicazioni e 8 TB riservati per il kernel.</span><span class="sxs-lookup"><span data-stu-id="db043-134">64-bit applications use 43 bits for addressing, which provides 8 TB of virtual address for applications and 8 TB reserved for the kernel.</span></span>

<span data-ttu-id="db043-135">Oltre alla semplice memoria, le applicazioni a 64 bit che utilizzano I/O di file mappati alla memoria traggono notevolmente vantaggio dallo spazio degli indirizzi virtuale più elevato.</span><span class="sxs-lookup"><span data-stu-id="db043-135">Beyond just memory, 64-bit applications that use memory-mapped file I/O benefit greatly from the increased virtual address space.</span></span> <span data-ttu-id="db043-136">L'architettura a 64 bit ha anche migliorato le prestazioni a virgola mobile e il passaggio più rapido dei parametri.</span><span class="sxs-lookup"><span data-stu-id="db043-136">The 64-bit architecture also has improved floating-point performance and faster passing of parameters.</span></span> <span data-ttu-id="db043-137">I processori a 64 bit hanno il doppio del numero di registri, sia dei tipi di utilizzo generico che di Streaming SIMD Extensions (SSE), oltre al supporto per i set di istruzioni SSE e SSE2. molti processori a 64 bit supportano anche set di istruzioni SSE3.</span><span class="sxs-lookup"><span data-stu-id="db043-137">Sixty-four-bit processors have double the number of registers, of both general purpose and streaming SIMD extensions (SSE) types, as well as support for SSE and SSE2 instruction sets; many 64-bit processors even support SSE3 instruction sets.</span></span>

## <a name="specifying-large-address-aware-when-building"></a><span data-ttu-id="db043-138">Specifica di indirizzi di grandi dimensioni quando si compila</span><span class="sxs-lookup"><span data-stu-id="db043-138">Specifying Large-Address-Aware When Building</span></span>

<span data-ttu-id="db043-139">Quando si compilano applicazioni a 32 bit, è consigliabile specificare un indirizzo di grandi dimensioni, utilizzando il flag del linker/LARGEADDRESSAWARE, anche se l'applicazione non è destinata a una piattaforma a 64 bit, a causa dei vantaggi ottenuti senza costi aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="db043-139">It is a good practice to specify large-address-aware when building 32-bit applications, by using the linker flag /LARGEADDRESSAWARE, even if the application is not intended for a 64-bit platform, because of the advantages that are gained at no cost.</span></span> <span data-ttu-id="db043-140">Come spiegato in precedenza, l'abilitazione di questo flag per una compilazione consente a un programma a 32 bit di accedere a una quantità maggiore di memoria con opzioni di avvio speciali in un sistema operativo a 32 bit o in un sistema operativo a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-140">As explained earlier, enabling this flag for a build allows a 32-bit program to access more memory with special boot options on a 32-bit OS or on a 64-bit OS.</span></span> <span data-ttu-id="db043-141">Tuttavia, gli sviluppatori devono prestare attenzione che i presupposti del puntatore non vengano eseguiti, ad esempio presumendo che l'alto bit non venga mai impostato in un puntatore a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-141">However, developers must be careful that pointer assumptions are not made, such as assuming that the high-bit is never set in a 32-bit pointer.</span></span> <span data-ttu-id="db043-142">In generale, l'abilitazione del flag/LARGEADDRESSAWARE è una procedura consigliata.</span><span class="sxs-lookup"><span data-stu-id="db043-142">In general, enabling the /LARGEADDRESSAWARE flag is a good practice.</span></span>

<span data-ttu-id="db043-143">Le applicazioni a 32 bit che sono compatibili con gli indirizzi grandi possono determinare in fase di esecuzione la quantità totale di spazio degli indirizzi virtuali disponibile con la configurazione del sistema operativo corrente chiamando [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span><span class="sxs-lookup"><span data-stu-id="db043-143">Thirty-two-bit applications that are large-address-aware can determine at run time how much total virtual address space is available to them with the current OS configuration by calling [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span></span> <span data-ttu-id="db043-144">Il risultato di ullTotalVirtual è compreso tra 2147352576 byte (2 GB) e 4294836224 byte (4 GB).</span><span class="sxs-lookup"><span data-stu-id="db043-144">The ullTotalVirtual result will range from 2147352576 bytes (2 GB) to 4294836224 bytes (4 GB).</span></span> <span data-ttu-id="db043-145">I valori maggiori di 3221094400 (3 GB) possono essere ottenuti solo nelle edizioni di Windows a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-145">Values that are larger than 3221094400 (3 GB) can only be obtained on 64-bit editions of Windows.</span></span> <span data-ttu-id="db043-146">Se, ad esempio, il valore di IncreaseUserVa è 2560, il risultato sarà ullTotalVirtual con un valore di 2684223488 byte.</span><span class="sxs-lookup"><span data-stu-id="db043-146">For example, if IncreaseUserVa has a value of 2560, the result is ullTotalVirtual with a value of 2684223488 bytes.</span></span>

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a><span data-ttu-id="db043-147">Compatibilità delle applicazioni a 32 bit su piattaforme a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-147">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>

<span data-ttu-id="db043-148">I sistemi operativi Windows a 64 bit sono compatibili con l'architettura IA32 e la maggior parte delle API usate dalle applicazioni a 32 bit è disponibile tramite Windows 32-bit nell'emulatore Windows a 64 bit, WOW64.</span><span class="sxs-lookup"><span data-stu-id="db043-148">Sixty-four-bit Windows operating systems are binary compatible with the IA32 architecture, and the majority of APIs that 32-bit applications use are available through the Windows 32-bit on Windows 64-bit Emulator, WOW64.</span></span> <span data-ttu-id="db043-149">WOW64 contribuisce a garantire che queste API funzioneranno come previsto.</span><span class="sxs-lookup"><span data-stu-id="db043-149">WOW64 helps ensure that these APIs will work as intended.</span></span>

<span data-ttu-id="db043-150">WOW64 dispone di un livello di esecuzione che gestisce il marshalling dei dati a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-150">WOW64 has an execution layer that handles the marshalling of 32-bit data.</span></span> <span data-ttu-id="db043-151">WOW64 reindirizza le richieste di file DLL, reindirizza alcuni rami del registro di sistema per le applicazioni a 32 bit e riflette alcuni rami del registro di sistema per le applicazioni 32 e 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-151">WOW64 redirects DLL file requests, redirects some registry branches for 32-bit applications, and reflects some registry branches for 32- and 64-bit applications.</span></span>

<span data-ttu-id="db043-152">Altre informazioni su WOW64 sono reperibili in [Dettagli di implementazione di WOW64](/windows/desktop/WinProg64/wow64-implementation-details) in MSDN.</span><span class="sxs-lookup"><span data-stu-id="db043-152">More information on WOW64 can be found at [WOW64 Implementation Details](/windows/desktop/WinProg64/wow64-implementation-details) on MSDN.</span></span> <span data-ttu-id="db043-153">Per le procedure consigliate per la creazione di applicazioni eseguite in WOW64, vedere procedure consigliate [per WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) in Windows Hardware Developer Central.</span><span class="sxs-lookup"><span data-stu-id="db043-153">For best practices for building applications that run on WOW64, see [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span></span>

### <a name="potential-compatibility-pitfalls"></a><span data-ttu-id="db043-154">Potenziali problemi di compatibilità</span><span class="sxs-lookup"><span data-stu-id="db043-154">Potential Compatibility Pitfalls</span></span>

<span data-ttu-id="db043-155">La maggior parte delle applicazioni sviluppate per una piattaforma a 32 bit viene eseguita senza problemi in una piattaforma a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-155">Most applications developed for a 32-bit platform will run without problems on a 64-bit platform.</span></span> <span data-ttu-id="db043-156">Alcune applicazioni potrebbero avere problemi, che possono includere quanto segue:</span><span class="sxs-lookup"><span data-stu-id="db043-156">A few applications could have issues, which might include the following:</span></span>

-   <span data-ttu-id="db043-157">Tutti i driver per le edizioni a 64 bit dei sistemi operativi Windows devono essere versioni a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-157">All drivers for by 64-bit editions of Windows operating systems must be 64-bit versions.</span></span> <span data-ttu-id="db043-158">La richiesta di nuovi driver a 64 bit presenta implicazioni per gli schemi di protezione da copia basati sui driver precedenti.</span><span class="sxs-lookup"><span data-stu-id="db043-158">Requiring new 64-bit drivers has implications for copy-protection schemes that rely on old drivers.</span></span> <span data-ttu-id="db043-159">Si noti che i driver in modalità kernel devono avere firma Authenticode per essere caricati da edizioni di Windows a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-159">Note that kernel-mode drivers must be Authenticode-signed to be loaded by 64-bit editions of Windows.</span></span>
-   <span data-ttu-id="db043-160">i processi a 64 bit non possono caricare DLL a 32 bit e i processi a 32 bit non possono caricare DLL a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-160">64-bit processes cannot load 32-bit DLLs, and 32-bit processes cannot load 64-bit DLLs.</span></span> <span data-ttu-id="db043-161">Prima di procedere con lo sviluppo, gli sviluppatori devono assicurarsi che siano disponibili versioni a 64 bit di dll di terze parti.</span><span class="sxs-lookup"><span data-stu-id="db043-161">Developers must ensure that 64-bit versions of third-party DLLs are available before proceeding with development.</span></span> <span data-ttu-id="db043-162">Se è necessario usare una DLL a 32 bit in un processo a 64 bit, è possibile usare la comunicazione tra processi di Windows (IPC).</span><span class="sxs-lookup"><span data-stu-id="db043-162">If you must use a 32-bit DLL in a 64-bit process, then Windows inter-process communication (IPC) can be used.</span></span> <span data-ttu-id="db043-163">I componenti COM possono inoltre utilizzare i server out-of-process e il marshalling per la comunicazione tra i limiti, ma ciò può comportare una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="db043-163">COM components can also make use of out-of-process servers and marshalling to communicate between boundaries, but doing so may introduce a performance penalty.</span></span>
-   <span data-ttu-id="db043-164">Molti processori x64 sono anche processori multicore e gli sviluppatori devono testare il modo in cui questo influiscono sulle applicazioni legacy.</span><span class="sxs-lookup"><span data-stu-id="db043-164">Many x64 processors are also multi-core processors, and developers need to test to how this affects their legacy applications.</span></span> <span data-ttu-id="db043-165">Altre informazioni sui processori multicore e sulle implicazioni per le applicazioni di gioco sono disponibili nei [processori di temporizzazione e multicore](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span><span class="sxs-lookup"><span data-stu-id="db043-165">More information on multi-core processors and the implications for gaming applications can be found in [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>
-   <span data-ttu-id="db043-166">Le applicazioni devono inoltre chiamare [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) per individuare i percorsi di file, in quanto alcuni nomi di cartella sono stati modificati in alcuni casi.</span><span class="sxs-lookup"><span data-stu-id="db043-166">Applications should also call [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) to discover file paths, as some folder names have changed in certain cases.</span></span> <span data-ttu-id="db043-167">Ad esempio, \_ i file di programma CSIDL \_ restituiranno "c: \\ Program Files (x86)" per un'applicazione a 32 bit in esecuzione su una piattaforma a 64 bit anziché "c: \\ Program Files".</span><span class="sxs-lookup"><span data-stu-id="db043-167">For example, CSIDL\_PROGRAM\_FILES would return "C:\\Program Files(x86)" for a 32-bit application running on a 64-bit platform instead of "C:\\Program Files".</span></span> <span data-ttu-id="db043-168">Gli sviluppatori devono essere consapevoli del funzionamento delle funzionalità di reindirizzamento e Reflection dell'emulatore WOW64.</span><span class="sxs-lookup"><span data-stu-id="db043-168">Developers must be mindful of how the WOW64 emulator's redirection and reflection capabilities work.</span></span>

<span data-ttu-id="db043-169">Inoltre, gli sviluppatori devono diffidare dei programmi a 16 bit che potrebbero ancora usare.</span><span class="sxs-lookup"><span data-stu-id="db043-169">In addition, developers need to be wary of 16-bit programs that they might still be using.</span></span> <span data-ttu-id="db043-170">WOW64 non è in grado di gestire le applicazioni a 16 bit; sono inclusi i programmi di installazione obsoleti e tutti i programmi MS-DOS.</span><span class="sxs-lookup"><span data-stu-id="db043-170">WOW64 cannot handle 16-bit applications; this includes old installers and all MS-DOS programs.</span></span>

> [!Note]  
> <span data-ttu-id="db043-171">I problemi di compatibilità più comuni sono i programmi di installazione che eseguono codice a 16 bit e non hanno driver a 64 bit per gli schemi di protezione della copia.</span><span class="sxs-lookup"><span data-stu-id="db043-171">The most common compatibility issues are installers that execute 16-bit code and not having 64-bit drivers for copy protection schemes.</span></span>

 

<span data-ttu-id="db043-172">Nella sezione successiva vengono illustrati i problemi relativi al porting del codice a 64 bit nativo per gli sviluppatori che desiderano garantire il funzionamento dei programmi legacy sulle piattaforme a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-172">The next section discusses issues related to porting code to 64-bit native for developers that want to ensure their legacy programs work on 64-bit platforms.</span></span> <span data-ttu-id="db043-173">È anche per gli sviluppatori che non hanno familiarità con la programmazione a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-173">It is also for developers who are unfamiliar with 64-bit programming.</span></span>

## <a name="porting-applications-to-64-bit-platforms"></a><span data-ttu-id="db043-174">Porting di applicazioni a piattaforme a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-174">Porting Applications to 64-Bit Platforms</span></span>

<span data-ttu-id="db043-175">Con gli strumenti e le librerie appropriati è possibile semplificare la transizione dallo sviluppo a 32 bit a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-175">Having the right tools and libraries will help to ease the transition from 32-bit to 64-bit development.</span></span> <span data-ttu-id="db043-176">DirectX 9 SDK dispone di librerie per supportare i progetti basati su x86 e x64.</span><span class="sxs-lookup"><span data-stu-id="db043-176">The DirectX 9 SDK has libraries to support both x86- and x64-based projects.</span></span> <span data-ttu-id="db043-177">Microsoft Visual Studio 2005 e Visual Studio 2008 supportano la generazione di codice sia per x86 che per x64 e sono forniti con librerie ottimizzate per la generazione di codice x64.</span><span class="sxs-lookup"><span data-stu-id="db043-177">Microsoft Visual Studio 2005 and Visual Studio 2008 support code generation for both x86 and x64, and they comes with libraries optimized for generating x64 code.</span></span> <span data-ttu-id="db043-178">Tuttavia, sarà anche necessario per gli sviluppatori distribuire i runtime di Visual C con le applicazioni.</span><span class="sxs-lookup"><span data-stu-id="db043-178">However, it will also be necessary for developers to distribute the Visual C runtimes with their applications.</span></span> <span data-ttu-id="db043-179">Si noti che le edizioni Express di Visual Studio 2005 e Visual Studio 2008 non includono il compilatore x64, ma le edizioni standard, Professional e Team System.</span><span class="sxs-lookup"><span data-stu-id="db043-179">Note that the Express Editions of Visual Studio 2005 and Visual Studio 2008 do not include the x64 compiler, but that the Standard, Professional, and Team System editions all do.</span></span>

<span data-ttu-id="db043-180">Gli sviluppatori destinati a piattaforme a 32 bit possono preparare lo sviluppo a 64 bit per semplificare la transizione in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="db043-180">Developers who are targeting 32-bit platforms can prepare for 64-bit development to make their transition easier later on.</span></span> <span data-ttu-id="db043-181">Quando si compilano progetti a 32 bit, gli sviluppatori devono usare il flag/Wp64, che causerà la generazione di avvisi relativi a problemi che influiscono sulla portabilità.</span><span class="sxs-lookup"><span data-stu-id="db043-181">When compiling 32-bit projects, developers should use the /Wp64 flag, which will cause the generation of warnings about issues that affect portability.</span></span> <span data-ttu-id="db043-182">Il cambio a strumenti e librerie a 64 bit genererà inizialmente molti nuovi errori di compilazione. è quindi consigliabile cambiare gli strumenti e le librerie indipendenti da bit e correggere eventuali avvisi prima di passare a una compilazione a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-182">Switching to 64-bit tools and libraries will probably generate a lot of new build errors initially; so, it is advisable to switch bit-neutral tools and libraries and correct any warnings before switching to a 64-bit build.</span></span>

<span data-ttu-id="db043-183">Tuttavia, la modifica degli strumenti, la modifica delle librerie e l'utilizzo di determinati flag del compilatore non saranno sufficienti.</span><span class="sxs-lookup"><span data-stu-id="db043-183">Changing tools, changing libraries, and using certain compiler flags will not be enough, though.</span></span> <span data-ttu-id="db043-184">È necessario rivalutare i presupposti negli standard di codifica per assicurarsi che gli standard di codifica correnti non consentano problemi di portabilità.</span><span class="sxs-lookup"><span data-stu-id="db043-184">Assumptions in coding standards must be reevaluated to ensure that current coding standards don't allow portability issues.</span></span> <span data-ttu-id="db043-185">I problemi di portabilità possono includere il troncamento del puntatore, le dimensioni e l'allineamento dei tipi di dati, la dipendenza da dll a 32 bit, l'uso di API legacy, codice assembly e file binari obsoleti.</span><span class="sxs-lookup"><span data-stu-id="db043-185">Portability issues can include pointer truncation, size and alignment of data types, reliance on 32-bit DLLs, use of legacy APIs, assembly code, and old binary files.</span></span>

> [!Note]  
> <span data-ttu-id="db043-186">Visual C++ 2010 include le intestazioni stdint. h e cstdint C99 che definiscono i tipi di portabilità standard Int32 \_ t, UInt32 \_ t, Int64 \_ t, UInt64 \_ t, IntPtr t \_ e UIntPtr \_ t.</span><span class="sxs-lookup"><span data-stu-id="db043-186">Visual C++ 2010 includes the stdint.h and cstdint C99 headers which define the standard portability types int32\_t, uint32\_t, int64\_t, uint64\_t, intptr\_t, and uintptr\_t.</span></span> <span data-ttu-id="db043-187">L'uso di questi \_ tipi di dati, insieme ai tipi di dati ptrdiff t e size t, \_ può essere preferibile ai tipi portabilty di Windows usati di seguito per migliorare la portabilità del codice.</span><span class="sxs-lookup"><span data-stu-id="db043-187">Using these along with the standard ptrdiff\_t and size\_t data types may be preferrable to the Windows portabilty types used below for improving portability of code.</span></span>

 

<span data-ttu-id="db043-188">I principali problemi di porting includono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="db043-188">Major porting issues include the following:</span></span>

<dl> <dt>

<span data-ttu-id="db043-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Troncamento puntatore**</span><span class="sxs-lookup"><span data-stu-id="db043-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Pointer Truncation**</span></span>
</dt> <dd>

<span data-ttu-id="db043-190">I puntatori sono 64 bit in un sistema operativo a 64 bit, quindi i puntatori di cast ad altri tipi di dati possono causare il troncamento e l'aritmetica dei puntatori può causare un danneggiamento.</span><span class="sxs-lookup"><span data-stu-id="db043-190">Pointers are 64-bits on a 64-bit OS, so casting pointers to other data types can result in truncation, and pointer arithmetic can result in corruption.</span></span> <span data-ttu-id="db043-191">Se si usa il flag/Wp64, in genere viene visualizzato un avviso relativo a questo tipo di problema, ma l'uso di tipi polimorfici (INT \_ ptr, DWORD \_ ptr, Size \_ T, uint \_ ptr e così via) quando si esegue il cast dei tipi di puntatore è una procedura consigliata che consente di evitare il problema.</span><span class="sxs-lookup"><span data-stu-id="db043-191">Using the /Wp64 flag will usually provide a warning about this kind of issue, but using polymorphic types (INT\_PTR, DWORD\_PTR, SIZE\_T, UINT\_PTR, and so on) when casting pointer types is a good practice to help avoid this issue altogether.</span></span> <span data-ttu-id="db043-192">Poiché i puntatori sono a 64 bit sulle nuove piattaforme, gli sviluppatori devono controllare l'ordine dei puntatori e i tipi di dati nelle classi e nelle strutture per ridurre o eliminare la spaziatura interna.</span><span class="sxs-lookup"><span data-stu-id="db043-192">Since pointers are 64-bit on new platforms, developers should check the ordering of pointers, and the data types in classes and structures, to reduce or eliminate padding.</span></span>

</dd> <dt>

<span data-ttu-id="db043-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Tipi di dati e file binari**</span><span class="sxs-lookup"><span data-stu-id="db043-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Data Types and Binary Files**</span></span>
</dt> <dd>

<span data-ttu-id="db043-194">Sebbene i puntatori aumentino da 32 bit a 64 in una piattaforma a 64 bit, altri tipi di dati non lo sono.</span><span class="sxs-lookup"><span data-stu-id="db043-194">While pointers increase from 32 bits to 64 on a 64-bit platform, other data types don't.</span></span> <span data-ttu-id="db043-195">I tipi di dati a precisione fissa (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) possono essere utilizzati in posizioni in cui è necessario conoscere le dimensioni del tipo di dati. ad esempio, in una struttura di file binaria.</span><span class="sxs-lookup"><span data-stu-id="db043-195">Fixed-precision data types (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) can be used in places where the size of the data type must be known; for example, in a binary file structure.</span></span> <span data-ttu-id="db043-196">Le modifiche alle dimensioni e all'allineamento dei dati del puntatore richiedono una gestione speciale per garantire la compatibilità da 32 bit a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-196">The changes in pointer size and data alignment require special handling to ensure 32-bit-to-64-bit compatibility.</span></span> <span data-ttu-id="db043-197">Altre informazioni sono reperibili in [preparazione per Windows a 64 bit: i nuovi tipi di dati](/windows/desktop/WinProg64/the-new-data-types).</span><span class="sxs-lookup"><span data-stu-id="db043-197">More information can be found in [Getting Ready for 64-bit Windows: The New Data Types](/windows/desktop/WinProg64/the-new-data-types).</span></span>

</dd> <dt>

<span data-ttu-id="db043-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**API Win32 e allineamento dati precedenti**</span><span class="sxs-lookup"><span data-stu-id="db043-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Older Win32 APIs and Data Alignment**</span></span>
</dt> <dd>

<span data-ttu-id="db043-199">Alcune API Win32 sono state deprecate e sostituite con chiamate API più neutre, ad esempio SetWindowLongPtr al posto di SetWindowLong.</span><span class="sxs-lookup"><span data-stu-id="db043-199">Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong.</span></span>

<span data-ttu-id="db043-200">La riduzione delle prestazioni per gli accessi non allineati è maggiore sulla piattaforma x64 rispetto a una piattaforma x86.</span><span class="sxs-lookup"><span data-stu-id="db043-200">The performance penalty for non-aligned accesses is greater on x64 platform than on an x86 platform.</span></span> <span data-ttu-id="db043-201">È \_ possibile utilizzare le macro Alignment (t) e offset del campo \_ (t, Member) per determinare le informazioni di allineamento che possono essere utilizzate direttamente dal codice.</span><span class="sxs-lookup"><span data-stu-id="db043-201">The TYPE\_ALIGNMENT(t) and the FIELD\_OFFSET(t, member) macros can be used to determine alignment information that can used directly by code.</span></span> <span data-ttu-id="db043-202">L'uso corretto di queste macro suddette dovrebbe eliminare le potenziali penalità di accesso non allineate.</span><span class="sxs-lookup"><span data-stu-id="db043-202">Correct use of these aforementioned macros should eliminate potential non-aligned access penalties.</span></span>

<span data-ttu-id="db043-203">Altre informazioni sulla macro di \_ allineamento dei tipi, sulla macro di offset dei campi \_ e sulle informazioni di programmazione generali a 64 bit sono disponibili nella [programmazione Windows a 64 bit: suggerimenti per la migrazione: considerazioni aggiuntive](/windows/desktop/WinProg64/additional-considerations) e [preparazione per Windows a 64 bit: regole per l'utilizzo di puntatori](/windows/desktop/WinProg64/rules-for-using-pointers).</span><span class="sxs-lookup"><span data-stu-id="db043-203">More information on the TYPE\_ALIGNMENT macro, the FIELD\_OFFSET macro, and general 64-bit programming information can be found at [64-bit Windows Programming: Migration Tips: Additional Considerations](/windows/desktop/WinProg64/additional-considerations) and [Getting Ready for 64-bit Windows: Rules for Using Pointers](/windows/desktop/WinProg64/rules-for-using-pointers).</span></span>

</dd> <dt>

<span data-ttu-id="db043-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Codice assembly**</span><span class="sxs-lookup"><span data-stu-id="db043-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assembly Code**</span></span>
</dt> <dd>

<span data-ttu-id="db043-205">Il codice assembly inline non è supportato nelle piattaforme a 64 bit e deve essere sostituito.</span><span class="sxs-lookup"><span data-stu-id="db043-205">Inline assembly code is not supported on 64-bit platforms and needs to be replaced.</span></span> <span data-ttu-id="db043-206">Le modifiche all'architettura potrebbero avere modificato i colli di bottiglia dell'applicazione e C/C++ o gli intrinseci possono ottenere risultati simili con codice più facile da leggere.</span><span class="sxs-lookup"><span data-stu-id="db043-206">Changes in the architecture may have changed application bottlenecks, and C/C++ or intrinsics can achieve similar results with code that is easier to read.</span></span> <span data-ttu-id="db043-207">La procedura più consigliata consiste nel passare tutto il codice assembly a C o C++.</span><span class="sxs-lookup"><span data-stu-id="db043-207">The most advisable practice is to switch all assembly code to C or C++.</span></span> <span data-ttu-id="db043-208">Gli intrinseci possono essere utilizzati al posto del codice dell'assembly, ma devono essere utilizzati solo dopo l'esecuzione della profilatura completa e dell'analisi.</span><span class="sxs-lookup"><span data-stu-id="db043-208">Intrinsics can be used in place of assembly code, but should only be used after full profiling and analysis has been performed.</span></span>

<span data-ttu-id="db043-209">X87, MMX e 3DNow!</span><span class="sxs-lookup"><span data-stu-id="db043-209">The x87, MMX, and 3DNow!</span></span> <span data-ttu-id="db043-210">i set di istruzioni sono deprecati in modalità a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-210">instruction sets are deprecated in 64-bit modes.</span></span> <span data-ttu-id="db043-211">I set di istruzioni sono ancora presenti per la compatibilità con le versioni precedenti per la modalità a 32 bit. Tuttavia, per evitare problemi di compatibilità in futuro, è sconsigliato l'uso nei progetti correnti e futuri.</span><span class="sxs-lookup"><span data-stu-id="db043-211">The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, their use in current and future projects is discouraged.</span></span>

</dd> <dt>

<span data-ttu-id="db043-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**API deprecate**</span><span class="sxs-lookup"><span data-stu-id="db043-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Deprecated APIs**</span></span>
</dt> <dd>

<span data-ttu-id="db043-213">Alcune API DirectX obsolete sono state eliminate per le applicazioni native a 64 bit: DirectPlay 4 e versioni precedenti, DirectDraw 6 e versioni precedenti, Direct3D 8 e versioni precedenti e DirectInput 7 e versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="db043-213">Some older DirectX APIs have been dropped for 64-bit native applications: DirectPlay 4 and earlier, DirectDraw 6 and earlier, Direct3D 8 and earlier, and DirectInput 7 and earlier.</span></span> <span data-ttu-id="db043-214">Inoltre, l'API di base di DirectMusic è disponibile per le applicazioni native a 64 bit, ma il livello di prestazioni e il produttore DirectMusic sono deprecati.</span><span class="sxs-lookup"><span data-stu-id="db043-214">Also, the core API of DirectMusic is available to native 64-bit applications, but the performance layer and DirectMusic Producer are deprecated.</span></span>

<span data-ttu-id="db043-215">Visual Studio rilascia avvisi di deprecazione e queste modifiche non rappresentano un problema per gli sviluppatori che usano le API più recenti.</span><span class="sxs-lookup"><span data-stu-id="db043-215">Visual Studio issues deprecation warnings, and these changes are not an issue for developers who use the latest APIs.</span></span>

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a><span data-ttu-id="db043-216">Profilatura e ottimizzazione di applicazioni con porting</span><span class="sxs-lookup"><span data-stu-id="db043-216">Profiling and Optimization of Ported Applications</span></span>

<span data-ttu-id="db043-217">Tutti gli sviluppatori devono riprofilare tutte le applicazioni che vengono trasferite a nuove architetture.</span><span class="sxs-lookup"><span data-stu-id="db043-217">All developers need to re-profile any applications that are being ported to new architectures.</span></span> <span data-ttu-id="db043-218">Molte applicazioni che vengono trasferite a piattaforme a 64 bit avranno profili di prestazioni diversi dalle versioni a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-218">Many applications being ported to 64-bit platforms will have different performance profiles from their 32-bit versions.</span></span> <span data-ttu-id="db043-219">Gli sviluppatori devono eseguire test delle prestazioni a 64 bit prima di valutare gli elementi che devono essere ottimizzati.</span><span class="sxs-lookup"><span data-stu-id="db043-219">Developers need to run 64-bit performance tests before assessing what needs to be optimized.</span></span> <span data-ttu-id="db043-220">L'aspetto positivo è che molte ottimizzazioni tradizionali funzionano su piattaforme a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-220">The good news about this is that many traditional optimizations work on 64-bit platforms.</span></span> <span data-ttu-id="db043-221">Inoltre, i compilatori a 64 bit possono anche eseguire numerose ottimizzazioni con l'uso corretto dei flag del compilatore e degli hint di codifica.</span><span class="sxs-lookup"><span data-stu-id="db043-221">In addition, 64-bit compilers can also perform many optimizations with the correct use of compiler flags and coding hints.</span></span>

<span data-ttu-id="db043-222">Alcune strutture possono avere tipi di dati interni riordinati per conservare lo spazio di memoria e migliorare la memorizzazione nella cache.</span><span class="sxs-lookup"><span data-stu-id="db043-222">Some structures may have their internal data types reordered to conserve memory space and improve caching.</span></span> <span data-ttu-id="db043-223">In alcuni casi, è possibile usare gli indici di matrice al posto di un puntatore a 64 bit completo.</span><span class="sxs-lookup"><span data-stu-id="db043-223">Array indices can be used instead of a full 64-bit pointer in some cases.</span></span> <span data-ttu-id="db043-224">Il flag/FP: Fast può migliorare l'ottimizzazione e la vettorizzazione a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="db043-224">The /fp:fast flag can improve floating-point optimizing and vectorization.</span></span> <span data-ttu-id="db043-225">\_ \_ L'uso di Restrict, declspec (restrict) e declspec (noalias) può aiutare il compilatore a risolvere gli alias e a migliorare l'uso del file di registro.</span><span class="sxs-lookup"><span data-stu-id="db043-225">Using \_\_restrict, declspec(restrict), and declspec(noalias) can help the compiler resolve aliasing and improve use of the register file.</span></span>

<span data-ttu-id="db043-226">Altre informazioni su/FP: Fast sono disponibili in [/FP (specificare il comportamento di Floating-Point)](/cpp/build/reference/fp-specify-floating-point-behavior).</span><span class="sxs-lookup"><span data-stu-id="db043-226">More information on /fp:fast can be found at [/fp (Specify Floating-Point Behavior)](/cpp/build/reference/fp-specify-floating-point-behavior).</span></span>

<span data-ttu-id="db043-227">Altre informazioni sulla \_ \_ limitazione sono reperibili in [modificatori specifici di Microsoft](/cpp/cpp/microsoft-specific-modifiers).</span><span class="sxs-lookup"><span data-stu-id="db043-227">More information on \_\_restrict can be found at [Microsoft-Specific Modifiers](/cpp/cpp/microsoft-specific-modifiers).</span></span>

<span data-ttu-id="db043-228">Altre informazioni su declspec (restrict) sono disponibili in [procedure consigliate](/cpp/build/optimization-best-practices)per l'ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="db043-228">More information on declspec(restrict) can be found at [Optimization Best Practices](/cpp/build/optimization-best-practices).</span></span>

<span data-ttu-id="db043-229">Altre informazioni su declspec (noalias) sono reperibili in [ \_ \_ declspec (noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span><span class="sxs-lookup"><span data-stu-id="db043-229">More information on declspec(noalias) can be found at [\_\_declspec(noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span></span>

## <a name="managed-code-on-a-64-bit-operating-system"></a><span data-ttu-id="db043-230">Codice gestito in un sistema operativo a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-230">Managed Code on a 64-bit Operating System</span></span>

<span data-ttu-id="db043-231">Il codice gestito viene usato da molti sviluppatori di giochi nella rispettiva catena di strumenti, quindi è utile comprendere il comportamento di un sistema operativo a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-231">Managed code is used by many game developers in their tool chain, so an understanding of how it behaves on a 64-bit OS can be helpful.</span></span> <span data-ttu-id="db043-232">Il codice gestito è un set di istruzioni neutro. Pertanto, quando si esegue un'applicazione gestita in un sistema operativo a 64 bit, Common Language Runtime (CLR) può eseguirlo come processo a 32 o a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-232">Managed code is instruction-set neutral, so when you run a managed application on a 64-bit OS, the Common Language Runtime (CLR) can run it as either a 32-bit or 64-bit process.</span></span> <span data-ttu-id="db043-233">Per impostazione predefinita, CLR esegue le applicazioni gestite come 64 bit e dovrebbero funzionare correttamente senza problemi.</span><span class="sxs-lookup"><span data-stu-id="db043-233">By default, the CLR runs managed applications as 64-bit, and they should work fine with no problems.</span></span> <span data-ttu-id="db043-234">Tuttavia, se l'applicazione dipende da una DLL nativa a 32 bit, l'applicazione avrà esito negativo quando tenterà di chiamare la DLL.</span><span class="sxs-lookup"><span data-stu-id="db043-234">However, if your application depends on a DLL that is native 32-bit, then your application will fail when it tries to call this DLL.</span></span> <span data-ttu-id="db043-235">Un processo a 64 bit richiede codice completamente a 64 bit e non è possibile chiamare una DLL a 32 bit da un processo a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-235">A 64-bit process needs completely 64-bit code, and a 32-bit DLL cannot be called from a 64-bit process.</span></span> <span data-ttu-id="db043-236">La soluzione migliore a lungo termine consiste nel compilare il codice nativo anche come 64 bit, ma una soluzione perfettamente ragionevole a breve termine è semplicemente contrassegnare l'applicazione gestita come per x86 solo usando il flag di compilazione/Platform: x86.</span><span class="sxs-lookup"><span data-stu-id="db043-236">The best long-term solution is to compile your native code as 64-bit also, but a perfectly reasonable short-term solution is to simply mark your managed application as being for x86 only by using the /platform:x86 build flag.</span></span>

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a><span data-ttu-id="db043-237">Implicazioni sulle prestazioni dell'esecuzione di un sistema operativo a 64 bit</span><span class="sxs-lookup"><span data-stu-id="db043-237">Performance Implications of Running a 64-bit Operating System</span></span>

<span data-ttu-id="db043-238">Poiché i processori con l'architettura AMD64 e Intel 64 possono eseguire istruzioni a 32 bit a livello nativo, possono eseguire applicazioni a 32 bit a velocità intera, anche in un sistema operativo a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-238">Because processors with AMD64 and Intel 64 architecture can execute 32-bit instructions natively, they can run 32-bit applications at full speed, even on a 64-bit OS.</span></span> <span data-ttu-id="db043-239">È previsto un costo modesto per la conversione di parametri tra 32 bit e 64 bit quando si chiamano funzioni del sistema operativo, ma questo costo è generalmente irrilevante.</span><span class="sxs-lookup"><span data-stu-id="db043-239">There is a modest cost for converting parameters between 32-bit and 64-bit when calling operating system functions, but this cost is generally negligible.</span></span> <span data-ttu-id="db043-240">Ciò significa che non si verifica alcun rallentamento quando si eseguono applicazioni a 32 bit in un sistema operativo a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="db043-240">This means that you should see no slowdown when running 32-bit applications on a 64-bit OS.</span></span>

<span data-ttu-id="db043-241">Quando si compilano applicazioni come 64 bit, i calcoli risultano più complessi.</span><span class="sxs-lookup"><span data-stu-id="db043-241">When you compile applications as 64-bit, the calculations get more complicated.</span></span> <span data-ttu-id="db043-242">Un programma a 64 bit usa puntatori a 64 bit e le istruzioni sono leggermente più grandi, quindi il requisito di memoria è leggermente maggiore.</span><span class="sxs-lookup"><span data-stu-id="db043-242">A 64-bit program uses 64-bit pointers, and its instructions are slightly larger, so the memory requirement is slightly increased.</span></span> <span data-ttu-id="db043-243">Questo può causare una lieve riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="db043-243">This can cause a slight drop in performance.</span></span> <span data-ttu-id="db043-244">D'altra parte, il doppio dei registri e la possibilità di eseguire calcoli di interi a 64 bit in un'unica istruzione spesso sono più che compensano.</span><span class="sxs-lookup"><span data-stu-id="db043-244">On the other hand, having twice as many registers and having the ability to do 64-bit integer calculations in a single instruction will often more than compensate.</span></span> <span data-ttu-id="db043-245">Il risultato finale è che un'applicazione a 64 bit può essere eseguita leggermente più lentamente rispetto alla stessa applicazione compilata come 32 bit, ma viene spesso eseguita leggermente più velocemente.</span><span class="sxs-lookup"><span data-stu-id="db043-245">The net result is that a 64-bit application might run slightly slower than the same application compiled as 32-bit, but it will often run slightly faster.</span></span>

## <a name="summary"></a><span data-ttu-id="db043-246">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="db043-246">Summary</span></span>

<span data-ttu-id="db043-247">Le architetture a 64 bit consentono agli sviluppatori di effettuare il push delle limitazioni relative all'aspetto, al suono e alla riproduzione dei giochi.</span><span class="sxs-lookup"><span data-stu-id="db043-247">Sixty-four-bit architectures allow developers to push the limitations on how games look, sound, and play.</span></span> <span data-ttu-id="db043-248">Tuttavia, la transizione dalla programmazione a 32 bit alla programmazione a 64 bit non è semplice.</span><span class="sxs-lookup"><span data-stu-id="db043-248">Transitioning from 32-bit programming to 64-bit programming is not trivial, however.</span></span> <span data-ttu-id="db043-249">Comprendendo le differenze tra i due e usando gli strumenti più recenti, la transizione alle piattaforme a 64 bit può essere più semplice e veloce.</span><span class="sxs-lookup"><span data-stu-id="db043-249">By understanding the differences between the two, and by using the newest tools, the transition to 64-bit platforms can be easier and faster.</span></span>

<span data-ttu-id="db043-250">Altre informazioni sulla programmazione a 64 bit sono disponibili in [Visual C++ Developer Center: programmazione a 64 bit](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span><span class="sxs-lookup"><span data-stu-id="db043-250">More information on 64-bit programming can be found at [Visual C++ Developer Center: 64-Bit Programming](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span></span>

 

 