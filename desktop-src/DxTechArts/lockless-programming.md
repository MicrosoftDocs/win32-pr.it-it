---
title: Considerazioni sulla programmazione senza blocchi per Xbox 360 e Microsoft Windows
description: In questo articolo viene illustrata una panoramica di alcuni dei problemi da considerare quando si tenta di utilizzare tecniche di programmazione non bloccate.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 23bf8d66cada8aff00735fe6d6ac2d4f1369bc32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/21/2020
ms.locfileid: "103963556"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a><span data-ttu-id="dd8ef-103">Considerazioni sulla programmazione senza blocchi per Xbox 360 e Microsoft Windows</span><span class="sxs-lookup"><span data-stu-id="dd8ef-103">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</span></span>

<span data-ttu-id="dd8ef-104">La programmazione senza blocchi è un modo per condividere in modo sicuro i dati mutevoli tra più thread senza il costo di acquisizione e rilascio dei blocchi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-104">Lockless programming is a way to safely share changing data between multiple threads without the cost of acquiring and releasing locks.</span></span> <span data-ttu-id="dd8ef-105">Si tratta di una panacea, ma la programmazione senza blocchi è complessa e leggera e talvolta non offre i vantaggi che promette.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-105">This sounds like a panacea, but lockless programming is complex and subtle, and sometimes doesn't give the benefits that it promises.</span></span> <span data-ttu-id="dd8ef-106">La programmazione con blocco è particolarmente complessa in Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-106">Lockless programming is particularly complex on Xbox 360.</span></span>

<span data-ttu-id="dd8ef-107">La programmazione senza blocchi è una tecnica valida per la programmazione multithreading, ma non deve essere usata con leggerezza.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-107">Lockless programming is a valid technique for multithreaded programming, but it should not be used lightly.</span></span> <span data-ttu-id="dd8ef-108">Prima di usarlo, è necessario comprendere le complessità ed è necessario misurarlo attentamente per assicurarsi che sia effettivamente in grado di fornire i vantaggi previsti.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-108">Before using it you must understand the complexities, and you should measure carefully to make sure that it is actually giving you the gains that you expect.</span></span> <span data-ttu-id="dd8ef-109">In molti casi sono disponibili soluzioni più semplici e veloci, ad esempio la condivisione di dati con una frequenza minore, che devono essere usate in alternativa.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-109">In many cases, there are simpler and faster solutions, such as sharing data less frequently, which should be used instead.</span></span>

<span data-ttu-id="dd8ef-110">L'uso corretto e sicuro della programmazione senza blocco richiede una conoscenza significativa dell'hardware e del compilatore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-110">Using lockless programming correctly and safely requires significant knowledge of both your hardware and your compiler.</span></span> <span data-ttu-id="dd8ef-111">In questo articolo viene illustrata una panoramica di alcuni dei problemi da considerare quando si tenta di utilizzare tecniche di programmazione non bloccate.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-111">This article gives an overview of some of the issues to consider when trying to use lockless programming techniques.</span></span>

## <a name="programming-with-locks"></a><span data-ttu-id="dd8ef-112">Programmazione con blocchi</span><span class="sxs-lookup"><span data-stu-id="dd8ef-112">Programming with Locks</span></span>

<span data-ttu-id="dd8ef-113">Quando si scrive codice multithread, spesso è necessario condividere i dati tra i thread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-113">When writing multi-threaded code it is often necessary to share data between threads.</span></span> <span data-ttu-id="dd8ef-114">Se più thread leggono e scrivono simultaneamente le strutture dei dati condivise, può verificarsi un danneggiamento della memoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-114">If multiple threads are simultaneously reading and writing the shared data structures, memory corruption can occur.</span></span> <span data-ttu-id="dd8ef-115">Il modo più semplice per risolvere questo problema consiste nell'usare i blocchi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-115">The simplest way of solving this problem is to use locks.</span></span> <span data-ttu-id="dd8ef-116">Se, ad esempio, ManipulateSharedData deve essere eseguito solo da un thread alla volta, \_ è possibile usare una sezione critica per garantire questo problema, come nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-116">For instance, if ManipulateSharedData should only be executed by one thread at a time, a CRITICAL\_SECTION can be used to guarantee this, as in the following code:</span></span>

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

<span data-ttu-id="dd8ef-117">Questo codice è piuttosto semplice e semplice ed è facile stabilire che sia corretto.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-117">This code is fairly simple and straightforward, and it is easy to tell that it is correct.</span></span> <span data-ttu-id="dd8ef-118">Tuttavia, la programmazione con blocchi presenta diversi svantaggi potenziali.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-118">However, programming with locks comes with several potential disadvantages.</span></span> <span data-ttu-id="dd8ef-119">Se ad esempio due thread tentano di acquisire gli stessi due blocchi ma li acquisiscono in un ordine diverso, è possibile che venga generato un deadlock.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-119">For example, if two threads try to acquire the same two locks but acquire them in a different order, you may get a deadlock.</span></span> <span data-ttu-id="dd8ef-120">Se un programma contiene un blocco per troppo tempo, a causa di una progettazione insufficiente o perché il thread è stato sostituito da un thread con priorità più elevata, è possibile che altri thread siano bloccati per un lungo periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-120">If a program holds a lock for too long—because of poor design or because the thread has been swapped out by a higher priority thread—other threads may be blocked for a long time.</span></span> <span data-ttu-id="dd8ef-121">Questo rischio è particolarmente utile in Xbox 360 perché ai thread software viene assegnato un thread hardware dallo sviluppatore e il sistema operativo non li sposta in un altro thread hardware, anche se uno è inattivo.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-121">This risk is particularly great on Xbox 360 because the software threads are assigned a hardware thread by the developer, and the operating system won't move them to another hardware thread, even if one is idle.</span></span> <span data-ttu-id="dd8ef-122">La versione Xbox 360 non dispone inoltre di protezione contro la priorità inversione, in cui un thread con priorità alta si blocca in un ciclo mentre è in attesa che un thread con priorità bassa rilasci un blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-122">The Xbox 360 also has no protection against priority inversion, where a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock.</span></span> <span data-ttu-id="dd8ef-123">Infine, se una chiamata di routine posticipata o una routine del servizio di interrupt tenta di acquisire un blocco, è possibile che venga generato un deadlock.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-123">Finally, if a deferred procedure call or interrupt service routine tries to acquire a lock, you may get a deadlock.</span></span>

<span data-ttu-id="dd8ef-124">Nonostante questi problemi, le primitive di sincronizzazione, ad esempio le sezioni critiche, rappresentano in genere il modo migliore per coordinare più thread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-124">Despite these problems, synchronization primitives, such as critical sections, are generally the best way of coordinating multiple threads.</span></span> <span data-ttu-id="dd8ef-125">Se le primitive di sincronizzazione sono troppo lente, la soluzione migliore è in genere utilizzarle con minore frequenza.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-125">If the synchronization primitives are too slow, the best solution is usually to use them less frequently.</span></span> <span data-ttu-id="dd8ef-126">Tuttavia, per coloro che possono permettersi la complessità aggiuntiva, un'altra opzione è la programmazione non bloccata.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-126">However, for those who can afford the extra complexity, another option is lockless programming.</span></span>

## <a name="lockless-programming"></a><span data-ttu-id="dd8ef-127">Programmazione con blocco</span><span class="sxs-lookup"><span data-stu-id="dd8ef-127">Lockless Programming</span></span>

<span data-ttu-id="dd8ef-128">La programmazione senza blocco, come suggerisce il nome, è una famiglia di tecniche per la manipolazione sicura dei dati condivisi senza utilizzare i blocchi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-128">Lockless programming, as the name suggests, is a family of techniques for safely manipulating shared data without using locks.</span></span> <span data-ttu-id="dd8ef-129">Sono disponibili algoritmi di blocco per il passaggio di messaggi, la condivisione di elenchi e code di dati e altre attività.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-129">There are lockless algorithms available for passing messages, sharing lists and queues of data, and other tasks.</span></span>

<span data-ttu-id="dd8ef-130">Quando si esegue la programmazione senza blocchi, è necessario gestire due problemi: operazioni non atomiche e riordino.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-130">When doing lockless programming, there are two challenges that you must deal with: non-atomic operations and reordering.</span></span>

## <a name="non-atomic-operations"></a><span data-ttu-id="dd8ef-131">Operazioni non atomiche</span><span class="sxs-lookup"><span data-stu-id="dd8ef-131">Non-Atomic Operations</span></span>

<span data-ttu-id="dd8ef-132">Un'operazione atomica è un valore indivisibile, ovvero uno in cui si garantisce che gli altri thread non visualizzino mai l'operazione quando il tempo è finito.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-132">An atomic operation is one that is indivisible—one where other threads are guaranteed to never see the operation when it is half done.</span></span> <span data-ttu-id="dd8ef-133">Le operazioni atomiche sono importanti per la programmazione senza blocco, perché senza di esse, altri thread potrebbero visualizzare valori parzialmente scritti o uno stato altrimenti incoerente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-133">Atomic operations are important for lockless programming, because without them, other threads might see half-written values, or otherwise inconsistent state.</span></span>

<span data-ttu-id="dd8ef-134">In tutti i processori moderni è possibile presupporre che le letture e le scritture dei tipi nativi allineati naturalmente siano atomiche.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-134">On all modern processors, you can assume that reads and writes of naturally aligned native types are atomic.</span></span> <span data-ttu-id="dd8ef-135">Finché il bus di memoria è almeno uguale a quello del tipo letto o scritto, la CPU legge e scrive questi tipi in una singola transazione del bus, rendendo impossibile per gli altri thread visualizzarli in uno stato a metà completato.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-135">As long as the memory bus is at least as wide as the type being read or written, the CPU reads and writes these types in a single bus transaction, making it impossible for other threads to see them in a half-completed state.</span></span> <span data-ttu-id="dd8ef-136">In x86 e x64 non è garantito che le letture e le Scritture maggiori di otto byte siano atomiche.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-136">On x86 and x64 there, is no guarantee that reads and writes larger than eight bytes are atomic.</span></span> <span data-ttu-id="dd8ef-137">Ciò significa che le letture e le Scritture a 16 byte dei registri di estensione di Streaming SIMD (SSE) e delle operazioni di stringa potrebbero non essere atomiche.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-137">This means that 16-byte reads and writes of streaming SIMD extension (SSE) registers, and string operations, might not be atomic.</span></span>

<span data-ttu-id="dd8ef-138">Le letture e le scritture di tipi non allineati naturalmente, ad esempio la scrittura di DWORD che superano i limiti di quattro byte, non sono necessariamente atomiche.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-138">Reads and writes of types that are not naturally aligned—for instance, writing DWORDs that cross four-byte boundaries—are not guaranteed to be atomic.</span></span> <span data-ttu-id="dd8ef-139">La CPU potrebbe dover eseguire queste operazioni di lettura e scrittura come più transazioni del bus, che potrebbero consentire a un altro thread di modificare o visualizzare i dati al centro della lettura o della scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-139">The CPU may have to do these reads and writes as multiple bus transactions, which could allow another thread to modify or see the data in the middle of the read or write.</span></span>

<span data-ttu-id="dd8ef-140">Le operazioni composite, ad esempio la sequenza di lettura-modifica-scrittura che si verifica quando si incrementa una variabile condivisa, non sono atomiche.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-140">Composite operations, such as the read-modify-write sequence that occurs when you increment a shared variable, are not atomic.</span></span> <span data-ttu-id="dd8ef-141">In Xbox 360 queste operazioni vengono implementate come più istruzioni (LWZ, addi e CAL) e il thread può essere sostituito legato tramite la sequenza.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-141">On Xbox 360, these operations are implemented as multiple instructions (lwz, addi, and stw), and the thread could be swapped out partway through the sequence.</span></span> <span data-ttu-id="dd8ef-142">In x86 e x64 è presente una singola istruzione (Inc) che può essere usata per incrementare una variabile in memoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-142">On x86 and x64, there is a single instruction (inc) that can be used to increment a variable in memory.</span></span> <span data-ttu-id="dd8ef-143">Se si usa questa istruzione, l'incremento di una variabile è atomico nei sistemi a processore singolo, ma non è ancora atomico nei sistemi a più processori.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-143">If you use this instruction, incrementing a variable is atomic on single-processor systems, but it is still not atomic on multi-processor systems.</span></span> <span data-ttu-id="dd8ef-144">Per la creazione di un sistema a più processori basato su x86 e x64 è necessario usare il prefisso di blocco, che impedisce a un altro processore di eseguire una propria sequenza di lettura-modifica-scrittura tra la lettura e la scrittura dell'istruzione Inc.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-144">Making inc atomic on x86- and x64-based multi-processor systems requires using the lock prefix, which prevents another processor from doing its own read-modify-write sequence between the read and the write of the inc instruction.</span></span>

<span data-ttu-id="dd8ef-145">Il codice seguente illustra alcuni esempi:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-145">The following code shows some examples:</span></span>

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a><span data-ttu-id="dd8ef-146">Garanzia dell'atomicità</span><span class="sxs-lookup"><span data-stu-id="dd8ef-146">Guaranteeing Atomicity</span></span>

<span data-ttu-id="dd8ef-147">È possibile assicurarsi di usare le operazioni atomiche con una combinazione dei seguenti elementi:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-147">You can be sure you are using atomic operations by a combination of the following:</span></span>

-   <span data-ttu-id="dd8ef-148">Operazioni atomiche naturalmente</span><span class="sxs-lookup"><span data-stu-id="dd8ef-148">Naturally atomic operations</span></span>
-   <span data-ttu-id="dd8ef-149">Blocchi per eseguire il wrapping di operazioni composite</span><span class="sxs-lookup"><span data-stu-id="dd8ef-149">Locks to wrap composite operations</span></span>
-   <span data-ttu-id="dd8ef-150">Funzioni del sistema operativo che implementano versioni atomiche delle operazioni composite più diffuse</span><span class="sxs-lookup"><span data-stu-id="dd8ef-150">Operating system functions that implement atomic versions of popular composite operations</span></span>

<span data-ttu-id="dd8ef-151">L'incremento di una variabile non è un'operazione atomica e l'incremento può causare il danneggiamento dei dati se eseguiti su più thread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-151">Incrementing a variable is not an atomic operation, and incrementing may lead to data corruption if executed on multiple threads.</span></span>

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

<span data-ttu-id="dd8ef-152">Win32 viene fornita con una famiglia di funzioni che offrono versioni atomiche di lettura-modifica-scrittura di diverse operazioni comuni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-152">Win32 comes with a family of functions that offer atomic read-modify-write versions of several common operations.</span></span> <span data-ttu-id="dd8ef-153">Si tratta della famiglia di funzioni InterlockedXxx.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-153">These are the InterlockedXxx family of functions.</span></span> <span data-ttu-id="dd8ef-154">Se tutte le modifiche della variabile condivisa utilizzano queste funzioni, le modifiche saranno thread-safe.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-154">If all modifications of the shared variable use these functions, the modifications will be thread safe.</span></span>

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a><span data-ttu-id="dd8ef-155">Riordinamento</span><span class="sxs-lookup"><span data-stu-id="dd8ef-155">Reordering</span></span>

<span data-ttu-id="dd8ef-156">Un problema più delicato è riordinare.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-156">A more subtle problem is reordering.</span></span> <span data-ttu-id="dd8ef-157">Le letture e le Scritture non sempre si verificano nell'ordine in cui sono state scritte nel codice e ciò può causare problemi molto confusi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-157">Reads and writes do not always happen in the order that you have written them in your code, and this can lead to very confusing problems.</span></span> <span data-ttu-id="dd8ef-158">In molti algoritmi multithread, un thread scrive alcuni dati e quindi scrive in un flag che indica ad altri thread che i dati sono pronti.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-158">In many multi-threaded algorithms, a thread writes some data and then writes to a flag that tells other threads that the data is ready.</span></span> <span data-ttu-id="dd8ef-159">Questa operazione è nota come versione di scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-159">This is known as a write-release.</span></span> <span data-ttu-id="dd8ef-160">Se le scritture vengono riordinate, è possibile che altri thread rivedano che il flag è impostato prima di poter visualizzare i dati scritti.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-160">If the writes are reordered, other threads may see that the flag is set before they can see the written data.</span></span>

<span data-ttu-id="dd8ef-161">Analogamente, in molti casi, un thread legge da un flag e quindi legge alcuni dati condivisi se il flag indica che il thread ha acquisito l'accesso ai dati condivisi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-161">Similarly, in many cases, a thread reads from a flag and then reads some shared data if the flag says that the thread has acquired access to the shared data.</span></span> <span data-ttu-id="dd8ef-162">Questa operazione è nota come acquisizione di lettura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-162">This is known as a read-acquire.</span></span> <span data-ttu-id="dd8ef-163">Se le letture vengono riordinate, i dati possono essere letti dallo spazio di archiviazione condiviso prima del flag e i valori visualizzati potrebbero non essere aggiornati.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-163">If reads are reordered, then the data may be read from shared storage before the flag, and the values seen might not be up to date.</span></span>

<span data-ttu-id="dd8ef-164">Il riordino di letture e scritture può essere eseguito sia dal compilatore che dal processore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-164">Reordering of reads and writes can be done both by the compiler and by the processor.</span></span> <span data-ttu-id="dd8ef-165">I compilatori e i processori hanno eseguito questo riordino per anni, ma sui computer a processore singolo era meno problematico.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-165">Compilers and processors have done this reordering for years, but on single-processor machines it was less of an issue.</span></span> <span data-ttu-id="dd8ef-166">Questo è dovuto al fatto che la ridisposizione della CPU di letture e scritture è invisibile nei computer a processore singolo (per il codice di driver non di dispositivo che non fa parte di un driver di dispositivo) e la riorganizzazione del compilatore di letture e scritture è meno probabile che causi problemi sui computer a processore singolo.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-166">This is because CPU rearrangement of reads and writes is invisible on single-processor machines (for non-device driver code that is not part of a device driver), and compiler rearrangement of reads and writes is less likely to cause problems on single-processor machines.</span></span>

<span data-ttu-id="dd8ef-167">Se il compilatore o la CPU riorganizza le Scritture illustrate nel codice seguente, un altro thread potrebbe vedere che il flag Alive è impostato, visualizzando comunque i valori precedenti per x o y.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-167">If the compiler or the CPU rearranges the writes shown in the following code, another thread may see that the alive flag is set while still seeing the old values for x or y.</span></span> <span data-ttu-id="dd8ef-168">Una riorganizzazione simile può verificarsi durante la lettura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-168">Similar rearrangement can happen when reading.</span></span>

<span data-ttu-id="dd8ef-169">In questo codice un thread aggiunge una nuova voce alla matrice sprite:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-169">In this code, one thread adds a new entry to the sprite array:</span></span>

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="dd8ef-170">In questo blocco di codice successivo, un altro thread legge dalla matrice di sprite:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-170">In this next code block, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="dd8ef-171">Per rendere il sistema sprite sicuro, è necessario impedire il riordinamento del compilatore e della CPU per le operazioni di lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-171">To make this sprite system safe, we need to prevent both compiler and CPU reordering of reads and writes.</span></span>

### <a name="understanding-cpu-rearrangement-of-writes"></a><span data-ttu-id="dd8ef-172">Informazioni sulla ridisposizione della CPU per le Scritture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-172">Understanding CPU Rearrangement of Writes</span></span>

<span data-ttu-id="dd8ef-173">Alcune CPU riordinano le Scritture in modo che siano visibili esternamente ad altri processori o dispositivi in ordine non di programma.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-173">Some CPUs rearrange writes so that they are externally visible to other processors or devices in non-program order.</span></span> <span data-ttu-id="dd8ef-174">Questa ridisposizione non è mai visibile al codice non driver a thread singolo, ma può causare problemi nel codice multithread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-174">This rearranging is never visible to single-threaded non-driver code, but it can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="dd8ef-175">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="dd8ef-175">Xbox 360</span></span>

<span data-ttu-id="dd8ef-176">Sebbene la CPU Xbox 360 non riordini le istruzioni, vengono riorganizzate le operazioni di scrittura, che vengono completate dopo le istruzioni stesse.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-176">While the Xbox 360 CPU does not reorder instructions, it does rearrange write operations, which complete after the instructions themselves.</span></span> <span data-ttu-id="dd8ef-177">Questa ridisposizione delle Scritture è consentita in modo specifico dal modello di memoria PowerPC.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-177">This rearranging of writes is specifically allowed by the PowerPC memory model.</span></span>

<span data-ttu-id="dd8ef-178">Le Scritture su Xbox 360 non passano direttamente alla cache L2.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-178">Writes on Xbox 360 do not go directly to the L2 cache.</span></span> <span data-ttu-id="dd8ef-179">Al contrario, per migliorare la larghezza di banda di scrittura della cache L2, passano attraverso le code di archiviazione e quindi per archiviare i buffer.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-179">Instead, in order to improve L2 cache write bandwidth, they go through store queues and then to store-gather buffers.</span></span> <span data-ttu-id="dd8ef-180">I buffer di archiviazione-raccolta consentono di scrivere blocchi di 64 byte nella cache L2 in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-180">The store-gather buffers allow 64-byte blocks to be written to the L2 cache in one operation.</span></span> <span data-ttu-id="dd8ef-181">Sono disponibili otto buffer di raccolta dei punti vendita, che consentono di scrivere in modo efficiente in diverse aree di memoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-181">There are eight store-gather buffers, which allow efficient writing to several different areas of memory.</span></span>

<span data-ttu-id="dd8ef-182">I buffer di archiviazione-raccolta vengono in genere scritti nella cache L2 nell'ordine FIFO (First in, First-out).</span><span class="sxs-lookup"><span data-stu-id="dd8ef-182">The store-gather buffers are normally written to the L2 cache in first-in-first-out (FIFO) order.</span></span> <span data-ttu-id="dd8ef-183">Tuttavia, se la riga della cache di destinazione di una scrittura non è presente nella cache L2, tale scrittura può essere posticipata mentre la riga della cache viene recuperata dalla memoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-183">However, if the target cache-line of a write is not in the L2 cache, that write may be delayed while the cache-line is fetched from memory.</span></span>

<span data-ttu-id="dd8ef-184">Anche quando i buffer di raccolta dati vengono scritti nella cache L2 in un ordine FIFO rigoroso, questo non garantisce che le singole scritture vengano scritte nella cache L2 nell'ordine.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-184">Even when the store-gather buffers are written to the L2 cache in strict FIFO order, this does not guarantee that individual writes are written to the L2 cache in order.</span></span> <span data-ttu-id="dd8ef-185">Si supponga, ad esempio, che la CPU scriva nel percorso 0x1000, quindi nel percorso 0x2000 e quindi nel percorso 0x1004.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-185">For instance, imagine that the CPU writes to location 0x1000, then to location 0x2000, and then to location 0x1004.</span></span> <span data-ttu-id="dd8ef-186">La prima scrittura alloca un buffer di raccolta dati e lo inserisce all'inizio della coda.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-186">The first write allocates a store-gather buffer and puts it at the front of the queue.</span></span> <span data-ttu-id="dd8ef-187">La seconda scrittura alloca un altro buffer di raccolta e lo inserisce successivamente nella coda.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-187">The second write allocates another store-gather buffer and puts it next in the queue.</span></span> <span data-ttu-id="dd8ef-188">La terza scrittura aggiunge i dati al primo buffer di raccolta, che rimane nella parte anteriore della coda.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-188">The third write adds its data to the first store-gather buffer, which remains at the front of the queue.</span></span> <span data-ttu-id="dd8ef-189">Quindi, la terza scrittura finisce per passare alla cache L2 prima della seconda scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-189">Thus, the third write ends up going to the L2 cache before the second write.</span></span>

<span data-ttu-id="dd8ef-190">Il riordino causato dai buffer di raccolta dei dati di archiviazione è fondamentalmente imprevedibile, soprattutto perché entrambi i thread in un core condividono i buffer di archiviazione-raccolta, rendendo l'allocazione e lo svuotamento dei buffer di archiviazione-raccolta estremamente variabili.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-190">Reordering caused by store-gather buffers is fundamentally unpredictable, especially because both threads on a core share the store-gather buffers, making the allocation and emptying of the store-gather buffers highly variable.</span></span>

<span data-ttu-id="dd8ef-191">Questo è un esempio di come è possibile riordinare le Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-191">This is one example of how writes can be reordered.</span></span> <span data-ttu-id="dd8ef-192">Potrebbero essere disponibili altre possibilità.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-192">There may be other possibilities.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="dd8ef-193">x86 e x64</span><span class="sxs-lookup"><span data-stu-id="dd8ef-193">x86 and x64</span></span>

<span data-ttu-id="dd8ef-194">Anche se le CPU x86 e x64 riordinano le istruzioni, in genere non riordinano le operazioni di scrittura relative ad altre Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-194">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder write operations relative to other writes.</span></span> <span data-ttu-id="dd8ef-195">Esistono alcune eccezioni per la memoria combinata in scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-195">There are some exceptions for write-combined memory.</span></span> <span data-ttu-id="dd8ef-196">Inoltre, le operazioni di stringa (MOVS e STOS) e le Scritture SSE a 16 byte possono essere riordinate internamente, ma in caso contrario, le Scritture non vengono riordinate l'una rispetto all'altra.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-196">Additionally, string operations (MOVS and STOS) and 16-byte SSE writes can be internally reordered, but otherwise, writes are not reordered relative to each other.</span></span>

### <a name="understanding-cpu-rearrangement-of-reads"></a><span data-ttu-id="dd8ef-197">Informazioni sulla ridisposizione della CPU delle letture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-197">Understanding CPU Rearrangement of Reads</span></span>

<span data-ttu-id="dd8ef-198">Alcune CPU riordinano le letture in modo che derivano effettivamente dall'archiviazione condivisa in ordine non di programma.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-198">Some CPUs rearrange reads so that they effectively come from shared storage in non-program order.</span></span> <span data-ttu-id="dd8ef-199">Questa ridisposizione non è mai visibile al codice non driver a thread singolo, ma può causare problemi nel codice multithread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-199">This rearranging is never visible to single-threaded non-driver code, but can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="dd8ef-200">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="dd8ef-200">Xbox 360</span></span>

<span data-ttu-id="dd8ef-201">I mancati riscontri nella cache possono causare un ritardo delle letture, che causa la mancata riuscita delle letture dalla memoria condivisa e la tempistica dei mancati riscontri nella cache è fondamentalmente imprevedibile.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-201">Cache misses can cause some reads to be delayed, which effectively causes reads to come from shared memory out of order, and the timing of these cache misses is fundamentally unpredictable.</span></span> <span data-ttu-id="dd8ef-202">La prelettura e la stima del ramo possono anche causare la derivazione dei dati dalla memoria condivisa non ordinata.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-202">Prefetching and branch prediction can also cause data to come from shared memory out of order.</span></span> <span data-ttu-id="dd8ef-203">Questi sono solo alcuni esempi di come è possibile riordinare le letture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-203">These are just a few examples of how reads can be reordered.</span></span> <span data-ttu-id="dd8ef-204">Potrebbero essere disponibili altre possibilità.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-204">There may be other possibilities.</span></span> <span data-ttu-id="dd8ef-205">Questa ridisposizione delle letture è consentita in modo specifico dal modello di memoria PowerPC.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-205">This rearranging of reads is specifically allowed by the PowerPC memory model.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="dd8ef-206">x86 e x64</span><span class="sxs-lookup"><span data-stu-id="dd8ef-206">x86 and x64</span></span>

<span data-ttu-id="dd8ef-207">Anche se le CPU x86 e x64 riordinano le istruzioni, in genere non riordinano le operazioni di lettura relative ad altre letture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-207">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder read operations relative to other reads.</span></span> <span data-ttu-id="dd8ef-208">Le operazioni di stringa (MOVS e STOS) e le letture SSE a 16 byte possono essere riordinate internamente, ma in caso contrario le letture non vengono riordinate in modo reciproco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-208">String operations (MOVS and STOS) and 16-byte SSE reads can be internally reordered, but otherwise, reads are not reordered relative to each other.</span></span>

### <a name="other-reordering"></a><span data-ttu-id="dd8ef-209">Altro riordino</span><span class="sxs-lookup"><span data-stu-id="dd8ef-209">Other Reordering</span></span>

<span data-ttu-id="dd8ef-210">Anche se le CPU x86 e x64 non riordinano le Scritture in relazione ad altre scritture o riordinano le letture rispetto ad altre letture, possono riordinare le letture rispetto alle Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-210">Even though x86 and x64 CPUs do not reorder writes relative to other writes, or reorder reads relative to other reads, they can reorder reads relative to writes.</span></span> <span data-ttu-id="dd8ef-211">In particolare, se un programma scrive in una posizione seguita dalla lettura da una posizione diversa, i dati letti possono provenire dalla memoria condivisa prima che i dati scritti li rendano disponibili.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-211">Specifically, if a program writes to one location followed by reading from a different location, the read data may come from shared memory before the written data makes it there.</span></span> <span data-ttu-id="dd8ef-212">Questo riordino può suddividere alcuni algoritmi, ad esempio gli algoritmi di esclusione reciproca di Dekker.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-212">This reordering can break some algorithms, such as Dekker’s mutual exclusion algorithms.</span></span> <span data-ttu-id="dd8ef-213">Nell'algoritmo di Dekker ogni thread imposta un flag per indicare che vuole entrare nell'area critica, quindi controlla il flag dell'altro thread per verificare se l'altro thread si trova nell'area critica o se tenta di immetterlo.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-213">In Dekker's algorithm, each thread sets a flag to indicate that it wants to enter the critical region, and then checks the other thread’s flag to see if the other thread is in the critical region or trying to enter it.</span></span> <span data-ttu-id="dd8ef-214">Il codice iniziale segue.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-214">The initial code follows.</span></span>

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

<span data-ttu-id="dd8ef-215">Il problema è che la lettura di F1 in P0Acquire può leggere dallo spazio di archiviazione condiviso prima che la scrittura in F0 lo renda lo spazio di archiviazione condiviso.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-215">The problem is that the read of f1 in P0Acquire can read from shared storage before the write to f0 makes it to shared storage.</span></span> <span data-ttu-id="dd8ef-216">Nel frattempo, la lettura di F0 in P1Acquire può leggere dallo spazio di archiviazione condiviso prima che la scrittura in F1 lo renda lo spazio di archiviazione condiviso.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-216">Meanwhile, the read of f0 in P1Acquire can read from shared storage before the write to f1 makes it to shared storage.</span></span> <span data-ttu-id="dd8ef-217">L'effetto finale è che entrambi i thread impostano i relativi flag su TRUE ed entrambi i thread visualizzano il flag dell'altro thread come FALSE, quindi entrambi entrano nell'area critica.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-217">The net effect is that both threads set their flags to TRUE, and both threads see the other thread's flag as being FALSE, so they both enter the critical region.</span></span> <span data-ttu-id="dd8ef-218">Pertanto, anche se i problemi di riordino nei sistemi basati su x86 e x64 sono meno comuni rispetto a Xbox 360, è possibile che si verifichino comunque.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-218">Therefore, while problems with reordering on x86- and x64-based systems are less common than on Xbox 360, they definitely can still happen.</span></span> <span data-ttu-id="dd8ef-219">L'algoritmo di Dekker non funzionerà senza barriere di memoria hardware su nessuna di queste piattaforme.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-219">Dekker’s algorithm will not work without hardware memory barriers on any of these platforms.</span></span>

<span data-ttu-id="dd8ef-220">le CPU x86 e x64 non riordinano una scrittura in anticipo rispetto a una lettura precedente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-220">x86 and x64 CPUs will not reorder a write ahead of a previous read.</span></span> <span data-ttu-id="dd8ef-221">le CPU x86 e x64 riordinano le letture prima delle Scritture precedenti se hanno come destinazione posizioni diverse.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-221">x86 and x64 CPUs only reorder reads ahead of previous writes if they target different locations.</span></span>

<span data-ttu-id="dd8ef-222">Le CPU PowerPC possono riordinare le letture prima delle Scritture e possono riordinare le Scritture prima delle letture, purché siano indirizzate a indirizzi diversi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-222">PowerPC CPUs can reorder reads ahead of writes, and can reorder writes ahead of reads, as long as they are to different addresses.</span></span>

### <a name="reordering-summary"></a><span data-ttu-id="dd8ef-223">Riepilogo di riordinamento</span><span class="sxs-lookup"><span data-stu-id="dd8ef-223">Reordering Summary</span></span>

<span data-ttu-id="dd8ef-224">La CPU Xbox 360 Riordina le operazioni di memoria molto più in modo più aggressivo rispetto alle CPU x86 e x64, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-224">The Xbox 360 CPU reorders memory operations much more aggressively than do x86 and x64 CPUs, as shown in the following table.</span></span> <span data-ttu-id="dd8ef-225">Per ulteriori informazioni, consultare la documentazione del processore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-225">For more details, consult the processor documentation.</span></span>



| <span data-ttu-id="dd8ef-226">Riordino dell'attività</span><span class="sxs-lookup"><span data-stu-id="dd8ef-226">Reordering Activity</span></span>           | <span data-ttu-id="dd8ef-227">x86 e x64</span><span class="sxs-lookup"><span data-stu-id="dd8ef-227">x86 and x64</span></span> | <span data-ttu-id="dd8ef-228">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="dd8ef-228">Xbox 360</span></span> |
|-------------------------------|-------------|----------|
| <span data-ttu-id="dd8ef-229">Letture in avanti rispetto alle letture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-229">Reads moving ahead of reads</span></span>   | <span data-ttu-id="dd8ef-230">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-230">No</span></span>          | <span data-ttu-id="dd8ef-231">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-231">Yes</span></span>      |
| <span data-ttu-id="dd8ef-232">Scritture in avanti nelle Scritture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-232">Writes moving ahead of writes</span></span> | <span data-ttu-id="dd8ef-233">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-233">No</span></span>          | <span data-ttu-id="dd8ef-234">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-234">Yes</span></span>      |
| <span data-ttu-id="dd8ef-235">Scritture in avanti rispetto alle letture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-235">Writes moving ahead of reads</span></span>  | <span data-ttu-id="dd8ef-236">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-236">No</span></span>          | <span data-ttu-id="dd8ef-237">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-237">Yes</span></span>      |
| <span data-ttu-id="dd8ef-238">Letture in avanti nelle Scritture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-238">Reads moving ahead of writes</span></span>  | <span data-ttu-id="dd8ef-239">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-239">Yes</span></span>         | <span data-ttu-id="dd8ef-240">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-240">Yes</span></span>      |



 

## <a name="read-acquire-and-write-release-barriers"></a><span data-ttu-id="dd8ef-241">Barriere Read-Acquire e Write-Release</span><span class="sxs-lookup"><span data-stu-id="dd8ef-241">Read-Acquire and Write-Release Barriers</span></span>

<span data-ttu-id="dd8ef-242">I costrutti principali usati per impedire il riordino di letture e scritture sono detti barriere Read-Acquire e Write-release.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-242">The main constructs used to prevent reordering of reads and writes are called read-acquire and write-release barriers.</span></span> <span data-ttu-id="dd8ef-243">Una lettura-acquisizione è una lettura di un flag o di un'altra variabile per ottenere la proprietà di una risorsa, abbinata a una barriera contro il riordinamento.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-243">A read-acquire is a read of a flag or other variable to gain ownership of a resource, coupled with a barrier against reordering.</span></span> <span data-ttu-id="dd8ef-244">Analogamente, una versione di scrittura è una scrittura di un flag o di un'altra variabile per fornire la proprietà di una risorsa, abbinata a una barriera contro il riordinamento.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-244">Similarly, a write-release is a write of a flag or other variable to give away ownership of a resource, coupled with a barrier against reordering.</span></span>

<span data-ttu-id="dd8ef-245">Le definizioni formali, per cortesia di Herb Sutter, sono:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-245">The formal definitions, courtesy of Herb Sutter, are:</span></span>

-   <span data-ttu-id="dd8ef-246">Un'acquisizione di lettura viene eseguita prima di tutte le letture e scritture da parte dello stesso thread che lo seguono nell'ordine del programma.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-246">A read-acquire executes before all reads and writes by the same thread that follow it in program order.</span></span>
-   <span data-ttu-id="dd8ef-247">Una versione Write-Release viene eseguita dopo tutte le operazioni di lettura e scrittura dallo stesso thread che lo precede nell'ordine del programma.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-247">A write-release executes after all reads and writes by the same thread that precede it in program order.</span></span>

<span data-ttu-id="dd8ef-248">Quando il codice acquisisce la proprietà di una certa memoria, acquisendo un blocco o estraendo un elemento da un elenco collegato condiviso (senza blocco), c'è sempre una lettura complessa, ovvero testando un flag o un puntatore per verificare se la proprietà della memoria è stata acquisita.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-248">When your code acquires ownership of some memory, either by acquiring a lock or by pulling an item off of a shared linked list (without a lock), there is always a read involved—testing a flag or pointer to see if ownership of the memory has been acquired.</span></span> <span data-ttu-id="dd8ef-249">Questa operazione di lettura può far parte di un'operazione **InterlockedXxx** , nel qual caso comporta sia la lettura che la scrittura, ma è la lettura che indica se la proprietà è stata acquisita.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-249">This read may be part of an **InterlockedXxx** operation, in which case it involves both a read and a write, but it is the read that indicates whether ownership has been gained.</span></span> <span data-ttu-id="dd8ef-250">Dopo aver acquisito la proprietà della memoria, i valori vengono in genere letti o scritti in tale memoria ed è molto importante che le letture e le Scritture vengano eseguite dopo l'acquisizione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-250">After ownership of the memory is acquired, values are typically read from or written to that memory, and it is very important that these reads and writes execute after acquiring ownership.</span></span> <span data-ttu-id="dd8ef-251">Una barriera di lettura/acquisizione garantisce questo problema.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-251">A read-acquire barrier guarantees this.</span></span>

<span data-ttu-id="dd8ef-252">Quando la proprietà di una determinata memoria viene rilasciata, rilasciando un blocco o eseguendo il push di un elemento in un elenco collegato condiviso, è sempre necessario un elemento Write che notifica ad altri thread che la memoria è ora disponibile.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-252">When ownership of some memory is released, either by releasing a lock or by pushing an item on to a shared linked list, there is always a write involved which notifies other threads that the memory is now available to them.</span></span> <span data-ttu-id="dd8ef-253">Sebbene il codice abbia la proprietà della memoria, è probabile che sia in grado di leggere o scrivere ed è molto importante che le letture e le Scritture vengano eseguite prima di rilasciare la proprietà.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-253">While your code had ownership of the memory, it probably read from or wrote to it, and it is very important that these reads and writes execute before releasing ownership.</span></span> <span data-ttu-id="dd8ef-254">Una barriera per la scrittura della versione garantisce questo problema.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-254">A write-release barrier guarantees this.</span></span>

<span data-ttu-id="dd8ef-255">È più semplice considerare le barriere Read-Acquire e Write-release come singole operazioni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-255">It is simplest to think of read-acquire and write-release barriers as single operations.</span></span> <span data-ttu-id="dd8ef-256">In alcuni casi, tuttavia, devono essere costruiti da due parti: una lettura o una scrittura e una barriera che non consente lo spostamento di letture o Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-256">However, they sometimes have to be constructed from two parts: a read or write and a barrier that does not allow reads or writes to move across it.</span></span> <span data-ttu-id="dd8ef-257">In questo caso, la posizione della barriera è fondamentale.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-257">In this case, the placement of the barrier is critical.</span></span> <span data-ttu-id="dd8ef-258">Per una barriera di lettura/acquisizione, la lettura del flag viene innanzitutto, quindi la barriera, quindi le letture e le scritture dei dati condivisi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-258">For a read-acquire barrier, the read of the flag comes first, then the barrier, and then the reads and writes of the shared data.</span></span> <span data-ttu-id="dd8ef-259">Per una barriera della versione Write, le letture e le scritture dei dati condivisi vengono prima di tutto, quindi la barriera, quindi la scrittura del flag.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-259">For a write-release barrier the reads and writes of the shared data come first, then the barrier, and then the write of the flag.</span></span>

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

<span data-ttu-id="dd8ef-260">L'unica differenza tra un'acquisizione di lettura e una versione di scrittura è la posizione della barriera di memoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-260">The only difference between a read-acquire and a write-release is the location of the memory barrier.</span></span> <span data-ttu-id="dd8ef-261">Una lettura-acquisizione presenta la barriera dopo l'operazione di blocco e una versione di scrittura ha la barriera prima di.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-261">A read-acquire has the barrier after the lock operation, and a write-release has the barrier before.</span></span> <span data-ttu-id="dd8ef-262">In entrambi i casi la barriera è tra i riferimenti alla memoria bloccata e i riferimenti al blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-262">In both cases the barrier is in-between the references to the locked memory and the references to the lock.</span></span>

<span data-ttu-id="dd8ef-263">Per comprendere il motivo per cui sono necessarie le barriere durante l'acquisizione e il rilascio dei dati, è preferibile (e più accurato) considerare queste barriere come garantire la sincronizzazione con la memoria condivisa, non con altri processori.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-263">To understand why barriers are needed both when acquiring and when releasing data, it is best (and most accurate) to think of these barriers as guaranteeing synchronization with shared memory, not with other processors.</span></span> <span data-ttu-id="dd8ef-264">Se un processore usa una versione di scrittura per rilasciare una struttura di dati alla memoria condivisa e un altro processore usa un'acquisizione di lettura per ottenere l'accesso alla struttura dei dati dalla memoria condivisa, il codice funzionerà correttamente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-264">If one processor uses a write-release to release a data structure to shared memory, and another processor uses a read-acquire to gain access to that data structure from shared memory, the code will then work properly.</span></span> <span data-ttu-id="dd8ef-265">Se uno dei processori non usa la barriera appropriata, la condivisione dei dati potrebbe non riuscire.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-265">If either processor doesn't use the appropriate barrier, the data sharing may fail.</span></span>

<span data-ttu-id="dd8ef-266">L'uso della barriera giusta per impedire il riordino del compilatore e della CPU per la piattaforma è fondamentale.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-266">Using the right barrier to prevent compiler and CPU reordering for your platform is critical.</span></span>

<span data-ttu-id="dd8ef-267">Uno dei vantaggi derivanti dall'utilizzo delle primitive di sincronizzazione fornite dal sistema operativo è che tutti includono le barriere di memoria appropriate.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-267">One of the advantages of using the synchronization primitives provided by the operating system is that all of them include the appropriate memory barriers.</span></span>

## <a name="preventing-compiler-reordering"></a><span data-ttu-id="dd8ef-268">Prevenzione del riordino del compilatore</span><span class="sxs-lookup"><span data-stu-id="dd8ef-268">Preventing Compiler Reordering</span></span>

<span data-ttu-id="dd8ef-269">Un processo del compilatore consiste nell'ottimizzare il codice in modo aggressivo per migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-269">A compiler's job is to aggressively optimize your code in order to improve performance.</span></span> <span data-ttu-id="dd8ef-270">Sono incluse le istruzioni per la ridisposizione laddove è utile e ovunque non cambino il comportamento.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-270">This includes rearranging instructions wherever it is helpful and wherever it will not change behavior.</span></span> <span data-ttu-id="dd8ef-271">Poiché lo standard C++ non menziona mai il multithreading e perché il compilatore non sa quale codice deve essere thread-safe, il compilatore presuppone che il codice sia a thread singolo quando si definiscono le riordinazioni che può eseguire in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-271">Because the C++ Standard never mentions multithreading, and because the compiler doesn't know what code needs to be thread-safe, the compiler assumes that your code is single-threaded when deciding what rearrangements it can safely do.</span></span> <span data-ttu-id="dd8ef-272">Pertanto, è necessario indicare al compilatore quando non è consentito riordinare le letture e le Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-272">Therefore, you need to tell the compiler when it is not allowed to reorder reads and writes.</span></span>

<span data-ttu-id="dd8ef-273">Con Visual C++ è possibile impedire il riordino del compilatore usando il [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)intrinseco del compilatore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-273">With Visual C++ you can prevent compiler reordering by using the compiler intrinsic [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx).</span></span> <span data-ttu-id="dd8ef-274">Quando si inserisce **\_ ReadWriteBarrier** nel codice, il compilatore non sposta le letture e le Scritture su di esso.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-274">Where you insert **\_ReadWriteBarrier** into your code, the compiler will not move reads and writes across it.</span></span>

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="dd8ef-275">Nel codice seguente un altro thread legge dalla matrice di sprite:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-275">In the following code, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="dd8ef-276">È importante comprendere che [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) non inserisce istruzioni aggiuntive e non impedisce alla CPU di riorganizzare le letture e le Scritture, ma impedisce solo al compilatore di riorganizzarle.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-276">It is important to understand that [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) does not insert any additional instructions, and it does not prevent the CPU from rearranging reads and writes—it only prevents the compiler from rearranging them.</span></span> <span data-ttu-id="dd8ef-277">Pertanto, **\_ ReadWriteBarrier** è sufficiente quando si implementa una barriera di scrittura in x86 e x64 (poiché x86 e x64 non riordinano le Scritture e una scrittura normale è sufficiente per rilasciare un blocco), ma nella maggior parte degli altri casi è anche necessario impedire alla CPU di riordinare le letture e le Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-277">Thus, **\_ReadWriteBarrier** is sufficient when you implement a write-release barrier on x86 and x64 (because x86 and x64 do not reorder writes, and a normal write is sufficient for releasing a lock), but in most other cases, it is also necessary to prevent the CPU from reordering reads and writes.</span></span>

<span data-ttu-id="dd8ef-278">È anche possibile usare [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) quando si scrive in una memoria non memorizzabile nella cache in scrittura per impedire il riordinamento delle Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-278">You can also use [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) when you write to non-cacheable write-combined memory to prevent reordering of writes.</span></span> <span data-ttu-id="dd8ef-279">In questo caso **\_ ReadWriteBarrier** consente di migliorare le prestazioni, garantendo che le Scritture avvengano nell'ordine lineare preferito del processore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-279">In this case **\_ReadWriteBarrier** helps to improve performance, by guaranteeing that the writes happen in the processor's preferred linear order.</span></span>

<span data-ttu-id="dd8ef-280">È anche possibile usare gli intrinseci [**\_ ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) e [**\_ WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) per un controllo più preciso del riordino del compilatore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-280">It is also possible to use the [**\_ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) and [**\_WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) intrinsics for more precise control of compiler reordering.</span></span> <span data-ttu-id="dd8ef-281">Il compilatore non sposterà le letture in un **\_ ReadBarrier** e non sposterà le Scritture in un **\_ WriteBarrier**.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-281">The compiler will not move reads across a **\_ReadBarrier**, and it will not move writes across a **\_WriteBarrier**.</span></span>

## <a name="preventing-cpu-reordering"></a><span data-ttu-id="dd8ef-282">Prevenzione del riordino della CPU</span><span class="sxs-lookup"><span data-stu-id="dd8ef-282">Preventing CPU Reordering</span></span>

<span data-ttu-id="dd8ef-283">Il riordino della CPU è più sottile rispetto al riordino del compilatore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-283">CPU reordering is more subtle than compiler reordering.</span></span> <span data-ttu-id="dd8ef-284">Non è possibile vedere che si verifica direttamente, vengono visualizzati solo i bug inspiegabili.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-284">You can't ever see it happen directly, you just see inexplicable bugs.</span></span> <span data-ttu-id="dd8ef-285">Per evitare il riordino della CPU di letture e scritture, è necessario usare le istruzioni per la barriera di memoria su alcuni processori.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-285">In order to prevent CPU reordering of reads and writes you need to use memory barrier instructions, on some processors.</span></span> <span data-ttu-id="dd8ef-286">Il nome di tutte le finalità per un'istruzione della barriera di memoria, su Xbox 360 e su Windows, è [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span><span class="sxs-lookup"><span data-stu-id="dd8ef-286">The all-purpose name for a memory barrier instruction, on Xbox 360 and on Windows, is [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span></span> <span data-ttu-id="dd8ef-287">Questa macro è implementata in modo appropriato per ogni piattaforma.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-287">This macro is implemented appropriately for each platform.</span></span>

<span data-ttu-id="dd8ef-288">In Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) è definito come **lwsync** (Lightweight Sync), disponibile anche tramite la funzione intrinseca **\_ \_ lwsync** , definita in ppcintrinsics. h.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-288">On Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined as **lwsync** (lightweight sync), also available through the **\_\_lwsync** intrinsic, which is defined in ppcintrinsics.h.</span></span> <span data-ttu-id="dd8ef-289">**\_ \_ lwsync** funge anche da barriera di memoria del compilatore, impedendo la ridisposizione delle letture e scritture da parte del compilatore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-289">**\_\_lwsync** also serves as a compiler memory barrier, preventing rearranging of reads and writes by the compiler.</span></span>

<span data-ttu-id="dd8ef-290">L'istruzione **lwsync** è una barriera di memoria su Xbox 360 che sincronizza un core del processore con la cache L2.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-290">The **lwsync** instruction is a memory barrier on Xbox 360 that synchronizes one processor core with the L2 cache.</span></span> <span data-ttu-id="dd8ef-291">Garantisce che tutte le Scritture prima di **lwsync** lo rendano nella cache L2 prima di qualsiasi scrittura successiva.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-291">It guarantees that all writes before **lwsync** make it to the L2 cache before any writes that follow.</span></span> <span data-ttu-id="dd8ef-292">Garantisce inoltre che le letture che seguono **lwsync** non ottengano dati meno recenti da L2 rispetto alle letture precedenti.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-292">It also guarantees that any reads that follow **lwsync** don't get older data from L2 than previous reads.</span></span> <span data-ttu-id="dd8ef-293">Il tipo di riordino che non impedisce è quello di una lettura che precede la scrittura in un indirizzo diverso.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-293">The one type of reordering that it does not prevent is a read moving ahead of a write to a different address.</span></span> <span data-ttu-id="dd8ef-294">Quindi, **lwsync** impone l'ordine di memoria che corrisponde all'ordine di memoria predefinito nei processori x86 e x64.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-294">Thus, **lwsync** enforces memory ordering that matches the default memory ordering on x86 and x64 processors.</span></span> <span data-ttu-id="dd8ef-295">Per ottenere l'ordinamento della memoria completa, è necessaria l'istruzione di sincronizzazione più costosa (nota anche come sincronizzazione dei pesi massimi), ma nella maggior parte dei casi questa operazione non è obbligatoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-295">To get full memory ordering requires the more expensive sync instruction (also known as heavyweight sync), but in most cases, this is not required.</span></span> <span data-ttu-id="dd8ef-296">Le opzioni di riordino della memoria in Xbox 360 sono illustrate nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-296">The memory reordering options on Xbox 360 are shown in the following table.</span></span>



| <span data-ttu-id="dd8ef-297">Riordino di Xbox 360</span><span class="sxs-lookup"><span data-stu-id="dd8ef-297">Xbox 360 Reordering</span></span>           | <span data-ttu-id="dd8ef-298">Nessuna sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="dd8ef-298">No sync</span></span> | <span data-ttu-id="dd8ef-299">lwsync</span><span class="sxs-lookup"><span data-stu-id="dd8ef-299">lwsync</span></span> | <span data-ttu-id="dd8ef-300">sync</span><span class="sxs-lookup"><span data-stu-id="dd8ef-300">sync</span></span> |
|-------------------------------|---------|--------|------|
| <span data-ttu-id="dd8ef-301">Letture in avanti rispetto alle letture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-301">Reads moving ahead of reads</span></span>   | <span data-ttu-id="dd8ef-302">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-302">Yes</span></span>     | <span data-ttu-id="dd8ef-303">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-303">No</span></span>     | <span data-ttu-id="dd8ef-304">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-304">No</span></span>   |
| <span data-ttu-id="dd8ef-305">Scritture in avanti nelle Scritture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-305">Writes moving ahead of writes</span></span> | <span data-ttu-id="dd8ef-306">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-306">Yes</span></span>     | <span data-ttu-id="dd8ef-307">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-307">No</span></span>     | <span data-ttu-id="dd8ef-308">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-308">No</span></span>   |
| <span data-ttu-id="dd8ef-309">Scritture in avanti rispetto alle letture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-309">Writes moving ahead of reads</span></span>  | <span data-ttu-id="dd8ef-310">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-310">Yes</span></span>     | <span data-ttu-id="dd8ef-311">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-311">No</span></span>     | <span data-ttu-id="dd8ef-312">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-312">No</span></span>   |
| <span data-ttu-id="dd8ef-313">Letture in avanti nelle Scritture</span><span class="sxs-lookup"><span data-stu-id="dd8ef-313">Reads moving ahead of writes</span></span>  | <span data-ttu-id="dd8ef-314">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-314">Yes</span></span>     | <span data-ttu-id="dd8ef-315">Sì</span><span class="sxs-lookup"><span data-stu-id="dd8ef-315">Yes</span></span>    | <span data-ttu-id="dd8ef-316">No</span><span class="sxs-lookup"><span data-stu-id="dd8ef-316">No</span></span>   |



 

<span data-ttu-id="dd8ef-317">PowerPC include anche le istruzioni di sincronizzazione **iSync** e **eieio** (che viene usato per controllare il riordino della memoria inibita dalla memorizzazione nella cache).</span><span class="sxs-lookup"><span data-stu-id="dd8ef-317">PowerPC also has the synchronization instructions **isync** and **eieio** (which is used to control reordering to caching-inhibited memory).</span></span> <span data-ttu-id="dd8ef-318">Queste istruzioni di sincronizzazione non devono essere necessarie per scopi di sincronizzazione normali.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-318">These synchronization instructions should not be needed for normal synchronization purposes.</span></span>

<span data-ttu-id="dd8ef-319">In Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) è definito in Winnt. h e fornisce un'altra istruzione della barriera di memoria a seconda che si stia compilando per x86 o x64.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-319">On Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined in Winnt.h and gives you a different memory barrier instruction depending on whether you are compiling for x86 or x64.</span></span> <span data-ttu-id="dd8ef-320">L'istruzione della barriera di memoria funge da barriera completa, impedendo il riordino di letture e scritture attraverso la barriera.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-320">The memory barrier instruction serves as a full barrier, preventing all reordering of reads and writes across the barrier.</span></span> <span data-ttu-id="dd8ef-321">**MemoryBarrier** in Windows offre quindi una garanzia di riordinamento più avanzata rispetto a Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-321">Thus, **MemoryBarrier** on Windows gives a stronger reordering guarantee than it does on Xbox 360.</span></span>

<span data-ttu-id="dd8ef-322">In Xbox 360 e in molte altre CPU è possibile evitare un altro modo in cui la CPU può essere riordinata dalla CPU.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-322">On Xbox 360, and on many other CPUs, there is one additional way that read-reordering by the CPU can be prevented.</span></span> <span data-ttu-id="dd8ef-323">Se si legge un puntatore e si utilizza tale puntatore per caricare altri dati, la CPU garantisce che le letture del puntatore non siano precedenti alla lettura del puntatore.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-323">If you read a pointer and then use that pointer to load other data, the CPU guarantees that the reads off of the pointer are not older than the read of the pointer.</span></span> <span data-ttu-id="dd8ef-324">Se il flag di blocco è un puntatore e se tutte le letture dei dati condivisi sono disattivate dal puntatore, il [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) può essere omesso, per un modesto risparmio delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-324">If your lock flag is a pointer and if all reads of shared data are off of the pointer, the [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) can be omitted, for a modest performance savings.</span></span>

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

<span data-ttu-id="dd8ef-325">L'istruzione [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) impedisce solo il riordinamento delle letture e scritture nella memoria memorizzabile nella cache.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-325">The [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) instruction only prevents reordering of reads and writes to cacheable memory.</span></span> <span data-ttu-id="dd8ef-326">Se si alloca memoria come pagina \_ NoCache o pagina \_ WRITECOMBINE, una tecnica comune per gli autori di driver di dispositivo e per gli sviluppatori di giochi su Xbox 360, **MemoryBarrier** non ha alcun effetto sugli accessi alla memoria.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-326">If you allocate memory as PAGE\_NOCACHE or PAGE\_WRITECOMBINE, a common technique for device driver authors and for game developers on Xbox 360, **MemoryBarrier** has no effect on accesses to this memory.</span></span> <span data-ttu-id="dd8ef-327">La maggior parte degli sviluppatori non necessita della sincronizzazione della memoria non memorizzabile nella cache.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-327">Most developers don't need synchronization of non-cacheable memory.</span></span> <span data-ttu-id="dd8ef-328">Questa operazione non rientra nell'ambito di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-328">That is beyond the scope of this article.</span></span>

## <a name="interlocked-functions-and-cpu-reordering"></a><span data-ttu-id="dd8ef-329">Funzioni Interlocked e riordino della CPU</span><span class="sxs-lookup"><span data-stu-id="dd8ef-329">Interlocked Functions and CPU Reordering</span></span>

<span data-ttu-id="dd8ef-330">In alcuni casi, la lettura o la scrittura che acquisisce o rilascia una risorsa viene eseguita utilizzando una delle funzioni **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="dd8ef-330">Sometimes the read or write that acquires or releases a resource is done using one of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="dd8ef-331">In Windows questo semplifica le cose; Poiché in Windows, le funzioni **InterlockedXxx** sono tutte barriere a memoria totale.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-331">On Windows, this simplifies things; because on Windows, the **InterlockedXxx** functions are all full-memory barriers.</span></span> <span data-ttu-id="dd8ef-332">Hanno una barriera di memoria della CPU sia prima che dopo di esse, il che significa che si tratta di una barriera completa di lettura/acquisizione o di scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-332">They effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.</span></span>

<span data-ttu-id="dd8ef-333">In Xbox 360 le funzioni **InterlockedXxx** non contengono barriere di memoria CPU.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-333">On Xbox 360, the **InterlockedXxx** functions do not contain CPU memory barriers.</span></span> <span data-ttu-id="dd8ef-334">Evitano il riordino del compilatore di letture e scritture ma non di riordino della CPU.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-334">They prevent compiler reordering of reads and writes but not CPU reordering.</span></span> <span data-ttu-id="dd8ef-335">Pertanto, nella maggior parte dei casi, quando si usano le funzioni **InterlockedXxx** su Xbox 360, è necessario precederle o seguirle con un **\_ \_ lwsync** per renderle una barriera di lettura/acquisizione o di scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-335">Therefore, in most cases when using **InterlockedXxx** functions on Xbox 360, you should precede or follow them with an **\_\_lwsync**, to make them a read-acquire or write-release barrier.</span></span> <span data-ttu-id="dd8ef-336">Per praticità e per semplificare la leggibilità, sono disponibili versioni di **acquisizione** e **rilascio** di molte delle funzioni di **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="dd8ef-336">For convenience and for easier readability, there are **Acquire** and **Release** versions of many of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="dd8ef-337">Questi sono dotati di una barriera di memoria incorporata.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-337">These come with a built-in memory barrier.</span></span> <span data-ttu-id="dd8ef-338">Ad esempio, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) esegue un incremento Interlocked seguito da una barriera di memoria **\_ \_ lwsync** per fornire la funzionalità di lettura/acquisizione completa.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-338">For instance, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) does an interlocked increment followed by an **\_\_lwsync** memory barrier to give the full read-acquire functionality.</span></span>

<span data-ttu-id="dd8ef-339">Si consiglia di usare le versioni di **acquisizione** e **rilascio** delle funzioni **InterlockedXxx** (la maggior parte delle quali sono disponibili anche in Windows, senza alcuna riduzione delle prestazioni), per rendere più ovvia la finalità e per semplificare l'ottenimento delle istruzioni della barriera di memoria nella posizione corretta.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-339">It is recommended that you use the **Acquire** and **Release** versions of the **InterlockedXxx** functions (most of which are available on Windows as well, with no performance penalty) to make your intent more obvious and to make it easier to get the memory barrier instructions in the correct place.</span></span> <span data-ttu-id="dd8ef-340">Qualsiasi uso di **InterlockedXxx** su Xbox 360 senza una barriera di memoria deve essere esaminato con molta attenzione, perché si tratta spesso di un bug.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-340">Any use of **InterlockedXxx** on Xbox 360 without a memory barrier should be examined very carefully, because it is often a bug.</span></span>

<span data-ttu-id="dd8ef-341">Questo esempio illustra come un thread può passare attività o altri dati a un altro thread usando le versioni di **acquisizione** e **rilascio** delle funzioni **InterlockedXxxSList** .</span><span class="sxs-lookup"><span data-stu-id="dd8ef-341">This sample demonstrates how one thread can pass tasks or other data to another thread using the **Acquire** and **Release** versions of the **InterlockedXxxSList** functions.</span></span> <span data-ttu-id="dd8ef-342">Le funzioni **InterlockedXxxSList** sono una famiglia di funzioni per la gestione di un elenco con collegamento singolarmente condiviso senza blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-342">The **InterlockedXxxSList** functions are a family of functions for maintaining a shared singly linked list without a lock.</span></span> <span data-ttu-id="dd8ef-343">Si noti che le varianti di **acquisizione** e **rilascio** di queste funzioni non sono disponibili in Windows, ma le versioni normali di queste funzioni rappresentano una barriera di memoria completa per Windows.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-343">Note that **Acquire** and **Release** variants of these functions are not available on Windows, but the regular versions of these functions are a full memory barrier on Windows.</span></span>

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a><span data-ttu-id="dd8ef-344">Variabili volatili e riordino</span><span class="sxs-lookup"><span data-stu-id="dd8ef-344">Volatile Variables and Reordering</span></span>

<span data-ttu-id="dd8ef-345">Lo standard C++ indica che le letture di variabili volatili non possono essere memorizzate nella cache, le scritture volatili non possono essere posticipate e le letture e le scritture volatili non possono essere spostate dopo l'altra.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-345">The C++ Standard says that reads of volatile variables cannot be cached, volatile writes cannot be delayed, and volatile reads and writes cannot be moved past each other.</span></span> <span data-ttu-id="dd8ef-346">Questa operazione è sufficiente per la comunicazione con i dispositivi hardware, ovvero lo scopo della parola chiave volatile nello standard C++.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-346">This is sufficient for communicating with hardware devices, which is the purpose of the volatile keyword in the C++ Standard.</span></span>

<span data-ttu-id="dd8ef-347">Tuttavia, le garanzie dello standard non sono sufficienti per l'uso di volatile per il multithreading.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-347">However, the guarantees of the standard are not sufficient for using volatile for multi-threading.</span></span> <span data-ttu-id="dd8ef-348">Lo standard C++ non impedisce al compilatore di riordinare le letture e le Scritture non volatili relative a letture e scritture volatili e non indica nulla sulla prevenzione del riordino della CPU.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-348">The C++ Standard does not stop the compiler from reordering non-volatile reads and writes relative to volatile reads and writes, and it says nothing about preventing CPU reordering.</span></span>

<span data-ttu-id="dd8ef-349">Visual C++ 2005 va oltre il linguaggio C++ standard per definire una semantica intuitiva per il multithreading per l'accesso a variabili volatili.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-349">Visual C++ 2005 goes beyond standard C++ to define multi-threading-friendly semantics for volatile variable access.</span></span> <span data-ttu-id="dd8ef-350">A partire da Visual C++ 2005, le letture dalle variabili volatili sono definite in modo da avere una semantica di lettura-acquisizione e le Scritture in variabili volatili sono definite in modo da avere una semantica di scrittura della versione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-350">Starting with Visual C++ 2005, reads from volatile variables are defined to have read-acquire semantics, and writes to volatile variables are defined to have write-release semantics.</span></span> <span data-ttu-id="dd8ef-351">Questo significa che il compilatore non riorganizzerà le letture e le Scritture che li hanno incollato e in Windows assicurerà che la CPU non esegua questa operazione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-351">This means that the compiler will not rearrange any reads and writes past them, and on Windows it will ensure that the CPU does not do so either.</span></span>

<span data-ttu-id="dd8ef-352">È importante comprendere che queste nuove garanzie si applicano solo a Visual C++ 2005 e alle versioni future di Visual C++.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-352">It is important to understand that these new guarantees only apply to Visual C++ 2005 and future versions of Visual C++.</span></span> <span data-ttu-id="dd8ef-353">In genere, i compilatori di altri fornitori implementano una semantica diversa, senza le garanzie aggiuntive di Visual C++ 2005.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-353">Compilers from other vendors will generally implement different semantics, without the extra guarantees of Visual C++ 2005.</span></span> <span data-ttu-id="dd8ef-354">Inoltre, su Xbox 360, il compilatore non inserisce istruzioni per impedire che la CPU riordini le letture e le Scritture.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-354">Also, on Xbox 360, the compiler does not insert any instructions to prevent the CPU from reordering reads and writes.</span></span>

## <a name="example-of-a-lock-free-data-pipe"></a><span data-ttu-id="dd8ef-355">Esempio di una pipe di dati Lock-Free</span><span class="sxs-lookup"><span data-stu-id="dd8ef-355">Example of a Lock-Free Data Pipe</span></span>

<span data-ttu-id="dd8ef-356">Una pipe è un costrutto che consente a uno o più thread di scrivere dati che vengono quindi letti da altri thread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-356">A pipe is a construct that lets one or more threads write data that is then read by other threads.</span></span> <span data-ttu-id="dd8ef-357">Una versione con blocco di una pipe può essere un modo elegante ed efficiente per passare il lavoro dal thread al thread.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-357">A lockless version of a pipe can be an elegant and efficient way to pass work from thread to thread.</span></span> <span data-ttu-id="dd8ef-358">DirectX SDK fornisce **LockFreePipe**, una pipe a singolo lettore e un solo Writer, disponibile in DXUTLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-358">The DirectX SDK supplies **LockFreePipe**, a single-reader, single-writer lockless pipe that is available in DXUTLockFreePipe.h.</span></span> <span data-ttu-id="dd8ef-359">Lo stesso **LockFreePipe** è disponibile in Xbox 360 SDK in AtgLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-359">The same **LockFreePipe** is available in the Xbox 360 SDK in AtgLockFreePipe.h.</span></span>

<span data-ttu-id="dd8ef-360">**LockFreePipe** può essere usato quando due thread hanno una relazione producer/consumer.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-360">**LockFreePipe** can be used when two threads have a producer/consumer relationship.</span></span> <span data-ttu-id="dd8ef-361">Il thread producer può scrivere dati sulla pipe affinché il thread consumer venga elaborato in un secondo momento, senza mai bloccarsi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-361">The producer thread can write data to the pipe for the consumer thread to process at a later date, without ever blocking.</span></span> <span data-ttu-id="dd8ef-362">Se la pipe si riempie, le Scritture hanno esito negativo e il thread producer deve riprovare più tardi, ma ciò si verifica solo se il thread Producer è in anticipo.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-362">If the pipe fills up, writes fail, and the producer thread will have to try again later, but this would only happen if the producer thread is ahead.</span></span> <span data-ttu-id="dd8ef-363">Se la pipe viene svuotata, le letture hanno esito negativo e il thread consumer deve riprovare in un secondo momento, ma ciò si verifica solo se non sono presenti operazioni da eseguire per il thread consumer.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-363">If the pipe empties, reads fail, and the consumer thread will have to try again later, but this would only happen if there is no work for the consumer thread to do.</span></span> <span data-ttu-id="dd8ef-364">Se i due thread sono ben bilanciati e la pipe è sufficientemente grande, la pipe consente di passare facilmente i dati insieme senza ritardi o blocchi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-364">If the two threads are well-balanced, and the pipe is big enough, the pipe lets them smoothly pass data along with no delays or blocks.</span></span>

## <a name="xbox-360-performance"></a><span data-ttu-id="dd8ef-365">Prestazioni di Xbox 360</span><span class="sxs-lookup"><span data-stu-id="dd8ef-365">Xbox 360 Performance</span></span>

<span data-ttu-id="dd8ef-366">Le prestazioni delle istruzioni e delle funzioni di sincronizzazione in Xbox 360 variano a seconda dell'altro codice eseguito.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-366">The performance of synchronization instructions and functions on Xbox 360 will vary depending on what other code is running.</span></span> <span data-ttu-id="dd8ef-367">L'acquisizione dei blocchi ridurrà molto più tempo se un altro thread attualmente possiede il blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-367">Acquiring locks will take much longer if another thread currently owns the lock.</span></span> <span data-ttu-id="dd8ef-368">Le operazioni [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) e della sezione critica possono richiedere molto più tempo se altri thread scrivono nella stessa riga della cache.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-368">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and critical section operations will take much longer if other threads are writing to the same cache line.</span></span> <span data-ttu-id="dd8ef-369">Anche il contenuto delle code di archiviazione può influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-369">The contents of the store queues can also affect performance.</span></span> <span data-ttu-id="dd8ef-370">Pertanto, tutti questi numeri sono solo approssimazioni, generati da test molto semplici:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-370">Therefore, all of these numbers are just approximations, generated from very simple tests:</span></span>

-   <span data-ttu-id="dd8ef-371">**lwsync** è stato misurato come 33-48 cicli di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-371">**lwsync** was measured as taking 33-48 cycles.</span></span>
-   <span data-ttu-id="dd8ef-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) è stato misurato come 225-260 cicli di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 225-260 cycles.</span></span>
-   <span data-ttu-id="dd8ef-373">L'acquisizione o il rilascio di una sezione critica è stato misurato in modo da richiedere circa 345 cicli.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-373">Acquiring or releasing a critical section was measured as taking about 345 cycles.</span></span>
-   <span data-ttu-id="dd8ef-374">L'acquisizione o il rilascio di un mutex è stato misurato in modo da richiedere circa 2350 cicli.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-374">Acquiring or releasing a mutex was measured as taking about 2350 cycles.</span></span>

## <a name="windows-performance"></a><span data-ttu-id="dd8ef-375">Prestazioni Windows</span><span class="sxs-lookup"><span data-stu-id="dd8ef-375">Windows Performance</span></span>

<span data-ttu-id="dd8ef-376">Le prestazioni delle istruzioni e delle funzioni di sincronizzazione in Windows variano notevolmente a seconda del tipo di processore e della configurazione e dell'altro codice in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-376">The performance of synchronization instructions and functions on Windows vary widely depending on the processor type and configuration, and on what other code is running.</span></span> <span data-ttu-id="dd8ef-377">I sistemi multicore e a più socket spesso importano più tempo per eseguire le istruzioni di sincronizzazione e l'acquisizione di blocchi è molto più lunga se un altro thread attualmente possiede il blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-377">Multi-core and multi-socket systems often take longer to execute synchronizing instructions, and acquiring locks take much longer if another thread currently owns the lock.</span></span>

<span data-ttu-id="dd8ef-378">Tuttavia, sono utili anche alcune misurazioni generate da test molto semplici:</span><span class="sxs-lookup"><span data-stu-id="dd8ef-378">However, even some measurements generated from very simple tests are helpful:</span></span>

-   <span data-ttu-id="dd8ef-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) è stato misurato come 20-90 cicli di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) was measured as taking 20-90 cycles.</span></span>
-   <span data-ttu-id="dd8ef-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) è stato misurato come 36-90 cicli di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 36-90 cycles.</span></span>
-   <span data-ttu-id="dd8ef-381">L'acquisizione o il rilascio di una sezione critica è stata misurata come esecuzione di 40-100 cicli.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-381">Acquiring or releasing a critical section was measured as taking 40-100 cycles.</span></span>
-   <span data-ttu-id="dd8ef-382">L'acquisizione o il rilascio di un mutex è stato misurato in modo da richiedere circa 750-2500 cicli.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-382">Acquiring or releasing a mutex was measured as taking about 750-2500 cycles.</span></span>

<span data-ttu-id="dd8ef-383">Questi test sono stati eseguiti su Windows XP in un intervallo di processori diversi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-383">These tests were done on Windows XP on a range of different processors.</span></span> <span data-ttu-id="dd8ef-384">I tempi brevi sono stati eseguiti su un computer a processore singolo e i tempi più lunghi erano in un computer a più processori.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-384">The short times were on a single-processor machine, and the longer times were on a multi-processor machine.</span></span>

<span data-ttu-id="dd8ef-385">Mentre l'acquisizione e il rilascio di blocchi è più costosa rispetto all'uso della programmazione senza blocco, è ancora meglio condividere i dati con una frequenza minore, evitando così il costo totale.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-385">While acquiring and releasing locks is more expensive than using lockless programming, it is even better to share data less frequently, thus avoiding the cost altogether.</span></span>

## <a name="performance-thoughts"></a><span data-ttu-id="dd8ef-386">Considerazioni sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="dd8ef-386">Performance Thoughts</span></span>

<span data-ttu-id="dd8ef-387">L'acquisizione o il rilascio di una sezione critica è costituito da una barriera di memoria, un'operazione **InterlockedXxx** e un controllo aggiuntivo per gestire la ricorsione e per eseguire il fallback a un mutex, se necessario.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-387">Acquiring or releasing a critical section consists of a memory barrier, an **InterlockedXxx** operation, and some extra checking to handle recursion and to fall back to a mutex, if necessary.</span></span> <span data-ttu-id="dd8ef-388">È necessario prestare attenzione all'implementazione di una sezione critica, perché la rotazione in un ciclo in attesa di un blocco è disponibile, senza eseguire il fallback a un mutex, può comportare notevoli prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-388">You should be wary of implementing your own critical section, because spinning in a loop waiting for a lock to be free, without falling back to a mutex, can waste considerable performance.</span></span> <span data-ttu-id="dd8ef-389">Per le sezioni critiche che sono molto contese ma che non vengono mantenute per un periodo di tempo elevato, è consigliabile usare [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) in modo che il sistema operativo girerà per un periodo di tempo in attesa che la sezione critica sia disponibile, anziché immediatamente rinviarla a un mutex se la sezione critica è di proprietà quando si tenta di acquisirla.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-389">For critical sections that are heavily contended but not held for long, you should consider using [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) so that the operating system will spin for a while waiting for the critical section to be available rather than immediately deferring to a mutex if the critical section is owned when you try to acquire it.</span></span> <span data-ttu-id="dd8ef-390">Per identificare le sezioni critiche che possono trarre vantaggio da un numero di spin, è necessario misurare la lunghezza dell'attesa tipica per un blocco specifico.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-390">In order to identify critical sections that can benefit from a spin count, it is necessary to measure the length of the typical wait for a particular lock.</span></span>

<span data-ttu-id="dd8ef-391">Se viene usato un heap condiviso per le allocazioni di memoria, il comportamento predefinito, ogni allocazione di memoria e libero comporta l'acquisizione di un blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-391">If a shared heap is used for memory allocations—the default behavior—every memory allocation and free involves acquiring a lock.</span></span> <span data-ttu-id="dd8ef-392">Con l'aumentare del numero di thread e del numero di allocazioni, i livelli di prestazioni sono disattivati e infine si inizia a diminuire.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-392">As the number of threads and the number of allocations increases, performance levels off, and eventually starts to decrease.</span></span> <span data-ttu-id="dd8ef-393">L'uso di heap per thread o la riduzione del numero di allocazioni può evitare questo collo di bottiglia di blocco.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-393">Using per-thread heaps, or reducing the number of allocations, can avoid this locking bottleneck.</span></span>

<span data-ttu-id="dd8ef-394">Se un thread genera dati e un altro thread sta consumando dati, è possibile che i dati vengano condivisi di frequente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-394">If one thread is generating data and another thread is consuming data, they may end up sharing data frequently.</span></span> <span data-ttu-id="dd8ef-395">Questo problema può verificarsi se un thread sta caricando le risorse e un altro thread sta eseguendo il rendering della scena.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-395">This can happen if one thread is loading resources and another thread is rendering the scene.</span></span> <span data-ttu-id="dd8ef-396">Se il thread di rendering fa riferimento ai dati condivisi in ogni chiamata di progetto, il sovraccarico di blocco sarà elevato.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-396">If the rendering thread references the shared data on every draw call, the locking overhead will be high.</span></span> <span data-ttu-id="dd8ef-397">È possibile ottenere prestazioni molto migliori se ogni thread dispone di strutture di dati private, che vengono quindi sincronizzate una volta per ogni frame o meno.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-397">Much better performance can be realized if each thread has private data structures which are then synchronized once per frame or less.</span></span>

<span data-ttu-id="dd8ef-398">Gli algoritmi senza blocco non sono necessariamente più veloci di quelli che utilizzano blocchi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-398">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</span></span> <span data-ttu-id="dd8ef-399">È necessario verificare se i blocchi causano effettivamente problemi prima di tentare di evitarli ed è necessario misurare per verificare se il codice non bloccato migliora effettivamente le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-399">You should check to see if locks are actually causing you problems before trying to avoid them, and you should measure to see if your lockless code actually improves performance.</span></span>

## <a name="platform-differences-summary"></a><span data-ttu-id="dd8ef-400">Riepilogo delle differenze della piattaforma</span><span class="sxs-lookup"><span data-stu-id="dd8ef-400">Platform Differences Summary</span></span>

-   <span data-ttu-id="dd8ef-401">Le funzioni **InterlockedXxx** impediscono il riordinamento della CPU in lettura/scrittura in Windows, ma non in Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-401">**InterlockedXxx** functions prevent CPU read/write reordering on Windows, but not on Xbox 360.</span></span>
-   <span data-ttu-id="dd8ef-402">La lettura e la scrittura di variabili volatili con Visual Studio C++ 2005 impedisce il riordino di lettura/scrittura della CPU in Windows, ma su Xbox 360, impedisce solo il riordino del compilatore in lettura/scrittura.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-402">Reading and writing of volatile variables using Visual Studio C++ 2005 prevents CPU read/write reordering on Windows, but on Xbox 360, it only prevents compiler read/write reordering.</span></span>
-   <span data-ttu-id="dd8ef-403">Le scritture vengono riordinate su Xbox 360, ma non su x86 o x64.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-403">Writes are reordered on Xbox 360, but not on x86 or x64.</span></span>
-   <span data-ttu-id="dd8ef-404">Le letture vengono riordinate su Xbox 360, ma in x86 o x64 sono riordinate solo rispetto alle Scritture e solo se le letture e le Scritture sono destinate a posizioni diverse.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-404">Reads are reordered on Xbox 360, but on x86 or x64 they are only reordered relative to writes, and only if the reads and writes target different locations.</span></span>

## <a name="recommendations"></a><span data-ttu-id="dd8ef-405">Consigli</span><span class="sxs-lookup"><span data-stu-id="dd8ef-405">Recommendations</span></span>

-   <span data-ttu-id="dd8ef-406">Usare i blocchi quando possibile perché sono più facili da usare correttamente.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-406">Use locks when possible because they are easier to use correctly.</span></span>
-   <span data-ttu-id="dd8ef-407">Evitare un blocco troppo frequente, in modo che i costi di blocco non diventino significativi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-407">Avoid locking too frequently, so that locking costs do not become significant.</span></span>
-   <span data-ttu-id="dd8ef-408">Evitare di mantenere i blocchi per un tempo troppo lungo, in modo da evitare blocchi lunghi.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-408">Avoid holding locks for too long, in order to avoid long stalls.</span></span>
-   <span data-ttu-id="dd8ef-409">Utilizzare la programmazione senza blocco quando appropriato, ma assicurarsi che i guadagni giustifichino la complessità.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-409">Use lockless programming when appropriate, but be sure that the gains justify the complexity.</span></span>
-   <span data-ttu-id="dd8ef-410">Utilizzare la programmazione o i blocchi di blocco in situazioni in cui non sono consentiti altri blocchi, ad esempio quando si condividono dati tra chiamate di procedure posticipate e codice normale.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-410">Use lockless programming or spin locks in situations where other locks are prohibited, such as when sharing data between deferred procedure calls and normal code.</span></span>
-   <span data-ttu-id="dd8ef-411">Usare solo algoritmi di programmazione privi di blocco standard che sono stati rivelati corretti.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-411">Only use standard lockless programming algorithms that have been proven to be correct.</span></span>
-   <span data-ttu-id="dd8ef-412">Quando si esegue la programmazione con blocco, assicurarsi di usare variabili di flag volatili e istruzioni per la barriera di memoria in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-412">When doing lockless programming, be sure to use volatile flag variables and memory barrier instructions as needed.</span></span>
-   <span data-ttu-id="dd8ef-413">Quando si usa **InterlockedXxx** in Xbox 360, usare le varianti di **acquisizione** e **rilascio** .</span><span class="sxs-lookup"><span data-stu-id="dd8ef-413">When using **InterlockedXxx** on Xbox 360, use the **Acquire** and **Release** variants.</span></span>

## <a name="references"></a><span data-ttu-id="dd8ef-414">Riferimenti</span><span class="sxs-lookup"><span data-stu-id="dd8ef-414">References</span></span>

-   <span data-ttu-id="dd8ef-415">MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-415">MSDN Library.</span></span> <span data-ttu-id="dd8ef-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)".</span><span class="sxs-lookup"><span data-stu-id="dd8ef-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)."</span></span> <span data-ttu-id="dd8ef-417">Riferimenti al linguaggio C++.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-417">C++ Language Reference.</span></span>
-   <span data-ttu-id="dd8ef-418">Vance Morrison.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-418">Vance Morrison.</span></span> <span data-ttu-id="dd8ef-419">"[Comprendere l'effetto delle tecniche di Low-Lock nelle app multithread](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)".</span><span class="sxs-lookup"><span data-stu-id="dd8ef-419">"[Understand the Impact of Low-Lock Techniques in Multithreaded Apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span></span> <span data-ttu-id="dd8ef-420">MSDN Magazine, ottobre 2005.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-420">MSDN Magazine, October 2005.</span></span>
-   <span data-ttu-id="dd8ef-421">Lione, Michael.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-421">Lyons, Michael.</span></span> <span data-ttu-id="dd8ef-422">"[Modello di archiviazione PowerPC e programmazione Aix](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)".</span><span class="sxs-lookup"><span data-stu-id="dd8ef-422">"[PowerPC Storage Model and AIX Programming](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)."</span></span> <span data-ttu-id="dd8ef-423">IBM developerWorks, 16 nov 2005.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-423">IBM developerWorks, 16 Nov 2005.</span></span>
-   <span data-ttu-id="dd8ef-424">McKenney, Paul E. "[memoria ordinata nei microprocessori moderni, parte II](https://www.linuxjournal.com/article/8212)".</span><span class="sxs-lookup"><span data-stu-id="dd8ef-424">McKenney, Paul E. "[Memory Ordering in Modern Microprocessors, Part II](https://www.linuxjournal.com/article/8212)."</span></span> <span data-ttu-id="dd8ef-425">Journal Linux, 2005 settembre.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-425">Linux Journal, September 2005.</span></span> <span data-ttu-id="dd8ef-426">\[Questo articolo contiene alcuni dettagli x86.\]</span><span class="sxs-lookup"><span data-stu-id="dd8ef-426">\[This article has some x86 details.\]</span></span>
-   <span data-ttu-id="dd8ef-427">Intel Corporation.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-427">Intel Corporation.</span></span> <span data-ttu-id="dd8ef-428">"[Ordine di memoria architettura Intel® 64](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)".</span><span class="sxs-lookup"><span data-stu-id="dd8ef-428">"[Intel® 64 Architecture Memory Ordering](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)."</span></span> <span data-ttu-id="dd8ef-429">2007 agosto.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-429">August 2007.</span></span> <span data-ttu-id="dd8ef-430">\[Si applica a entrambi i processori IA-32 e Intel 64.\]</span><span class="sxs-lookup"><span data-stu-id="dd8ef-430">\[Applies to both IA-32 and Intel 64 processors.\]</span></span>
-   <span data-ttu-id="dd8ef-431">Niebler, Eric.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-431">Niebler, Eric.</span></span> <span data-ttu-id="dd8ef-432">"[Report di viaggio: riunione ad hoc sui thread in C++](https://www.artima.com/cppsource/threads_meeting.html)".</span><span class="sxs-lookup"><span data-stu-id="dd8ef-432">"[Trip Report: Ad-Hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)."</span></span> <span data-ttu-id="dd8ef-433">Origine C++, 17 ottobre 2006.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-433">The C++ Source, 17 Oct 2006.</span></span>
-   <span data-ttu-id="dd8ef-434">Hart, Thomas E. 2006.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-434">Hart, Thomas E. 2006.</span></span> <span data-ttu-id="dd8ef-435">"[Creazione rapida di sincronizzazione con blocco: implicazioni delle prestazioni del recupero di memoria](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span><span class="sxs-lookup"><span data-stu-id="dd8ef-435">"[Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span></span> <span data-ttu-id="dd8ef-436">Procedure di 2006 International Parallel and Distributed Processing Simposio (IPDPS 2006), isola di Rodi, Grecia, 2006 aprile.</span><span class="sxs-lookup"><span data-stu-id="dd8ef-436">Proceedings of the 2006 International Parallel and Distributed Processing Symposium (IPDPS 2006), Rhodes Island, Greece, April 2006.</span></span>

 

 