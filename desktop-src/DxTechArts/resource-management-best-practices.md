---
title: Procedure consigliate per la gestione delle risorse
description: Questo articolo illustra le procedure consigliate per la gestione delle risorse in genere, il comportamento delle risorse gestite e non gestite e fornisce alcuni dettagli sul modo in cui le risorse vengono in genere gestite dal runtime e dai driver.
ms.assetid: 265ae0b2-f268-a4a4-551e-9d3dae886517
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 27cdadb8cee3cb57f4208657054784937ecd1ea2
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104338438"
---
# <a name="resource-management-best-practices"></a><span data-ttu-id="7e96b-103">Procedure consigliate per la gestione delle risorse</span><span class="sxs-lookup"><span data-stu-id="7e96b-103">Resource Management Best Practices</span></span>

<span data-ttu-id="7e96b-104">Le trame gestite, note anche come gestione automatica delle trame, sono state rese disponibili in DirectX dalla versione 6, con diverse revisioni e miglioramenti apportati nelle versioni successive.</span><span class="sxs-lookup"><span data-stu-id="7e96b-104">Managed textures, also known as automatic texture management, have been available in DirectX since version 6, with several revisions and enhancements made in subsequent releases.</span></span> <span data-ttu-id="7e96b-105">A partire dalla versione dell'API Direct3D 9, la gestione automatica delle risorse include il supporto per le trame, i buffer dei vertici e i buffer di indice, il tutto con un'interfaccia condivisa coerente.</span><span class="sxs-lookup"><span data-stu-id="7e96b-105">As of the release of the Direct3D 9 API, the automatic resource management includes support for textures, vertex buffers, and index buffers, all with a consistent shared interface.</span></span> <span data-ttu-id="7e96b-106">Grazie a Direct3D Resource Manager, le applicazioni possono semplificare notevolmente la gestione delle situazioni di dispositivo smarrito e possono fare affidamento sul sistema per gestire una quantità ragionevole di risorse di memoria video.</span><span class="sxs-lookup"><span data-stu-id="7e96b-106">By using the Direct3D resource manager, applications can greatly simplify the handling of lost-device situations and can rely on the system to handle a reasonable amount of over-commitment of video memory resources.</span></span>

<span data-ttu-id="7e96b-107">Gli sviluppatori talvolta presentano difficoltà nell'utilizzo di risorse gestite, in parte grazie alla natura astratta del sistema.</span><span class="sxs-lookup"><span data-stu-id="7e96b-107">Developers sometimes have difficulties using managed resources, in part due to the abstract nature of the system.</span></span> <span data-ttu-id="7e96b-108">Sebbene molti scenari comuni per le risorse siano una scelta ottimale per le risorse gestite, alcuni casi offrono prestazioni migliori quando si utilizzano risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="7e96b-108">While many common scenarios for resources are a good fit for managed resources, some cases perform better when using unmanaged resources.</span></span> <span data-ttu-id="7e96b-109">Questo articolo illustra le procedure consigliate per la gestione delle risorse in genere, il comportamento delle risorse gestite e non gestite e fornisce alcuni dettagli sul modo in cui le risorse vengono in genere gestite dal runtime e dai driver.</span><span class="sxs-lookup"><span data-stu-id="7e96b-109">This article discusses best practices for dealing with resources generally, how managed and unmanaged resources behave, and provides some detail on how resources are typically handled by the runtime and drivers.</span></span>

<span data-ttu-id="7e96b-110">Questo articolo illustra i concetti seguenti:</span><span class="sxs-lookup"><span data-stu-id="7e96b-110">This article covers these concepts:</span></span>

-   [<span data-ttu-id="7e96b-111">Memoria video</span><span class="sxs-lookup"><span data-stu-id="7e96b-111">Video Memory</span></span>](#video-memory)
-   [<span data-ttu-id="7e96b-112">Risorse gestite</span><span class="sxs-lookup"><span data-stu-id="7e96b-112">Managed Resources</span></span>](#managed-resources)
-   [<span data-ttu-id="7e96b-113">Risorse gestite dal driver</span><span class="sxs-lookup"><span data-stu-id="7e96b-113">Driver-Managed Resources</span></span>](#driver-managed-resources)
-   [<span data-ttu-id="7e96b-114">Risorse predefinite</span><span class="sxs-lookup"><span data-stu-id="7e96b-114">Default Resources</span></span>](#default-resources)
    -   [<span data-ttu-id="7e96b-115">Uso di risorse gestite e predefinite</span><span class="sxs-lookup"><span data-stu-id="7e96b-115">Using Both Managed and Default Resources</span></span>](#using-both-managed-and-default-resources)
    -   [<span data-ttu-id="7e96b-116">Risorse predefinite dinamiche</span><span class="sxs-lookup"><span data-stu-id="7e96b-116">Dynamic Default Resources</span></span>](#dynamic-default-resources)
-   [<span data-ttu-id="7e96b-117">Risorse di memoria di sistema</span><span class="sxs-lookup"><span data-stu-id="7e96b-117">System Memory Resources</span></span>](#system-memory-resources)
-   [<span data-ttu-id="7e96b-118">Raccomandazioni generali</span><span class="sxs-lookup"><span data-stu-id="7e96b-118">General Recommendations</span></span>](#general-recommendations)
-   [<span data-ttu-id="7e96b-119">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="7e96b-119">Related topics</span></span>](#related-topics)

## <a name="video-memory"></a><span data-ttu-id="7e96b-120">Memoria video</span><span class="sxs-lookup"><span data-stu-id="7e96b-120">Video Memory</span></span>

<span data-ttu-id="7e96b-121">Per fare in modo che il sistema video usi una risorsa, deve trovarsi in memoria accessibile alla GPU.</span><span class="sxs-lookup"><span data-stu-id="7e96b-121">For the video system to make use of a resource, it must be located in memory that is accessible to the GPU.</span></span> <span data-ttu-id="7e96b-122">La memoria video locale offre le migliori prestazioni per la GPU e alcune risorse, ad esempio le destinazioni di rendering e i buffer di profondità/stencil, devono trovarsi nella memoria video locale.</span><span class="sxs-lookup"><span data-stu-id="7e96b-122">Local video memory provides the best performance for the GPU, and certain resources (such as render targets and depth/stencil buffers) must be located in local video memory.</span></span> <span data-ttu-id="7e96b-123">Con l'avvento di AGP, la GPU può anche accedere direttamente a una parte della memoria di sistema.</span><span class="sxs-lookup"><span data-stu-id="7e96b-123">With the advent of AGP, the GPU can also access a portion of the system memory directly.</span></span> <span data-ttu-id="7e96b-124">Questa area di memoria, nota come apertura AGP, viene definita memoria video non locale e non è disponibile per altri scopi.</span><span class="sxs-lookup"><span data-stu-id="7e96b-124">This memory area, known as the AGP aperture, is referred to as non-local video memory and is not available for other purposes.</span></span> <span data-ttu-id="7e96b-125">La memoria del video non locale può essere letta e scritta dalla CPU, che in genere non ha accesso a prestazioni elevate alla memoria video locale ed è quindi ideale per l'uso come risorsa di memoria condivisa.</span><span class="sxs-lookup"><span data-stu-id="7e96b-125">Non-local video memory can be read from and written to by the CPU, which typically has no high-performance access to local video memory, and is thus ideal for use as a shared memory resource.</span></span> <span data-ttu-id="7e96b-126">Un aspetto fondamentale da tenere presente sulla memoria AGP è che l'it, ad esempio la memoria del video locale, viene invalidato in situazioni di dispositivo smarrito ed è necessario ripristinare gli asset permanenti.</span><span class="sxs-lookup"><span data-stu-id="7e96b-126">A key thing to remember about AGP memory is that it, like local video memory, is invalidated in lost-device situations, and persistent assets located there must be restored.</span></span>

<span data-ttu-id="7e96b-127">**Figura 1. Relazione tra GPU, CPU, RAM video e RAM di sistema**</span><span class="sxs-lookup"><span data-stu-id="7e96b-127">**Figure 1. Relationship of the GPU, CPU, video RAM, and system RAM**</span></span>

![relazione tra GPU, CPU, RAM video e RAM di sistema](images/managingresources1.gif)

<span data-ttu-id="7e96b-129">Alcune soluzioni video integrate si avvaleno di un'architettura di memoria unificata (UMA), in cui la memoria principale è indirizzabile da tutti i componenti dei sistemi.</span><span class="sxs-lookup"><span data-stu-id="7e96b-129">Some integrated video solutions make use of a unified memory architecture (UMA), where main memory is addressable by all components of the systems.</span></span> <span data-ttu-id="7e96b-130">Direct3D supporta UMA senza richiedere alcuna modifica all'applicazione, usando gli stessi hint delle configurazioni di memoria video locale.</span><span class="sxs-lookup"><span data-stu-id="7e96b-130">Direct3D supports UMA without requiring any change to the application, utilizing the same hints as for local video memory configurations.</span></span> <span data-ttu-id="7e96b-131">Per tali sistemi, le risorse sono sempre situate nella memoria di sistema e il driver è responsabile di garantire che le risorse funzionino in modo analogo a quanto avviene in un'architettura più tradizionale, sfruttando al contempo le proprietà di UMA e qualsiasi comportamento specifico dell'implementazione dell'hardware.</span><span class="sxs-lookup"><span data-stu-id="7e96b-131">For such systems, resources are always located in system memory, and the driver is responsible for ensuring that resources work much like they do in a more traditional architecture while taking advantage of UMA's properties and any specific behavior of the hardware implementation.</span></span>

<span data-ttu-id="7e96b-132">**Figura 2. GPU e CPU hanno accesso uguale alla RAM di sistema in un'architettura di memoria unificata**</span><span class="sxs-lookup"><span data-stu-id="7e96b-132">**Figure 2. GPU and CPU have equal access to system RAM in a unified memory architecture**</span></span>

![GPU e CPU hanno accesso uguale alla RAM di sistema in un'architettura di memoria unificata](images/managingresources2.gif)

## <a name="managed-resources"></a><span data-ttu-id="7e96b-134">Risorse gestite</span><span class="sxs-lookup"><span data-stu-id="7e96b-134">Managed Resources</span></span>

<span data-ttu-id="7e96b-135">La maggior parte delle risorse deve essere creata come risorse gestite nel POOL \_ gestito.</span><span class="sxs-lookup"><span data-stu-id="7e96b-135">The majority of your resources should be created as managed resources in POOL\_MANAGED.</span></span> <span data-ttu-id="7e96b-136">Tutte le risorse verranno create nella memoria di sistema e quindi copiate in base alle esigenze nella memoria video.</span><span class="sxs-lookup"><span data-stu-id="7e96b-136">All your resources will be created in system memory and then copied as needed into video memory.</span></span> <span data-ttu-id="7e96b-137">Le situazioni di dispositivo perso verranno gestite automaticamente dalla copia di memoria di sistema.</span><span class="sxs-lookup"><span data-stu-id="7e96b-137">Lost-device situations will be handled automatically from the system memory copy.</span></span> <span data-ttu-id="7e96b-138">Poiché non tutte le risorse gestite sono necessarie per rientrare nella memoria video in una sola volta, è possibile eseguire il commit della memoria in cui una memoria video più piccola working set di risorse è sufficiente per il rendering in un frame specifico.</span><span class="sxs-lookup"><span data-stu-id="7e96b-138">Since not all managed resources are required to fit into video memory all at once, you can over-commit memory where a smaller video memory working set of resources is all that is required to render in any given frame.</span></span> <span data-ttu-id="7e96b-139">Si noti che è probabile che la maggior parte della memoria del sistema di archiviazione di backup venga rilasciata su disco nel tempo, motivo per cui l'operazione di reimpostazione può essere lenta a causa della necessità di riportare i dati in modo da ripristinare la memoria video persa.</span><span class="sxs-lookup"><span data-stu-id="7e96b-139">Note that it is likely that the majority of this backing-store system memory will be paged out to disk over time, which is why the Reset operation can be slow due to the need to page this data back in to restore the lost video memory.</span></span>

<span data-ttu-id="7e96b-140">Il runtime mantiene un timestamp per l'ultima volta che viene usata una risorsa e quando un'allocazione di memoria video non riesce a caricare una risorsa gestita necessaria, rilascia le risorse basate su questo timestamp in modo LRU.</span><span class="sxs-lookup"><span data-stu-id="7e96b-140">The runtime keeps a timestamp for the last time a resource is used, and when a video memory allocation fails for loading a needed managed resource, it will release resources based on this timestamp in a LRU fashion.</span></span> <span data-ttu-id="7e96b-141">L'utilizzo di [**Sepriority**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3dresource9-setpriority) ha la precedenza sul timestamp, quindi le risorse più comunemente utilizzate devono essere impostate su un valore di priorità più alto.</span><span class="sxs-lookup"><span data-stu-id="7e96b-141">Usage of [**SetPriority**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3dresource9-setpriority) takes precedence over the timestamp, so more commonly used resources should be set to a higher priority value.</span></span> <span data-ttu-id="7e96b-142">Direct3D 9,0 contiene informazioni limitate sulla memoria video gestita dal driver, quindi è possibile che il runtime debba rimuovere diverse risorse per creare un'area sufficientemente grande affinché l'allocazione riesca.</span><span class="sxs-lookup"><span data-stu-id="7e96b-142">Direct3D 9.0 has limited information about the video memory managed by the driver, so the runtime may need to evict several resources to create a large enough region for the allocation to succeed.</span></span> <span data-ttu-id="7e96b-143">Le priorità appropriate consentono di eliminare le situazioni in cui un elemento viene eliminato e quindi viene richiesto di nuovo poco dopo.</span><span class="sxs-lookup"><span data-stu-id="7e96b-143">Proper priorities can help eliminate situations where something gets evicted and then is required again shortly thereafter.</span></span> <span data-ttu-id="7e96b-144">L'applicazione può anche chiamare [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) per forzare la rimozione di tutte le risorse gestite.</span><span class="sxs-lookup"><span data-stu-id="7e96b-144">The application can also call [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) to force all the managed resources to be removed.</span></span> <span data-ttu-id="7e96b-145">Anche in questo caso, può trattarsi di un'operazione che richiede molto tempo per ricaricare tutte le risorse necessarie per il frame successivo, ma è molto utile per le transizioni di livello in cui il working set cambia significativamente e per la rimozione della frammentazione della memoria del video.</span><span class="sxs-lookup"><span data-stu-id="7e96b-145">Again, this can be a time-consuming operation to reload all the resources required for the next frame, but is very useful for level transitions where the working set changes significantly and for removing video memory fragmentation.</span></span>

<span data-ttu-id="7e96b-146">Viene anche mantenuto un conteggio dei frame per consentire al runtime di rilevare se la risorsa che ha appena scelto di rimuovere è stata usata prima del frame corrente, il che implica una situazione di thrashing in cui sono in uso più risorse in un singolo frame che rientrerà nella memoria video.</span><span class="sxs-lookup"><span data-stu-id="7e96b-146">A frame count is also kept to allow the runtime to detect if the resource it just chose to evict was used early the current frame, which implies a thrashing situation where more resources are in use in a single frame than will fit into video memory.</span></span> <span data-ttu-id="7e96b-147">In questo modo i criteri di sostituzione vengono attivati per passare a un tipo di file obsoleto anziché a LRU per il resto del frame, in quanto tende a offrire prestazioni leggermente migliori in tali condizioni.</span><span class="sxs-lookup"><span data-stu-id="7e96b-147">This triggers the replacement policy to switch to a MRU fashion rather than LRU for the remainder of the frame as this tends to perform slightly better under such conditions.</span></span> <span data-ttu-id="7e96b-148">Questo comportamento di thrashing influirà in modo significativo sulle prestazioni di rendering.</span><span class="sxs-lookup"><span data-stu-id="7e96b-148">Such thrashing behavior will significantly impact the rendering performance.</span></span> <span data-ttu-id="7e96b-149">Si noti che la nozione di frame corrente è associata a [**EndScene**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-endscene), pertanto tutte le applicazioni che usano le risorse gestite devono effettuare chiamate normali a questo metodo.</span><span class="sxs-lookup"><span data-stu-id="7e96b-149">Note that the notion of current frame is tied to [**EndScene**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-endscene), so any application making use of managed resources needs to make regular calls to this method.</span></span>

<span data-ttu-id="7e96b-150">Gli sviluppatori che desiderano trovare ulteriori informazioni sul comportamento delle risorse gestite nell'applicazione possono utilizzare la query di eventi RESOURCEMANAGER tramite l'interfaccia [**IDirect3DQuery9**](/windows/desktop/api/d3d9helper/nn-d3d9helper-idirect3dquery9) .</span><span class="sxs-lookup"><span data-stu-id="7e96b-150">Developers looking to find more information about how managed resources are behaving in their application can make use of the RESOURCEMANAGER event query via the [**IDirect3DQuery9**](/windows/desktop/api/d3d9helper/nn-d3d9helper-idirect3dquery9) interface.</span></span> <span data-ttu-id="7e96b-151">Questa operazione funziona solo quando si usano i runtime di debug, pertanto queste informazioni non possono dipendere dall'applicazione, ma forniscono informazioni approfondite sulle risorse gestite dal runtime.</span><span class="sxs-lookup"><span data-stu-id="7e96b-151">This only works when using the debug runtimes, so this information cannot be depended upon by the application, but it provides deep detail on the resources managed by the runtime.</span></span>

<span data-ttu-id="7e96b-152">Per comprendere il funzionamento di gestione risorse può essere utile quando si esegue l'ottimizzazione e il debug delle applicazioni, è importante non collegare eccessivamente l'applicazione ai dettagli di implementazione del runtime o dei driver correnti.</span><span class="sxs-lookup"><span data-stu-id="7e96b-152">While understanding how the resource manager works can help when tuning and debugging your applications, it is important to not tie your application too tightly to the implementation details of the current runtime or drivers.</span></span> <span data-ttu-id="7e96b-153">Le revisioni del driver o delle modifiche apportate all'hardware possono modificare significativamente il comportamento e le versioni future di Direct3D avranno una gestione delle risorse notevolmente migliorata e sofisticata.</span><span class="sxs-lookup"><span data-stu-id="7e96b-153">Revisions of the driver or changes in hardware can significantly change the behavior, and future versions of Direct3D will have significantly improved and sophisticated resource management.</span></span>

## <a name="driver-managed-resources"></a><span data-ttu-id="7e96b-154">Risorse Driver-Managed</span><span class="sxs-lookup"><span data-stu-id="7e96b-154">Driver-Managed Resources</span></span>

<span data-ttu-id="7e96b-155">I driver Direct3D sono liberi di implementare la funzionalità di trame gestite dal driver, indicata da D3DCAPS2 \_ CANMANAGERESOURCE, che consente al driver di gestire la gestione delle risorse anziché il Runtime.</span><span class="sxs-lookup"><span data-stu-id="7e96b-155">Direct3D drivers are free to implement the driver managed textures capability, indicated by D3DCAPS2\_CANMANAGERESOURCE, which allows the driver to handle the resource management instead of the runtime.</span></span> <span data-ttu-id="7e96b-156">Per il driver (rare) che implementa questa funzionalità, il comportamento esatto del gestore di risorse del driver può variare notevolmente ed è necessario contattare il fornitore del driver per informazioni dettagliate su come funziona per la loro implementazione.</span><span class="sxs-lookup"><span data-stu-id="7e96b-156">For the (rare) driver that implements this feature, the exact behavior of the driver's resource manager can vary widely, and you should contact the driver's vendor for details on how this works for their implementation.</span></span> <span data-ttu-id="7e96b-157">In alternativa, è possibile assicurarsi che gestione runtime venga sempre utilizzato specificando D3DCREATE \_ Disabilita \_ \_ Gestione driver durante la creazione del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="7e96b-157">Alternatively, you can ensure that the runtime manager is always used instead by specifying D3DCREATE\_DISABLE\_DRIVER\_MANAGEMENT when creating the device.</span></span>

## <a name="default-resources"></a><span data-ttu-id="7e96b-158">Risorse predefinite</span><span class="sxs-lookup"><span data-stu-id="7e96b-158">Default Resources</span></span>

<span data-ttu-id="7e96b-159">Sebbene le risorse gestite siano semplici, efficienti e facili da usare, in alcuni casi è preferibile usare la memoria video direttamente o anche obbligatoria.</span><span class="sxs-lookup"><span data-stu-id="7e96b-159">While managed resources are simple, efficient, and easy to use, there are times when using video memory directly is preferred or even required.</span></span> <span data-ttu-id="7e96b-160">Tali risorse vengono create nella \_ categoria predefinita del pool.</span><span class="sxs-lookup"><span data-stu-id="7e96b-160">Such resources are created in the POOL\_DEFAULT category.</span></span> <span data-ttu-id="7e96b-161">L'uso di tali risorse comporta ulteriori complicazioni per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="7e96b-161">Making use of such resources does cause additional complications for your application.</span></span> <span data-ttu-id="7e96b-162">Il codice è necessario per gestire la situazione dei dispositivi perduti per tutte le \_ risorse predefinite del pool e tenere conto delle considerazioni sulle prestazioni durante la copia dei dati.</span><span class="sxs-lookup"><span data-stu-id="7e96b-162">Code is required to cope with the lost-device situation for all the POOL\_DEFAULT resources, and performance considerations must be taken into account when copying data into them.</span></span> <span data-ttu-id="7e96b-163">La mancata specifica dell'utilizzo \_ WRITEONLY o la creazione di una destinazione di rendering bloccabile può comportare anche gravi sanzioni in merito alle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7e96b-163">Failure to specify USAGE\_WRITEONLY or making a render target lockable can also impose serious performance penalties.</span></span>

<span data-ttu-id="7e96b-164">La chiamata di **blocco** su una \_ risorsa predefinita del pool è più probabile che la GPU si blocchi rispetto all'utilizzo di una \_ risorsa gestita del pool, a meno che non si utilizzino determinati flag di hint.</span><span class="sxs-lookup"><span data-stu-id="7e96b-164">Calling **Lock** on a POOL\_DEFAULT resource is more likely to cause the GPU to stall than working with a POOL\_MANAGED resource, unless using certain hint flags.</span></span> <span data-ttu-id="7e96b-165">A seconda della posizione della risorsa, il puntatore restituito può essere un buffer di memoria di sistema temporaneo o un puntatore direttamente nella memoria AGP.</span><span class="sxs-lookup"><span data-stu-id="7e96b-165">Depending on the location of the resource, the pointer returned could be to a temporary system memory buffer, or it can be a pointer directly into AGP memory.</span></span> <span data-ttu-id="7e96b-166">Se si tratta di un buffer di memoria di sistema temporaneo, sarà necessario trasferire i dati alla memoria video dopo la chiamata di **sblocco** .</span><span class="sxs-lookup"><span data-stu-id="7e96b-166">If it is a temporary system memory buffer, data will need to be transferred to the video memory after the **Unlock** call.</span></span> <span data-ttu-id="7e96b-167">Se la risorsa video non è di sola scrittura, i dati dovranno essere trasferiti nel buffer temporaneo durante il **blocco**.</span><span class="sxs-lookup"><span data-stu-id="7e96b-167">If the video resource is not write-only, data will have to be transferred into the temporary buffer during the **Lock**.</span></span> <span data-ttu-id="7e96b-168">Se si tratta di un'area di memoria AGP, le copie temporanee vengono evitate, ma il comportamento della cache necessario può causare un rallentamento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7e96b-168">If it is an AGP memory area, temporary copies are avoided but the cache behavior required can result in slow performance.</span></span>

<span data-ttu-id="7e96b-169">È necessario prestare attenzione a scrivere una riga di dati completa della cache in qualsiasi puntatore alla memoria di apertura AGP per evitare la rigore della pettinatura di scrittura, che provoca un ciclo di lettura/scrittura e l'accesso sequenziale dell'area di memoria.</span><span class="sxs-lookup"><span data-stu-id="7e96b-169">Care should be taken to write a full cache line of data into any pointer to AGP aperture memory to avoid the penalty of write-combing, which induces a read-write cycle, and sequential access of the memory area is preferred.</span></span> <span data-ttu-id="7e96b-170">Se l'applicazione deve eseguire l'accesso casuale ai dati durante la creazione e non si desidera utilizzare una risorsa gestita per il buffer, è consigliabile utilizzare una copia di memoria di sistema.</span><span class="sxs-lookup"><span data-stu-id="7e96b-170">If your application needs to make random access to data during creation, and you do not wish to make use of a managed resource for the buffer, you should work with a system memory copy instead.</span></span> <span data-ttu-id="7e96b-171">Una volta creati i dati, è possibile trasmettere il risultato nella memoria della risorsa bloccata per evitare di pagare una penalità elevata per l'operazione di combinazione di scrittura nella cache.</span><span class="sxs-lookup"><span data-stu-id="7e96b-171">Once the data has been created, you can then stream the result into the locked resource memory to avoid paying a high penalty for the cache write-combining operation.</span></span>

<span data-ttu-id="7e96b-172">Il \_ flag Lock overwrite può essere usato per accodare i dati in modo efficiente per alcune risorse, ma idealmente è possibile evitare più chiamate di **blocco** e **sblocco** alla stessa risorsa.</span><span class="sxs-lookup"><span data-stu-id="7e96b-172">The LOCK\_NOOVERWRITE flag can be used to append data in an efficient manner for some resources, but ideally, multiple **Lock** and **Unlock** calls to the same resource can be avoided.</span></span> <span data-ttu-id="7e96b-173">L'uso corretto dei diversi flag di blocco è importante per ottenere prestazioni ottimali, in quanto usa un modello descrittivo per la cache di accesso ai dati durante il riempimento della memoria bloccata.</span><span class="sxs-lookup"><span data-stu-id="7e96b-173">Making proper use of the various lock flags is important to optimal performance, as is using a cache-friendly pattern of data access when filling locked memory.</span></span>

### <a name="using-both-managed-and-default-resources"></a><span data-ttu-id="7e96b-174">Uso di risorse gestite e predefinite</span><span class="sxs-lookup"><span data-stu-id="7e96b-174">Using Both Managed and Default Resources</span></span>

<span data-ttu-id="7e96b-175">La combinazione di allocazioni di risorse predefinite gestite e di POOL \_ può causare la frammentazione della memoria video e confondere la visualizzazione del runtime della memoria video disponibile per le risorse gestite.</span><span class="sxs-lookup"><span data-stu-id="7e96b-175">Mixing allocations of managed and POOL\_DEFAULT resources can cause video memory fragmentation and confuse the runtime's view of the video memory available for managed resources.</span></span> <span data-ttu-id="7e96b-176">Idealmente, è consigliabile creare tutte le \_ risorse predefinite del pool prima di utilizzare \_ le risorse gestite del pool o utilizzare la chiamata [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) prima di allocare le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="7e96b-176">Ideally, you should create all POOL\_DEFAULT resources before making use of POOL\_MANAGED resources or make use of the [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) call before allocating unmanaged resources.</span></span> <span data-ttu-id="7e96b-177">Tenere presente che tutte le allocazioni effettuate dall' \_ impostazione predefinita del pool che si trovano nella memoria video rilegano memoria per la durata della risorsa che non è disponibile per l'uso da parte di Resource Manager o per altri scopi.</span><span class="sxs-lookup"><span data-stu-id="7e96b-177">Remember that all allocations made from POOL\_DEFAULT that reside in video memory tie up memory for the life that resource that is unavailable for use by the resource manager or for any other purpose.</span></span>

<span data-ttu-id="7e96b-178">Si noti che, a differenza delle versioni precedenti di Direct3D, il runtime della versione 9 Elimina automaticamente alcune risorse gestite prima di rinunciare a un'allocazione di risorse non gestite non riuscita per la mancanza di memoria video, ma ciò può potenzialmente creare una frammentazione aggiuntiva e anche forzare una risorsa in una posizione non ottimale, ad esempio con una trama statica nella memoria video non locale.</span><span class="sxs-lookup"><span data-stu-id="7e96b-178">Note that unlike previous versions of Direct3D, the version 9 runtime automatically evicts some managed resources before giving up on a failed unmanaged resource allocation for a lack of video memory, but this can potentially create additional fragmentation and even force a resource into a sub-optimal location (for example, having a static texture in non-local video memory).</span></span> <span data-ttu-id="7e96b-179">Anche in questo caso, è preferibile allocare tutte le risorse non gestite richieste prima e prima di usare le risorse gestite.</span><span class="sxs-lookup"><span data-stu-id="7e96b-179">Again, it is best to allocate all required unmanaged resources up front and before using any managed resources.</span></span>

### <a name="dynamic-default-resources"></a><span data-ttu-id="7e96b-180">Risorse predefinite dinamiche</span><span class="sxs-lookup"><span data-stu-id="7e96b-180">Dynamic Default Resources</span></span>

<span data-ttu-id="7e96b-181">I dati generati e aggiornati con una frequenza elevata non hanno bisogno dell'archivio di backup perché tutte le informazioni verranno ricreate durante il ripristino del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="7e96b-181">Data that is generated and updated at a high frequency has no need for the backing-store since all the information will be re-created when restoring the device.</span></span> <span data-ttu-id="7e96b-182">Questi dati vengono in genere creati in modo ottimale nell' \_ impostazione predefinita del pool, specificando l' \_ hint Dynamic Usage, in modo che il driver possa prendere decisioni di ottimizzazione quando si posiziona la risorsa, sapendo che verrà aggiornata spesso.</span><span class="sxs-lookup"><span data-stu-id="7e96b-182">Such data is typically best created in POOL\_DEFAULT, specifying the USAGE\_DYNAMIC hint, so that the driver can make optimization decisions when placing the resource, knowing that it will be updated often.</span></span> <span data-ttu-id="7e96b-183">Ciò significa in genere che la risorsa viene posizionata nella memoria video non locale e, di conseguenza, è in genere molto più lenta per poter accedere alla GPU rispetto alla memoria video locale.</span><span class="sxs-lookup"><span data-stu-id="7e96b-183">This typically means putting the resource into non-local video memory, and thus, it is usually much slower for the GPU to access than local video memory.</span></span> <span data-ttu-id="7e96b-184">Per le architetture UMA, il driver potrebbe scegliere una posizione specifica per le risorse dinamiche da ottimizzare per l'accesso in scrittura alla CPU.</span><span class="sxs-lookup"><span data-stu-id="7e96b-184">For UMA architectures, the driver might choose a particular placement for dynamic resources to optimize for CPU write access.</span></span>

<span data-ttu-id="7e96b-185">Questo utilizzo è tipico per le soluzioni di skinning software e i sistemi particellari basati su CPU che compilano i buffer di vertex/index e il flag di scarto del blocco garantirà \_ che i blocchi non vengano creati nei casi in cui la risorsa è ancora in uso dal frame precedente.</span><span class="sxs-lookup"><span data-stu-id="7e96b-185">This usage is typical for software skinning solutions and CPU-based particle systems filling out vertex/index buffers, and the LOCK\_DISCARD flag will ensure that stalls are not created in cases where the resource is still in use from the previous frame.</span></span> <span data-ttu-id="7e96b-186">In questo caso, l'utilizzo di una risorsa gestita aggiorna un buffer di memoria di sistema, che viene quindi copiato nella memoria video e quindi utilizzato solo per un frame o due prima di essere sostituito.</span><span class="sxs-lookup"><span data-stu-id="7e96b-186">Using a managed resource in this case would update a system memory buffer, which would then be copied to video memory, and then used for only a frame or two before being replaced.</span></span> <span data-ttu-id="7e96b-187">Per i sistemi con memoria video non locale, la copia aggiuntiva viene eliminata con l'uso corretto di questo modello dinamico.</span><span class="sxs-lookup"><span data-stu-id="7e96b-187">For systems with non-local video memory, the extra copy is eliminated by proper use of this dynamic pattern.</span></span>

<span data-ttu-id="7e96b-188">Le trame standard non possono essere bloccate e possono essere aggiornate solo tramite [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) o [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span><span class="sxs-lookup"><span data-stu-id="7e96b-188">Standard textures cannot be locked, and can only be updated via [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) or [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span></span> <span data-ttu-id="7e96b-189">Alcuni sistemi supportano le trame dinamiche, che possono essere bloccate e usano il \_ modello di scarto del blocco, ma è necessario verificare un bit delle funzionalità (D3DCAPS2 \_ DYNAMICTEXTURES) prima di usare tali risorse.</span><span class="sxs-lookup"><span data-stu-id="7e96b-189">Some systems support dynamic textures, which can be locked, and use the LOCK\_DISCARD pattern, but a capabilities bit (D3DCAPS2\_DYNAMICTEXTURES) must be checked before making use of such resources.</span></span> <span data-ttu-id="7e96b-190">Per le trame altamente dinamiche (video o procedurale), l'applicazione può creare \_ risorse di pool SYSTEMMEM predefinite e pool corrispondenti \_ e gestire gli aggiornamenti della memoria video usando **UpdateTexture**.</span><span class="sxs-lookup"><span data-stu-id="7e96b-190">For highly dynamic textures (video or procedural), your application could create matching POOL\_DEFAULT and POOL\_SYSTEMMEM resources and handle video-memory updates by using **UpdateTexture**.</span></span> <span data-ttu-id="7e96b-191">Per gli aggiornamenti estremamente frequenti e parziali, il paradigma **UpdateTexture** è probabilmente la scelta migliore.</span><span class="sxs-lookup"><span data-stu-id="7e96b-191">For highly frequent and partial updates, the **UpdateTexture** paradigm is likely the better choice.</span></span>

<span data-ttu-id="7e96b-192">Per quanto possibile, è opportuno prestare attenzione quando si progettano sistemi che si basano molto sull'invio dinamico.</span><span class="sxs-lookup"><span data-stu-id="7e96b-192">As useful as dynamic resources can be, be careful when designing systems that rely heavily on dynamic submission.</span></span> <span data-ttu-id="7e96b-193">Le risorse statiche devono essere inserite in un POOL \_ gestito per garantire un utilizzo ottimale della memoria video locale e per sfruttare in modo più efficiente il bus limitato e la larghezza di banda della memoria principale.</span><span class="sxs-lookup"><span data-stu-id="7e96b-193">Static resources should be placed into POOL\_MANAGED to ensure both good utilization of local video memory, and to make more efficient use of limited bus and main memory bandwidth.</span></span> <span data-ttu-id="7e96b-194">Per le risorse semi-statiche, è possibile che il costo di un caricamento occasionale nella memoria del video locale sia molto inferiore rispetto al traffico del bus costante generato rendendoli dinamici.</span><span class="sxs-lookup"><span data-stu-id="7e96b-194">For resources that are semi-static, you may find that the cost of an occasional upload to local video memory is much less than the constant bus traffic generated by making them dynamic.</span></span>

## <a name="system-memory-resources"></a><span data-ttu-id="7e96b-195">Risorse di memoria di sistema</span><span class="sxs-lookup"><span data-stu-id="7e96b-195">System Memory Resources</span></span>

<span data-ttu-id="7e96b-196">È anche possibile creare risorse nel POOL \_ SYSTEMMEM.</span><span class="sxs-lookup"><span data-stu-id="7e96b-196">Resources can also be created in POOL\_SYSTEMMEM.</span></span> <span data-ttu-id="7e96b-197">Sebbene non possano essere usati dalla pipeline grafica, possono essere usati come origini per l'aggiornamento \_ delle risorse predefinite del pool tramite [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) o [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span><span class="sxs-lookup"><span data-stu-id="7e96b-197">While they cannot be used by the graphics pipeline, they can be used as sources for updating POOL\_DEFAULT resources by using [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) or [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span></span> <span data-ttu-id="7e96b-198">Il comportamento di blocco è semplice, sebbene i blocchi possano verificarsi se sono utilizzati da uno dei metodi citati in precedenza.</span><span class="sxs-lookup"><span data-stu-id="7e96b-198">Their locking behavior is simple, although stalls might occur if they are in use by one of the previously mentioned methods.</span></span>

<span data-ttu-id="7e96b-199">Sebbene si trovino nella memoria di sistema, le \_ risorse SYSTEMMEM del pool sono limitate agli stessi formati e funzionalità, ad esempio le dimensioni massime, supportate dal driver di dispositivo.</span><span class="sxs-lookup"><span data-stu-id="7e96b-199">Though they reside in system memory, POOL\_SYSTEMMEM resources are limited to the same formats and capabilities (such as maximum size) supported by the device driver.</span></span> <span data-ttu-id="7e96b-200">Il \_ tipo di risorsa Scratch del pool è un altro tipo di risorsa di memoria di sistema che può utilizzare tutti i formati e le funzionalità supportati dal runtime, ma non è possibile accedervi dal dispositivo.</span><span class="sxs-lookup"><span data-stu-id="7e96b-200">The POOL\_SCRATCH resource type is another form of system memory resource that can utilize all formats and capabilities supported by the runtime, but cannot be accessed by the device.</span></span> <span data-ttu-id="7e96b-201">Le risorse Scratch sono destinate principalmente all'uso da strumenti di contenuto.</span><span class="sxs-lookup"><span data-stu-id="7e96b-201">Scratch resources are intended primarily for use by content tools.</span></span>

<span data-ttu-id="7e96b-202">**Figura 3. Risorse di memoria in RAM video, aperture AGP e RAM di sistema**</span><span class="sxs-lookup"><span data-stu-id="7e96b-202">**Figure 3. Memory resources in video RAM, AGP aperture, and system RAM**</span></span>

![risorse di memoria in RAM video, aperture AGP e RAM di sistema](images/managingresources3.gif)

## <a name="general-recommendations"></a><span data-ttu-id="7e96b-204">Suggerimenti generali</span><span class="sxs-lookup"><span data-stu-id="7e96b-204">General Recommendations</span></span>

<span data-ttu-id="7e96b-205">Ottenere i dettagli di implementazione tecnica della gestione delle risorse corretta è molto lungo per raggiungere gli obiettivi di prestazioni per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="7e96b-205">Getting the technical implementation details of resource management correct will go a long way toward achieving your performance goals for your application.</span></span> <span data-ttu-id="7e96b-206">Pianificare il modo in cui le risorse vengono presentate a Direct3D e la progettazione dell'architettura per ottenere i dati caricati in modo tempestivo è un'attività più complicata.</span><span class="sxs-lookup"><span data-stu-id="7e96b-206">Planning how the resources are presented to Direct3D and the architectural design around getting the data loaded in a timely fashion is a more complicated task.</span></span> <span data-ttu-id="7e96b-207">Quando si prendono le decisioni seguenti per l'applicazione, è consigliabile scegliere una serie di procedure consigliate:</span><span class="sxs-lookup"><span data-stu-id="7e96b-207">We recommend a number of best practices when making these decisions for your application:</span></span>

-   <span data-ttu-id="7e96b-208">Pre-elaborare tutte le risorse.</span><span class="sxs-lookup"><span data-stu-id="7e96b-208">Pre-process all your resources.</span></span> <span data-ttu-id="7e96b-209">L'uso di una conversione costosa e l'ottimizzazione del tempo di caricamento per le risorse risultano utili durante lo sviluppo, ma ciò comporta un notevole carico di prestazioni nei computer degli utenti.</span><span class="sxs-lookup"><span data-stu-id="7e96b-209">Relying on expensive load-time conversion and optimization for your resources is convenient during development, but doing so puts a great performance burden on your users' computers.</span></span> <span data-ttu-id="7e96b-210">Le risorse pre-elaborate sono più veloci da caricare, più velocemente da usare e offrono la possibilità di eseguire attività non in linea sofisticate.</span><span class="sxs-lookup"><span data-stu-id="7e96b-210">Pre-processed resources are faster to load, faster to use, and give you the option of doing sophisticated off-line work.</span></span>
-   <span data-ttu-id="7e96b-211">Evitare di creare molte risorse per fotogramma.</span><span class="sxs-lookup"><span data-stu-id="7e96b-211">Avoid creating many resources per frame.</span></span> <span data-ttu-id="7e96b-212">Le interazioni dei driver necessarie possono serializzare la CPU e la GPU e le operazioni implicate sono pesanti, perché spesso richiedono transizioni del kernel.</span><span class="sxs-lookup"><span data-stu-id="7e96b-212">The driver interactions required can serialize the CPU and GPU, and the operations involved are heavy-weight, as they often require kernel transitions.</span></span> <span data-ttu-id="7e96b-213">Distribuire la creazione in diversi frame o riutilizzare le risorse senza crearle/rilasciarle.</span><span class="sxs-lookup"><span data-stu-id="7e96b-213">Spread out creation over several frames or reuse resources without creating/releasing them.</span></span> <span data-ttu-id="7e96b-214">Idealmente, è consigliabile attendere diversi frame prima di bloccare o rilasciare le risorse usate di recente per il rendering.</span><span class="sxs-lookup"><span data-stu-id="7e96b-214">Ideally, you should wait several frames before locking or releasing resources that were recently used to render.</span></span>
-   <span data-ttu-id="7e96b-215">Alla fine del frame, assicurarsi di annullare l'associazione di tutti i canali di risorse (ovvero origini di flusso, fasi della trama e indici correnti).</span><span class="sxs-lookup"><span data-stu-id="7e96b-215">At the end of the frame, be sure to unbind all resource channels (that is, stream sources, texture stages, and current indices).</span></span> <span data-ttu-id="7e96b-216">In questo modo si garantisce la rimozione dei riferimenti in sospeso alle risorse prima che il gestore di risorse mantenga le risorse che non sono più in uso.</span><span class="sxs-lookup"><span data-stu-id="7e96b-216">Doing so will ensure that dangling references to resources are removed before they cause the resource manager to keep resources resident that are actually no longer in use.</span></span>
-   <span data-ttu-id="7e96b-217">Per le trame, usare formati compressi (ad esempio, DXTn) con MIP-Maps e prendere in considerazione l'uso di un Atlante delle trame.</span><span class="sxs-lookup"><span data-stu-id="7e96b-217">For textures, use compressed formats (for example, DXTn) with mip-maps, and consider making use of a texture atlas.</span></span> <span data-ttu-id="7e96b-218">Questi riducono notevolmente i requisiti di larghezza di banda e possono ridurre le dimensioni complessive delle risorse, rendendole così più efficienti.</span><span class="sxs-lookup"><span data-stu-id="7e96b-218">These greatly reduce bandwidth requirements, and they can reduce the overall size of the resources, thus making them more efficient.</span></span>
-   <span data-ttu-id="7e96b-219">Per la geometria, usare la geometria indicizzata, in quanto consente di comprimere le risorse del buffer dei vertici e l'hardware video moderno è altamente ottimizzato per quanto riguarda il riutilizzo dei vertici.</span><span class="sxs-lookup"><span data-stu-id="7e96b-219">For geometry, make use of indexed geometry as this helps compress vertex buffer resources, and modern video hardware is heavily optimized around reuse of vertices.</span></span> <span data-ttu-id="7e96b-220">Usando i vertex shader programmabili, è possibile comprimere le informazioni sui vertici ed espanderle durante l'elaborazione del vertice.</span><span class="sxs-lookup"><span data-stu-id="7e96b-220">By making use of programmable vertex shaders, you can compress the vertex information and expand it during the vertex processing.</span></span> <span data-ttu-id="7e96b-221">Anche in questo caso, è possibile ridurre i requisiti di larghezza di banda e rendere più efficienti le risorse del buffer</span><span class="sxs-lookup"><span data-stu-id="7e96b-221">Again, this helps reduce bandwidth requirements and makes vertex buffer resources more efficient.</span></span>
-   <span data-ttu-id="7e96b-222">Evitare di ottimizzare la gestione delle risorse.</span><span class="sxs-lookup"><span data-stu-id="7e96b-222">Avoid over-optimizing your resource management.</span></span> <span data-ttu-id="7e96b-223">Le revisioni future di driver, hardware e il sistema operativo possono causare problemi di compatibilità se l'applicazione viene ottimizzata troppo spesso in una combinazione particolare.</span><span class="sxs-lookup"><span data-stu-id="7e96b-223">Future revisions of drivers, hardware, and the operating system can potentially cause compatibility problems if the application is tuned too heavily to a particularly combination.</span></span> <span data-ttu-id="7e96b-224">Poiché la maggior parte delle applicazioni è associata alla CPU, una gestione costosa basata sulla CPU causa in genere più problemi di prestazioni rispetto a quanto si risolve.</span><span class="sxs-lookup"><span data-stu-id="7e96b-224">Since most applications are CPU-bound, expensive CPU-based management generally causes more performance issues than it solves.</span></span>

## <a name="related-topics"></a><span data-ttu-id="7e96b-225">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="7e96b-225">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="7e96b-226">Gestione delle risorse</span><span class="sxs-lookup"><span data-stu-id="7e96b-226">Managing Resources</span></span>](/windows/desktop/direct3d9/managing-resources)
</dt> <dt>

[<span data-ttu-id="7e96b-227">Dispositivi persi</span><span class="sxs-lookup"><span data-stu-id="7e96b-227">Lost Devices</span></span>](/windows/desktop/direct3d9/lost-devices)
</dt> <dt>

[<span data-ttu-id="7e96b-228">Ottimizzazioni delle prestazioni</span><span class="sxs-lookup"><span data-stu-id="7e96b-228">Performance Optimizations</span></span>](/windows/desktop/direct3d9/performance-optimizations)
</dt> <dt>

[<span data-ttu-id="7e96b-229">Risorse di trama compresse</span><span class="sxs-lookup"><span data-stu-id="7e96b-229">Compressed Texture Resources</span></span>](/windows/desktop/direct3d9/compressed-texture-resources)
</dt> <dt>

[<span data-ttu-id="7e96b-230">Query</span><span class="sxs-lookup"><span data-stu-id="7e96b-230">Queries</span></span>](/windows/desktop/direct3d9/queries)
</dt> <dt>

[<span data-ttu-id="7e96b-231">**D3DUSAGE**</span><span class="sxs-lookup"><span data-stu-id="7e96b-231">**D3DUSAGE**</span></span>](/windows/desktop/direct3d9/d3dusage)
</dt> <dt>

[<span data-ttu-id="7e96b-232">**D3DPOOL**</span><span class="sxs-lookup"><span data-stu-id="7e96b-232">**D3DPOOL**</span></span>](/windows/desktop/direct3d9/d3dpool)
</dt> <dt>

[<span data-ttu-id="7e96b-233">D3DCREATE</span><span class="sxs-lookup"><span data-stu-id="7e96b-233">D3DCREATE</span></span>](/windows/desktop/direct3d9/d3dcreate)
</dt> </dl>

 

 