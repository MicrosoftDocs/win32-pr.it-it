---
title: Codifica per multicore in Xbox 360 e Windows
description: In questo argomento vengono fornite alcune indicazioni su come iniziare a usare la programmazione multithreading.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/21/2020
ms.locfileid: "104399914"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a><span data-ttu-id="7db4d-103">Codifica per multicore in Xbox 360 e Windows</span><span class="sxs-lookup"><span data-stu-id="7db4d-103">Coding for multicore on Xbox 360 and Windows</span></span>

<span data-ttu-id="7db4d-104">Per anni le prestazioni dei processori sono aumentate costantemente e i giochi e altri programmi hanno sfruttato i vantaggi di questa potenza crescente senza dover eseguire alcuna operazione speciale.</span><span class="sxs-lookup"><span data-stu-id="7db4d-104">For years the performance of processors has increased steadily, and games and other programs have reaped the benefits of this increasing power without having to do anything special.</span></span>

<span data-ttu-id="7db4d-105">Le regole sono state modificate.</span><span class="sxs-lookup"><span data-stu-id="7db4d-105">The rules have changed.</span></span> <span data-ttu-id="7db4d-106">Le prestazioni dei core del processore singolo ora aumentano molto lentamente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-106">The performance of single processor cores is now increasing very slowly, if at all.</span></span> <span data-ttu-id="7db4d-107">Tuttavia, la potenza di calcolo disponibile in un computer o in una console tipica continua ad aumentare.</span><span class="sxs-lookup"><span data-stu-id="7db4d-107">However, the computing power available in a typical computer or console continues to grow.</span></span> <span data-ttu-id="7db4d-108">La differenza è che la maggior parte di questo miglioramento delle prestazioni ora deriva dalla presenza di più core del processore in un singolo computer, spesso in un singolo chip.</span><span class="sxs-lookup"><span data-stu-id="7db4d-108">The difference is that most of this performance gain now comes from having multiple processor cores in a single machine, often in a single chip.</span></span> <span data-ttu-id="7db4d-109">La CPU Xbox 360 dispone di tre core del processore su un chip e circa il 70% dei processori del PC venduti in 2006 era multicore.</span><span class="sxs-lookup"><span data-stu-id="7db4d-109">The Xbox 360 CPU has three processor cores on one chip, and roughly 70 percent of PC processors sold in 2006 were multi-core.</span></span>

<span data-ttu-id="7db4d-110">L'aumento della potenza di elaborazione disponibile è altrettanto drammatico quanto in passato, ma ora gli sviluppatori devono scrivere codice multithreading per poter usare questa potenza.</span><span class="sxs-lookup"><span data-stu-id="7db4d-110">The increases in available processing power are just as dramatic as in the past, but now developers have to write multithreaded code in order to use this power.</span></span> <span data-ttu-id="7db4d-111">La programmazione multithread comporta nuove problemi di progettazione e programmazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-111">Multi-threaded programming brings with it new design and programming challenges.</span></span> <span data-ttu-id="7db4d-112">In questo argomento vengono fornite alcune indicazioni su come iniziare a usare la programmazione multithreading.</span><span class="sxs-lookup"><span data-stu-id="7db4d-112">This topic gives some advice on how to get started with multithreaded programming.</span></span>

## <a name="the-importance-of-good-design"></a><span data-ttu-id="7db4d-113">Importanza della progettazione corretta</span><span class="sxs-lookup"><span data-stu-id="7db4d-113">The Importance of Good Design</span></span>

<span data-ttu-id="7db4d-114">La progettazione di un programma multithreading efficace è fondamentale, ma può essere molto difficile.</span><span class="sxs-lookup"><span data-stu-id="7db4d-114">Good multithreaded program design is critical, but it can be very difficult.</span></span> <span data-ttu-id="7db4d-115">Se si spostano i sistemi di gioco principali su thread diversi, probabilmente si noterà che ogni thread trascorre la maggior parte del tempo in attesa sugli altri thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-115">If you haphazardly move your major game systems onto different threads, you will likely find that each thread spends most of its time waiting on the other threads.</span></span> <span data-ttu-id="7db4d-116">Questo tipo di progettazione comporta una maggiore complessità e un lavoro di debug significativo, senza praticamente alcun miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-116">This type of design leads to increased complexity and significant debugging effort, with virtually no performance gain.</span></span>

<span data-ttu-id="7db4d-117">Ogni volta che i thread devono sincronizzare o condividere dati, è possibile che si verifichino danneggiamenti dei dati, sovraccarico della sincronizzazione, deadlock e complessità.</span><span class="sxs-lookup"><span data-stu-id="7db4d-117">Every time that threads have to synchronize or share data there is the potential for data corruption, synchronization overhead, deadlocks, and complexity.</span></span> <span data-ttu-id="7db4d-118">Pertanto, la progettazione multithreading deve documentare chiaramente ogni punto di sincronizzazione e di comunicazione ed è necessario ridurre al minimo tali punti.</span><span class="sxs-lookup"><span data-stu-id="7db4d-118">Therefore, your multithreaded design needs to clearly document every synchronization and communication point, and it should minimize such points as much as possible.</span></span> <span data-ttu-id="7db4d-119">Quando i thread devono comunicare, il lavoro di codifica aumenterà, che può ridurre la produttività se interessa un codice sorgente troppo elevato.</span><span class="sxs-lookup"><span data-stu-id="7db4d-119">Where threads need to communicate, coding effort will increase, which can lower productivity if it affects too much source code.</span></span>

<span data-ttu-id="7db4d-120">L'obiettivo di progettazione più semplice per il multithreading consiste nel suddividere il codice in parti indipendenti di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-120">The simplest design goal for multithreading is to break up the code into large independent pieces.</span></span> <span data-ttu-id="7db4d-121">Se quindi si limitano queste parti alla comunicazione solo alcune volte per fotogramma, si noterà un aumento significativo del multithreading, senza eccessive complessità.</span><span class="sxs-lookup"><span data-stu-id="7db4d-121">If you then restrict these pieces to communicating just a few times per frame, you will see significant speedup from multithreading, without undue complexity.</span></span>

## <a name="typical-threaded-tasks"></a><span data-ttu-id="7db4d-122">Attività tipiche con thread</span><span class="sxs-lookup"><span data-stu-id="7db4d-122">Typical Threaded Tasks</span></span>

<span data-ttu-id="7db4d-123">Alcuni tipi di attività si sono rivelati suscettibili di essere inseriti su thread separati.</span><span class="sxs-lookup"><span data-stu-id="7db4d-123">A few types of tasks have proven amenable to being put onto separate threads.</span></span> <span data-ttu-id="7db4d-124">L'elenco seguente non è destinato a essere esaustivo, ma dovrebbe fornire alcune idee.</span><span class="sxs-lookup"><span data-stu-id="7db4d-124">The following list is not intended to be exhaustive, but should give some ideas.</span></span>

### <a name="rendering"></a><span data-ttu-id="7db4d-125">Rendering</span><span class="sxs-lookup"><span data-stu-id="7db4d-125">Rendering</span></span>

<span data-ttu-id="7db4d-126">Il rendering, che può includere l'esplorazione del grafico della scena o, probabilmente, solo la chiamata di funzioni D3D, spesso rappresenta il 50% o più del tempo di CPU.</span><span class="sxs-lookup"><span data-stu-id="7db4d-126">Rendering — which may include walking the scene graph or, possibly, only calling D3D functions — often accounts for 50 percent or more of CPU time.</span></span> <span data-ttu-id="7db4d-127">Pertanto, lo stato del rendering in un altro thread può avere vantaggi significativi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-127">Therefore, moving rendering to another thread can have significant benefits.</span></span> <span data-ttu-id="7db4d-128">Il thread di aggiornamento può compilare un tipo di buffer di descrizione di rendering, che può essere elaborato dal thread di rendering.</span><span class="sxs-lookup"><span data-stu-id="7db4d-128">The update thread can fill in some sort of render description buffer, which the rendering thread can then process.</span></span>

<span data-ttu-id="7db4d-129">Il thread di aggiornamento del gioco è sempre un fotogramma avanti rispetto al thread di rendering, il che significa che prima di visualizzare le azioni utente sullo schermo sono necessari due fotogrammi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-129">The game update thread is always one frame ahead of the render thread, which means that it takes two frames before user actions show up on the screen.</span></span> <span data-ttu-id="7db4d-130">Anche se questa latenza maggiore può costituire un problema, la frequenza dei fotogrammi aumentata dalla suddivisione del carico di lavoro in genere mantiene la latenza totale accettabile.</span><span class="sxs-lookup"><span data-stu-id="7db4d-130">Although this increased latency can be a problem, the increased frame rate from splitting up the workload generally keeps the total latency acceptable.</span></span>

<span data-ttu-id="7db4d-131">Nella maggior parte dei casi, tutto il rendering viene ancora eseguito su un singolo thread, ma è un thread diverso dall'aggiornamento del gioco.</span><span class="sxs-lookup"><span data-stu-id="7db4d-131">In most cases all rendering is still done on a single thread, but it is a different thread from the game update.</span></span>

<span data-ttu-id="7db4d-132">Il \_ flag MULTIthreading D3DCREATE viene talvolta usato per consentire il rendering in un thread e la creazione di risorse in altri thread. questo flag viene ignorato in Xbox 360 ed è consigliabile evitare di usarlo in Windows.</span><span class="sxs-lookup"><span data-stu-id="7db4d-132">The D3DCREATE\_MULTITHREADED flag is sometimes used to allow rendering on one thread and resource creation on other threads; this flag is ignored on Xbox 360, and you should avoid using it on Windows.</span></span> <span data-ttu-id="7db4d-133">In Windows, se si specifica questo flag, D3D impiega una quantità di tempo significativa per la sincronizzazione, rallentando così il thread di rendering.</span><span class="sxs-lookup"><span data-stu-id="7db4d-133">On Windows, specifying this flag forces D3D to spend a significant amount of time on synchronization, thus slowing down the render thread.</span></span>

### <a name="file-decompression"></a><span data-ttu-id="7db4d-134">Decompressione file</span><span class="sxs-lookup"><span data-stu-id="7db4d-134">File Decompression</span></span>

<span data-ttu-id="7db4d-135">I tempi di caricamento sono sempre troppo lunghi e il flusso dei dati in memoria senza influire sulla frequenza dei fotogrammi può risultare complesso.</span><span class="sxs-lookup"><span data-stu-id="7db4d-135">Load times are always too long, and streaming data into memory without affecting the frame rate can be challenging.</span></span> <span data-ttu-id="7db4d-136">Se tutti i dati sono compressi in modo aggressivo sul disco, la velocità di trasferimento dei dati dal disco rigido o dal disco ottico è meno probabile che sia un fattore limitante.</span><span class="sxs-lookup"><span data-stu-id="7db4d-136">If all data is aggressively compressed on disc, then data transfer speed from the hard drive or optical disc is less likely to be a limiting factor.</span></span> <span data-ttu-id="7db4d-137">In un processore a thread singolo, il tempo di elaborazione disponibile in genere non è sufficiente per la compressione, in modo da agevolare i tempi di caricamento.</span><span class="sxs-lookup"><span data-stu-id="7db4d-137">On a single-threaded processor, there is usually not enough processor time available for compression to help load times.</span></span> <span data-ttu-id="7db4d-138">In un sistema multiprocessore, tuttavia, la decompressione dei file USA cicli CPU che altrimenti sarebbero sprecati; migliora i tempi di caricamento e il flusso; e salva spazio sul disco.</span><span class="sxs-lookup"><span data-stu-id="7db4d-138">On a multiprocessor system, however, file decompression uses CPU cycles that would otherwise be wasted; it improves load times and streaming; and it saves space on the disc.</span></span>

<span data-ttu-id="7db4d-139">Non utilizzare la decompressione di file come sostituzione per l'elaborazione da eseguire durante la produzione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-139">Do not use file decompression as a replacement for processing that should be done during production.</span></span> <span data-ttu-id="7db4d-140">Se ad esempio si dedica un thread aggiuntivo all'analisi dei dati XML durante il caricamento del livello, non si usa il multithreading per migliorare l'esperienza del lettore.</span><span class="sxs-lookup"><span data-stu-id="7db4d-140">For instance, if you devote an extra thread to parsing XML data during level loading, you are not using multithreading to improve the player's experience.</span></span>

<span data-ttu-id="7db4d-141">Quando si utilizza un thread di decompressione file, è comunque necessario utilizzare l'I/O di file asincrono e le letture di grandi dimensioni per ottimizzare l'efficienza di lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="7db4d-141">When using a file decompression thread, you should still use asynchronous file I/O and large reads in order to maximize data-reading efficiency.</span></span>

### <a name="graphics-fluff"></a><span data-ttu-id="7db4d-142">Fluff grafica</span><span class="sxs-lookup"><span data-stu-id="7db4d-142">Graphics Fluff</span></span>

<span data-ttu-id="7db4d-143">Sono disponibili molte sottigliezze grafiche che consentono di migliorare l'aspetto del gioco, ma non sono strettamente necessarie.</span><span class="sxs-lookup"><span data-stu-id="7db4d-143">There are many graphical niceties that improve the look of the game but aren't strictly necessary.</span></span> <span data-ttu-id="7db4d-144">Sono inclusi elementi come animazioni cloud generate in modo procedurale, simulazioni di stoffa e capelli, onde procedurali, vegetazione procedurale, più particelle o fisica non di gioco.</span><span class="sxs-lookup"><span data-stu-id="7db4d-144">These include things like procedurally generated cloud animations, cloth and hair simulations, procedural waves, procedural vegetation, more particles, or non-gameplay physics.</span></span>

<span data-ttu-id="7db4d-145">Poiché questi effetti non influiscono sul gameplay, non causano problemi di sincronizzazione complessi, ma possono essere sincronizzati con gli altri thread una volta per frame o meno spesso.</span><span class="sxs-lookup"><span data-stu-id="7db4d-145">Because these effects don't affect gameplay, they don't cause tricky synchronization problems—they can synchronize with the other threads once per frame or less often.</span></span> <span data-ttu-id="7db4d-146">Inoltre, nei giochi per Windows questi effetti possono aggiungere valore per i giocatori con CPU multicore, ignorando in modo invisibile i computer a core singolo, offrendo così un modo semplice per ridimensionare un'ampia gamma di funzionalità.</span><span class="sxs-lookup"><span data-stu-id="7db4d-146">Additionally, on games for Windows these effects can add value for gamers with multicore CPUs, while silently being omitted on single-core computers, thus giving an easy way of scaling across a wide range of capabilities.</span></span>

### <a name="physics"></a><span data-ttu-id="7db4d-147">Fisica</span><span class="sxs-lookup"><span data-stu-id="7db4d-147">Physics</span></span>

<span data-ttu-id="7db4d-148">Spesso la fisica non può essere inserita in un thread separato per l'esecuzione in parallelo con l'aggiornamento del gioco, perché l'aggiornamento del gioco richiede in genere i risultati dei calcoli fisici immediatamente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-148">Physics often cannot be put onto a separate thread to run in parallel with the game update because the game update usually requires the results of the physics calculations immediately.</span></span> <span data-ttu-id="7db4d-149">L'alternativa per la fisica del multithreading consiste nell'eseguirla su più processori.</span><span class="sxs-lookup"><span data-stu-id="7db4d-149">The alternative for multithreading physics is to run it on multiple processors.</span></span> <span data-ttu-id="7db4d-150">Sebbene sia possibile eseguire questa operazione, si tratta di un'attività complessa che richiede l'accesso frequente alle strutture di dati condivise.</span><span class="sxs-lookup"><span data-stu-id="7db4d-150">Although this can be done, it is a complex task requiring frequent access to shared data structures.</span></span> <span data-ttu-id="7db4d-151">Se il carico di lavoro fisico può essere sufficientemente basso da adattarsi al thread principale, il processo sarà più semplice.</span><span class="sxs-lookup"><span data-stu-id="7db4d-151">If you can keep your physics workload low enough to fit on the main thread, your job will be simpler.</span></span>

<span data-ttu-id="7db4d-152">Sono disponibili librerie che supportano l'esecuzione di fisica in più thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-152">Libraries that support running physics on multiple threads are available.</span></span> <span data-ttu-id="7db4d-153">Tuttavia, questo può causare un problema: quando il gioco esegue la fisica, USA molti thread, ma il resto del tempo ne usa pochi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-153">However, this can lead to a problem: when your game is running physics, it uses many threads, but the rest of the time it uses few.</span></span> <span data-ttu-id="7db4d-154">Per eseguire la fisica su più thread, è necessario risolverlo in modo che il carico di lavoro venga distribuito uniformemente sul frame.</span><span class="sxs-lookup"><span data-stu-id="7db4d-154">Running physics on multiple threads will require addressing this so that the workload is distributed evenly over the frame.</span></span> <span data-ttu-id="7db4d-155">Se si scrive un motore di fisica multithreading, è necessario prestare attenzione a tutte le strutture di dati, i punti di sincronizzazione e il bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="7db4d-155">If you write a multithreaded physics engine, you must pay careful attention to all of your data structures, synchronization points, and load balancing.</span></span>

## <a name="example-multithreaded-designs"></a><span data-ttu-id="7db4d-156">Esempi di progettazione multithreading</span><span class="sxs-lookup"><span data-stu-id="7db4d-156">Example Multithreaded Designs</span></span>

<span data-ttu-id="7db4d-157">I giochi per Windows devono essere eseguiti in computer con diversi numeri di core CPU.</span><span class="sxs-lookup"><span data-stu-id="7db4d-157">Games for Windows need to run on computers with different numbers of CPU cores.</span></span> <span data-ttu-id="7db4d-158">La maggior parte dei computer di gioco ha ancora un solo core, sebbene il numero di macchine virtuali a due core stia crescendo rapidamente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-158">Most game machines still have only one core, although the number of two-core machines is growing rapidly.</span></span> <span data-ttu-id="7db4d-159">Un tipico gioco per Windows potrebbe suddividere il carico di lavoro in un thread per l'aggiornamento e il rendering, con thread di lavoro facoltativi per l'aggiunta di funzionalità aggiuntive.</span><span class="sxs-lookup"><span data-stu-id="7db4d-159">A typical game for Windows might break its workload into one thread for update and rendering, with optional worker threads for adding extra functionality.</span></span> <span data-ttu-id="7db4d-160">Inoltre, potrebbero essere usati alcuni thread in background per l'I/O dei file e la rete.</span><span class="sxs-lookup"><span data-stu-id="7db4d-160">In addition, some background threads for doing file I/O and networking would probably be used.</span></span> <span data-ttu-id="7db4d-161">Nella figura 1 vengono illustrati i thread, insieme ai punti di trasferimento dei dati principali.</span><span class="sxs-lookup"><span data-stu-id="7db4d-161">Figure 1 shows the threads, together with the main data transfer points.</span></span>

<span data-ttu-id="7db4d-162">**Figura 1. Progettazione del threading in un gioco per Windows**</span><span class="sxs-lookup"><span data-stu-id="7db4d-162">**Figure 1. Threading design in a game for Windows**</span></span>

![progettazione del threading in un gioco per Windows](images/coding-for-multiple-cores-1.gif)

<span data-ttu-id="7db4d-164">Un tipico gioco Xbox 360 può utilizzare thread software a elevato utilizzo di CPU, quindi potrebbe suddividere il carico di lavoro in un thread di aggiornamento, un thread di rendering e tre thread di lavoro, come illustrato nella figura 2.</span><span class="sxs-lookup"><span data-stu-id="7db4d-164">A typical Xbox 360 game can use additional CPU-intensive software threads, so it might break up its workload into an update thread, rendering thread, and three worker threads, as shown in Figure 2.</span></span>

<span data-ttu-id="7db4d-165">**Figura 2. Progettazione del threading in un gioco per Xbox 360**</span><span class="sxs-lookup"><span data-stu-id="7db4d-165">**Figure 2. Threading design in a game for Xbox 360**</span></span>

![progettazione del threading in un gioco per Xbox 360](images/coding-for-multiple-cores-2.gif)

<span data-ttu-id="7db4d-167">Fatta eccezione per le operazioni di I/O di file e di rete, queste attività possono avere un elevato utilizzo della CPU per trarre vantaggio dal proprio thread hardware.</span><span class="sxs-lookup"><span data-stu-id="7db4d-167">With the exception of file I/O and networking, these tasks all have the potential to be CPU-intensive enough to benefit from being on their own hardware thread.</span></span> <span data-ttu-id="7db4d-168">Queste attività hanno anche la possibilità di essere sufficientemente indipendenti da poter essere eseguite per un intero frame senza comunicazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-168">These tasks also have the potential to be independent enough that they can run for an entire frame without communicating.</span></span>

<span data-ttu-id="7db4d-169">Il thread di aggiornamento del gioco gestisce l'input del controller, l'intelligenza artificiale e la fisica e prepara le istruzioni per gli altri quattro thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-169">The game update thread manages controller input, AI, and physics, and prepares instructions for the other four threads.</span></span> <span data-ttu-id="7db4d-170">Queste istruzioni vengono inserite nei buffer di proprietà del thread di aggiornamento del gioco, pertanto non è necessaria alcuna sincronizzazione quando vengono generate le istruzioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-170">These instructions are placed into buffers owned by the game update thread, so no synchronization is required as the instructions are generated.</span></span>

<span data-ttu-id="7db4d-171">Alla fine del frame, il thread di aggiornamento del gioco passa i buffer di istruzione ai quattro altri thread, quindi inizia a lavorare sul frame successivo, compilando un altro set di buffer di istruzioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-171">At the end of the frame, the game update thread hands off the instruction buffers to the four other threads, and then starts working on the next frame, filling in another set of instruction buffers.</span></span>

<span data-ttu-id="7db4d-172">Poiché i thread di aggiornamento e di rendering funzionano in contemporanea l'uno con l'altro, i buffer di comunicazione sono semplicemente a doppio buffer: in un determinato momento, il thread di aggiornamento sta riempiendo un buffer mentre il thread di rendering sta leggendo l'altro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-172">Because the update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered: at any given time, the update thread is filling one buffer while the render thread is reading from the other.</span></span>

<span data-ttu-id="7db4d-173">Gli altri thread di lavoro non sono necessariamente collegati alla frequenza dei fotogrammi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-173">The other worker threads are not necessarily tied to the frame rate.</span></span> <span data-ttu-id="7db4d-174">La decompressione di una porzione di dati potrebbe richiedere molto meno di un frame o potrebbe richiedere molti frame.</span><span class="sxs-lookup"><span data-stu-id="7db4d-174">Decompressing a piece of data may take much less than a frame, or it may take many frames.</span></span> <span data-ttu-id="7db4d-175">Anche la simulazione del panno e dei capelli potrebbe non essere necessaria per essere eseguita esattamente alla frequenza dei fotogrammi perché gli aggiornamenti meno frequenti possono essere abbastanza accettabili.</span><span class="sxs-lookup"><span data-stu-id="7db4d-175">Even the cloth and hair simulation may not need to run exactly at the frame rate because less frequent updates may be quite acceptable.</span></span> <span data-ttu-id="7db4d-176">Pertanto, questi tre thread necessitano di strutture di dati diverse per comunicare con il thread di aggiornamento e il thread di rendering.</span><span class="sxs-lookup"><span data-stu-id="7db4d-176">Therefore, these three threads need different data structures to communicate with the update thread and the render thread.</span></span> <span data-ttu-id="7db4d-177">Ognuno di essi necessita di una coda di input in grado di gestire le richieste di lavoro e il thread di rendering necessita di una coda di dati che può conservare i risultati prodotti dai thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-177">They each need an input queue that can hold work requests, and the render thread needs a data queue that can hold the results produced by the threads.</span></span> <span data-ttu-id="7db4d-178">Alla fine di ogni frame, il thread di aggiornamento aggiungerà un blocco di richieste di lavoro alle code dei thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-178">At the end of each frame the update thread will add a block of work requests to worker threads' queues.</span></span> <span data-ttu-id="7db4d-179">L'aggiunta all'elenco una sola volta per frame garantisce che il thread di aggiornamento riduca al minimo l'overhead di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-179">Adding to the list just once per frame ensures that the update thread minimizes the synchronization overhead.</span></span> <span data-ttu-id="7db4d-180">Ogni thread di lavoro estrae le assegnazioni dalla coda di lavoro nel modo più rapido possibile, usando un ciclo simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="7db4d-180">Each of the worker threads pulls assignments from the work queue as quickly as it can, using a loop that looks something like this:</span></span>


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



<span data-ttu-id="7db4d-181">Poiché i dati passano dai thread di aggiornamento ai thread di lavoro e quindi al thread di rendering, può esserci un ritardo di tre o più frame prima che alcune azioni lo rendano sullo schermo.</span><span class="sxs-lookup"><span data-stu-id="7db4d-181">Because the data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions make it to the screen.</span></span> <span data-ttu-id="7db4d-182">Tuttavia, se si assegnano attività a tolleranza di latenza ai thread di lavoro, questo non dovrebbe essere un problema.</span><span class="sxs-lookup"><span data-stu-id="7db4d-182">However, if you assign latency-tolerant tasks to the worker threads, then this should not be a problem.</span></span>

<span data-ttu-id="7db4d-183">Una progettazione alternativa consiste nel fare in modo che diversi thread di lavoro vengano disegnati dalla stessa coda di lavoro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-183">An alternate design would be to have several worker threads all drawing from the same work queue.</span></span> <span data-ttu-id="7db4d-184">Questo darebbe un bilanciamento automatico del carico e renderà più probabile che tutti i thread di lavoro rimarranno occupati.</span><span class="sxs-lookup"><span data-stu-id="7db4d-184">This would give automatic load balancing and would make it more likely that all of the worker threads would stay busy.</span></span>

<span data-ttu-id="7db4d-185">Il thread di aggiornamento del gioco deve prestare attenzione a non concedere troppo lavoro ai thread di lavoro. in caso contrario, è possibile che le code di lavoro crescano continuamente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-185">The game update thread must take care to not give too much work to the worker threads, or else the work queues may continuously grow.</span></span> <span data-ttu-id="7db4d-186">Il modo in cui il thread di aggiornamento gestisce questa operazione dipende dal tipo di attività eseguite dai thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-186">How the update thread manages this depends on what sort of tasks the worker threads are doing.</span></span>

## <a name="simultaneous-multithreading-and-number-of-threads"></a><span data-ttu-id="7db4d-187">Multithreading simultaneo e numero di thread</span><span class="sxs-lookup"><span data-stu-id="7db4d-187">Simultaneous Multithreading and Number of Threads</span></span>

<span data-ttu-id="7db4d-188">Tutti i thread non vengono creati uguali.</span><span class="sxs-lookup"><span data-stu-id="7db4d-188">All threads are not created equal.</span></span> <span data-ttu-id="7db4d-189">Due thread hardware possono trovarsi su chip distinti, sullo stesso chip o anche sullo stesso core.</span><span class="sxs-lookup"><span data-stu-id="7db4d-189">Two hardware threads might be on separate chips, on the same chip, or even on the same core.</span></span> <span data-ttu-id="7db4d-190">La configurazione più importante per i programmatori di giochi da tenere in considerazione è costituita da due thread hardware su un core, ovvero la tecnologia multithreading (SMT) o la tecnologia Hyper-Threading (tecnologia HT).</span><span class="sxs-lookup"><span data-stu-id="7db4d-190">The most important configuration for game programmers to be aware of is two hardware threads on one core—Simultaneous Multi-Threading (SMT) or Hyper-Threading Technology (HT Technology).</span></span>

<span data-ttu-id="7db4d-191">I thread della tecnologia SMT o HT condividono le risorse del core CPU.</span><span class="sxs-lookup"><span data-stu-id="7db4d-191">SMT or HT Technology threads share the resources of the CPU core.</span></span> <span data-ttu-id="7db4d-192">Poiché condividono le unità di esecuzione, la massima velocità di esecuzione di due thread invece di uno è in genere dal 10 al 20%, invece del 100% che è possibile da due thread di hardware indipendenti.</span><span class="sxs-lookup"><span data-stu-id="7db4d-192">Because they share the execution units, the maximum speedup from running two threads instead of one is typically 10 to 20 percent, instead of the 100 percent that is possible from two independent hardware threads.</span></span>

<span data-ttu-id="7db4d-193">Più significativamente, i thread della tecnologia SMT o HT condividono le cache di dati e l'istruzione L1.</span><span class="sxs-lookup"><span data-stu-id="7db4d-193">More significantly, SMT or HT Technology threads share the L1 instruction and data caches.</span></span> <span data-ttu-id="7db4d-194">Se i modelli di accesso alla memoria non sono compatibili, possono superare la cache e causare molti mancati riscontri nella cache.</span><span class="sxs-lookup"><span data-stu-id="7db4d-194">If their memory access patterns are incompatible, they can end up fighting over the cache and causing many cache misses.</span></span> <span data-ttu-id="7db4d-195">Nel peggiore dei casi, le prestazioni totali per il nucleo CPU possono effettivamente diminuire quando viene eseguito un secondo thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-195">In the worst case, the total performance for the CPU core can actually decrease when a second thread is run.</span></span> <span data-ttu-id="7db4d-196">In Xbox 360 questo è un problema piuttosto semplice.</span><span class="sxs-lookup"><span data-stu-id="7db4d-196">On Xbox 360, this is a fairly simple problem.</span></span> <span data-ttu-id="7db4d-197">La configurazione di Xbox 360 è nota: tre core CPU ognuno con due thread hardware, e gli sviluppatori assegnano i thread software a specifici thread della CPU e possono misurare per verificare se la progettazione del threading offre prestazioni aggiuntive.</span><span class="sxs-lookup"><span data-stu-id="7db4d-197">The configuration of the Xbox 360 is known—three CPU cores each with two hardware threads—and developers assign their software threads to specific CPU threads and can measure to see whether their threading design gives them extra performance.</span></span>

<span data-ttu-id="7db4d-198">In Windows, la situazione è più complessa.</span><span class="sxs-lookup"><span data-stu-id="7db4d-198">On Windows, the situation is more complicated.</span></span> <span data-ttu-id="7db4d-199">Il numero di thread e la relativa configurazione variano da computer a computer e la determinazione della configurazione è complessa.</span><span class="sxs-lookup"><span data-stu-id="7db4d-199">The number of threads and their configuration will vary from computer to computer, and determining the configuration is complicated.</span></span> <span data-ttu-id="7db4d-200">La funzione [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) fornisce informazioni sulla relazione tra diversi thread hardware e questa funzione è disponibile in Windows Vista, Windows 7 e Windows XP SP3.</span><span class="sxs-lookup"><span data-stu-id="7db4d-200">The function [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) gives information about the relationship between different hardware threads, and this function is available on Windows Vista, Windows 7, and Windows XP SP3.</span></span> <span data-ttu-id="7db4d-201">Per questo motivo, è necessario usare l'istruzione CPUID e gli algoritmi forniti da Intel e AMD per decidere il numero di thread "reali" disponibili.</span><span class="sxs-lookup"><span data-stu-id="7db4d-201">Therefore, for now you have to use the CPUID instruction and the algorithms given by Intel and AMD in order to decide how many "real" threads you have available.</span></span> <span data-ttu-id="7db4d-202">Per ulteriori informazioni, vedere i riferimenti.</span><span class="sxs-lookup"><span data-stu-id="7db4d-202">See the references for more information.</span></span>

<span data-ttu-id="7db4d-203">L'esempio CoreDetection in DirectX SDK contiene codice di esempio che usa la funzione [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) o l'istruzione CPUID per restituire la topologia core della CPU.</span><span class="sxs-lookup"><span data-stu-id="7db4d-203">The CoreDetection sample in the DirectX SDK contains sample code that uses the [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) function or the CPUID instruction to return the CPU core topology.</span></span> <span data-ttu-id="7db4d-204">L'istruzione CPUID viene utilizzata se **GetLogicalProcessorInformation** non è supportato nella piattaforma corrente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-204">The CPUID instruction is used if **GetLogicalProcessorInformation** is not supported on the current platform.</span></span> <span data-ttu-id="7db4d-205">CoreDetection si trova nei percorsi seguenti:</span><span class="sxs-lookup"><span data-stu-id="7db4d-205">CoreDetection can be found in the following locations:</span></span>

<dl> <dt>

<span data-ttu-id="7db4d-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Origine</span><span class="sxs-lookup"><span data-stu-id="7db4d-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Source:</span></span>
</dt> <dd>

<span data-ttu-id="7db4d-207">Radice di DirectX *SDK* \\ Esempi \\ C++ \\ \\ CoreDetection varie</span><span class="sxs-lookup"><span data-stu-id="7db4d-207">*DirectX SDK root*\\Samples\\C++\\Misc\\CoreDetection</span></span>

</dd> <dt>

<span data-ttu-id="7db4d-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Eseguibile</span><span class="sxs-lookup"><span data-stu-id="7db4d-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executable:</span></span>
</dt> <dd>

<span data-ttu-id="7db4d-209">Radice di DirectX *SDK* \\ Esempi \\ \\ \\CoreDetection.exe bin varie \\ C++</span><span class="sxs-lookup"><span data-stu-id="7db4d-209">*DirectX SDK root*\\Samples\\C++\\Misc\\Bin\\CoreDetection.exe</span></span>

</dd> </dl>

<span data-ttu-id="7db4d-210">Il presupposto più sicuro consiste nel non avere più di un thread con utilizzo intensivo della CPU per ogni core CPU.</span><span class="sxs-lookup"><span data-stu-id="7db4d-210">The safest assumption is to have no more than one CPU-intensive thread per CPU core.</span></span> <span data-ttu-id="7db4d-211">La presenza di più thread con utilizzo intensivo della CPU rispetto ai core CPU non offre vantaggi minimi o null e comporta un sovraccarico aggiuntivo e una maggiore complessità dei thread aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-211">Having more CPU-intensive threads than CPU cores gives little or no benefits, and brings the extra overhead and complexity of additional threads.</span></span>

## <a name="creating-threads"></a><span data-ttu-id="7db4d-212">Creazione di thread</span><span class="sxs-lookup"><span data-stu-id="7db4d-212">Creating Threads</span></span>

<span data-ttu-id="7db4d-213">La creazione di thread è un'operazione piuttosto semplice, ma ci sono molti potenziali errori.</span><span class="sxs-lookup"><span data-stu-id="7db4d-213">Creating threads is a fairly simple operation, but there are many potential errors.</span></span> <span data-ttu-id="7db4d-214">Il codice seguente illustra il modo corretto per creare un thread, attenderne l'interruzione e quindi pulire.</span><span class="sxs-lookup"><span data-stu-id="7db4d-214">The code below shows the proper way of creating a thread, waiting for it to terminate, and then cleaning up.</span></span>


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



<span data-ttu-id="7db4d-215">Quando si crea un thread, è possibile specificare la dimensione dello stack per il thread figlio o specificare zero, nel qual caso il thread figlio erediterà la dimensione dello stack del thread padre.</span><span class="sxs-lookup"><span data-stu-id="7db4d-215">When you create a thread, you have the option to specify the stack size for the child thread, or specify zero, in which case the child thread will inherit the parent thread's stack size.</span></span> <span data-ttu-id="7db4d-216">In Xbox 360, in cui viene eseguito il commit completo degli stack all'avvio del thread, se si specifica zero è possibile sprecare memoria significativa, perché molti thread figlio non necessitano di un numero di stack pari a quello dell'elemento padre.</span><span class="sxs-lookup"><span data-stu-id="7db4d-216">On Xbox 360, where stacks are fully committed when the thread starts, specifying zero can waste significant memory, because many child threads will not need as much stack as the parent.</span></span> <span data-ttu-id="7db4d-217">In Xbox 360 è inoltre importante che le dimensioni dello stack siano un multiplo di 64-KB.</span><span class="sxs-lookup"><span data-stu-id="7db4d-217">On Xbox 360 it is also important that the stack size be a multiple of 64-KB.</span></span>

<span data-ttu-id="7db4d-218">Se si usa la funzione [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) per creare thread, il runtime di C/C++ (CRT) non viene inizializzato correttamente in Windows.</span><span class="sxs-lookup"><span data-stu-id="7db4d-218">If you use the [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function to create threads, then the C/C++ runtime (CRT) will not get properly initialized on Windows.</span></span> <span data-ttu-id="7db4d-219">È consigliabile usare invece la funzione CRT [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) .</span><span class="sxs-lookup"><span data-stu-id="7db4d-219">We recommend that you use the CRT [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) function instead.</span></span>

<span data-ttu-id="7db4d-220">Il valore restituito da [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) o [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) è un handle di thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-220">The return value from [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) or [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) is a thread handle.</span></span> <span data-ttu-id="7db4d-221">Questo thread può essere usato per attendere che il thread figlio termini, che è molto più semplice e molto più efficiente rispetto alla rotazione in un ciclo che controlla lo stato del thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-221">This thread can be used to wait for the child thread to terminate, which is much simpler and much more efficient than spinning in a loop checking the thread status.</span></span> <span data-ttu-id="7db4d-222">Per attendere la terminazione del thread, è sufficiente chiamare [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) con l'handle del thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-222">To wait for the thread to terminate, simply call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) with the thread handle.</span></span>

<span data-ttu-id="7db4d-223">Le risorse per il thread non verranno liberate fino a quando il thread non viene terminato e l'handle del thread non è stato chiuso.</span><span class="sxs-lookup"><span data-stu-id="7db4d-223">The resources for the thread will not be freed until the thread has terminated and the thread handle has been closed.</span></span> <span data-ttu-id="7db4d-224">Pertanto, è importante chiudere l'handle del thread con [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) al termine dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-224">Therefore, it is important to close the thread handle with [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) when you are finished with it.</span></span> <span data-ttu-id="7db4d-225">Se si è in attesa dell'interruzione del thread con [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), assicurarsi di non chiudere l'handle fino al completamento dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="7db4d-225">If you will be waiting for the thread to terminate with [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), be sure to not close the handle until after the wait has completed.</span></span>

<span data-ttu-id="7db4d-226">In Xbox 360, è necessario assegnare in modo esplicito i thread software a un particolare thread hardware usando **XSetThreadProcessor**.</span><span class="sxs-lookup"><span data-stu-id="7db4d-226">On Xbox 360, you must explicitly assign software threads to a particular hardware thread by using **XSetThreadProcessor**.</span></span> <span data-ttu-id="7db4d-227">In caso contrario, tutti i thread figlio resteranno nello stesso thread hardware del padre.</span><span class="sxs-lookup"><span data-stu-id="7db4d-227">Otherwise, all child threads will stay on the same hardware thread as the parent.</span></span> <span data-ttu-id="7db4d-228">In Windows è possibile usare [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) per suggerire fortemente al sistema operativo i thread di hardware in cui deve essere eseguito il thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-228">On Windows, you can use [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) to strongly suggest to the operating system which hardware threads your thread should run on.</span></span> <span data-ttu-id="7db4d-229">Questa tecnica dovrebbe in genere essere evitata in Windows, poiché non si conoscono gli altri processi che potrebbero essere in esecuzione nel sistema.</span><span class="sxs-lookup"><span data-stu-id="7db4d-229">This technique should generally be avoided on Windows since you don't know what other processes might be running on the system.</span></span> <span data-ttu-id="7db4d-230">È in genere preferibile consentire all'utilità di pianificazione di Windows di assegnare i thread ai thread hardware inattivi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-230">It is typically better to let the Windows scheduler assign your threads to idle hardware threads.</span></span>

<span data-ttu-id="7db4d-231">La creazione di thread è un'operazione costosa.</span><span class="sxs-lookup"><span data-stu-id="7db4d-231">Creating threads is an expensive operation.</span></span> <span data-ttu-id="7db4d-232">I thread devono essere creati ed eliminati raramente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-232">Threads should be created and destroyed rarely.</span></span> <span data-ttu-id="7db4d-233">Se si desidera creare ed eliminare spesso i thread, utilizzare un pool di thread in attesa di lavoro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-233">If you find yourself wanting to create and destroy threads frequently, use a pool of threads that wait around for work instead.</span></span>

## <a name="synchronizing-threads"></a><span data-ttu-id="7db4d-234">Sincronizzazione di thread</span><span class="sxs-lookup"><span data-stu-id="7db4d-234">Synchronizing Threads</span></span>

<span data-ttu-id="7db4d-235">Per il corretto funzionamento di più thread, è necessario essere in grado di sincronizzare i thread, passare i messaggi e richiedere l'accesso esclusivo alle risorse.</span><span class="sxs-lookup"><span data-stu-id="7db4d-235">For multiple threads to work together, you must be able to synchronize threads, pass messages, and request exclusive access to resources.</span></span> <span data-ttu-id="7db4d-236">Windows e Xbox 360 sono dotati di un set completo di primitive di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-236">Windows and Xbox 360 come with a rich set of synchronization primitives.</span></span> <span data-ttu-id="7db4d-237">Per informazioni dettagliate sulle primitive di sincronizzazione, vedere la documentazione della piattaforma.</span><span class="sxs-lookup"><span data-stu-id="7db4d-237">For full details on these synchronization primitives, see the platform documentation.</span></span>

### <a name="exclusive-access"></a><span data-ttu-id="7db4d-238">Accesso esclusivo</span><span class="sxs-lookup"><span data-stu-id="7db4d-238">Exclusive Access</span></span>

<span data-ttu-id="7db4d-239">Ottenere l'accesso esclusivo a una risorsa, una struttura dei dati o un percorso del codice è una necessità comune.</span><span class="sxs-lookup"><span data-stu-id="7db4d-239">Gaining exclusive access to a resource, data structure, or code path is a common need.</span></span> <span data-ttu-id="7db4d-240">Un'opzione per ottenere l'accesso esclusivo è un mutex, il cui utilizzo tipico è illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="7db4d-240">One option for gaining exclusive access is a mutex, whose typical usage is shown here.</span></span>


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



<span data-ttu-id="7db4d-241">Le sezioni critiche hanno una semantica simile a mutex, ma possono essere usate per la sincronizzazione solo all'interno di un processo, non tra i processi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-241">Critical sections have similar semantics to mutexes, but they can be used to synchronize only within a process, not between processes.</span></span> <span data-ttu-id="7db4d-242">Il vantaggio principale è che vengono eseguite approssimativamente venti volte più velocemente di mutex.</span><span class="sxs-lookup"><span data-stu-id="7db4d-242">Their main advantage is that they execute roughly twenty times faster than mutexes.</span></span>

### <a name="events"></a><span data-ttu-id="7db4d-243">Eventi</span><span class="sxs-lookup"><span data-stu-id="7db4d-243">Events</span></span>

<span data-ttu-id="7db4d-244">Se due thread, ad esempio un thread di aggiornamento e un thread di rendering, stanno utilizzando una coppia di buffer di descrizione di rendering, è necessario un modo per indicare quando vengono eseguiti con il buffer specifico.</span><span class="sxs-lookup"><span data-stu-id="7db4d-244">If two threads—perhaps an update thread and a render thread—are taking turns using a pair of render description buffers, they need a way to indicate when they are done with their particular buffer.</span></span> <span data-ttu-id="7db4d-245">Questa operazione può essere eseguita associando un evento (allocato con [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) a ogni buffer.</span><span class="sxs-lookup"><span data-stu-id="7db4d-245">This can be done by associating an event (allocated with [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) with each buffer.</span></span> <span data-ttu-id="7db4d-246">Quando un thread viene eseguito con un buffer, può usare [**Seevent**](/windows/win32/api/synchapi/nf-synchapi-setevent) per segnalare questo e può quindi chiamare [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) sull'evento dell'altro buffer.</span><span class="sxs-lookup"><span data-stu-id="7db4d-246">When a thread is done with a buffer, it can use [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) to signal this, and can then call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) on the other buffer's event.</span></span> <span data-ttu-id="7db4d-247">Questa tecnica consente di estrapolare facilmente il buffering delle risorse.</span><span class="sxs-lookup"><span data-stu-id="7db4d-247">This technique extrapolates easily to triple buffering of resources.</span></span>

### <a name="semaphores"></a><span data-ttu-id="7db4d-248">Semafori</span><span class="sxs-lookup"><span data-stu-id="7db4d-248">Semaphores</span></span>

<span data-ttu-id="7db4d-249">Un semaforo viene usato per controllare il numero di thread che possono essere in esecuzione e viene comunemente usato per implementare le code di lavoro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-249">A semaphore is used to control how many threads can be running and is commonly used to implement work queues.</span></span> <span data-ttu-id="7db4d-250">Un thread aggiunge il lavoro a una coda e USA [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) ogni volta che aggiunge un nuovo elemento alla coda.</span><span class="sxs-lookup"><span data-stu-id="7db4d-250">One thread adds work to a queue and uses [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) whenever it adds a new item to the queue.</span></span> <span data-ttu-id="7db4d-251">Questo consente di rilasciare un thread di lavoro dal pool di thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="7db4d-251">This allows one worker thread to be released from the pool of waiting threads.</span></span> <span data-ttu-id="7db4d-252">I thread di lavoro chiamano semplicemente [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)e, quando viene restituito, è presente un elemento di lavoro nella coda.</span><span class="sxs-lookup"><span data-stu-id="7db4d-252">The worker threads just call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and when it returns they know there is a work item in the queue for them.</span></span> <span data-ttu-id="7db4d-253">Inoltre, è necessario utilizzare una sezione critica o un'altra tecnica di sincronizzazione per garantire un accesso sicuro alla coda di lavoro condivisa.</span><span class="sxs-lookup"><span data-stu-id="7db4d-253">In addition, a critical section or other synchronization technique must be used in order to guarantee safe access to the shared work queue.</span></span>

### <a name="avoid-suspendthread"></a><span data-ttu-id="7db4d-254">Evitare SuspendThread</span><span class="sxs-lookup"><span data-stu-id="7db4d-254">Avoid SuspendThread</span></span>

<span data-ttu-id="7db4d-255">In alcuni casi, quando si vuole che un thread interrompa il comportamento, si tenta di usare [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) anziché le primitive di sincronizzazione corrette.</span><span class="sxs-lookup"><span data-stu-id="7db4d-255">Sometimes when you want a thread to stop what it is doing, it is tempting to use [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) instead of the correct synchronization primitives.</span></span> <span data-ttu-id="7db4d-256">Si tratta sempre di una pessima idea e può causare facilmente deadlock e altri problemi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-256">This is always a bad idea and can easily lead to deadlocks and other problems.</span></span> <span data-ttu-id="7db4d-257">**SuspendThread** interagisce anche male con il debugger di Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="7db4d-257">**SuspendThread** also interacts badly with the Visual Studio debugger.</span></span> <span data-ttu-id="7db4d-258">Evitare **SuspendThread**.</span><span class="sxs-lookup"><span data-stu-id="7db4d-258">Avoid **SuspendThread**.</span></span> <span data-ttu-id="7db4d-259">In alternativa, usare [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="7db4d-259">Use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) instead.</span></span>

### <a name="waitforsingleobject-and-waitformultipleobjects"></a><span data-ttu-id="7db4d-260">WaitForSingleObject e WaitForMultipleObjects</span><span class="sxs-lookup"><span data-stu-id="7db4d-260">WaitForSingleObject and WaitForMultipleObjects</span></span>

<span data-ttu-id="7db4d-261">La funzione [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) è la funzione di sincronizzazione utilizzata più di frequente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-261">The function [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) is the most commonly used synchronization function.</span></span> <span data-ttu-id="7db4d-262">Tuttavia, a volte si vuole che un thread attenda che vengano soddisfatte contemporaneamente diverse condizioni o fino a quando non viene soddisfatta una delle condizioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-262">However, sometimes you want a thread to wait until several conditions are simultaneously satisfied, or until one of a set of conditions are satisfied.</span></span> <span data-ttu-id="7db4d-263">In questo caso, è consigliabile usare [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="7db4d-263">In this case, you should use [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

### <a name="interlocked-functions-and-lockless-programming"></a><span data-ttu-id="7db4d-264">Funzioni Interlocked e programmazione con blocco</span><span class="sxs-lookup"><span data-stu-id="7db4d-264">Interlocked Functions and Lockless Programming</span></span>

<span data-ttu-id="7db4d-265">Per eseguire semplici operazioni thread-safe senza utilizzare blocchi è disponibile una famiglia di funzioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-265">There is a family of functions for performing simple thread-safe operations without using locks.</span></span> <span data-ttu-id="7db4d-266">Si tratta della famiglia di funzioni Interlocked, ad esempio [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span><span class="sxs-lookup"><span data-stu-id="7db4d-266">These are the Interlocked family of functions, such as [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span></span> <span data-ttu-id="7db4d-267">Queste funzioni, oltre ad altre tecniche che usano un'attenta impostazione dei flag, sono note come programmazione non bloccata.</span><span class="sxs-lookup"><span data-stu-id="7db4d-267">These functions, plus other techniques using careful setting of flags, are together known as lockless programming.</span></span> <span data-ttu-id="7db4d-268">La programmazione senza blocchi può essere estremamente difficile da eseguire correttamente ed è sostanzialmente più difficile in Xbox 360 che in Windows.</span><span class="sxs-lookup"><span data-stu-id="7db4d-268">Lockless programming can be extremely tricky to do correctly, and is substantially more difficult on Xbox 360 than on Windows.</span></span>

<span data-ttu-id="7db4d-269">Per ulteriori informazioni sulla programmazione senza blocchi, vedere [considerazioni sulla programmazione senza blocco per Xbox 360 e Microsoft Windows](./lockless-programming.md).</span><span class="sxs-lookup"><span data-stu-id="7db4d-269">For more information about programming without locks, see [Lockless Programming Considerations for Xbox 360 and Microsoft Windows](./lockless-programming.md).</span></span>

### <a name="minimizing-synchronization"></a><span data-ttu-id="7db4d-270">Riduzione della sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="7db4d-270">Minimizing Synchronization</span></span>

<span data-ttu-id="7db4d-271">Alcuni metodi di sincronizzazione sono più veloci di altri.</span><span class="sxs-lookup"><span data-stu-id="7db4d-271">Some synchronization methods are faster than others.</span></span> <span data-ttu-id="7db4d-272">Tuttavia, anziché ottimizzare il codice scegliendo le tecniche di sincronizzazione più veloci possibili, in genere è preferibile eseguire una sincronizzazione meno frequente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-272">However, rather than optimizing your code by choosing the fastest synchronization techniques possible, it is usually better to synchronize less often.</span></span> <span data-ttu-id="7db4d-273">Questa operazione è più rapida della sincronizzazione troppo frequente e rende più semplice il debug del codice.</span><span class="sxs-lookup"><span data-stu-id="7db4d-273">This is faster than synchronizing too frequently, and it makes for simpler code that is easier to debug.</span></span>

<span data-ttu-id="7db4d-274">Per il corretto funzionamento di alcune operazioni, ad esempio l'allocazione della memoria, potrebbe essere necessario utilizzare primitive di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-274">Some operations, such as memory allocation, may have to use synchronization primitives in order to work correctly.</span></span> <span data-ttu-id="7db4d-275">Pertanto, l'esecuzione di allocazioni frequenti dall'heap condiviso predefinito comporterà una sincronizzazione frequente, che può comportare un certo dispendio di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-275">Therefore, doing frequent allocations from the default shared heap will result in frequent synchronization, which will waste some performance.</span></span> <span data-ttu-id="7db4d-276">Evitare le allocazioni frequenti o l'utilizzo di heap per thread ( \_ \_ se si usa l'heap no Serialize se si usa HeapCreate) può evitare questa sincronizzazione nascosta.</span><span class="sxs-lookup"><span data-stu-id="7db4d-276">Avoiding frequent allocations or using per-thread heaps (using HEAP\_NO\_SERIALIZE if you use HeapCreate) can avoid this hidden synchronization.</span></span>

<span data-ttu-id="7db4d-277">Un'altra causa della sincronizzazione nascosta è D3DCREATE \_ MULTIthreading, in modo che D3D in Windows usi la sincronizzazione in molte operazioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-277">Another cause of hidden synchronization is D3DCREATE\_MULTITHREADED, which causes D3D on Windows to use synchronization on many operations.</span></span> <span data-ttu-id="7db4d-278">(Il flag viene ignorato in Xbox 360).</span><span class="sxs-lookup"><span data-stu-id="7db4d-278">(The flag is ignored on Xbox 360.)</span></span>

<span data-ttu-id="7db4d-279">I dati per thread, noti anche come archiviazione locale di thread, possono essere un modo importante per evitare la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-279">Per-thread data, also known as thread local storage, can be an important way of avoiding synchronization.</span></span> <span data-ttu-id="7db4d-280">Visual C++ consente di dichiarare le variabili globali come per thread con la sintassi **\_ \_ declspec (thread)** .</span><span class="sxs-lookup"><span data-stu-id="7db4d-280">Visual C++ allows you to declare global variables as being per-thread with the **\_\_declspec(thread)** syntax.</span></span>


```C++
__declspec( thread ) int tls_i = 1;
```



<span data-ttu-id="7db4d-281">In questo modo ogni thread del processo elabora una propria copia di TLS \_ i, a cui è possibile fare riferimento in modo sicuro ed efficiente senza richiedere la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-281">This gives each thread in the process its own copy of tls\_i, which can be referenced safely and efficiently without requiring synchronization.</span></span>

<span data-ttu-id="7db4d-282">La tecnica **\_ \_ declspec (thread)** non funziona con le DLL caricate dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-282">The **\_\_declspec(thread)** technique does not work with dynamically loaded DLLs.</span></span> <span data-ttu-id="7db4d-283">Se si usano le DLL caricate in modo dinamico, sarà necessario usare la famiglia di funzioni TLSAlloc per implementare l'archiviazione thread-local.</span><span class="sxs-lookup"><span data-stu-id="7db4d-283">If you use dynamically loaded DLLs, you will need to use the TLSAlloc family of functions to implement thread local storage.</span></span>

## <a name="destroying-threads"></a><span data-ttu-id="7db4d-284">Distruzione di thread</span><span class="sxs-lookup"><span data-stu-id="7db4d-284">Destroying Threads</span></span>

<span data-ttu-id="7db4d-285">L'unico modo sicuro per eliminare un thread consiste nel far uscire il thread, restituendo dalla funzione thread principale o facendo in modo che il thread chiami [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) o [**\_ endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span><span class="sxs-lookup"><span data-stu-id="7db4d-285">The only safe way to destroy a thread is to have the thread itself exit, either by returning from the main thread function or by having the thread call [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) or [**\_endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span></span> <span data-ttu-id="7db4d-286">Se viene creato un thread con [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), è necessario usare **\_ endthreadex** o restituire dalla funzione thread principale, poiché l'uso di **ExitThread** non consentirà di liberare correttamente le risorse CRT.</span><span class="sxs-lookup"><span data-stu-id="7db4d-286">If a thread is created with [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), then it should use **\_endthreadex** or return from the main thread function, since using **ExitThread** won't properly free CRT resources.</span></span> <span data-ttu-id="7db4d-287">Non chiamare mai la funzione [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) , perché il thread non verrà pulito correttamente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-287">Never call the [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) function, because the thread will not be properly cleaned up.</span></span> <span data-ttu-id="7db4d-288">I thread devono sempre eseguire il commit del suicido, non dovrebbero mai essere uccisi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-288">Threads should always commit suicide—they should never be murdered.</span></span>

## <a name="openmp"></a><span data-ttu-id="7db4d-289">OpenMP</span><span class="sxs-lookup"><span data-stu-id="7db4d-289">OpenMP</span></span>

<span data-ttu-id="7db4d-290">OpenMP è un'estensione del linguaggio per l'aggiunta del multithreading al programma usando i pragma per guidare il compilatore nei cicli parallelizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-290">OpenMP is a language extension for adding multithreading to your program by using pragmas to guide the compiler in parallelizing loops.</span></span> <span data-ttu-id="7db4d-291">OpenMP è supportato da Visual C++ 2005 in Windows e Xbox 360 e può essere usato insieme alla gestione manuale dei thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-291">OpenMP is supported by Visual C++ 2005 on Windows and Xbox 360 and can be used in conjunction with manual thread management.</span></span> <span data-ttu-id="7db4d-292">OpenMP può essere un modo pratico per multithread le parti del codice, ma è improbabile che sia la soluzione ideale, soprattutto per i giochi.</span><span class="sxs-lookup"><span data-stu-id="7db4d-292">OpenMP can be a convenient way to multithread parts of your code, but is unlikely to be the ideal solution, especially for games.</span></span> <span data-ttu-id="7db4d-293">OpenMP può essere più applicabile a attività di produzione a esecuzione prolungata, ad esempio l'elaborazione dell'arte e altre risorse.</span><span class="sxs-lookup"><span data-stu-id="7db4d-293">OpenMP may be more applicable to longer-running production tasks such as processing art and other resources.</span></span> <span data-ttu-id="7db4d-294">Per ulteriori informazioni, vedere la documentazione di Visual C++ o accedere al [sito Web](https://www.openmp.org/)OpenMP.</span><span class="sxs-lookup"><span data-stu-id="7db4d-294">For more information, see the Visual C++ documentation or go to the OpenMP [website](https://www.openmp.org/).</span></span>

## <a name="profiling"></a><span data-ttu-id="7db4d-295">Profilatura</span><span class="sxs-lookup"><span data-stu-id="7db4d-295">Profiling</span></span>

<span data-ttu-id="7db4d-296">La profilatura multithreading è importante.</span><span class="sxs-lookup"><span data-stu-id="7db4d-296">Multithreaded profiling is important.</span></span> <span data-ttu-id="7db4d-297">È facile finire con blocchi lunghi in cui i thread sono in attesa l'uno sull'altro.</span><span class="sxs-lookup"><span data-stu-id="7db4d-297">It is easy to end up with long stalls where threads are waiting on each other.</span></span> <span data-ttu-id="7db4d-298">Questi stalli possono essere difficili da trovare e diagnosticare.</span><span class="sxs-lookup"><span data-stu-id="7db4d-298">These stalls can be difficult to find and diagnose.</span></span> <span data-ttu-id="7db4d-299">Per facilitarne l'identificazione, è consigliabile aggiungere strumentazione alle chiamate di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-299">To help identify them, consider adding instrumentation to your synchronization calls.</span></span> <span data-ttu-id="7db4d-300">Un profiler di campionamento consente inoltre di identificare questi problemi perché può registrare le informazioni di temporizzazione senza modificarle sostanzialmente.</span><span class="sxs-lookup"><span data-stu-id="7db4d-300">A sampling profiler can also help identify these problems because it can record timing information without substantially altering it.</span></span>

## <a name="timing"></a><span data-ttu-id="7db4d-301">Intervallo</span><span class="sxs-lookup"><span data-stu-id="7db4d-301">Timing</span></span>

<span data-ttu-id="7db4d-302">L'istruzione RDTSC è un modo per ottenere informazioni accurate sull'intervallo in Windows.</span><span class="sxs-lookup"><span data-stu-id="7db4d-302">The rdtsc instruction is one way to get accurate timing information on Windows.</span></span> <span data-ttu-id="7db4d-303">Sfortunatamente, RDTSC presenta diversi problemi che lo rendono una scelta scadente per il titolo di spedizione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-303">Unfortunately, rdtsc has multiple problems that make it a poor choice for your shipping title.</span></span> <span data-ttu-id="7db4d-304">I contatori RDTSC non sono necessariamente sincronizzati tra le CPU, pertanto quando il thread si sposta tra i thread hardware è possibile che si verifichino differenze positive o negative di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="7db4d-304">The rdtsc counters are not necessarily synchronized between CPUs, so when your thread moves between hardware threads you may get large positive or negative differences.</span></span> <span data-ttu-id="7db4d-305">A seconda delle impostazioni di risparmio energia, la frequenza con cui incrementa il contatore RDTSC può cambiare anche durante l'esecuzione del gioco.</span><span class="sxs-lookup"><span data-stu-id="7db4d-305">Depending on power management settings, the frequency at which the rdtsc counter increments may also change as your game runs.</span></span> <span data-ttu-id="7db4d-306">Per evitare queste difficoltà, è preferibile preferire [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) e [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) per la tempistica a precisione elevata nel gioco di spedizione.</span><span class="sxs-lookup"><span data-stu-id="7db4d-306">To avoid these difficulties, you should prefer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) for high-precision timing in your shipping game.</span></span> <span data-ttu-id="7db4d-307">Per ulteriori informazioni sulla temporizzazione, vedere la pagina relativa alla [temporizzazione dei giochi e ai processori multicore](./game-timing-and-multicore-processors.md).</span><span class="sxs-lookup"><span data-stu-id="7db4d-307">For more information about timing, see [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md).</span></span>

## <a name="debugging"></a><span data-ttu-id="7db4d-308">Debug</span><span class="sxs-lookup"><span data-stu-id="7db4d-308">Debugging</span></span>

<span data-ttu-id="7db4d-309">Visual Studio supporta completamente il debug multithread per Windows e Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="7db4d-309">Visual Studio fully supports multithreaded debugging for Windows and Xbox 360.</span></span> <span data-ttu-id="7db4d-310">La finestra thread di Visual Studio consente di passare da un thread all'altro per visualizzare gli stack di chiamate e le variabili locali.</span><span class="sxs-lookup"><span data-stu-id="7db4d-310">The Visual Studio threads window lets you switch between threads in order to see the different call stacks and local variables.</span></span> <span data-ttu-id="7db4d-311">La finestra thread consente inoltre di bloccare e sbloccare thread specifici.</span><span class="sxs-lookup"><span data-stu-id="7db4d-311">The threads window also lets you freeze and thaw particular threads.</span></span>

<span data-ttu-id="7db4d-312">In Xbox 360 è possibile usare la meta-variabile **\@ hwthread** nella finestra espressioni di controllo per visualizzare il thread hardware in cui è in esecuzione il thread software attualmente selezionato.</span><span class="sxs-lookup"><span data-stu-id="7db4d-312">On Xbox 360, you can use the **\@hwthread** meta-variable in the watch window to show the hardware thread on which the currently selected software thread is running.</span></span>

<span data-ttu-id="7db4d-313">La finestra thread è più semplice da usare se i thread vengono denominati in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="7db4d-313">The threads window is easier to use if you name your threads meaningfully.</span></span> <span data-ttu-id="7db4d-314">Visual Studio e altri debugger Microsoft consentono di assegnare un nome ai thread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-314">Visual Studio and other Microsoft debuggers allow you to name your threads.</span></span> <span data-ttu-id="7db4d-315">Implementare la funzione **Getthreadname** seguente e chiamarla da ogni thread mentre viene avviata.</span><span class="sxs-lookup"><span data-stu-id="7db4d-315">Implement the following **SetThreadName** function and call it from each thread as it starts up.</span></span>


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



<span data-ttu-id="7db4d-316">Il debugger del kernel (KD) e WinDBG supportano anche il debug multithread.</span><span class="sxs-lookup"><span data-stu-id="7db4d-316">The kernel debugger (KD) and WinDBG also support multithreaded debugging.</span></span>

## <a name="testing"></a><span data-ttu-id="7db4d-317">Test</span><span class="sxs-lookup"><span data-stu-id="7db4d-317">Testing</span></span>

<span data-ttu-id="7db4d-318">La programmazione multithreading può risultare complessa e alcuni bug multithread vengono visualizzati solo raramente, rendendoli difficili da trovare e correggere.</span><span class="sxs-lookup"><span data-stu-id="7db4d-318">Multithreaded programming can be tricky, and some multithreaded bugs show up only rarely, making them difficult to find and fix.</span></span> <span data-ttu-id="7db4d-319">Uno dei modi migliori per scaricarli è eseguire test su un'ampia gamma di computer, in particolare su quelli con quattro o più processori.</span><span class="sxs-lookup"><span data-stu-id="7db4d-319">One of the best ways to flush them out is to test on a wide range of computers, particularly those with four or more processors.</span></span> <span data-ttu-id="7db4d-320">Il codice multithreading che funziona perfettamente in un computer a thread singolo potrebbe non riuscire immediatamente in un computer a quattro processori.</span><span class="sxs-lookup"><span data-stu-id="7db4d-320">Multithreaded code that works perfectly on a single-threaded computer may fail instantly on a four-processor computer.</span></span> <span data-ttu-id="7db4d-321">Le caratteristiche di prestazioni e tempistiche delle CPU AMD e Intel possono variare in modo sostanziale, quindi assicurarsi di eseguire test sui computer multiprocessore basati sulle CPU di entrambi i fornitori.</span><span class="sxs-lookup"><span data-stu-id="7db4d-321">The performance and timing characteristics of AMD and Intel CPUs can vary substantially, so be sure to test on multiprocessor computers based on CPUs from both vendors.</span></span>

## <a name="windows-vista-and-windows-7-improvements"></a><span data-ttu-id="7db4d-322">Miglioramenti di Windows Vista e Windows 7</span><span class="sxs-lookup"><span data-stu-id="7db4d-322">Windows Vista and Windows 7 Improvements</span></span>

<span data-ttu-id="7db4d-323">Per i giochi destinati alle versioni più recenti di Windows, sono disponibili numerose API che consentono di semplificare la creazione di applicazioni multithreading scalabili.</span><span class="sxs-lookup"><span data-stu-id="7db4d-323">For games targeting the newer versions of Windows, there are a number of APIs that can simplify the creation of scalable multithreaded applications.</span></span> <span data-ttu-id="7db4d-324">Questa situazione è particolarmente valida con la nuova API ThreadPool e con alcune primitive syncrhonziation aggiuntive (variabili di condizione, blocco Read/Writer Slim e inizializzazione unica).</span><span class="sxs-lookup"><span data-stu-id="7db4d-324">This is particularly true with the new ThreadPool API and some additional syncrhonziation primitives (condition variables, the slim read/writer lock, and one-time initialization).</span></span> <span data-ttu-id="7db4d-325">Per una panoramica di queste tecnologie, vedere gli articoli di MSDN Magazine seguenti:</span><span class="sxs-lookup"><span data-stu-id="7db4d-325">You can find an overview of these technologies in the following MSDN Magazine articles:</span></span>

-   [<span data-ttu-id="7db4d-326">Migliorare la scalabilità con le nuove API del pool di thread</span><span class="sxs-lookup"><span data-stu-id="7db4d-326">Improve Scalability With New Thread Pool APIs</span></span>](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [<span data-ttu-id="7db4d-327">Primitive di sincronizzazione nuove in Windows Vista</span><span class="sxs-lookup"><span data-stu-id="7db4d-327">Synchronization Primitives New To Windows Vista</span></span>](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

<span data-ttu-id="7db4d-328">Le applicazioni che usano le [funzionalità di Direct3D 11](../direct3d11/direct3d-11-features.md) in questi sistemi operativi possono anche sfruttare la nuova progettazione per la creazione di oggetti simultanei e gli elenchi di comandi di contesto posticipati per una migliore scalabilità per il rendering multithreading.</span><span class="sxs-lookup"><span data-stu-id="7db4d-328">Applications using [Direct3D 11 Features](../direct3d11/direct3d-11-features.md) on these operating systems can also take advantage of the new design for concurrent object creation and deferred context command lists for better scalability for multithreaded rendering.</span></span>

## <a name="summary"></a><span data-ttu-id="7db4d-329">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="7db4d-329">Summary</span></span>

<span data-ttu-id="7db4d-330">Con un'attenta progettazione che riduce al minimo le interazioni tra i thread, è possibile ottenere miglioramenti sostanziali in termini di prestazioni dalla programmazione multithreading senza aggiungere eccessiva complessità al codice.</span><span class="sxs-lookup"><span data-stu-id="7db4d-330">With careful design that minimizes the interactions between threads, you can get substantial performance gains from multithreaded programming without adding excessive complexity to your code.</span></span> <span data-ttu-id="7db4d-331">Questo conferirà al codice del gioco la prossima ondata di miglioramenti del processore e offrirà esperienze di gioco sempre più accattivanti.</span><span class="sxs-lookup"><span data-stu-id="7db4d-331">This will let your game code ride the next wave of processor improvements and deliver ever more compelling gaming experiences.</span></span>

## <a name="references"></a><span data-ttu-id="7db4d-332">Riferimenti</span><span class="sxs-lookup"><span data-stu-id="7db4d-332">References</span></span>

-   <span data-ttu-id="7db4d-333">Jim Beveridge & Robert Weiner, *applicazioni multithread in Win32*, Addison-Wesley, 1997</span><span class="sxs-lookup"><span data-stu-id="7db4d-333">Jim Beveridge & Robert Weiner, *Multithreading Applications in Win32*, Addison-Wesley, 1997</span></span>
-   <span data-ttu-id="7db4d-334">Chuck Walbourn, [Time Game e processori multicore](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span><span class="sxs-lookup"><span data-stu-id="7db4d-334">Chuck Walbourn, [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span></span>
-   <span data-ttu-id="7db4d-335">MSDN Library: [ **GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span><span class="sxs-lookup"><span data-stu-id="7db4d-335">MSDN Library: [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span></span>
-   [<span data-ttu-id="7db4d-336">OpenMP</span><span class="sxs-lookup"><span data-stu-id="7db4d-336">OpenMP</span></span>](https://www.openmp.org/)

 

 