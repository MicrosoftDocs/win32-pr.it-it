---
description: Programmazione di DirectX con COM.
title: Programmazione di DirectX con COM
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/26/2021
ms.locfileid: "103968789"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="ba2a9-103">Programmazione di DirectX con COM</span><span class="sxs-lookup"><span data-stu-id="ba2a9-103">Programming DirectX with COM</span></span>

<span data-ttu-id="ba2a9-104">Microsoft Component Object Model (COM) è un modello di programmazione orientato a oggetti usato da diverse tecnologie, inclusa la maggior parte della superficie dell'API DirectX.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="ba2a9-105">Per questo motivo, quando si programma DirectX è necessario che l'utente, come sviluppatore di DirectX, usi inevitabilmente COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="ba2a9-106">L'argomento utilizzo di [componenti com con c++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) illustra come utilizzare le API DirectX (e qualsiasi API com) con [c++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="ba2a9-107">Questa è la tecnologia più comoda e consigliata da usare.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="ba2a9-108">In alternativa, è possibile usare COM non elaborato e questo è il significato di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="ba2a9-109">Sarà necessaria una conoscenza di base dei principi e delle tecniche di programmazione necessari per l'utilizzo delle API COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="ba2a9-110">Sebbene COM abbia la reputazione di essere difficile e complesso, la programmazione COM richiesta dalla maggior parte delle applicazioni DirectX è molto semplice.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="ba2a9-111">In parte, questo è dovuto al fatto che verranno utilizzati gli oggetti COM forniti da DirectX.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="ba2a9-112">Non è necessario creare oggetti COM, in genere in cui si verifica la complessità.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="ba2a9-113">Panoramica sul componente COM</span><span class="sxs-lookup"><span data-stu-id="ba2a9-113">COM component overview</span></span>

<span data-ttu-id="ba2a9-114">Un oggetto COM è essenzialmente un componente incapsulato di funzionalità che può essere utilizzato dalle applicazioni per eseguire una o più attività.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="ba2a9-115">Per la distribuzione, uno o più componenti COM vengono assemblati in un file binario denominato server COM; più spesso che non come una DLL.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="ba2a9-116">Una DLL tradizionale Esporta funzioni gratuite.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="ba2a9-117">Un server COM può eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-117">A COM server can do the same.</span></span> <span data-ttu-id="ba2a9-118">Tuttavia, i componenti COM all'interno del server COM espongono interfacce COM e metodi membro che appartengono a tali interfacce.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="ba2a9-119">L'applicazione crea istanze di componenti COM, recupera le interfacce da esse e chiama i metodi su tali interfacce per trarre vantaggio dalle funzionalità implementate nei componenti COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="ba2a9-120">In pratica, questo comportamento è simile alla chiamata di metodi su un normale oggetto C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="ba2a9-121">Esistono tuttavia alcune differenze.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-121">But there are some differences.</span></span>

- <span data-ttu-id="ba2a9-122">Un oggetto COM impone un incapsulamento più restrittivo rispetto a quello di un oggetto C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="ba2a9-123">Non è possibile creare semplicemente l'oggetto e quindi chiamare un metodo pubblico.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="ba2a9-124">Al contrario, i metodi pubblici di un componente COM vengono raggruppati in una o più interfacce COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="ba2a9-125">Per chiamare un metodo, è necessario creare l'oggetto e recuperare dall'oggetto l'interfaccia che implementa il metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="ba2a9-126">Un'interfaccia implementa in genere un set correlato di metodi che forniscono l'accesso a una particolare funzionalità dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="ba2a9-127">Ad esempio, l'interfaccia [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) rappresenta una scheda grafica virtuale e contiene metodi che consentono di creare risorse, ad esempio, e molte altre attività relative agli adapter.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="ba2a9-128">Un oggetto COM non viene creato allo stesso modo di un oggetto C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="ba2a9-129">Esistono diversi modi per creare un oggetto COM, ma tutti coinvolgono tecniche specifiche di COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="ba2a9-130">L'API DirectX include un'ampia gamma di funzioni di supporto e metodi che semplificano la creazione della maggior parte degli oggetti DirectX COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="ba2a9-131">È necessario utilizzare tecniche specifiche di COM per controllare la durata di un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="ba2a9-132">Non è necessario caricare in modo esplicito il server COM (in genere una DLL).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="ba2a9-133">Non è inoltre possibile collegarsi a una libreria statica per poter utilizzare un componente COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="ba2a9-134">Ogni componente COM dispone di un identificatore registrato univoco (un identificatore univoco globale o GUID) usato dall'applicazione per identificare l'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="ba2a9-135">L'applicazione identifica il componente e il runtime COM carica automaticamente la DLL del server COM corretta.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="ba2a9-136">COM è una specifica binaria.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-136">COM is a binary specification.</span></span> <span data-ttu-id="ba2a9-137">Gli oggetti COM possono essere scritti e accessibili da un'ampia gamma di linguaggi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="ba2a9-138">Non è necessario conoscere il codice sorgente dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="ba2a9-139">Ad esempio, Visual Basic applicazioni utilizzano periodicamente oggetti COM scritti in C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="ba2a9-140">Componente, oggetto e interfaccia</span><span class="sxs-lookup"><span data-stu-id="ba2a9-140">Component, object, and interface</span></span>

<span data-ttu-id="ba2a9-141">È importante comprendere la differenza tra i componenti, gli oggetti e le interfacce.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="ba2a9-142">Nell'utilizzo occasionale, è possibile che si verifichi un componente o un oggetto a cui fa riferimento il nome dell'interfaccia principale.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="ba2a9-143">Ma i termini non sono intercambiabili.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="ba2a9-144">Un componente può implementare un numero qualsiasi di interfacce. e un oggetto è un'istanza di un componente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="ba2a9-145">Ad esempio, mentre tutti i componenti devono implementare l' [**interfaccia IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), in genere implementano almeno un'interfaccia aggiuntiva e potrebbero implementare molti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="ba2a9-146">Per usare un particolare metodo di interfaccia, è necessario non solo creare un'istanza di un oggetto, ma è necessario ottenere anche l'interfaccia corretta.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="ba2a9-147">Inoltre, più di un componente può implementare la stessa interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="ba2a9-148">Un'interfaccia è un gruppo di metodi che eseguono un set di operazioni correlate logicamente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="ba2a9-149">La definizione dell'interfaccia specifica solo la sintassi dei metodi e le relative funzionalità generali.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="ba2a9-150">Qualsiasi componente COM che deve supportare un determinato set di operazioni può eseguire questa operazione implementando un'interfaccia appropriata.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="ba2a9-151">Alcune interfacce sono altamente specializzate e vengono implementate solo da un singolo componente; altre sono utili in varie circostanze e sono implementate da molti componenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="ba2a9-152">Se un componente implementa un'interfaccia, deve supportare tutti i metodi nella definizione dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="ba2a9-153">In altre parole, è necessario essere in grado di chiamare qualsiasi metodo e avere la certezza che esista.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="ba2a9-154">Tuttavia, i dettagli della modalità di implementazione di un particolare metodo possono variare da un componente a un altro.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="ba2a9-155">Ad esempio, diversi componenti possono utilizzare algoritmi diversi per ottenere il risultato finale.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="ba2a9-156">Non è inoltre garantito che un metodo sarà supportato in modo non semplice.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="ba2a9-157">In alcuni casi, un componente implementa un'interfaccia di uso comune, ma deve supportare solo un subset dei metodi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="ba2a9-158">Sarà comunque possibile chiamare correttamente i metodi rimanenti, ma restituiranno un [**HRESULT**](#hresult-values) (ovvero un tipo com standard che rappresenta un codice risultato) che contiene il valore **E_NOTIMPL**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="ba2a9-159">È necessario fare riferimento alla relativa documentazione per vedere come un'interfaccia viene implementata da un particolare componente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="ba2a9-160">Per lo standard COM è necessario che una definizione di interfaccia non venga modificata dopo la pubblicazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="ba2a9-161">L'autore, ad esempio, non può aggiungere un nuovo metodo a un'interfaccia esistente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="ba2a9-162">L'autore deve invece creare una nuova interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-162">The author must instead create a new interface.</span></span> <span data-ttu-id="ba2a9-163">Sebbene non esistano restrizioni sui metodi che devono trovarsi in tale interfaccia, una pratica comune è che l'interfaccia di nuova generazione includa tutti i metodi dell'interfaccia precedente, oltre a tutti i nuovi metodi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="ba2a9-164">Non è insolito che un'interfaccia abbia diverse generazioni.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="ba2a9-165">In genere, tutte le generazioni eseguono essenzialmente la stessa attività complessiva, ma sono diverse nelle specifiche.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="ba2a9-166">Spesso, un componente COM implementa ogni generazione corrente e precedente di una determinata derivazione di un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="ba2a9-167">In questo modo le applicazioni meno recenti possono continuare a utilizzare le interfacce precedenti dell'oggetto, mentre le applicazioni più recenti possono sfruttare le funzionalità delle interfacce più recenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="ba2a9-168">In genere, un gruppo di ridiscendenza di interfacce hanno tutti lo stesso nome, più un numero intero che indica la generazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="ba2a9-169">Ad esempio, se l'interfaccia originale era denominata **IMyInterface** (che implica la generazione 1), le due generazioni successive sarebbero denominate **IMyInterface2** e **IMyInterface3**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="ba2a9-170">Nel caso di interfacce DirectX, le generazioni successive vengono in genere denominate per il numero di versione di DirectX.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="ba2a9-171">GUID</span><span class="sxs-lookup"><span data-stu-id="ba2a9-171">GUIDs</span></span>

<span data-ttu-id="ba2a9-172">I GUID sono una parte essenziale del modello di programmazione COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="ba2a9-173">Per la maggior parte di base, un GUID è una struttura a 128 bit.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="ba2a9-174">Tuttavia, i GUID vengono creati in modo da garantire che due GUID non siano uguali.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="ba2a9-175">COM utilizza i GUID in maniera estensiva per due scopi primari.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="ba2a9-176">Per identificare in modo univoco un particolare componente COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="ba2a9-177">Un GUID assegnato per identificare un componente COM è denominato identificatore di classe (CLSID) e si utilizza un CLSID quando si desidera creare un'istanza del componente COM associato.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="ba2a9-178">Per identificare in modo univoco una particolare interfaccia COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="ba2a9-179">Un GUID assegnato per identificare un'interfaccia COM è denominato IID (Interface Identifier) e si utilizza un IID quando si richiede una particolare interfaccia da un'istanza di un componente (un oggetto).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="ba2a9-180">L'IID di un'interfaccia sarà lo stesso, indipendentemente dal componente che implementa l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="ba2a9-181">Per praticità, la documentazione di DirectX si riferisce in genere a componenti e interfacce in base ai relativi nomi descrittivi (ad esempio, **ID3D12Device**) anziché ai relativi GUID.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="ba2a9-182">Nel contesto della documentazione di DirectX, non c'è ambiguità.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="ba2a9-183">È tecnicamente possibile che un altro autore possa creare un'interfaccia con il nome descrittivo **ID3D12Device** (è necessario avere un IID diverso per essere valido).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="ba2a9-184">Per maggiore chiarezza, tuttavia, non è consigliabile.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="ba2a9-185">Quindi, l'unico modo non ambiguo per fare riferimento a un oggetto o a un'interfaccia particolare consiste nel GUID.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="ba2a9-186">Sebbene un GUID sia una struttura, un GUID viene spesso espresso in un formato stringa equivalente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="ba2a9-187">Il formato generale del formato stringa di un GUID è 32 cifre esadecimali, nel formato 8-4-4-4-12.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="ba2a9-188">Ovvero {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, dove ogni x corrisponde a una cifra esadecimale.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="ba2a9-189">Ad esempio, il formato stringa dell'IID per l'interfaccia **ID3D12Device** è {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="ba2a9-190">Poiché il GUID effettivo è piuttosto goffo da usare e facile da digitare, viene in genere fornito anche un nome equivalente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="ba2a9-191">Nel codice è possibile usare questo nome invece della struttura effettiva quando si chiamano le funzioni, ad esempio quando si passa un argomento per il `riid` parametro a [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="ba2a9-192">La convenzione di denominazione personalizzata prevede l'anteporre IID_ o CLSID_ al nome descrittivo dell'interfaccia o dell'oggetto, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="ba2a9-193">Ad esempio, il nome dell'IID dell'interfaccia **ID3D12Device** viene IID_ID3D12Device.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="ba2a9-194">Le applicazioni DirectX devono essere collegate con ``dxguid.lib`` e ``uuid.lib`` per fornire le definizioni per i diversi GUID dell'interfaccia e della classe.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="ba2a9-195">Visual C++ e altri compilatori supportano l'estensione del linguaggio dell'operatore **__uuidof** , ma il collegamento esplicito di tipo C con queste librerie di collegamenti è supportato e completamente portatile.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="ba2a9-196">Valori HRESULT</span><span class="sxs-lookup"><span data-stu-id="ba2a9-196">HRESULT values</span></span>

<span data-ttu-id="ba2a9-197">La maggior parte dei metodi COM restituisce un Integer a 32 bit denominato **HRESULT**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="ba2a9-198">Con la maggior parte dei metodi, HRESULT è essenzialmente una struttura che contiene due informazioni primarie.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="ba2a9-199">Indica se il metodo ha avuto esito positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="ba2a9-200">Informazioni più dettagliate sul risultato dell'operazione eseguita dal metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="ba2a9-201">Alcuni metodi restituiscono un valore **HRESULT** dal set standard definito in `Winerror.h` .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="ba2a9-202">Tuttavia, un metodo è libero di restituire un valore **HRESULT** personalizzato con informazioni più specializzate.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="ba2a9-203">Questi valori sono in genere documentati nella pagina di riferimento del metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="ba2a9-204">L'elenco dei valori **HRESULT** individuati nella pagina di riferimento di un metodo è spesso solo un subset dei valori possibili che possono essere restituiti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="ba2a9-205">Nell'elenco vengono in genere trattati solo i valori specifici del metodo, nonché i valori standard che hanno un significato specifico del metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="ba2a9-206">Si supponga che un metodo possa restituire una serie di valori **HRESULT** standard, anche se non sono documentati in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="ba2a9-207">Sebbene i valori **HRESULT** vengano spesso utilizzati per restituire informazioni sugli errori, è consigliabile non considerarli come codici di errore.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="ba2a9-208">Il fatto che il bit che indica l'esito positivo o negativo venga archiviato separatamente dai bit che contengono le informazioni dettagliate consente ai valori **HRESULT** di avere un numero qualsiasi di codici di esito positivo e negativo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="ba2a9-209">Per convenzione, i nomi dei codici di esito positivo sono preceduti da S_ e codici di errore E_.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="ba2a9-210">Ad esempio, i due codici usati più di frequente sono S_OK e E_FAIL, che indicano rispettivamente un semplice esito positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="ba2a9-211">Il fatto che i metodi COM possano restituire una serie di codici di esito positivo o negativo significa che è necessario prestare attenzione alla modalità di test del valore **HRESULT** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="ba2a9-212">Si consideri, ad esempio, un ipotetico metodo con valori restituiti documentati di S_OK, se ha esito positivo e E_FAIL in caso contrario</span><span class="sxs-lookup"><span data-stu-id="ba2a9-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="ba2a9-213">Tuttavia, tenere presente che il metodo può restituire anche altri codici di errore o di esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="ba2a9-214">Il frammento di codice seguente illustra il rischio di usare un semplice test, dove `hr` contiene il valore **HRESULT** restituito dal metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="ba2a9-215">Se, nel caso di errore, questo metodo restituisce solo E_FAIL (e non altri codici di errore), il test funziona.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="ba2a9-216">Tuttavia, è più realistico che un determinato metodo venga implementato per restituire un set di codici di errore specifici, ad esempio E_NOTIMPL o E_INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="ba2a9-217">Con il codice precedente, questi valori verrebbero erroneamente interpretati come esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="ba2a9-218">Se sono necessarie informazioni dettagliate sul risultato della chiamata al metodo, è necessario testare ogni valore **HRESULT** pertinente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="ba2a9-219">Tuttavia, si potrebbe essere interessati solo se il metodo ha avuto esito positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="ba2a9-220">Un modo efficace per verificare se un valore **HRESULT** indica esito positivo o negativo è quello di passare il valore a una delle macro seguenti, definite in Winerror. h.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="ba2a9-221">La `SUCCEEDED` macro restituisce true per un codice di esito positivo e false per un codice di errore.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="ba2a9-222">La `FAILED` macro restituisce true per un codice di errore e false per un codice di esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="ba2a9-223">È quindi possibile correggere il frammento di codice precedente usando la `FAILED` macro, come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="ba2a9-224">Questo frammento di codice corretto considera correttamente E_NOTIMPL e E_INVALIDARG come errori.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="ba2a9-225">Sebbene la maggior parte dei metodi COM restituisca valori **HRESULT** strutturati, un numero ridotto utilizza **HRESULT** per restituire un intero semplice.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="ba2a9-226">In modo implicito, questi metodi hanno sempre esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="ba2a9-227">Se si passa un valore **HRESULT** di questo tipo alla macro SUCCEEDED, la macro restituisce sempre true.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="ba2a9-228">Un esempio di metodo comunemente chiamato che non restituisce **HRESULT** è il metodo **IUnknown:: Release** , che restituisce un ULONG.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="ba2a9-229">Questo metodo decrementa il conteggio dei riferimenti di un oggetto e restituisce il conteggio dei riferimenti corrente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="ba2a9-230">Per informazioni sul conteggio dei riferimenti, vedere [gestione della durata di un oggetto com](#managing-a-com-objects-lifetime) .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="ba2a9-231">Indirizzo di un puntatore</span><span class="sxs-lookup"><span data-stu-id="ba2a9-231">The address of a pointer</span></span>

<span data-ttu-id="ba2a9-232">Se si visualizzano alcune pagine di riferimento del metodo COM, è probabile che si verifichi un risultato simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="ba2a9-233">Sebbene un puntatore normale sia abbastanza familiare per gli sviluppatori C/C++, COM spesso usa un livello di riferimento indiretto aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="ba2a9-234">Questo secondo livello di riferimento indiretto è indicato da due asterischi, `**` , che seguono la dichiarazione del tipo e il nome della variabile ha in genere un prefisso `pp` .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="ba2a9-235">Per la funzione precedente, il `ppDevice` parametro viene in genere definito come l'indirizzo di un puntatore a un void.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="ba2a9-236">In pratica, in questo esempio, `ppDevice` è l'indirizzo di un puntatore a un'interfaccia **ID3D12Device** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="ba2a9-237">A differenza di un oggetto C++, non è possibile accedere direttamente ai metodi di un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="ba2a9-238">Al contrario, è necessario ottenere un puntatore a un'interfaccia che espone il metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="ba2a9-239">Per richiamare il metodo, è necessario usare essenzialmente la stessa sintassi usata per richiamare un puntatore a un metodo C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="ba2a9-240">Per richiamare il metodo **IMyInterface::D osomething** , ad esempio, usare la sintassi seguente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="ba2a9-241">La necessità di un secondo livello di riferimento indiretto deriva dal fatto che i puntatori di interfaccia non vengono creati direttamente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="ba2a9-242">È necessario chiamare uno dei diversi metodi, ad esempio il metodo **D3D12CreateDevice** illustrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="ba2a9-243">Per usare questo metodo per ottenere un puntatore a interfaccia, dichiarare una variabile come puntatore all'interfaccia desiderata, quindi passare l'indirizzo della variabile al metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="ba2a9-244">In altre parole, si passa l'indirizzo di un puntatore al metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="ba2a9-245">Quando il metodo restituisce, la variabile punta all'interfaccia richiesta ed è possibile usare tale puntatore per chiamare uno dei metodi dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="ba2a9-246">Creazione di un oggetto COM</span><span class="sxs-lookup"><span data-stu-id="ba2a9-246">Creating a COM object</span></span>

<span data-ttu-id="ba2a9-247">Esistono diversi modi per creare un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="ba2a9-248">Questi sono i due più comunemente usati nella programmazione DirectX.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="ba2a9-249">Indirettamente, chiamando un metodo o una funzione DirectX che crea automaticamente l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="ba2a9-250">Il metodo crea l'oggetto e restituisce un'interfaccia sull'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="ba2a9-251">Quando si crea un oggetto in questo modo, talvolta è possibile specificare l'interfaccia da restituire, altre volte l'interfaccia è implicita.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="ba2a9-252">Nell'esempio di codice precedente viene illustrato come creare indirettamente un oggetto COM Direct3D 12 per dispositivi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="ba2a9-253">Direttamente, passando il CLSID dell'oggetto alla [**funzione CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="ba2a9-254">La funzione crea un'istanza dell'oggetto e restituisce un puntatore a un'interfaccia specificata.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="ba2a9-255">Una volta, prima di creare qualsiasi oggetto COM, è necessario inizializzare COM chiamando la [**funzione CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="ba2a9-256">Se gli oggetti vengono creati indirettamente, il metodo di creazione dell'oggetto gestisce questa attività.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="ba2a9-257">Tuttavia, se è necessario creare un oggetto con **CoCreateInstance**, è necessario chiamare **CoInitializeEx** in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="ba2a9-258">Al termine, è necessario non inizializzare COM chiamando [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="ba2a9-259">Se si effettua una chiamata a **CoInitializeEx** , è necessario associarla a una chiamata a **CoUninitialize**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="ba2a9-260">In genere, le applicazioni che devono inizializzare in modo esplicito COM eseguono questa operazione nella routine di avvio e deinizializzano COM nella routine di pulizia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="ba2a9-261">Per creare una nuova istanza di un oggetto COM con **CoCreateInstance**, è necessario avere il CLSID dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="ba2a9-262">Se il CLSID è disponibile pubblicamente, sarà possibile trovarlo nella documentazione di riferimento o nel file di intestazione appropriato.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="ba2a9-263">Se il CLSID non è disponibile pubblicamente, non è possibile creare l'oggetto direttamente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="ba2a9-264">La funzione **CoCreateInstance** ha cinque parametri.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="ba2a9-265">Per gli oggetti COM che verranno usati con DirectX, in genere è possibile impostare i parametri come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="ba2a9-266">*rclsid* Impostare questa impostazione sul CLSID dell'oggetto che si desidera creare.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="ba2a9-267">*pUnkOuter* Impostare su `nullptr` .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="ba2a9-268">Questo parametro viene utilizzato solo se si stanno aggregando oggetti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="ba2a9-269">Una discussione sull'aggregazione COM esula dall'ambito di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="ba2a9-270">*dwClsContext* Impostare su CLSCTX_INPROC_SERVER.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="ba2a9-271">Questa impostazione indica che l'oggetto viene implementato come DLL e viene eseguito come parte del processo dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="ba2a9-272">*riid* Impostare sull'IID dell'interfaccia che si desidera venga restituita.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="ba2a9-273">La funzione creerà l'oggetto e restituirà il puntatore a interfaccia richiesto nel parametro PPV.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="ba2a9-274">*PPV* Impostare questo valore sull'indirizzo di un puntatore che verrà impostato sull'interfaccia specificata da `riid` quando la funzione restituisce.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="ba2a9-275">Questa variabile deve essere dichiarata come puntatore all'interfaccia richiesta e il riferimento al puntatore nell'elenco di parametri deve essere eseguito come (LPVOID \*).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="ba2a9-276">La creazione di un oggetto indirettamente è in genere molto più semplice, come illustrato nell'esempio di codice precedente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="ba2a9-277">Si passa il metodo di creazione dell'oggetto all'indirizzo di un puntatore a interfaccia, quindi il metodo crea l'oggetto e restituisce un puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="ba2a9-278">Quando si crea un oggetto indirettamente, anche se non è possibile scegliere l'interfaccia restituita dal metodo, spesso è comunque possibile specificare una serie di elementi relativi alla modalità di creazione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="ba2a9-279">Ad esempio, è possibile passare a **D3D12CreateDevice** un valore che specifica il livello di funzionalità D3D minimo che deve essere supportato dal dispositivo restituito, come illustrato nell'esempio di codice precedente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="ba2a9-280">Uso di interfacce COM</span><span class="sxs-lookup"><span data-stu-id="ba2a9-280">Using COM interfaces</span></span>

<span data-ttu-id="ba2a9-281">Quando si crea un oggetto COM, il metodo di creazione restituisce un puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="ba2a9-282">È quindi possibile usare tale puntatore per accedere a uno dei metodi dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="ba2a9-283">La sintassi è identica a quella usata con un puntatore a un metodo C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="ba2a9-284">Richiesta di interfacce aggiuntive</span><span class="sxs-lookup"><span data-stu-id="ba2a9-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="ba2a9-285">In molti casi, il puntatore a un'interfaccia che si riceve dal metodo di creazione può essere l'unico necessario.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="ba2a9-286">Di fatto, è relativamente comune che un oggetto esporti solo un'interfaccia diversa da **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="ba2a9-287">Tuttavia, molti oggetti esportano più interfacce e potrebbero essere necessari puntatori a molti di essi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="ba2a9-288">Se sono necessarie più interfacce di quelle restituite dal metodo di creazione, non è necessario creare un nuovo oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="ba2a9-289">È necessario invece richiedere un altro puntatore a interfaccia usando il [**metodo IUnknown:: QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="ba2a9-290">Se si crea l'oggetto con **CoCreateInstance**, è possibile richiedere un puntatore all'interfaccia **IUnknown** e quindi chiamare **IUnknown:: QueryInterface** per richiedere ogni interfaccia necessaria.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="ba2a9-291">Tuttavia, questo approccio è scomodo se è necessaria una sola interfaccia e non funziona affatto se si usa un metodo di creazione di un oggetto che non consente di specificare quale puntatore a interfaccia deve essere restituito.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="ba2a9-292">In pratica, in genere non è necessario ottenere un puntatore **IUnknown** esplicito, perché tutte le interfacce com estendono l'interfaccia **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="ba2a9-293">L'estensione di un'interfaccia è concettualmente simile all'ereditarietà da una classe C++.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="ba2a9-294">L'interfaccia figlio espone tutti i metodi dell'interfaccia padre, oltre a uno o più dei relativi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="ba2a9-295">In realtà, viene spesso visualizzato "eredita da" usato al posto di "extends".</span><span class="sxs-lookup"><span data-stu-id="ba2a9-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="ba2a9-296">È necessario ricordare che l'ereditarietà è interna all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="ba2a9-297">L'applicazione non può ereditare o estendere l'interfaccia di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="ba2a9-298">Tuttavia, è possibile usare l'interfaccia figlio per chiamare qualsiasi metodo del figlio o dell'elemento padre.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="ba2a9-299">Poiché tutte le interfacce sono elementi figlio di **IUnknown**, è possibile chiamare **QueryInterface** su qualsiasi puntatore di interfaccia già disponibile per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="ba2a9-300">Quando si esegue questa operazione, è necessario fornire l'IID dell'interfaccia richiesta e l'indirizzo di un puntatore che conterrà il puntatore di interfaccia quando il metodo restituisce un risultato.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="ba2a9-301">Nel frammento di codice seguente, ad esempio, viene chiamato **IDXGIFactory2:: CreateSwapChainForHwnd** per creare un oggetto catena di scambio primario.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="ba2a9-302">Questo oggetto espone diverse interfacce.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-302">This object exposes several interfaces.</span></span> <span data-ttu-id="ba2a9-303">Il metodo **CreateSwapChainForHwnd** restituisce un'interfaccia **IDXGISwapChain1** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="ba2a9-304">Il codice successivo usa quindi l'interfaccia **IDXGISwapChain1** per chiamare **QueryInterface** per richiedere un'interfaccia **IDXGISwapChain3** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="ba2a9-305">In C++ è possibile usare la ``IID_PPV_ARGS`` macro anziché l'IID esplicito e il puntatore del cast: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="ba2a9-306">Viene spesso usato per i metodi di creazione e **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="ba2a9-307">Per ulteriori informazioni, vedere [combaseapi. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="ba2a9-308">Gestione della durata di un oggetto COM</span><span class="sxs-lookup"><span data-stu-id="ba2a9-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="ba2a9-309">Quando viene creato un oggetto, il sistema alloca le risorse di memoria necessarie.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="ba2a9-310">Quando un oggetto non è più necessario, deve essere eliminato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="ba2a9-311">Il sistema può utilizzare tale memoria per altri scopi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="ba2a9-312">Con gli oggetti C++, è possibile controllare la durata dell'oggetto direttamente con `new` gli `delete` operatori e nei casi in cui si sta operando a tale livello o semplicemente utilizzando la durata dello stack e dell'ambito.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="ba2a9-313">COM non consente di creare o distruggere direttamente oggetti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="ba2a9-314">Il motivo di questa progettazione è che lo stesso oggetto può essere utilizzato da più di una parte dell'applicazione o, in alcuni casi, da più di un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="ba2a9-315">Se uno di questi riferimenti era quello di eliminare l'oggetto, gli altri riferimenti diventeranno non validi.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="ba2a9-316">COM utilizza invece un sistema di conteggio dei riferimenti per controllare la durata di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="ba2a9-317">Il conteggio dei riferimenti di un oggetto indica il numero di volte in cui è stata richiesta una delle relative interfacce.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="ba2a9-318">Ogni volta che viene richiesta un'interfaccia, il conteggio dei riferimenti viene incrementato.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="ba2a9-319">Un'applicazione rilascia un'interfaccia quando tale interfaccia non è più necessaria, decrementa il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="ba2a9-320">Fino a quando il conteggio dei riferimenti è maggiore di zero, l'oggetto rimane in memoria.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="ba2a9-321">Quando il conteggio dei riferimenti raggiunge zero, l'oggetto Elimina se stesso.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="ba2a9-322">Non è necessario conoscere il conteggio dei riferimenti di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="ba2a9-323">Fino a quando si ottengono e si rilasciano correttamente le interfacce di un oggetto, l'oggetto avrà la durata appropriata.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="ba2a9-324">Una gestione corretta del conteggio dei riferimenti è una parte essenziale della programmazione COM.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="ba2a9-325">In caso contrario, è possibile creare facilmente una perdita di memoria o un arresto anomalo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="ba2a9-326">Uno degli errori più comuni apportati dai programmatori COM non riesce a rilasciare un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="ba2a9-327">In tal caso, il conteggio dei riferimenti non raggiunge mai zero e l'oggetto rimane in memoria per un periodo illimitato.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="ba2a9-328">Direct3D 10 o versione successiva ha regole di durata leggermente modificate per gli oggetti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="ba2a9-329">In particolare, gli oggetti derivati da **ID3DxxDeviceChild** non sopravvivono mai al dispositivo padre (ovvero se il **ID3DxxDevice** proprietario raggiunge un refcount 0, anche tutti gli oggetti figlio sono immediatamente non validi).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="ba2a9-330">Inoltre, quando si utilizzano i metodi **set** per associare oggetti alla pipeline di rendering, questi riferimenti non aumentano il conteggio dei riferimenti, ovvero sono riferimenti deboli.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="ba2a9-331">In pratica, questa operazione viene gestita in modo ottimale garantendo il rilascio completo di tutti gli oggetti figlio del dispositivo prima di rilasciare il dispositivo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="ba2a9-332">Incremento e decremento del conteggio dei riferimenti</span><span class="sxs-lookup"><span data-stu-id="ba2a9-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="ba2a9-333">Ogni volta che si ottiene un nuovo puntatore di interfaccia, il conteggio dei riferimenti deve essere incrementato da una chiamata a [**IUnknown:: AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="ba2a9-334">Tuttavia, l'applicazione in genere non deve chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="ba2a9-335">Se si ottiene un puntatore a interfaccia chiamando un metodo di creazione di un oggetto o chiamando **IUnknown:: QueryInterface**, l'oggetto incrementa automaticamente il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="ba2a9-336">Tuttavia, se si crea un puntatore di interfaccia in un altro modo, ad esempio la copia di un puntatore esistente, è necessario chiamare in modo esplicito **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="ba2a9-337">In caso contrario, quando si rilascia il puntatore di interfaccia originale, è possibile che l'oggetto venga eliminato definitivamente anche se è ancora necessario utilizzare la copia del puntatore.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="ba2a9-338">È necessario rilasciare tutti i puntatori a interfaccia, indipendentemente dal fatto che l'utente o l'oggetto abbia incrementato il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="ba2a9-339">Quando un puntatore di interfaccia non è più necessario, chiamare [**IUnknown:: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) per decrementare il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="ba2a9-340">Una procedura comune consiste nell'inizializzare tutti i puntatori di interfaccia a `nullptr` e quindi per impostarli nuovamente `nullptr` quando vengono rilasciati.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="ba2a9-341">Tale convenzione consente di testare tutti i puntatori di interfaccia nel codice di pulizia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="ba2a9-342">Quelli che non sono `nullptr` ancora attivi ed è necessario rilasciarli prima di terminare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="ba2a9-343">Il frammento di codice seguente estende l'esempio illustrato in precedenza per illustrare come gestire il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="ba2a9-344">Puntatori intelligenti COM</span><span class="sxs-lookup"><span data-stu-id="ba2a9-344">COM Smart Pointers</span></span>

<span data-ttu-id="ba2a9-345">Il codice finora ha chiamato in modo esplicito ``Release`` e ``AddRef`` per mantenere i conteggi dei riferimenti usando i metodi **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="ba2a9-346">Questo modello richiede che il programmatore sia diligente nel ricordare di gestire correttamente il conteggio in tutti i possibili percorsi di codepath.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="ba2a9-347">Questo può comportare una complessa gestione degli errori e la gestione delle eccezioni C++ abilitata può essere particolarmente difficile da implementare.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="ba2a9-348">Una soluzione migliore con C++ consiste nell'usare un [puntatore intelligente](/cpp/cpp/smart-pointers-modern-cpp).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="ba2a9-349">**WinRT:: com_ptr** è un puntatore intelligente fornito dalle [proiezioni del linguaggio C++/WinRT](/uwp/cpp-ref-for-winrt/com-ptr).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="ba2a9-350">Si tratta del puntatore intelligente COM consigliato da usare per le app UWP.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="ba2a9-351">Si noti che C++/WinRT richiede C++ 17.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="ba2a9-352">**Microsoft:: WRL:: ComPtr** è un puntatore intelligente fornito dalla [libreria di modelli C++ Windows Runtime (WRL)](/cpp/cppcx/wrl/comptr-class).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="ba2a9-353">Questa libreria è "pure" C++, quindi può essere usata per Windows Runtime applicazioni (tramite C++/CX o C++/WinRT), nonché per le applicazioni desktop Win32 classiche.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="ba2a9-354">Questo puntatore intelligente funziona anche nelle versioni precedenti di Windows che non supportano le API Windows Runtime.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="ba2a9-355">Per le applicazioni desktop Win32, è possibile utilizzare ``#include <wrl/client.h>`` per includere solo questa classe e, facoltativamente, definire anche il simbolo del preprocessore ``__WRL_CLASSIC_COM_STRICT__`` .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="ba2a9-356">Per ulteriori informazioni, vedere la pagina relativa ai [puntatori intelligenti com rivisitati](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="ba2a9-357">**CComPtr** è un puntatore intelligente fornito dal [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="ba2a9-358">**Microsoft:: WRL:: ComPtr** è una versione più recente di questa implementazione che risolve diversi problemi di utilizzo, pertanto l'utilizzo di questo puntatore intelligente non è consigliato per i nuovi progetti.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="ba2a9-359">Per ulteriori informazioni, vedere [come creare e usare CComPtr e CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span><span class="sxs-lookup"><span data-stu-id="ba2a9-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="ba2a9-360">Uso di ATL con DirectX 9</span><span class="sxs-lookup"><span data-stu-id="ba2a9-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="ba2a9-361">Per utilizzare il Active Template Library (ATL) con DirectX 9, è necessario ridefinire le interfacce per la compatibilità con ATL.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="ba2a9-362">Ciò consente di utilizzare correttamente la classe **CComQIPtr** per ottenere un puntatore a un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="ba2a9-363">Si saprà che se non si ridefiniscono le interfacce per ATL, verrà visualizzato il messaggio di errore seguente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="ba2a9-364">Nell'esempio di codice seguente viene illustrato come definire l'interfaccia IDirectXFileData.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="ba2a9-365">Dopo aver ridefinito l'interfaccia, è necessario usare il metodo di **associazione** per collegare l'interfaccia al puntatore di interfaccia restituito da **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="ba2a9-366">In caso contrario, l'interfaccia **IDirect3D9** non verrà rilasciata correttamente dalla classe del puntatore intelligente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="ba2a9-367">La classe **CComPtr** chiama internamente **IUnknown:: AddRef** sul puntatore a interfaccia quando viene creato l'oggetto e quando un'interfaccia viene assegnata alla classe **CComPtr** .</span><span class="sxs-lookup"><span data-stu-id="ba2a9-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="ba2a9-368">Per evitare la perdita del puntatore a interfaccia, non chiamare \* \* IUnknown:: AddRef sull'interfaccia restituita da **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="ba2a9-369">Il codice seguente rilascia correttamente l'interfaccia senza chiamare **IUnknown:: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="ba2a9-370">Usare il codice precedente.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-370">Use the previous code.</span></span> <span data-ttu-id="ba2a9-371">Non usare il codice seguente, che chiama **IUnknown:: AddRef** seguito da **IUnknown:: Release** e non rilascia il riferimento aggiunto da **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="ba2a9-372">Si noti che questa è l'unica posizione in Direct3D 9 in cui è necessario usare il metodo di **associazione** in questo modo.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="ba2a9-373">Per ulteriori informazioni sulle classi **CComPTR** e **CComQIPtr** , vedere le relative definizioni nel `Atlbase.h` file di intestazione.</span><span class="sxs-lookup"><span data-stu-id="ba2a9-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
