---
description: Gli oggetti denominati forniscono un modo semplice per la condivisione degli handle di oggetto da parte dei processi.
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: Nomi di oggetti
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106315302"
---
# <a name="object-names"></a><span data-ttu-id="93e38-103">Nomi di oggetti</span><span class="sxs-lookup"><span data-stu-id="93e38-103">Object Names</span></span>

<span data-ttu-id="93e38-104">Gli oggetti denominati forniscono un modo semplice per la condivisione degli handle di oggetto da parte dei processi.</span><span class="sxs-lookup"><span data-stu-id="93e38-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="93e38-105">Dopo che un processo ha creato un evento denominato, un mutex, un semaforo o un oggetto timer, altri processi possono usare il nome per chiamare la funzione appropriata ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**errore in OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)o [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) per aprire un handle per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="93e38-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="93e38-106">Il confronto tra nomi distingue tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="93e38-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="93e38-107">I nomi di evento, semaforo, mutex, timer waitable, mapping di file e oggetti processo condividono lo stesso spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="93e38-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="93e38-108">Se si tenta di creare un oggetto usando un nome usato da un oggetto di un altro tipo, la funzione ha esito negativo e [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) restituisce un **handle di errore \_ non valido \_**.</span><span class="sxs-lookup"><span data-stu-id="93e38-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="93e38-109">Pertanto, quando si creano oggetti denominati, utilizzare nomi univoci e assicurarsi di controllare i valori restituiti dalla funzione per gli errori relativi ai nomi duplicati.</span><span class="sxs-lookup"><span data-stu-id="93e38-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="93e38-110">Se si tenta di creare un oggetto utilizzando un nome utilizzato da un oggetto dello stesso tipo, la funzione ha esito positivo, restituendo un handle all'oggetto esistente e [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) restituisce un **errore \_ già \_ esistente**.</span><span class="sxs-lookup"><span data-stu-id="93e38-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="93e38-111">Se, ad esempio, il nome specificato in una chiamata alla funzione [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) corrisponde al nome di un oggetto mutex esistente, la funzione restituisce un handle per l'oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="93e38-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="93e38-112">In questo caso, la chiamata a **CreateMutex** è equivalente a una chiamata alla funzione [**errore in OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) .</span><span class="sxs-lookup"><span data-stu-id="93e38-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="93e38-113">La presenza di più processi utilizza **CreateMutex** per lo stesso mutex è pertanto equivalente a un processo che chiama **CreateMutex** mentre gli altri processi chiamano **errore in OpenMutex**, con la differenza che elimina la necessità di verificare che il processo di creazione venga avviato per primo.</span><span class="sxs-lookup"><span data-stu-id="93e38-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="93e38-114">Quando si usa questa tecnica per gli oggetti mutex, tuttavia, nessuno dei processi chiamante deve richiedere la proprietà immediata del mutex.</span><span class="sxs-lookup"><span data-stu-id="93e38-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="93e38-115">Se più processi richiedono la proprietà immediata, può essere difficile prevedere il processo che ottiene effettivamente la proprietà iniziale.</span><span class="sxs-lookup"><span data-stu-id="93e38-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="93e38-116">Un ambiente di servizi Terminal dispone di uno spazio dei nomi globale per eventi, semafori, mutex, temporizzazioni attese, oggetti di mapping di file e oggetti processo.</span><span class="sxs-lookup"><span data-stu-id="93e38-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="93e38-117">Ogni sessione client di servizi Terminal dispone inoltre di uno spazio dei nomi separato per questi oggetti.</span><span class="sxs-lookup"><span data-stu-id="93e38-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="93e38-118">I processi client di Servizi terminal possono utilizzare i nomi degli oggetti con prefisso "globale \\ " o "locale \\ " per creare in modo esplicito un oggetto nello spazio dei nomi globale o sessione.</span><span class="sxs-lookup"><span data-stu-id="93e38-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="93e38-119">Per altre informazioni, vedere [spazi dei nomi degli oggetti kernel](../termserv/kernel-object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="93e38-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="93e38-120">Il cambio rapido utente viene implementato tramite sessioni di Servizi terminal (ogni utente accede a una sessione diversa).</span><span class="sxs-lookup"><span data-stu-id="93e38-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="93e38-121">I nomi degli oggetti kernel devono seguire le linee guida descritte per Servizi terminal, in modo che le applicazioni possano supportare più utenti.</span><span class="sxs-lookup"><span data-stu-id="93e38-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="93e38-122">Gli oggetti di sincronizzazione possono essere creati in uno spazio dei nomi privato.</span><span class="sxs-lookup"><span data-stu-id="93e38-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="93e38-123">Per altre informazioni, vedere [spazi dei nomi degli oggetti](object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="93e38-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="93e38-124">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="93e38-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="93e38-125">Uso di oggetti denominati</span><span class="sxs-lookup"><span data-stu-id="93e38-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
