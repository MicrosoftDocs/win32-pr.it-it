---
description: Un oggetto sezione critica fornisce una sincronizzazione simile a quella fornita da un oggetto mutex, ad eccezione del fatto che una sezione critica può essere usata solo dai thread di un singolo processo.
ms.assetid: 2ec11a42-3d12-4d60-9dd7-dc38926d56e1
title: Oggetti sezione critica
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cbcada1f2ddbc6d370445f36a3dbd51c5c9f54bf
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106315307"
---
# <a name="critical-section-objects"></a><span data-ttu-id="0dece-103">Oggetti sezione critica</span><span class="sxs-lookup"><span data-stu-id="0dece-103">Critical Section Objects</span></span>

<span data-ttu-id="0dece-104">Un *oggetto sezione critica* fornisce una sincronizzazione simile a quella fornita da un oggetto mutex, ad eccezione del fatto che una sezione critica può essere usata solo dai thread di un singolo processo.</span><span class="sxs-lookup"><span data-stu-id="0dece-104">A *critical section object* provides synchronization similar to that provided by a mutex object, except that a critical section can be used only by the threads of a single process.</span></span> <span data-ttu-id="0dece-105">Gli oggetti sezione critici non possono essere condivisi tra più processi.</span><span class="sxs-lookup"><span data-stu-id="0dece-105">Critical section objects cannot be shared across processes.</span></span>

<span data-ttu-id="0dece-106">Gli oggetti Event, mutex e Semaphore possono essere utilizzati anche in un'applicazione a processo singolo, ma gli oggetti sezione critici forniscono un meccanismo leggermente più veloce e più efficiente per la sincronizzazione con esclusione reciproca (test specifici del processore e istruzioni set).</span><span class="sxs-lookup"><span data-stu-id="0dece-106">Event, mutex, and semaphore objects can also be used in a single-process application, but critical section objects provide a slightly faster, more efficient mechanism for mutual-exclusion synchronization (a processor-specific test and set instruction).</span></span> <span data-ttu-id="0dece-107">Analogamente a un oggetto mutex, un oggetto sezione critica può essere di proprietà di un solo thread alla volta, in modo da renderlo utile per la protezione di una risorsa condivisa dall'accesso simultaneo.</span><span class="sxs-lookup"><span data-stu-id="0dece-107">Like a mutex object, a critical section object can be owned by only one thread at a time, which makes it useful for protecting a shared resource from simultaneous access.</span></span> <span data-ttu-id="0dece-108">A differenza di un oggetto mutex, non è possibile stabilire se una sezione critica è stata abbandonata.</span><span class="sxs-lookup"><span data-stu-id="0dece-108">Unlike a mutex object, there is no way to tell whether a critical section has been abandoned.</span></span>

<span data-ttu-id="0dece-109">A partire da Windows Server 2003 con Service Pack 1 (SP1), i thread in attesa di una sezione critica non acquisiscono la sezione critica in base alla prima, prima di tutto.</span><span class="sxs-lookup"><span data-stu-id="0dece-109">Starting with Windows Server 2003 with Service Pack 1 (SP1), threads waiting on a critical section do not acquire the critical section on a first-come, first-serve basis.</span></span> <span data-ttu-id="0dece-110">Questa modifica migliora significativamente le prestazioni per la maggior parte del codice.</span><span class="sxs-lookup"><span data-stu-id="0dece-110">This change increases performance significantly for most code.</span></span> <span data-ttu-id="0dece-111">Tuttavia, alcune applicazioni dipendono dall'ordinamento First-in, First-out (FIFO) e possono essere eseguite in modo non corretto o non in tutte le versioni correnti di Windows (ad esempio, le applicazioni che hanno usato sezioni critiche come un limite di velocità).</span><span class="sxs-lookup"><span data-stu-id="0dece-111">However, some applications depend on first-in, first-out (FIFO) ordering and may perform poorly or not at all on current versions of Windows (for example, applications that have been using critical sections as a rate-limiter).</span></span> <span data-ttu-id="0dece-112">Per assicurarsi che il codice continui a funzionare correttamente, potrebbe essere necessario aggiungere un ulteriore livello di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0dece-112">To ensure that your code continues to work correctly, you may need to add an additional level of synchronization.</span></span> <span data-ttu-id="0dece-113">Si supponga, ad esempio, di avere un thread producer e un thread consumer che usano un oggetto sezione critica per sincronizzare il lavoro.</span><span class="sxs-lookup"><span data-stu-id="0dece-113">For example, suppose you have a producer thread and a consumer thread that are using a critical section object to synchronize their work.</span></span> <span data-ttu-id="0dece-114">Creare due oggetti evento, uno per ogni thread da usare per segnalare che è pronto per continuare l'altro thread.</span><span class="sxs-lookup"><span data-stu-id="0dece-114">Create two event objects, one for each thread to use to signal that it is ready for the other thread to proceed.</span></span> <span data-ttu-id="0dece-115">Il thread consumer attenderà che il producer segnali il proprio evento prima di entrare nella sezione critica e il thread producer attenderà che il thread consumer segnali il proprio evento prima di immettere la sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-115">The consumer thread will wait for the producer to signal its event before entering the critical section, and the producer thread will wait for the consumer thread to signal its event before entering the critical section.</span></span> <span data-ttu-id="0dece-116">Quando ogni thread esce dalla sezione critica, segnala l'evento per rilasciare l'altro thread.</span><span class="sxs-lookup"><span data-stu-id="0dece-116">After each thread leaves the critical section, it signals its event to release the other thread.</span></span>

<span data-ttu-id="0dece-117">**Windows Server 2003 e Windows XP:** I thread in attesa di una sezione critica vengono aggiunti a una coda di attesa. vengono riattivate e in genere acquisiscono la sezione critica nell'ordine in cui sono state aggiunte alla coda.</span><span class="sxs-lookup"><span data-stu-id="0dece-117">**Windows Server 2003 and Windows XP:** Threads that are waiting on a critical section are added to a wait queue; they are woken and generally acquire the critical section in the order in which they were added to the queue.</span></span> <span data-ttu-id="0dece-118">Tuttavia, se i thread vengono aggiunti a questa coda a una velocità sufficientemente elevata, le prestazioni possono risultare ridotte a causa del tempo necessario per riattivare ogni thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="0dece-118">However, if threads are added to this queue at a fast enough rate, performance can be degraded because of the time it takes to awaken each waiting thread.</span></span>

<span data-ttu-id="0dece-119">Il processo è responsabile dell'allocazione della memoria utilizzata da una sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-119">The process is responsible for allocating the memory used by a critical section.</span></span> <span data-ttu-id="0dece-120">Questa operazione viene in genere eseguita semplicemente dichiarando una variabile di **tipo \_ sezione critica**.</span><span class="sxs-lookup"><span data-stu-id="0dece-120">Typically, this is done by simply declaring a variable of type **CRITICAL\_SECTION**.</span></span> <span data-ttu-id="0dece-121">Prima che i thread del processo possano utilizzarlo, inizializzare la sezione critica utilizzando la funzione [**InitializeCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection) o [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) .</span><span class="sxs-lookup"><span data-stu-id="0dece-121">Before the threads of the process can use it, initialize the critical section by using the [**InitializeCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection) or [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) function.</span></span>

<span data-ttu-id="0dece-122">Un thread usa la funzione [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) o [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) per richiedere la proprietà di una sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-122">A thread uses the [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) or [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) function to request ownership of a critical section.</span></span> <span data-ttu-id="0dece-123">Usa la funzione [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) per rilasciare la proprietà di una sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-123">It uses the [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) function to release ownership of a critical section.</span></span> <span data-ttu-id="0dece-124">Se l'oggetto sezione critica è attualmente di proprietà di un altro thread, **EnterCriticalSection** attende indefinitamente per la proprietà.</span><span class="sxs-lookup"><span data-stu-id="0dece-124">If the critical section object is currently owned by another thread, **EnterCriticalSection** waits indefinitely for ownership.</span></span> <span data-ttu-id="0dece-125">Al contrario, quando un oggetto mutex viene utilizzato per l'esclusione reciproca, le [funzioni di attesa](wait-functions.md) accettano un intervallo di timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="0dece-125">In contrast, when a mutex object is used for mutual exclusion, the [wait functions](wait-functions.md) accept a specified time-out interval.</span></span> <span data-ttu-id="0dece-126">La funzione **TryEnterCriticalSection** tenta di immettere una sezione critica senza bloccare il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="0dece-126">The **TryEnterCriticalSection** function attempts to enter a critical section without blocking the calling thread.</span></span>

<span data-ttu-id="0dece-127">Quando un thread è proprietario di una sezione critica, può effettuare chiamate aggiuntive a [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) o [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) senza bloccarne l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="0dece-127">When a thread owns a critical section, it can make additional calls to [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) or [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) without blocking its execution.</span></span> <span data-ttu-id="0dece-128">In questo modo si impedisce a un thread di verificarsi un deadlock durante l'attesa di una sezione critica di cui è già proprietario.</span><span class="sxs-lookup"><span data-stu-id="0dece-128">This prevents a thread from deadlocking itself while waiting for a critical section that it already owns.</span></span> <span data-ttu-id="0dece-129">Per rilasciare la proprietà, il thread deve chiamare [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) una volta per ogni volta in cui è stata immessa la sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-129">To release its ownership, the thread must call [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) one time for each time that it entered the critical section.</span></span> <span data-ttu-id="0dece-130">Non esiste alcuna garanzia sull'ordine in cui i thread in attesa acquisiscono la proprietà della sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-130">There is no guarantee about the order in which waiting threads will acquire ownership of the critical section.</span></span>

<span data-ttu-id="0dece-131">Un thread usa la funzione [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) o [**SetCriticalSectionSpinCount**](/windows/win32/api/synchapi/nf-synchapi-setcriticalsectionspincount) per specificare un numero di spin per l'oggetto sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-131">A thread uses the [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) or [**SetCriticalSectionSpinCount**](/windows/win32/api/synchapi/nf-synchapi-setcriticalsectionspincount) function to specify a spin count for the critical section object.</span></span> <span data-ttu-id="0dece-132">La rotazione significa che quando un thread tenta di acquisire una sezione critica bloccata, il thread entra in un ciclo, verifica se il blocco viene rilasciato e se il blocco non viene rilasciato, il thread passa alla modalità di sospensione.</span><span class="sxs-lookup"><span data-stu-id="0dece-132">Spinning means that when a thread tries to acquire a critical section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not released, the thread goes to sleep.</span></span> <span data-ttu-id="0dece-133">Nei sistemi a processore singolo, il numero di spin viene ignorato e il conteggio delle sezioni critiche è impostato su 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0dece-133">On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero).</span></span> <span data-ttu-id="0dece-134">Nei sistemi multiprocessore, se la sezione critica non è disponibile, il thread chiamante gira *dwSpinCount* volte prima di eseguire un'operazione di attesa su un semaforo associato alla sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-134">On multiprocessor systems, if the critical section is unavailable, the calling thread spins *dwSpinCount* times before performing a wait operation on a semaphore that is associated with the critical section.</span></span> <span data-ttu-id="0dece-135">Se la sezione critica diventa disponibile durante l'operazione di rotazione, il thread chiamante evita l'operazione di attesa.</span><span class="sxs-lookup"><span data-stu-id="0dece-135">If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</span></span>

<span data-ttu-id="0dece-136">Qualsiasi thread del processo può utilizzare la funzione [**DeleteCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection) per rilasciare le risorse di sistema allocate quando viene inizializzato l'oggetto sezione critica.</span><span class="sxs-lookup"><span data-stu-id="0dece-136">Any thread of the process can use the [**DeleteCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection) function to release the system resources that are allocated when the critical section object is initialized.</span></span> <span data-ttu-id="0dece-137">Dopo la chiamata a questa funzione, l'oggetto sezione critica non può essere utilizzato per la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0dece-137">After this function is called, the critical section object cannot be used for synchronization.</span></span>

<span data-ttu-id="0dece-138">Quando un oggetto sezione critico è di proprietà, gli unici altri thread interessati sono i thread in attesa di proprietà in una chiamata a [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection).</span><span class="sxs-lookup"><span data-stu-id="0dece-138">When a critical section object is owned, the only other threads affected are the threads that are waiting for ownership in a call to [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection).</span></span> <span data-ttu-id="0dece-139">I thread che non sono in attesa possono continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="0dece-139">Threads that are not waiting are free to continue running.</span></span>

## <a name="related-topics"></a><span data-ttu-id="0dece-140">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="0dece-140">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="0dece-141">Oggetti mutex</span><span class="sxs-lookup"><span data-stu-id="0dece-141">Mutex Objects</span></span>](mutex-objects.md)
</dt> <dt>

[<span data-ttu-id="0dece-142">Utilizzo di oggetti sezione critici</span><span class="sxs-lookup"><span data-stu-id="0dece-142">Using Critical Section Objects</span></span>](using-critical-section-objects.md)
</dt> </dl>

 

 
