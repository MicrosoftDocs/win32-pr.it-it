---
description: I componenti sono spesso progettati per eseguire attività di inizializzazione quando vengono chiamati per la prima volta, anziché quando vengono caricati.
ms.assetid: 404c083c-7bee-44c2-b8e7-da1901b6ab2f
title: Inizializzazione One-Time
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 16f451e3c51716b4ff6f33b55d8d8602b5d5c28f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106318610"
---
# <a name="one-time-initialization"></a><span data-ttu-id="56c09-103">Inizializzazione One-Time</span><span class="sxs-lookup"><span data-stu-id="56c09-103">One-Time Initialization</span></span>

<span data-ttu-id="56c09-104">I componenti sono spesso progettati per eseguire attività di inizializzazione quando vengono chiamati per la prima volta, anziché quando vengono caricati.</span><span class="sxs-lookup"><span data-stu-id="56c09-104">Components are often designed to perform initialization tasks when they are first called, rather than when they are loaded.</span></span> <span data-ttu-id="56c09-105">Le funzioni di inizializzazione monouso assicurano che l'inizializzazione venga eseguita una sola volta, anche quando più thread possono tentare l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-105">The one-time initialization functions ensure that this initialization occurs only once, even when multiple threads may attempt the initialization.</span></span>

<span data-ttu-id="56c09-106">**Windows Server 2003 e Windows XP:** Le applicazioni devono fornire una sincronizzazione personalizzata per l'inizializzazione singola usando le [funzioni Interlocked](interlocked-variable-access.md) o un altro meccanismo di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-106">**Windows Server 2003 and Windows XP:** Applications must provide their own synchronization for one-time initialization by using the [interlocked functions](interlocked-variable-access.md) or other synchronization mechanism.</span></span> <span data-ttu-id="56c09-107">Le funzioni di inizializzazione una volta sono disponibili a partire da Windows Vista e Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="56c09-107">The one-time initialization functions are available starting with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="56c09-108">Le funzioni di inizializzazione monouso offrono vantaggi significativi per garantire che solo un thread esegua l'inizializzazione:</span><span class="sxs-lookup"><span data-stu-id="56c09-108">The one-time initialization functions provide significant advantages to ensure that only one thread performs the initialization:</span></span>

-   <span data-ttu-id="56c09-109">Sono ottimizzate per la velocità.</span><span class="sxs-lookup"><span data-stu-id="56c09-109">They are optimized for speed.</span></span>
-   <span data-ttu-id="56c09-110">Creano le barriere appropriate nelle architetture del processore che le richiedono.</span><span class="sxs-lookup"><span data-stu-id="56c09-110">They create the appropriate barriers on processor architectures that require them.</span></span>
-   <span data-ttu-id="56c09-111">Supportano sia l'inizializzazione bloccata che quella parallela.</span><span class="sxs-lookup"><span data-stu-id="56c09-111">They support both locked and parallel initialization.</span></span>
-   <span data-ttu-id="56c09-112">Evitano il blocco interno, in modo che il codice possa funzionare in modo asincrono o sincrono.</span><span class="sxs-lookup"><span data-stu-id="56c09-112">They avoid internal locking so the code can operate asynchronously or synchronously.</span></span>

<span data-ttu-id="56c09-113">Il sistema gestisce il processo di inizializzazione tramite una struttura opaca **init \_ once** che contiene dati e informazioni sullo stato.</span><span class="sxs-lookup"><span data-stu-id="56c09-113">The system manages the initialization process through an opaque **INIT\_ONCE** structure that contains data and state information.</span></span> <span data-ttu-id="56c09-114">Il chiamante alloca questa struttura e la inizializza chiamando [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (per inizializzare la struttura in modo dinamico) o assegnando la costante **init \_ una volta \_ statico \_ init** alla variabile di struttura (per inizializzare la struttura in modo statico).</span><span class="sxs-lookup"><span data-stu-id="56c09-114">The caller allocates this structure and initializes it by either calling [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (to initialize the structure dynamically) or assigning the constant **INIT\_ONCE\_STATIC\_INIT** to the structure variable (to initialize the structure statically).</span></span> <span data-ttu-id="56c09-115">Inizialmente, i dati archiviati nella struttura di inizializzazione singola sono NULL e il suo stato non è inizializzato.</span><span class="sxs-lookup"><span data-stu-id="56c09-115">Initially, the data stored in the one-time initialization structure is NULL and its state is uninitialized.</span></span>

<span data-ttu-id="56c09-116">Le strutture di inizializzazione monouso non possono essere condivise tra processi.</span><span class="sxs-lookup"><span data-stu-id="56c09-116">One-time initialization structures cannot be shared across processes.</span></span>

<span data-ttu-id="56c09-117">Il thread che esegue l'inizializzazione può facoltativamente impostare un contesto disponibile al chiamante al termine dell'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-117">The thread that performs the initialization can optionally set a context that is available to the caller after initialization is complete.</span></span> <span data-ttu-id="56c09-118">Il contesto può essere un oggetto di sincronizzazione o può essere un valore o una struttura di dati.</span><span class="sxs-lookup"><span data-stu-id="56c09-118">The context can be a synchronization object or it can be a value or data structure.</span></span> <span data-ttu-id="56c09-119">Se il contesto è un valore, il relativo init di basso livello, **\_ una volta che i \_ \_ \_ bit riservati di CTX** , devono essere pari a zero.</span><span class="sxs-lookup"><span data-stu-id="56c09-119">If the context is a value, its low-order **INIT\_ONCE\_CTX\_RESERVED\_BITS** must be zero.</span></span> <span data-ttu-id="56c09-120">Se il contesto è una struttura di dati, è necessario che la struttura dei dati sia allineata a **DWORD**.</span><span class="sxs-lookup"><span data-stu-id="56c09-120">If the context is a data structure, the data structure must be **DWORD**-aligned.</span></span> <span data-ttu-id="56c09-121">Il contesto viene restituito al chiamante nel parametro di output *lpContext* della funzione [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) o [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) .</span><span class="sxs-lookup"><span data-stu-id="56c09-121">The context is returned to the caller in the *lpContext* output parameter of the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) or [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function.</span></span>

<span data-ttu-id="56c09-122">L'inizializzazione unica può essere eseguita in modo sincrono o asincrono.</span><span class="sxs-lookup"><span data-stu-id="56c09-122">One-time initialization can be performed synchronously or asynchronously.</span></span> <span data-ttu-id="56c09-123">Una funzione di callback facoltativa può essere utilizzata per l'inizializzazione unica sincrona.</span><span class="sxs-lookup"><span data-stu-id="56c09-123">An optional callback function can be used for synchronous one-time initialization.</span></span>

## <a name="synchronous-one-time-initialization"></a><span data-ttu-id="56c09-124">Inizializzazione unica sincrona</span><span class="sxs-lookup"><span data-stu-id="56c09-124">Synchronous One-time Initialization</span></span>

<span data-ttu-id="56c09-125">Nei passaggi seguenti viene descritta l'inizializzazione unica sincrona che non utilizza una funzione di callback.</span><span class="sxs-lookup"><span data-stu-id="56c09-125">The following steps describe synchronous one-time initialization that does not use a callback function.</span></span>

1.  <span data-ttu-id="56c09-126">Il primo thread per chiamare la funzione [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) fa sì che l'inizializzazione venga avviata una sola volta.</span><span class="sxs-lookup"><span data-stu-id="56c09-126">The first thread to call the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) function successfully causes one-time initialization to begin.</span></span> <span data-ttu-id="56c09-127">Per l'inizializzazione unica sincrona, è necessario chiamare **InitOnceBeginInitialize** senza il flag **init \_ once \_ asincrono** .</span><span class="sxs-lookup"><span data-stu-id="56c09-127">For synchronous one-time initialization, **InitOnceBeginInitialize** must be called without the **INIT\_ONCE\_ASYNC** flag.</span></span>
2.  <span data-ttu-id="56c09-128">I thread successivi che tentano l'inizializzazione vengono bloccati fino a quando il primo thread non completa l'inizializzazione o non riesce.</span><span class="sxs-lookup"><span data-stu-id="56c09-128">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="56c09-129">Se il primo thread ha esito negativo, il thread successivo può tentare l'inizializzazione e così via.</span><span class="sxs-lookup"><span data-stu-id="56c09-129">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="56c09-130">Al termine dell'inizializzazione, il thread chiama la funzione [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) .</span><span class="sxs-lookup"><span data-stu-id="56c09-130">When initialization is finished, the thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="56c09-131">Il thread può facoltativamente creare un oggetto di sincronizzazione (o altri dati di contesto) e specificarlo nel parametro *lpContext* della funzione **InitOnceComplete** .</span><span class="sxs-lookup"><span data-stu-id="56c09-131">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of the **InitOnceComplete** function.</span></span>
4.  <span data-ttu-id="56c09-132">Se l'inizializzazione ha esito positivo, lo stato della struttura di inizializzazione singola viene modificato in Initialized e l'handle *lpContext* (se presente) viene archiviato nella struttura di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-132">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="56c09-133">I tentativi di inizializzazione successivi restituiscono i dati di contesto.</span><span class="sxs-lookup"><span data-stu-id="56c09-133">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="56c09-134">Se l'inizializzazione ha esito negativo, i dati sono **null**.</span><span class="sxs-lookup"><span data-stu-id="56c09-134">If the initialization fails, the data is **NULL**.</span></span>

<span data-ttu-id="56c09-135">Nei passaggi seguenti viene descritta l'inizializzazione unica sincrona che utilizza una funzione di callback.</span><span class="sxs-lookup"><span data-stu-id="56c09-135">The following steps describe synchronous one-time initialization that uses a callback function.</span></span>

1.  <span data-ttu-id="56c09-136">Il primo thread per chiamare correttamente la funzione [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) passa un puntatore a una funzione di callback [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) definita dall'applicazione e ai dati richiesti dalla funzione di callback.</span><span class="sxs-lookup"><span data-stu-id="56c09-136">The first thread to successfully call the [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function passes a pointer to an application-defined [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) callback function and any data required by the callback function.</span></span> <span data-ttu-id="56c09-137">Se la chiamata ha esito positivo, viene eseguita la funzione di callback *InitOnceCallback* .</span><span class="sxs-lookup"><span data-stu-id="56c09-137">If the call succeeds, the *InitOnceCallback* callback function executes.</span></span>
2.  <span data-ttu-id="56c09-138">I thread successivi che tentano l'inizializzazione vengono bloccati fino a quando il primo thread non completa l'inizializzazione o non riesce.</span><span class="sxs-lookup"><span data-stu-id="56c09-138">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="56c09-139">Se il primo thread ha esito negativo, il thread successivo può tentare l'inizializzazione e così via.</span><span class="sxs-lookup"><span data-stu-id="56c09-139">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="56c09-140">Al termine dell'inizializzazione, la funzione di callback restituisce.</span><span class="sxs-lookup"><span data-stu-id="56c09-140">When initialization is finished, the callback function returns.</span></span> <span data-ttu-id="56c09-141">La funzione di callback può creare facoltativamente un oggetto di sincronizzazione (o altri dati di contesto) e specificarlo nel parametro di output del *contesto* .</span><span class="sxs-lookup"><span data-stu-id="56c09-141">The callback function can optionally create a synchronization object (or other context data) and specify it in its *Context* output parameter.</span></span>
4.  <span data-ttu-id="56c09-142">Se l'inizializzazione ha esito positivo, lo stato della struttura di inizializzazione monouso viene modificato in Initialized e l'handle del *contesto* , se presente, viene archiviato nella struttura di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-142">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *Context* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="56c09-143">I tentativi di inizializzazione successivi restituiscono i dati di contesto.</span><span class="sxs-lookup"><span data-stu-id="56c09-143">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="56c09-144">Se l'inizializzazione ha esito negativo, i dati sono **null**.</span><span class="sxs-lookup"><span data-stu-id="56c09-144">If the initialization fails, the data is **NULL**.</span></span>

## <a name="asynchronous-one-time-initialization"></a><span data-ttu-id="56c09-145">Inizializzazione unica asincrona</span><span class="sxs-lookup"><span data-stu-id="56c09-145">Asynchronous One-time Initialization</span></span>

<span data-ttu-id="56c09-146">Nei passaggi seguenti viene descritta l'inizializzazione unica asincrona.</span><span class="sxs-lookup"><span data-stu-id="56c09-146">The following steps describe asynchronous one-time initialization.</span></span>

1.  <span data-ttu-id="56c09-147">Se più thread tentano simultaneamente di iniziare l'inizializzazione chiamando [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) con **init \_ una volta \_ Async**, la funzione ha esito positivo per tutti i thread il cui parametro *fPending* è impostato su **true**.</span><span class="sxs-lookup"><span data-stu-id="56c09-147">If multiple threads simultaneously attempt to begin initialization by calling [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_ASYNC**, the function succeeds for all of the threads with the *fPending* parameter set to **TRUE**.</span></span> <span data-ttu-id="56c09-148">Solo un thread avrà effettivamente esito positivo in fase di inizializzazione. altri tentativi simultanei non modificano lo stato di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-148">Only one thread will actually succeed at initialization; other concurrent attempts do not change the initialization state.</span></span>
2.  <span data-ttu-id="56c09-149">Quando [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) restituisce, il parametro *fPending* indica lo stato di inizializzazione:</span><span class="sxs-lookup"><span data-stu-id="56c09-149">When [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) returns, the *fPending* parameter indicates the initialization status:</span></span>
    -   <span data-ttu-id="56c09-150">Se *fPending* è **false**, un thread ha avuto esito positivo in fase di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-150">If *fPending* is **FALSE**, one thread has succeeded at initialization.</span></span> <span data-ttu-id="56c09-151">Altri thread devono pulire tutti i dati di contesto creati e usare i dati di contesto nel parametro di output *lpContext* di [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span><span class="sxs-lookup"><span data-stu-id="56c09-151">Other threads should clean up any context data they have created and use the context data in the *lpContext* output parameter of [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span></span>
    -   <span data-ttu-id="56c09-152">Se *fPending* è **true**, l'inizializzazione non è ancora stata completata e gli altri thread continuano.</span><span class="sxs-lookup"><span data-stu-id="56c09-152">If *fPending* is **TRUE**, initialization has not yet completed and other threads should continue.</span></span>
3.  <span data-ttu-id="56c09-153">Ogni thread chiama la funzione [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) .</span><span class="sxs-lookup"><span data-stu-id="56c09-153">Each thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="56c09-154">Il thread può facoltativamente creare un oggetto di sincronizzazione (o altri dati di contesto) e specificarlo nel parametro *lpContext* di **InitOnceComplete**.</span><span class="sxs-lookup"><span data-stu-id="56c09-154">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of **InitOnceComplete**.</span></span>
4.  <span data-ttu-id="56c09-155">Quando [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) restituisce, il relativo valore restituito indica se il thread chiamante ha avuto esito positivo in fase di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-155">When [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) returns, its return value indicates whether the calling thread succeeded at initialization.</span></span>
    -   <span data-ttu-id="56c09-156">Se [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) ha esito positivo, il thread chiamante ha avuto esito positivo in fase di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-156">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) succeeds, the calling thread has succeeded at initialization.</span></span> <span data-ttu-id="56c09-157">Lo stato della struttura di inizializzazione monouso viene modificato in Initialized e l'handle *lpContext* (se presente) viene archiviato nella struttura di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-157">The state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span>
    -   <span data-ttu-id="56c09-158">Se [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) ha esito negativo, un altro thread ha completato l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="56c09-158">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) fails, another thread has succeeded at initialization.</span></span> <span data-ttu-id="56c09-159">Il thread chiamante deve pulire tutti i dati di contesto creati e chiamare [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) con **init \_ una sola volta \_ Check \_ solo** per recuperare i dati di contesto archiviati nella struttura di inizializzazione unica.</span><span class="sxs-lookup"><span data-stu-id="56c09-159">The calling thread should clean up any context data it has created and call [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_CHECK\_ONLY** to retrieve any context data stored in the one-time initialization structure.</span></span>

## <a name="calling-one-time-initialization-from-multiple-sites"></a><span data-ttu-id="56c09-160">Chiamata dell'inizializzazione di One-Time da più siti</span><span class="sxs-lookup"><span data-stu-id="56c09-160">Calling One-Time Initialization from multiple sites</span></span>

<span data-ttu-id="56c09-161">L'inizializzazione unica sorvegliata da una singola struttura **init \_ once** può essere eseguita da siti multipli. è possibile che vengano passati callback diversi da ogni sito e che la sincronizzazione con e senza callback possa essere mista.</span><span class="sxs-lookup"><span data-stu-id="56c09-161">One-time initialization guarded by a single **INIT\_ONCE** structure may be performed from mutiple sites; different callback may be passed from each site, and synchronization with and without callback may be mixed.</span></span> <span data-ttu-id="56c09-162">L'inizializzazione è ancora garantita per eseguire sucesfully una sola volta.</span><span class="sxs-lookup"><span data-stu-id="56c09-162">Initialization is still guaranted to perform sucesfully just once.</span></span>

<span data-ttu-id="56c09-163">L'inizializzazione asincrona e sincrona, tuttavia, non può essere mista: una volta eseguito un tentativo di inizializzazione asincrona, i tentativi di avviare l'inizializzazione sincrona</span><span class="sxs-lookup"><span data-stu-id="56c09-163">However, asynchronous and synchronous initialization cannot be mixed: once asynchronous initialization is attempted, attempts to start synchronous initialization would fail.</span></span>

## <a name="related-topics"></a><span data-ttu-id="56c09-164">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="56c09-164">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="56c09-165">Utilizzo dell'inizializzazione One-Time</span><span class="sxs-lookup"><span data-stu-id="56c09-165">Using One-Time Initialization</span></span>](using-one-time-initialization.md)
</dt> </dl>

 

 
