---
title: Prevenzione degli blocchi lato client
description: Esistono due modi in cui il client può bloccare la connettività di rete può causare la perdita delle richieste del server oppure il server stesso può arrestarsi in modo anomalo. Con le opzioni predefinite, la chiamata RPC non condurrà mai il timeout di una chiamata e il thread del client rimarrà in attesa di una risposta.
ms.assetid: 2c201e29-9d9c-48e6-b0b5-68e4b25c3fb7
keywords:
- RPC (Remote Procedure Call), procedure consigliate, impedire blocchi del client
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 18d4b5fc92ca18b575d081cd7b5abf90929e7df5
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "103727786"
---
# <a name="preventing-client-side-hangs"></a><span data-ttu-id="61587-105">Prevenzione degli blocchi lato client</span><span class="sxs-lookup"><span data-stu-id="61587-105">Preventing Client-side Hangs</span></span>

<span data-ttu-id="61587-106">È possibile bloccare il client in due modi: la connettività di rete può comportare la perdita delle richieste server oppure il server stesso può arrestarsi in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="61587-106">There are two ways your client can hang: network connectivity can cause server requests to become lost, or the server itself can crash.</span></span> <span data-ttu-id="61587-107">Con le opzioni predefinite, la chiamata RPC non condurrà mai il timeout di una chiamata e il thread del client rimarrà in attesa di una risposta.</span><span class="sxs-lookup"><span data-stu-id="61587-107">With default options, RPC will never time out a call, and your client thread will wait forever for a response.</span></span>

<span data-ttu-id="61587-108">Esistono due metodi per evitare questo problema: Keep-Alive e timeout.</span><span class="sxs-lookup"><span data-stu-id="61587-108">There are two methods to prevent this: keep alives and time outs.</span></span>

## <a name="tcp-keep-alives"></a><span data-ttu-id="61587-109">Keep-alive TCP</span><span class="sxs-lookup"><span data-stu-id="61587-109">TCP Keep Alives</span></span>

<span data-ttu-id="61587-110">Il client può essere configurato per eseguire periodicamente il ping del server per verificare che il server sia attivo e in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="61587-110">The client can be set up to periodically ping the server to ensure the server is alive and running.</span></span> <span data-ttu-id="61587-111">I ping sono Keep-alive TCP per le sequenze del protocollo [**\_ http**](/windows/desktop/Midl/ncacn-http) [**ncacn \_ \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) e ncacn e, di conseguenza, sono efficienti nell'utilizzo della CPU e della larghezza di banda di rete.</span><span class="sxs-lookup"><span data-stu-id="61587-111">The pings are TCP keep-alives for the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences, and as such, they are efficient in CPU utilization and network bandwidth.</span></span> <span data-ttu-id="61587-112">Per abilitare Keep Alive in una determinata chiamata di procedura remota, usare la funzione [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) prima dell'avvio della chiamata.</span><span class="sxs-lookup"><span data-stu-id="61587-112">To enable keep alives on a given remote procedure call, use the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function before the call is initiated.</span></span> <span data-ttu-id="61587-113">Questa funzione accetta un handle di binding e un timeout come argomenti.</span><span class="sxs-lookup"><span data-stu-id="61587-113">This function takes a binding handle and a time out as arguments.</span></span> <span data-ttu-id="61587-114">Ogni chiamata di procedura remota su questo handle di binding dopo **RpcMgmtSetComTimeout** usa il timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="61587-114">Every remote procedure call on this binding handle after **RpcMgmtSetComTimeout** uses the supplied time out.</span></span>

<span data-ttu-id="61587-115">Il parametro timeout per la funzione [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) specifica il tempo di attesa del tempo di esecuzione RPC prima che venga attivato Keep Alive.</span><span class="sxs-lookup"><span data-stu-id="61587-115">The Timeout parameter for the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function specifies how long the RPC run time waits before it turns on keep alives.</span></span> <span data-ttu-id="61587-116">Il timeout è un valore compreso tra 0 e 10, dove 0 indica il timeout minimo e 10 è il timeout infinito (nessun timeout).</span><span class="sxs-lookup"><span data-stu-id="61587-116">The time out is a value between 0 and 10, where 0 is the minimal time out, and 10 is infinite time out (no time out).</span></span> <span data-ttu-id="61587-117">Il timeout non è in secondi; la conversione dal valore di timeout fornito alla funzione **RpcMgmtSetComTimeout** ai secondi viene eseguita dal tempo di esecuzione RPC ed è specifica dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="61587-117">The time out itself is not in seconds; the translation from the time-out value supplied to the **RpcMgmtSetComTimeout** function to seconds is done by the RPC run time, and is implementation specific.</span></span>

<span data-ttu-id="61587-118">La tabella seguente fornisce la traduzione in secondi per Windows 2000 e Windows XP.</span><span class="sxs-lookup"><span data-stu-id="61587-118">The following table provides the translation to seconds for Windows 2000 and Windows XP.</span></span> <span data-ttu-id="61587-119">Le versioni future di Windows potrebbero modificare il mapping tra il parametro timeout e il valore di timeout in secondi:</span><span class="sxs-lookup"><span data-stu-id="61587-119">Future versions of Windows may change the mapping between the Timeout parameter and the time-out value in seconds:</span></span>

| <span data-ttu-id="61587-120">Parametro timeout</span><span class="sxs-lookup"><span data-stu-id="61587-120">Timeout parameter</span></span>                       | <span data-ttu-id="61587-121">Timeout effettivo in secondi</span><span class="sxs-lookup"><span data-stu-id="61587-121">Actual time out in seconds</span></span> |
|-----------------------------------------|----------------------------|
| <span data-ttu-id="61587-122">0 ( \_ \_ timeout minimo binding RPC c \_ \_ )</span><span class="sxs-lookup"><span data-stu-id="61587-122">0 (RPC\_C\_BINDING\_MIN\_TIMEOUT)</span></span>       | <span data-ttu-id="61587-123">120</span><span class="sxs-lookup"><span data-stu-id="61587-123">120</span></span>                        |
| <span data-ttu-id="61587-124">1</span><span class="sxs-lookup"><span data-stu-id="61587-124">1</span></span>                                       | <span data-ttu-id="61587-125">240</span><span class="sxs-lookup"><span data-stu-id="61587-125">240</span></span>                        |
| <span data-ttu-id="61587-126">2</span><span class="sxs-lookup"><span data-stu-id="61587-126">2</span></span>                                       | <span data-ttu-id="61587-127">360</span><span class="sxs-lookup"><span data-stu-id="61587-127">360</span></span>                        |
| <span data-ttu-id="61587-128">3</span><span class="sxs-lookup"><span data-stu-id="61587-128">3</span></span>                                       | <span data-ttu-id="61587-129">480</span><span class="sxs-lookup"><span data-stu-id="61587-129">480</span></span>                        |
| <span data-ttu-id="61587-130">4</span><span class="sxs-lookup"><span data-stu-id="61587-130">4</span></span>                                       | <span data-ttu-id="61587-131">600</span><span class="sxs-lookup"><span data-stu-id="61587-131">600</span></span>                        |
| <span data-ttu-id="61587-132">5 ( \_ \_ timeout predefinito associazione RPC C \_ \_ )</span><span class="sxs-lookup"><span data-stu-id="61587-132">5 (RPC\_C\_BINDING\_DEFAULT\_TIMEOUT)</span></span>   | <span data-ttu-id="61587-133">720</span><span class="sxs-lookup"><span data-stu-id="61587-133">720</span></span>                        |
| <span data-ttu-id="61587-134">6</span><span class="sxs-lookup"><span data-stu-id="61587-134">6</span></span>                                       | <span data-ttu-id="61587-135">840</span><span class="sxs-lookup"><span data-stu-id="61587-135">840</span></span>                        |
| <span data-ttu-id="61587-136">7</span><span class="sxs-lookup"><span data-stu-id="61587-136">7</span></span>                                       | <span data-ttu-id="61587-137">960</span><span class="sxs-lookup"><span data-stu-id="61587-137">960</span></span>                        |
| <span data-ttu-id="61587-138">8</span><span class="sxs-lookup"><span data-stu-id="61587-138">8</span></span>                                       | <span data-ttu-id="61587-139">1080</span><span class="sxs-lookup"><span data-stu-id="61587-139">1080</span></span>                       |
| <span data-ttu-id="61587-140">9 ( \_ \_ timeout massimo associazione RPC C \_ \_ )</span><span class="sxs-lookup"><span data-stu-id="61587-140">9 (RPC\_C\_BINDING\_MAX\_TIMEOUT)</span></span>       | <span data-ttu-id="61587-141">1200</span><span class="sxs-lookup"><span data-stu-id="61587-141">1200</span></span>                       |
| <span data-ttu-id="61587-142">10 ( \_ \_ timeout infinito associazione RPC C \_ \_ )</span><span class="sxs-lookup"><span data-stu-id="61587-142">10 (RPC\_C\_BINDING\_INFINITE\_TIMEOUT)</span></span> | <span data-ttu-id="61587-143">Timeout infinito</span><span class="sxs-lookup"><span data-stu-id="61587-143">Infinite time out</span></span>          |



 

<span data-ttu-id="61587-144">Una volta attivati i keep-alive, il client invia un pacchetto Keep-Alive ogni secondo.</span><span class="sxs-lookup"><span data-stu-id="61587-144">Once the keep alives are turned on, the client sends one keep alive packet every second.</span></span> <span data-ttu-id="61587-145">Se non è presente alcun riconoscimento dal server per tre o più Keep Alive, il client dichiara la connessione inattiva e non riesce a chiamare la procedura remota.</span><span class="sxs-lookup"><span data-stu-id="61587-145">If there is no acknowledgment from the server for three or more keep alives, the client declares the connection dead and fails the remote procedure call.</span></span> <span data-ttu-id="61587-146">Se il server invia una risposta entro il timeout specificato, Keep Alive non verrà attivato.</span><span class="sxs-lookup"><span data-stu-id="61587-146">If the server sends a response within the specified time out, keep alives will not be turned on.</span></span> <span data-ttu-id="61587-147">Se il server risponde per restare attivo, ma non risponde alla chiamata di procedura remota, il client continua a inviare keep alive.</span><span class="sxs-lookup"><span data-stu-id="61587-147">If the server responds to keep alives, but does not respond to the remote procedure call, the client continues sending keep alives.</span></span> <span data-ttu-id="61587-148">Una volta che il server risponde alla chiamata RPC, il Keep Alive viene disattivato.</span><span class="sxs-lookup"><span data-stu-id="61587-148">Once the server responds to the RPC call, the keep alives are turned off.</span></span> <span data-ttu-id="61587-149">Per Windows 2000, Keep Alive viene attivato solo per le chiamate RPC sincrone.</span><span class="sxs-lookup"><span data-stu-id="61587-149">For Windows 2000, keep alives are turned on only for synchronous RPC calls.</span></span> <span data-ttu-id="61587-150">Per Windows XP, i Keep Alive sono attivati anche per le chiamate RPC asincrone.</span><span class="sxs-lookup"><span data-stu-id="61587-150">For Windows XP, keep alives are turned on for asynchronous RPC calls as well.</span></span>

<span data-ttu-id="61587-151">Si tenta di impostare Keep-Alive sul valore più basso per garantire che l'applicazione client risponda tempestivamente ai problemi di rete.</span><span class="sxs-lookup"><span data-stu-id="61587-151">It is tempting to set keep alives to the lowest value to ensure the client application responds to network problems in a timely fashion.</span></span> <span data-ttu-id="61587-152">È necessario prestare particolare attenzione a tale tentazione e verificare che venga applicato un valore aggressivo.</span><span class="sxs-lookup"><span data-stu-id="61587-152">Careful consideration should be given to such temptation, and scrutiny applied to whether an aggressive value is warranted.</span></span> <span data-ttu-id="61587-153">Una volta ripristinato la connettività, un server che perde temporaneamente la connettività potrebbe trovarsi allagato con Keep-Alive da numerosi client.</span><span class="sxs-lookup"><span data-stu-id="61587-153">A server that temporarily loses connectivity may find itself flooded with keep alives from numerous clients once connectivity is restored.</span></span> <span data-ttu-id="61587-154">Inoltre, le attività di calcolo lunghe possono richiedere più di due minuti e il server potrebbe trovarsi a dover spendere più tempo della CPU rispondendo a Keep-Alive rispetto all'esecuzione di operazioni utili.</span><span class="sxs-lookup"><span data-stu-id="61587-154">In addition, long computational tasks can take more than two minutes, and the server may find itself spending more CPU time answering keep alives than performing useful work.</span></span> <span data-ttu-id="61587-155">Pertanto, è consigliabile utilizzare Keep Alive con moderazione.</span><span class="sxs-lookup"><span data-stu-id="61587-155">Therefore, keep alives should be used with moderation.</span></span> <span data-ttu-id="61587-156">Se il client non è in grado di tollerare che il thread venga associato per periodi prolungati, è necessario prendere in considerazione la RPC asincrona.</span><span class="sxs-lookup"><span data-stu-id="61587-156">If the client cannot tolerate its thread being tied up for long periods, asynchronous RPC should be considered.</span></span>

<span data-ttu-id="61587-157">Altre sequenze di protocollo possono implementare meccanismi diversi per il rilevamento di server che non rispondono, a seconda del trasporto usato.</span><span class="sxs-lookup"><span data-stu-id="61587-157">Other protocol sequences may implement different mechanisms for detecting unresponsive servers, depending on which transport is used.</span></span> <span data-ttu-id="61587-158">Il trasporto [**ncalrpc**](/windows/desktop/Midl/ncalrpc) non utilizza keep alive.</span><span class="sxs-lookup"><span data-stu-id="61587-158">The [**ncalrpc**](/windows/desktop/Midl/ncalrpc) transport does not use keep alives.</span></span> <span data-ttu-id="61587-159">Poiché tutte le comunicazioni in **ncalrpc** sono locali, se il server smette di rispondere mentre è in corso una chiamata, il tempo di esecuzione RPC sul client ha immediatamente esito negativo.</span><span class="sxs-lookup"><span data-stu-id="61587-159">Since all communications in **ncalrpc** are local, if the server becomes unresponsive while a call is in progress, the RPC run time on the client immediately fails the call.</span></span>

## <a name="call-time-outs"></a><span data-ttu-id="61587-160">Timeout chiamata</span><span class="sxs-lookup"><span data-stu-id="61587-160">Call Time Outs</span></span>

<span data-ttu-id="61587-161">I keep-alive TCP sono buoni se la connettività di rete viene persa o se il server si arresta in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="61587-161">TCP keep alives are fine if network connectivity is lost, or if the server crashes.</span></span> <span data-ttu-id="61587-162">Tuttavia, se il server si blocca in modalità utente, TCP Keep Alive viene restituito correttamente, ma la chiamata non viene mai restituita.</span><span class="sxs-lookup"><span data-stu-id="61587-162">But if the server deadlocks in user mode, TCP keep alives return successfully but the call will never return.</span></span> <span data-ttu-id="61587-163">Per gestire questo scenario, è stata aggiunta una nuova opzione di run-time per Windows XP: \_ timeout RPC C \_ opt \_ Call \_ .</span><span class="sxs-lookup"><span data-stu-id="61587-163">To deal with this scenario, a new run-time option was added for Windows XP: RPC\_C\_OPT\_CALL\_TIMEOUT.</span></span> <span data-ttu-id="61587-164">Questa opzione indica al runtime RPC di impostare un timer ogni volta che invia una richiesta al server.</span><span class="sxs-lookup"><span data-stu-id="61587-164">This option instructs the RPC run time to set up a timer each time it sends a request to the server.</span></span> <span data-ttu-id="61587-165">Se il timer scade, la chiamata viene annullata automaticamente e completata con la \_ chiamata RPC S \_ \_ annullata.</span><span class="sxs-lookup"><span data-stu-id="61587-165">If the timer expires, the call is automatically canceled and completes with RPC\_S\_CALL\_CANCELLED.</span></span> <span data-ttu-id="61587-166">Fino a quando il server risponde entro il limite di tempo specificato, il client non annulla la chiamata.</span><span class="sxs-lookup"><span data-stu-id="61587-166">As long as the server responds within the specified time limit, the client will not cancel the call.</span></span> <span data-ttu-id="61587-167">Ciò significa che una chiamata a più frammenti può richiedere più del periodo di timeout per il completamento, in quanto ogni risposta dal server viene ricevuta entro il periodo di timeout, anche se il periodo di tempo per tutte le risposte da raggiungere è maggiore del periodo di timeout.</span><span class="sxs-lookup"><span data-stu-id="61587-167">This means a multifragment call may take more than the time-out period to complete, as each response from the server is received within the time-out period, even though the time period for all responses to arrive was more than the time-out period.</span></span>

<span data-ttu-id="61587-168">Inoltre, quando viene annullata una chiamata, il server non riceve alcuna notifica dell'annullamento.</span><span class="sxs-lookup"><span data-stu-id="61587-168">Also, when a call is canceled the server is not notified of the cancellation.</span></span> <span data-ttu-id="61587-169">Il server, pertanto, eseguirà probabilmente la chiamata in un determinato momento e il client ignorerà semplicemente la risposta dal server.</span><span class="sxs-lookup"><span data-stu-id="61587-169">The server, therefore, will likely execute the call at some point, and the client will simply ignore the response from the server.</span></span>

<span data-ttu-id="61587-170">L'insidia più pericolosa con i timeout delle chiamate è la definizione di un breve timeout e l'esecuzione di un nuovo tentativo di chiamata sullo stesso server.</span><span class="sxs-lookup"><span data-stu-id="61587-170">The most dangerous pitfall with call time outs is establishing a short time out and retrying the call on the same server.</span></span> <span data-ttu-id="61587-171">Nello scenario seguente vengono illustrati i pericoli di questo approccio:</span><span class="sxs-lookup"><span data-stu-id="61587-171">The following scenario illustrates the dangers of this approach:</span></span>

<span data-ttu-id="61587-172">Immaginate un server che opera in prossimità della capacità.</span><span class="sxs-lookup"><span data-stu-id="61587-172">Imagine a server that operates near capacity.</span></span> <span data-ttu-id="61587-173">Dispone di un numero di client con timeout molto brevi, ad esempio cinque secondi.</span><span class="sxs-lookup"><span data-stu-id="61587-173">It has a number of clients with very short time outs, such as five seconds.</span></span> <span data-ttu-id="61587-174">Una perdita temporanea della connettività di rete o della congestione a un router causa un lasso di tempo nelle risposte del server per alcuni secondi.</span><span class="sxs-lookup"><span data-stu-id="61587-174">A temporary loss of network connectivity or congestion at a router causes a lapse in server replies for a few seconds.</span></span> <span data-ttu-id="61587-175">Nelle reti Ethernet questa situazione può essere facilmente causata da un picco di attività su un collegamento condiviso dal server con un altro computer.</span><span class="sxs-lookup"><span data-stu-id="61587-175">On Ethernet networks, this situation can easily be caused by a burst of activity on a link that the server shares with another machine.</span></span> <span data-ttu-id="61587-176">Il server non è in grado di inviare tutte le risposte prima del timeout di cinque secondi. I client ottengono le chiamate annullate e riprovano immediatamente.</span><span class="sxs-lookup"><span data-stu-id="61587-176">The server does not manage to send all replies before the five-second time out. The clients get their calls canceled, and immediately retry.</span></span> <span data-ttu-id="61587-177">Il server non è in grado di riconoscere che le chiamate sono tentativi e li esegue anche.</span><span class="sxs-lookup"><span data-stu-id="61587-177">The server is not aware the calls are retries, and executes them as well.</span></span> <span data-ttu-id="61587-178">Quindi, anziché eseguire il normale carico di lavoro delle chiamate, vengono eseguite 30-50% più chiamate, a seconda del numero di client che hanno raggiunto il timeout. Se questo supera la capacità e il server non è in grado di rispondere a tutti i client entro cinque secondi, al server viene inviato un altro round di chiamate.</span><span class="sxs-lookup"><span data-stu-id="61587-178">Thus, instead of executing its normal workload of calls, it executes 30-50% more calls, depending on how many clients timed out. If this exceeds its capacity, and the server cannot respond to all clients within five seconds, another round of calls are sent to the server.</span></span> <span data-ttu-id="61587-179">I client continuano a riemettere le stesse chiamate e, poiché il server è in overload per l'elaborazione delle chiamate precedenti, non è in grado di rispondere entro il timeout. Una volta risposto, i client hanno raggiunto il timeout, ha emesso una nuova chiamata ed eliminato la risposta.</span><span class="sxs-lookup"><span data-stu-id="61587-179">The clients keep reissuing the same calls, and since the server is overloaded processing previous calls, it is unable to respond within the time out. Once it responds, the clients have hit the time out, issued a new call, and discarded the answer.</span></span> <span data-ttu-id="61587-180">Nel peggiore dei casi, il server non verrà ripristinato fino al riavvio e, a seconda del modello di accesso client, potrebbe non essere ripristinato fino a quando non viene arrestato un numero sufficiente di client.</span><span class="sxs-lookup"><span data-stu-id="61587-180">In a worst case scenario, the server will not recover until reboot, and depending on client access pattern, may not recover until a sufficient number of clients are stopped.</span></span>

> [!Note]  
> <span data-ttu-id="61587-181">I timeout delle chiamate funzionano solo sulle sequenze di protocollo http [**\_ \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) e [**ncacn \_ http**](/windows/desktop/Midl/ncacn-http) ncacn.</span><span class="sxs-lookup"><span data-stu-id="61587-181">Call time outs work only on the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences.</span></span>

 

 

 