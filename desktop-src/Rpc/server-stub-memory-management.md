---
title: Gestione della memoria stub server
description: Gestione della memoria stub server
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Gestione della memoria stub server
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6e052df6da999e5371ac498a1d39852b4be2b5e
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/08/2020
ms.locfileid: "103873054"
---
# <a name="server-stub-memory-management"></a><span data-ttu-id="5e0c1-104">Gestione della memoria stub server</span><span class="sxs-lookup"><span data-stu-id="5e0c1-104">Server Stub Memory Management</span></span>

## <a name="an-introduction-to-server-stub-memory-management"></a><span data-ttu-id="5e0c1-105">Introduzione alla gestione della memoria Server-Stub</span><span class="sxs-lookup"><span data-stu-id="5e0c1-105">An Introduction to Server-Stub Memory Management</span></span>

<span data-ttu-id="5e0c1-106">Gli stub generati da MIDL fungono da interfaccia tra un processo client e un processo server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-106">MIDL-generated stubs act as the interface between a client process and a server process.</span></span> <span data-ttu-id="5e0c1-107">Uno Stub client esegue il marshalling di tutti i dati passati ai parametri contrassegnati con l'attributo [**\[ in \]**](../midl/in.md) e li invia allo stub del server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-107">A client stub marshals all data passed to parameters marked with the [**\[in\]**](../midl/in.md) attribute, and sends it to the server stub.</span></span> <span data-ttu-id="5e0c1-108">Lo stub del server, alla ricezione di questi dati, ricostruisce lo stack di chiamate e quindi esegue la corrispondente funzione Server implementata dall'utente.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-108">The server stub, upon receiving this data, reconstructs the call stack, and then executes the corresponding user-implemented server function.</span></span> <span data-ttu-id="5e0c1-109">Lo stub del server esegue anche il marshalling dei dati del parametro contrassegnati con l'attributo [**\[ out \]**](../midl/out-idl.md) e li restituisce all'applicazione client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-109">The server stub also marshals the parameter data marked with the [**\[out\]**](../midl/out-idl.md) attribute and returns it to the client application.</span></span>

<span data-ttu-id="5e0c1-110">Il formato dei dati con marshalling a 32 bit utilizzato da MSRPC è una versione conforme della sintassi di trasferimento di rappresentazione dei dati di rete (NDR).</span><span class="sxs-lookup"><span data-stu-id="5e0c1-110">The 32-bit marshaled data format used by MSRPC is a compliant version of the Network Data Representation (NDR) transfer syntax.</span></span> <span data-ttu-id="5e0c1-111">Per ulteriori informazioni su questo formato, vedere [il sito Web del gruppo Apri](https://www.opengroup.org/).</span><span class="sxs-lookup"><span data-stu-id="5e0c1-111">For more information about this format, see [The Open Group website](https://www.opengroup.org/).</span></span> <span data-ttu-id="5e0c1-112">Per le piattaforme a 64 bit, è possibile usare un'estensione Microsoft 64-bit per la sintassi di trasferimento di NDR denominata NDR64 per ottenere prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-112">For 64-bit platforms, a Microsoft 64-bit extension to NDR transfer syntax called NDR64 can be used for better performance.</span></span>

## <a name="unmarshaling-inbound-data"></a><span data-ttu-id="5e0c1-113">Unmarshalling dei dati in ingresso</span><span class="sxs-lookup"><span data-stu-id="5e0c1-113">Unmarshaling Inbound Data</span></span>

<span data-ttu-id="5e0c1-114">In MSRPC, lo stub client esegue il marshalling di tutti i dati dei parametri contrassegnati come [**\[ in \]**](../midl/in.md) in un buffer continuo per la trasmissione allo stub del server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-114">In MSRPC, the client stub marshals all of the parameter data tagged as [**\[in\]**](../midl/in.md) in one continuous buffer for transmission to the server stub.</span></span> <span data-ttu-id="5e0c1-115">Allo stesso modo, lo stub del server esegue il marshalling di tutti i dati contrassegnati con l'attributo [**\[ out \]**](../midl/out-idl.md) in un buffer continuo per tornare allo stub del client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-115">Likewise, the server stub marshals all data marked with the [**\[out\]**](../midl/out-idl.md) attribute in a continuous buffer for return to the client stub.</span></span> <span data-ttu-id="5e0c1-116">Sebbene il livello del protocollo di rete sotto RPC possa frammentare e packetize il buffer per la trasmissione, la frammentazione è trasparente per gli stub RPC.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-116">While the network protocol layer beneath RPC can fragment and packetize the buffer for transmission, the fragmentation is transparent to the RPC stubs.</span></span>

<span data-ttu-id="5e0c1-117">L'allocazione di memoria per la creazione del frame di chiamata del server può essere un'operazione costosa.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-117">Memory allocation for creating the server call frame can be an expensive operation.</span></span> <span data-ttu-id="5e0c1-118">Lo stub del server tenterà di ridurre al minimo l'utilizzo della memoria superflua, se possibile, e si presuppone che la routine del server non liberi o allochi i dati contrassegnati con gli attributi [**\[ in \]**](../midl/in.md) uscita o in **\[ uscita \]** .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-118">The server stub will attempt to minimize unnecessary memory usage when possible, and it is assumed that the server routine will not free or reallocate data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="5e0c1-119">Lo stub del server tenta di riutilizzare i dati nel buffer, quando possibile, per evitare la duplicazione non necessaria.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-119">The server stub attempts to reuse data in the buffer whenever possible to avoid unnecessary duplication.</span></span> <span data-ttu-id="5e0c1-120">La regola generale è che se il formato dei dati di cui è stato effettuato il marshalling corrisponde al formato di memoria, RPC utilizzerà i puntatori ai dati con marshalling anziché allocare memoria aggiuntiva per i dati formattati in modo identico.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-120">The general rule is that if the marshaled data format is the same as the memory format, RPC will use pointers to the marshalled data instead of allocating additional memory for identically formatted data.</span></span>

<span data-ttu-id="5e0c1-121">Ad esempio, la chiamata RPC seguente viene definita con una struttura il cui formato con marshalling è identico al formato in memoria.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-121">For example, the following RPC call is defined with a structure whose marshaled format is identical to its in-memory format.</span></span>

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

<span data-ttu-id="5e0c1-122">In questo caso, RPC non alloca memoria aggiuntiva per i dati a cui fa riferimento *plInStructure*. bensì semplicemente passa il puntatore ai dati di cui è stato eseguito il marshalling all'implementazione della funzione lato server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-122">In this case, RPC does not allocate additional memory for the data referenced by *plInStructure*; rather, it simply passes the pointer to the marshaled data to the server-side function implementation.</span></span> <span data-ttu-id="5e0c1-123">Lo stub del server RPC verifica il buffer durante il processo di unmarshalling se lo stub viene compilato usando il flag "-Solid", che è un'impostazione predefinita nella versione recente nmost del compilatore MIDL.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-123">The RPC server stub verifies the buffer during the unmarshaling process if the stub is compiled using the "-robust" flag (which is a default setting in the nmost recent version of the MIDL compiler).</span></span> <span data-ttu-id="5e0c1-124">RPC garantisce che i dati passati all'implementazione della funzione lato server siano validi.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-124">RPC guarantees that the data passed to the server-side function implementation is valid.</span></span>

<span data-ttu-id="5e0c1-125">Tenere presente che la memoria è allocata per *plOutStructure*, poiché nessun dato viene passato al server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-125">Be aware that memory is allocated for *plOutStructure*, since no data is passed to the server for it.</span></span>

## <a name="memory-allocation-for-inbound-data"></a><span data-ttu-id="5e0c1-126">Allocazione di memoria per i dati in ingresso</span><span class="sxs-lookup"><span data-stu-id="5e0c1-126">Memory Allocation for Inbound Data</span></span>

<span data-ttu-id="5e0c1-127">Possono verificarsi casi in cui lo stub del server alloca memoria per i dati dei parametri contrassegnati con gli attributi [**\[ in \]**](../midl/in.md) o in **\[ , out \]** .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-127">Cases can arise where the server stub allocates memory for parameter data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="5e0c1-128">Questo errore si verifica quando il formato dei dati di cui è stato effettuato il marshalling è diverso dal formato di memoria o quando le strutture che costituiscono i dati di cui è stato eseguito il marshalling sono sufficientemente complesse e devono essere lette in modo atomico dallo stub del server RPC.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-128">This occurs when the marshaled data format differs from the memory format, or when the structures that comprise the marshaled data are sufficient complex and must be read atomically by the RPC server stub.</span></span> <span data-ttu-id="5e0c1-129">Di seguito sono elencati alcuni casi comuni in cui è necessario allocare memoria per i dati ricevuti dallo stub del server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-129">Listed below are several common cases when memory must be allocated for data received by the server stub.</span></span>

-   <span data-ttu-id="5e0c1-130">I dati sono una matrice variabile o una matrice variabile conforme.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-130">The data is a varying array or a conformant varying array.</span></span> <span data-ttu-id="5e0c1-131">Si tratta di matrici (o puntatori a matrici) la cui [**\[ lunghezza \_ è () \]**](../midl/length-is.md) o il [**\[ primo attributo \_ è \]**](../midl/first-is.md) impostato su di essi.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-131">These are arrays (or pointers to arrays) that have the [**\[length\_is()\]**](../midl/length-is.md) or [**\[first\_is()\]**](../midl/first-is.md) attribute set on them.</span></span> <span data-ttu-id="5e0c1-132">In NDR viene effettuato il marshalling e la trasmissione solo del primo elemento di queste matrici.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-132">In NDR, only the first element of these arrays are marshaled and transmitted.</span></span> <span data-ttu-id="5e0c1-133">Nel frammento di codice seguente, ad esempio, per i dati passati nel parametro *PV* verrà allocata memoria.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-133">For example, in the code snippet below, the data passed in the parameter *pv* will have memory allocated for it.</span></span>

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   <span data-ttu-id="5e0c1-134">I dati sono una stringa di dimensioni o non conforme.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-134">The data is a sized string or non-conformant string.</span></span> <span data-ttu-id="5e0c1-135">Queste stringhe sono in genere puntatori a dati di tipo carattere contrassegnati con l'attributo [**\[ size \_ is () \]**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-135">These strings are usually pointers to character data tagged with the [**\[size\_is()\]**](../midl/size-is.md) attribute.</span></span> <span data-ttu-id="5e0c1-136">Nell'esempio seguente, alla stringa passata alla funzione lato server **SizedString** verrà allocata la memoria, mentre la stringa passata alla funzione **NormalString** verrà riutilizzata.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-136">In the example below, the string passed to the **SizedString** server-side function will have memory allocated, whereas the string passed to the **NormalString** function will be reused.</span></span>

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   <span data-ttu-id="5e0c1-137">I dati sono un tipo semplice le cui dimensioni della memoria sono diverse dalle dimensioni del marshalling, ad esempio **enum16** e **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-137">The data is a simple type whose memory size differs from its marshaled size, such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="5e0c1-138">I dati sono definiti da una struttura il cui allineamento di memoria è inferiore a quello naturale, contiene uno qualsiasi dei tipi di dati sopra indicati o con riempimento di byte finale.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-138">The data is defined by a structure whose memory alignment is smaller than the natural alignment, contains any of the above data types, or has trailing byte padding.</span></span> <span data-ttu-id="5e0c1-139">Ad esempio, la struttura dei dati complessa seguente ha forzato l'allineamento a 2 byte e ha la spaziatura interna alla fine.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-139">For example, the following complex data structure has forced 2-byte alignment and has padding at the end.</span></span>

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   <span data-ttu-id="5e0c1-140">I dati contengono una struttura che deve essere sottoposta a marshalling Field by Field.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-140">The data contains a structure that must be marshaled field by field.</span></span> <span data-ttu-id="5e0c1-141">Questi campi includono i puntatori di interfaccia definiti nelle interfacce DCOM; puntatori ignorati; valori integer impostati con l'attributo di [**\[ \] intervallo**](../midl/range.md) . gli elementi delle matrici definite con il [**\[ \_ \] marshalling di rete**](../midl/wire-marshal.md), il [**\[ \_ \] marshalling dell'utente**](../midl/user-marshal.md), la [**\[ trasmissione \_ come \]**](../midl/transmit-as.md) e [**\[ rappresentano \_ \]**](../midl/represent-as.md) gli attributi e le strutture di dati complesse incorporate.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-141">These fields include interface pointers defined in DCOM interfaces; ignored pointers; integer values set with the [**\[range\]**](../midl/range.md) attribute; elements of arrays defined with the [**\[wire\_marshal\]**](../midl/wire-marshal.md), [**\[user\_marshal\]**](../midl/user-marshal.md), [**\[transmit\_as\]**](../midl/transmit-as.md) and [**\[represent\_as\]**](../midl/represent-as.md) attributes; and embedded complex data structures.</span></span>
-   <span data-ttu-id="5e0c1-142">I dati contengono un'Unione, una struttura contenente un'Unione o una matrice di unioni.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-142">The data contains a union, a structure containing a union, or an array of unions.</span></span> <span data-ttu-id="5e0c1-143">Viene eseguito il marshalling in transito solo del ramo specifico dell'Unione.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-143">Only the specific branch of the union is marshaled on the wire.</span></span>
-   <span data-ttu-id="5e0c1-144">I dati contengono una struttura con una matrice conforme a più dimensioni con almeno una dimensione non fissa.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-144">The data contains a structure with a multidimensional conformant array that has at least one non-fixed dimension.</span></span>
-   <span data-ttu-id="5e0c1-145">I dati contengono una matrice di strutture complesse.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-145">The data contains an array of complex structures.</span></span>
-   <span data-ttu-id="5e0c1-146">I dati contengono una matrice di tipi di dati semplici, ad esempio **enum16** e **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-146">The data contains an array of simple data types such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="5e0c1-147">I dati contengono una matrice di puntatori Ref e Interface.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-147">The data contains an array of ref and interface pointers.</span></span>
-   <span data-ttu-id="5e0c1-148">Ai dati è applicato un attributo [**\[ Force \_ allocate \]**](../midl/force-allocate.md) a un puntatore.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-148">The data has a [**\[force\_allocate\]**](../midl/force-allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="5e0c1-149">Ai dati è applicato un attributo [**\[ allocate (tutti i \_ nodi) \]**](../midl/allocate.md) a un puntatore.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-149">The data has a [**\[allocate(all\_nodes)\]**](../midl/allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="5e0c1-150">Per i dati è stato applicato un attributo di [**\[ \_ conteggio \] byte**](../midl/byte-count.md) a un puntatore.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-150">The data has a [**\[byte\_count\]**](../midl/byte-count.md) attribute applied to a pointer.</span></span>

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a><span data-ttu-id="5e0c1-151">Sintassi di NDR64 e di trasferimento dei dati a 64 bit</span><span class="sxs-lookup"><span data-stu-id="5e0c1-151">64-bit Data and NDR64 Transfer Syntax</span></span>

<span data-ttu-id="5e0c1-152">Come indicato in precedenza, i dati a 64 bit vengono sottoposte a marshalling mediante una specifica sintassi di trasferimento a 64 bit denominata NDR64.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-152">As mentioned previously, 64-bit data is marshalled using a specific 64-bit transfer syntax called NDR64.</span></span> <span data-ttu-id="5e0c1-153">Questa sintassi di trasferimento è stata sviluppata per risolvere il problema specifico che si verifica quando viene effettuato il marshalling di puntatori in un rapporto di MANCAto a 32 bit e trasmesso a uno stub server in una piattaforma a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-153">This transfer syntax was developed to address the specific issue that arises when pointers are marshaled under 32-bit NDR and transmitted to a server-stub on a 64-bit platform.</span></span> <span data-ttu-id="5e0c1-154">In questo caso, un puntatore a dati a 32 bit con marshalling non corrisponde a un bit a 64 bit e l'allocazione di memoria si verificherà in modo invariabilmente.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-154">In this case, a marshaled 32-bit data pointer does not match a 64-bit one, and memory allocation will invariably occur.</span></span> <span data-ttu-id="5e0c1-155">Per creare un comportamento più coerente sulle piattaforme a 64 bit, Microsoft ha sviluppato una nuova sintassi di trasferimento denominata NDR64.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-155">To create a more consistent behavior on 64-bit platforms, Microsoft developed a new transfer syntax called NDR64.</span></span>

<span data-ttu-id="5e0c1-156">Di seguito è riportato un esempio che illustra questo problema:</span><span class="sxs-lookup"><span data-stu-id="5e0c1-156">An example illustrating this problem is as follows:</span></span>


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



<span data-ttu-id="5e0c1-157">Questa struttura, se sottoposta a marshalling, viene riutilizzata dallo stub del server in un sistema a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-157">This structure, when marshaled, will be reused by the server stub on a 32-bit system.</span></span> <span data-ttu-id="5e0c1-158">Tuttavia, se lo stub del server risiede in un sistema a 64 bit, i dati con marshalling NDR hanno una lunghezza di 4 byte, ma le dimensioni della memoria richieste saranno 8.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-158">However, if the server stub resides on a 64-bit system, the NDR-marshaled data is 4 bytes in length, but the required memory size will be 8.</span></span> <span data-ttu-id="5e0c1-159">Di conseguenza, l'allocazione di memoria viene forzata e il riutilizzo del buffer si verifica raramente.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-159">As a result, memory allocation is forced, and buffer reuse will rarely occur.</span></span> <span data-ttu-id="5e0c1-160">NDR64 risolve questo problema rendendo le dimensioni del marshalling di un puntatore a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-160">NDR64 addresses this problem by making the marshaled size of a pointer 64-bit.</span></span>

<span data-ttu-id="5e0c1-161">A differenza del NDR a 32 bit, i dati semplici Tyes, ad esempio **enum16** e **\_ \_ int3264** , non rendono una struttura o una matrice complessa in NDR64.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-161">In contrast with 32-bit NDR, simple data tyes such as **enum16** and **\_\_int3264** do not make a structure or array complex under NDR64.</span></span> <span data-ttu-id="5e0c1-162">Analogamente, i valori di riempimento finali non rendono una struttura complessa.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-162">Likewise, trailing pad values do not make a structure complex.</span></span> <span data-ttu-id="5e0c1-163">I puntatori di interfaccia vengono trattati come puntatori univoci al livello superiore; di conseguenza, le strutture e le matrici che contengono puntatori di interfaccia non sono considerate complesse e non richiedono l'allocazione di memoria specifica per l'utilizzo.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-163">Interface pointers are treated as unique pointers at the top level; as a result, structures and arrays containing interface pointers are not considered complex and will not require specific memory allocation for their use.</span></span>

## <a name="initializing-outbound-data"></a><span data-ttu-id="5e0c1-164">Inizializzazione dei dati in uscita</span><span class="sxs-lookup"><span data-stu-id="5e0c1-164">Initializing Outbound Data</span></span>

<span data-ttu-id="5e0c1-165">Dopo l'unmarshalling di tutti i dati in ingresso, lo stub del server deve inizializzare i puntatori solo in uscita contrassegnati con l'attributo [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-165">After all of the inbound data has been unmarshalled, the server stub needs to initialize the outbound-only pointers marked with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span>


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



<span data-ttu-id="5e0c1-166">Nella chiamata precedente lo stub del server deve inizializzare *plOutStructure* perché non era presente nei dati sottoposti a marshalling ed è un puntatore di [**\[ riferimento \]**](../midl/ref.md) implicito che deve essere reso disponibile all'implementazione della funzione server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-166">In the above call, the server stub must initialize *plOutStructure* because it was not present in the marshaled data, and it is an implied [**\[ref\]**](../midl/ref.md) pointer that must be made available to the server function implementation.</span></span> <span data-ttu-id="5e0c1-167">Lo stub del server RPC Inizializza e azzera tutti i puntatori di solo riferimento di primo livello con l'attributo [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-167">The RPC server stub initializes and zeroes out any top-level reference-only pointers with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span> <span data-ttu-id="5e0c1-168">Tutti i puntatori di riferimento al di sotto di esso vengono inizializzati in modo ricorsivo. **\[ \]**</span><span class="sxs-lookup"><span data-stu-id="5e0c1-168">Any **\[out\]** reference pointers beneath it are recursively initialized as well.</span></span> <span data-ttu-id="5e0c1-169">La ricorsione viene arrestata in corrispondenza di tutti i puntatori con attributi [**\[ Unique \]**](../midl/unique.md) o [**\[ ptr \]**](../midl/ptr.md) impostati su di essi.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-169">The recursion stops at any pointers with the [**\[unique\]**](../midl/unique.md) or [**\[ptr\]**](../midl/ptr.md) attributes set on them.</span></span>

<span data-ttu-id="5e0c1-170">L'implementazione della funzione server non può modificare direttamente i valori di puntatore di primo livello e pertanto non può riallocarli.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-170">The server function implementation cannot directly alter top-level pointer values, and thus cannot reallocate them.</span></span> <span data-ttu-id="5e0c1-171">Nell'implementazione di **ProcessRpcStructure** precedente, ad esempio, il codice seguente non è valido:</span><span class="sxs-lookup"><span data-stu-id="5e0c1-171">For example, in the implementation of **ProcessRpcStructure** above, the following code is invalid:</span></span>


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



<span data-ttu-id="5e0c1-172">*plOutStructure* è un valore dello stack e la relativa modifica non viene propagata a RPC.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-172">*plOutStructure* is a stack value and its change is not propagated back to RPC.</span></span> <span data-ttu-id="5e0c1-173">L'implementazione della funzione server può tentare di evitare l'allocazione tentando di liberare *plOutStructure*, il che potrebbe causare un danneggiamento della memoria.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-173">The server function implementation can attempt to avoid allocation by attempting to free *plOutStructure*, which may result in memory corruption.</span></span> <span data-ttu-id="5e0c1-174">Lo stub del server alloca quindi spazio per il puntatore di primo livello nella memoria (nel caso di puntatore a puntatore) e una struttura semplice di primo livello la cui dimensione nello stack è inferiore al previsto.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-174">The server stub will then allocate space for the top-level pointer in memory (in the pointer-to-pointer case) and a top-level simple structure whose size on the stack is smaller than expected.</span></span>

<span data-ttu-id="5e0c1-175">In determinate circostanze, il client può specificare le dimensioni di allocazione della memoria del lato server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-175">The client can, under certain circumstances, specify the memory allocation size of the server side.</span></span> <span data-ttu-id="5e0c1-176">Nell'esempio seguente il client specifica le dimensioni dei dati in uscita nel parametro delle *dimensioni* in ingresso.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-176">In the following example, the client specifies the size of the outbound data in the inbound *size* parameter.</span></span>

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

<span data-ttu-id="5e0c1-177">Dopo l'unmarshalling dei dati in ingresso, incluse le *dimensioni*, lo stub del server alloca un buffer per *PV* con una dimensione di "sizeof (Char) \* size".</span><span class="sxs-lookup"><span data-stu-id="5e0c1-177">After unmarshalling the inbound data, including *size*, the server stub allocates a buffer for *pv* with a size of "sizeof(char)\*size".</span></span> <span data-ttu-id="5e0c1-178">Dopo che lo spazio è stato allocato, lo stub del server Azzera il buffer.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-178">After the space has been allocated, the server stub zeroes out the buffer.</span></span> <span data-ttu-id="5e0c1-179">Si noti che in questo caso specifico lo stub alloca la memoria con l' **\_ utente MIDL \_ allocate ()**, perché la dimensione del buffer è determinata in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-179">Note that in this particular case, the stub allocates the memory with **MIDL\_user\_allocate()**, since the size of the buffer is determined at runtime.</span></span>

<span data-ttu-id="5e0c1-180">Si tenga presente che, nel caso di interfacce DCOM, gli stub generati da MIDL potrebbero non essere necessari se il client e il server condividono lo stesso apartment COM o se **ICallFrame** è implementato.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-180">Be aware that in the case of DCOM interfaces, MIDL-generated stubs may not be involved at all if the client and server share the same COM apartment, or if **ICallFrame** is implemented.</span></span> <span data-ttu-id="5e0c1-181">In questo caso, il server non può dipendere dal comportamento di allocazione e deve verificare in modo indipendente la memoria di dimensioni client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-181">In this case, the server cannot depend on the allocation behavior, and needs to independently verify client-sized memory.</span></span>

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a><span data-ttu-id="5e0c1-182">Implementazioni di funzioni sul lato server e marshalling dei dati in uscita</span><span class="sxs-lookup"><span data-stu-id="5e0c1-182">Server-side Function Implementations and Outbound Data Marshaling</span></span>

<span data-ttu-id="5e0c1-183">Immediatamente dopo l'unmarshalling sui dati in ingresso e l'inizializzazione della memoria allocata per contenere dati in uscita, lo stub del server RPC esegue l'implementazione lato server della funzione chiamata dal client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-183">Immediately subsequent to the unmarshalling on inbound data and the initialization of the memory allocated to contain outbound data, the RPC server stub executes the server-side implementation of the function called by the client.</span></span> <span data-ttu-id="5e0c1-184">Al momento, il server può modificare i dati contrassegnati in modo specifico con l'attributo **\[ in \] , out** e può popolare la memoria allocata per i dati in uscita (i dati contrassegnati con [**\[ out \]**](../midl/out-idl.md)).</span><span class="sxs-lookup"><span data-stu-id="5e0c1-184">At this time, the server can modify the data specifically marked with the **\[in, out\]** attribute, and it can populate the memory allocated for outbound-only data (the data tagged with [**\[out\]**](../midl/out-idl.md)).</span></span>

<span data-ttu-id="5e0c1-185">Le regole generali per la manipolazione dei dati dei parametri con marshalling sono semplici: il server può allocare solo la nuova memoria o modificare la memoria allocata in modo specifico dallo stub del server.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-185">The general rules for the manipulation of marshalled parameter data are simple: the server can only allocate new memory or modify the memory specifically allocated by the server stub.</span></span> <span data-ttu-id="5e0c1-186">La riallocazione o il rilascio della memoria esistente per i dati può influire negativamente sui risultati e sulle prestazioni della chiamata di funzione e può essere molto difficile eseguire il debug.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-186">Reallocating or releasing existing memory for data can have a negative impact on the results and performance of the function call, and can be very difficult to debug.</span></span>

<span data-ttu-id="5e0c1-187">Logicamente, il server RPC si trova in uno spazio di indirizzi diverso rispetto a quello del client e in genere può presumere che non condividono la memoria.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-187">Logically, the RPC server lives in a different address space than the client, and it can generally be assumed that they do not share memory.</span></span> <span data-ttu-id="5e0c1-188">Di conseguenza, l'implementazione della funzione server può utilizzare i dati contrassegnati con l'attributo [**\[ in \]**](../midl/in.md) come memoria "Scratch" senza influire sugli indirizzi di memoria del client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-188">As a result, it is safe for the server function implementation to use the data marked with the [**\[in\]**](../midl/in.md) attribute as "scratch" memory without affecting the client memory addresses.</span></span> <span data-ttu-id="5e0c1-189">Detto questo, il server non deve tentare di riallocare o **rilasciare \[ \] i** dati, lasciando il controllo di tali spazi allo stub del server RPC.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-189">That said, the server should not attempt to reallocate or release **\[in\]** data, leaving the control of those spaces to the RPC server stub itself.</span></span>

<span data-ttu-id="5e0c1-190">In genere, l'implementazione della funzione server non deve riallocare o rilasciare i dati contrassegnati con l'attributo **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-190">Generally, the server function implementation does not need to reallocate or release data marked with the **\[in, out\]** attribute.</span></span> <span data-ttu-id="5e0c1-191">Per i dati a dimensione fissa, la logica di implementazione della funzione può modificare direttamente i dati.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-191">For fixed size data, the function implementation logic can directly modify the data.</span></span> <span data-ttu-id="5e0c1-192">Analogamente, per i dati a dimensione variabile, l'implementazione della funzione non deve modificare il valore del campo fornito all'attributo [**\[ size \_ is () \]**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-192">Likewise, for variable-sized data, the function implementation must not modify the field value supplied to the [**\[size\_is()\]**](../midl/size-is.md) attribute, either.</span></span> <span data-ttu-id="5e0c1-193">Modificare il valore del campo utilizzato per ridimensionare i dati in un buffer più piccolo o più grande restituito al client, che potrebbe non essere in grado di gestire la lunghezza anomala.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-193">Change the field value used to size the data results in a smaller or larger buffer returned to the client which may be ill-equipped to deal with the abnormal length.</span></span>

<span data-ttu-id="5e0c1-194">Se si verificano situazioni in cui la routine del server deve riallocare la memoria utilizzata dai dati contrassegnati con l'attributo **\[ in, out \]** , è possibile che l'implementazione della funzione lato server non sia in grado di stabilire se il puntatore fornito dallo stub è alla memoria allocata con l' **\_ utente MIDL \_ allocato ()** o il buffer Wire di cui è stato effettuato il marshalling.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-194">If circumstances occur where the server routine has to reallocate the memory used by data marked with the **\[in, out\]** attribute, it is entirely possible that the server-side function implementation will not know if the pointer provided by the stub is to memory allocated with **MIDL\_user\_allocate()** or the marshaled wire buffer.</span></span> <span data-ttu-id="5e0c1-195">Per ovviare a questo problema, MS RPC può garantire che non si verifichino perdite di memoria o danneggiamenti se l'attributo [**\[ Force \_ allocate \]**](../midl/force-allocate.md) viene impostato sui dati.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-195">To work around this problem, MS RPC can ensure that no memory leak or corruption occurs if the [**\[force\_allocate\]**](../midl/force-allocate.md) attribute is set on the data.</span></span> <span data-ttu-id="5e0c1-196">Quando si imposta **\[ Force \_ allocate \]** , lo stub del server alloca sempre memoria per il puntatore, sebbene l'avvertenza riduca le prestazioni per ogni utilizzo.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-196">When **\[force\_allocate\]** is set, the server stub will always allocate memory for the pointer, although the caveat is that performance will decrease for every use of it.</span></span>

<span data-ttu-id="5e0c1-197">Quando la chiamata viene restituita dall'implementazione della funzione lato server, lo stub del server esegue il marshalling dei dati contrassegnati con l'attributo [**\[ out \]**](../midl/out-idl.md) e li invia al client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-197">When the call returns from the server-side function implementation, the server stub marshals the data marked with the [**\[out\]**](../midl/out-idl.md) attribute and sends it to the client.</span></span> <span data-ttu-id="5e0c1-198">Tenere presente che lo stub non esegue il marshalling dei dati se l'implementazione della funzione lato server genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-198">Be aware that the stub does not marshal the data if the server-side function implementation throws an exception.</span></span>

## <a name="releasing-allocated-memory"></a><span data-ttu-id="5e0c1-199">Rilascio della memoria allocata</span><span class="sxs-lookup"><span data-stu-id="5e0c1-199">Releasing Allocated Memory</span></span>

<span data-ttu-id="5e0c1-200">Lo stub del server RPC rilascerà la memoria dello stack dopo che la chiamata ha restituito dalla funzione sul lato server, indipendentemente dal fatto che si verifichi un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-200">The RPC server stub will release the stack memory after the call has returned from the server-side function, whether an exception occurs or not.</span></span> <span data-ttu-id="5e0c1-201">Lo stub del server libera tutta la memoria allocata dallo stub e la memoria allocata con **l' \_ utente MIDL \_ allocate ()**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-201">The server stub frees all memory allocated by the stub as well as any memory allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="5e0c1-202">L'implementazione della funzione sul lato server deve sempre assegnare a RPC uno stato coerente, generando un'eccezione o restituendo un codice di errore.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-202">The server-side function implementation must always give RPC a consistent state, either by throwing an exception or returning an error code.</span></span> <span data-ttu-id="5e0c1-203">Se la funzione ha esito negativo durante il popolamento di strutture di dati complesse, deve garantire che tutti i puntatori puntino a dati validi o siano impostati su **null**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-203">If the function fails during the population of complicated data structures, it must ensure that all pointers point to valid data or are set to **NULL**.</span></span>

<span data-ttu-id="5e0c1-204">Durante questo passaggio, lo stub del server libera tutta la memoria che non fa parte del buffer di cui è stato eseguito il marshalling che contiene [**\[ \] i dati.**](../midl/in.md)</span><span class="sxs-lookup"><span data-stu-id="5e0c1-204">During this pass, the server stub frees all memory that is not part of the marshaled buffer containing the [**\[in\]**](../midl/in.md) data.</span></span> <span data-ttu-id="5e0c1-205">Un'eccezione a questo comportamento è costituita dai dati con l'attributo [**\[ allocate (non \_ gratuito) \]**](../midl/allocate.md) . lo stub del server non libera alcuna memoria associata a tali puntatori.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-205">One exception to this behavior is data with the [**\[allocate(dont\_free)\]**](../midl/allocate.md) attribute set on them - the server stub does not free any memory associated with these pointers.</span></span>

<span data-ttu-id="5e0c1-206">Quando lo stub del server rilascia la memoria allocata dallo stub e dall'implementazione della funzione, lo stub chiama una funzione di notifica specifica se viene specificato l'attributo [**\[ Notify \_ flag \]**](../midl/notify-flag.md) per determinati dati.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-206">After the server stub releases the memory allocated by the stub and the function implementation, the stub calls a specific notification function if the [**\[notify\_flag\]**](../midl/notify-flag.md) attribute is specified for particular data.</span></span>

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a><span data-ttu-id="5e0c1-207">Marshalling di un elenco collegato tramite RPC, ad esempio</span><span class="sxs-lookup"><span data-stu-id="5e0c1-207">Marshalling a Linked List over RPC -- An Example</span></span>


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



<span data-ttu-id="5e0c1-208">Nell'esempio precedente, il formato di memoria per **LINKEDLIST** sarà identico al formato wire di cui è stato effettuato il marshalling.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-208">In the above example, the memory format for **LINKEDLIST** will be identical to the marshaled wire format.</span></span> <span data-ttu-id="5e0c1-209">Di conseguenza, lo stub del server non alloca memoria per l'intera catena di puntatori dati in *pin*.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-209">As a result, the server stub does not allocate memory for the entire chain of data pointers under *pIn*.</span></span> <span data-ttu-id="5e0c1-210">Invece, RPC riutilizza il buffer di trasmissione per l'intero elenco collegato.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-210">Rather, RPC reuses the wire buffer for the entire linked list.</span></span> <span data-ttu-id="5e0c1-211">Allo stesso modo, lo stub non alloca memoria per la *piedinatura*, ma riutilizza il buffer di rete sottoposto a marshalling dal client.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-211">Similarly, the stub does not allocate memory for *pInOut*, but instead reuses the wire buffer marshaled by the client.</span></span>

<span data-ttu-id="5e0c1-212">Poiché la firma della funzione contiene un parametro in uscita, il *broncio*, lo stub del server alloca memoria per contenere i dati restituiti.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-212">Because the function signature contains an outbound parameter, *pOut*, the server stub allocates memory to contain the returned data.</span></span> <span data-ttu-id="5e0c1-213">La memoria allocata viene inizialmente azzerata, con **pNext** impostato su **null**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-213">The allocated memory is initially zeroes out, with **pNext** set to **NULL**.</span></span> <span data-ttu-id="5e0c1-214">L'applicazione può allocare la memoria per un nuovo elenco collegato e puntare al *broncio* -> **pNext** .</span><span class="sxs-lookup"><span data-stu-id="5e0c1-214">The application can allocate the memory for a new linked list and point *pOut*->**pNext** to it.</span></span> <span data-ttu-id="5e0c1-215">il *pin* e l'elenco collegato che contiene possono essere usati come area scratch, ma l'applicazione non deve modificare i puntatori pNext.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-215">*pIn* and the linked list it contains can be used as a scratch area, but the application should not change any of the pNext pointers.</span></span>

<span data-ttu-id="5e0c1-216">L'applicazione può modificare liberamente il contenuto dell'elenco collegato a cui punta la *piedinatura*, ma non deve modificare alcuno dei puntatori **pNext** , tantomeno il collegamento di primo livello.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-216">The application can freely change the content of the linked list pointed to by *pInOut*, but it must not change any of the **pNext** pointers, let alone the top-level link itself.</span></span> <span data-ttu-id="5e0c1-217">Se l'applicazione decide di abbreviare l'elenco collegato, non è in grado di stabilire se un determinato puntatore **pNext** collega tto a un buffer interno RPC o a un buffer allocato in modo specifico con l' **\_ utente MIDL \_ allocate ()**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-217">If the application decides to shorten the linked list, it cannot know if any given **pNext** pointer links tto an RPC internal buffer or a buffer specifically allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="5e0c1-218">Per risolvere questo problema, aggiungere una dichiarazione di tipo specifico per i puntatori di elenco collegati che forzano l'allocazione degli utenti, come illustrato nel codice riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-218">To work around this issue, you add a specific type declaration for linked list pointers that forces user allocation, as seen in the code below.</span></span>

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

<span data-ttu-id="5e0c1-219">Questo attributo impone allo stub del server di allocare separatamente ogni nodo dell'elenco collegato e l'applicazione può liberare la parte abbreviata dell'elenco collegato chiamando l' **\_ utente MIDL \_ Free ()**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-219">This attribute forces the server stub to allocate each node of the linked list separately, and the application can free the shortened part of the linked list by calling **MIDL\_user\_free()**.</span></span> <span data-ttu-id="5e0c1-220">L'applicazione può quindi impostare in modo sicuro il puntatore **pNext** alla fine dell'elenco collegato appena abbreviato in **null**.</span><span class="sxs-lookup"><span data-stu-id="5e0c1-220">The application can then safely set the **pNext** pointer at the end of the newly-shortened linked list to **NULL**.</span></span>

 

 