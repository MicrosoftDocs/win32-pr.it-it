---
title: Ricerca di endpoint
description: I programmi server restano in ascolto degli endpoint per le richieste client. La sintassi della stringa dell'endpoint dipende dalla sequenza di protocollo utilizzata. L'endpoint per TCP/IP, ad esempio, è un numero di porta e la sintassi dell'endpoint per Named Pipes è un nome di pipe valido.
ms.assetid: 330bbe9f-b7e9-4a5b-86d8-824edec960d2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bb0a97df3408a4d3c24dff9de28553f9e4b2210d
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104337783"
---
# <a name="finding-endpoints"></a><span data-ttu-id="89ba4-105">Ricerca di endpoint</span><span class="sxs-lookup"><span data-stu-id="89ba4-105">Finding Endpoints</span></span>

<span data-ttu-id="89ba4-106">I programmi server restano in ascolto degli endpoint per le richieste client.</span><span class="sxs-lookup"><span data-stu-id="89ba4-106">Server programs listen to endpoints for client requests.</span></span> <span data-ttu-id="89ba4-107">La sintassi della stringa dell'endpoint dipende dalla sequenza di protocollo utilizzata.</span><span class="sxs-lookup"><span data-stu-id="89ba4-107">The syntax of the endpoint string depends on the protocol sequence you use.</span></span> <span data-ttu-id="89ba4-108">L'endpoint per TCP/IP, ad esempio, è un numero di porta e la sintassi dell'endpoint per Named Pipes è un nome di pipe valido.</span><span class="sxs-lookup"><span data-stu-id="89ba4-108">For example, the endpoint for TCP/IP is a port number, and the endpoint syntax for named pipes is a valid pipe name.</span></span>

<span data-ttu-id="89ba4-109">Esistono due tipi di endpoint: ben noti e dinamici.</span><span class="sxs-lookup"><span data-stu-id="89ba4-109">There are two types of endpoints: well-known and dynamic.</span></span> <span data-ttu-id="89ba4-110">La scelta del tipo di endpoint utilizzato dal programma determina se l'applicazione distribuita o la libreria di runtime specifica l'endpoint.</span><span class="sxs-lookup"><span data-stu-id="89ba4-110">Your choice of which type of endpoint your program uses determines whether the distributed application or the run-time library specifies the endpoint.</span></span>

<span data-ttu-id="89ba4-111">Questa sezione illustra gli endpoint e presenta informazioni su come trovarli.</span><span class="sxs-lookup"><span data-stu-id="89ba4-111">This section discusses endpoints and presents information on how to find them.</span></span> <span data-ttu-id="89ba4-112">Sono organizzati negli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="89ba4-112">It is organized into the following topics:</span></span>

-   [<span data-ttu-id="89ba4-113">Uso di endpoint Well-Known</span><span class="sxs-lookup"><span data-stu-id="89ba4-113">Using Well-Known Endpoints</span></span>](#using-well-known-endpoints)
-   [<span data-ttu-id="89ba4-114">Uso di endpoint dinamici</span><span class="sxs-lookup"><span data-stu-id="89ba4-114">Using Dynamic Endpoints</span></span>](#using-dynamic-endpoints)
-   [<span data-ttu-id="89ba4-115">Esportazione di endpoint Well-Known nel database di mapping degli endpoint</span><span class="sxs-lookup"><span data-stu-id="89ba4-115">Exporting Well-Known Endpoints Into the Endpoint Map Database</span></span>](#exporting-well-known-endpoints-into-the-endpoint-map-database)

> [!Note]  
> <span data-ttu-id="89ba4-116">I termini *endpoint statici* ed *endpoint noti* sono equivalenti e vengono usati in modo interscambiabile.</span><span class="sxs-lookup"><span data-stu-id="89ba4-116">The terms *static endpoints* and *well-known endpoints* are equivalent, and used interchangeably.</span></span>

 

<span data-ttu-id="89ba4-117">È possibile che l'applicazione client utilizzi la mappa dell'endpoint per determinare se un programma server è attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="89ba4-117">It is possible for your client application to use the endpoint map to determine whether or not a server program is currently running.</span></span> <span data-ttu-id="89ba4-118">Il client può chiamare [**RpcMgmtInqIfIds**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids), [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin)e [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) per verificare se il server ha registrato la particolare interfaccia richiesta nella mappa dell'endpoint.</span><span class="sxs-lookup"><span data-stu-id="89ba4-118">Your client can call [**RpcMgmtInqIfIds**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids), [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), and [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) to see if the server has registered the particular interface it requires in the endpoint map.</span></span>

## <a name="using-well-known-endpoints"></a><span data-ttu-id="89ba4-119">Uso di endpoint noti</span><span class="sxs-lookup"><span data-stu-id="89ba4-119">Using Well-known Endpoints</span></span>

<span data-ttu-id="89ba4-120">Gli endpoint noti sono endpoint pre-assegnati che il programma server utilizza ogni volta che viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="89ba4-120">Well-known endpoints are pre-assigned endpoints that the server program uses every time it runs.</span></span> <span data-ttu-id="89ba4-121">Poiché il server è sempre in ascolto di tale endpoint specifico, il client tenta sempre di connettersi a tale endpoint.</span><span class="sxs-lookup"><span data-stu-id="89ba4-121">Because the server always listens to that particular endpoint, the client always attempts to connect to it.</span></span> <span data-ttu-id="89ba4-122">Gli endpoint noti vengono in genere assegnati dall'autorità responsabile del protocollo di trasporto.</span><span class="sxs-lookup"><span data-stu-id="89ba4-122">Well-known endpoints are usually assigned by the authority responsible for the transport protocol.</span></span> <span data-ttu-id="89ba4-123">Poiché i computer host server hanno un numero finito di endpoint disponibili, gli sviluppatori di applicazioni sono fortemente sconsigliati di usare endpoint noti.</span><span class="sxs-lookup"><span data-stu-id="89ba4-123">Because server host computers have a finite number of available endpoints, application developers are strongly discouraged from using well-known endpoints.</span></span> <span data-ttu-id="89ba4-124">Un altro vantaggio degli endpoint dinamici è che semplificano la gestione e la manutenzione a lungo termine del sistema.</span><span class="sxs-lookup"><span data-stu-id="89ba4-124">Another advantage of dynamic endpoints is that they simplify long-term management and maintenance of the system.</span></span>

<span data-ttu-id="89ba4-125">Un'applicazione distribuita può specificare un endpoint noto in una stringa e passare tale stringa come parametro alla funzione [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep).</span><span class="sxs-lookup"><span data-stu-id="89ba4-125">A distributed application can specify a well-known endpoint in a string and pass that string as a parameter to the function [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep).</span></span> <span data-ttu-id="89ba4-126">In alternativa, la stringa dell'endpoint può essere visualizzata nell'intestazione dell'interfaccia del file IDL come parte dell'attributo dell'interfaccia dell' \[ [endpoint](/windows/desktop/Midl/endpoint) \] .</span><span class="sxs-lookup"><span data-stu-id="89ba4-126">Alternatively, the endpoint string can appear in the IDL file interface header as part of the \[ [endpoint](/windows/desktop/Midl/endpoint)\] interface attribute.</span></span>

<span data-ttu-id="89ba4-127">Per implementare l'endpoint noto, è possibile usare due approcci:</span><span class="sxs-lookup"><span data-stu-id="89ba4-127">You can use two approaches to implement the well-known endpoint:</span></span>

-   <span data-ttu-id="89ba4-128">Specificare tutte le informazioni in un'associazione di stringa</span><span class="sxs-lookup"><span data-stu-id="89ba4-128">Specify all information in a string binding</span></span>
-   <span data-ttu-id="89ba4-129">Archiviare l'endpoint noto nel database del servizio dei nomi</span><span class="sxs-lookup"><span data-stu-id="89ba4-129">Store the well-known endpoint in the name service database</span></span>

<span data-ttu-id="89ba4-130">È possibile scrivere tutte le informazioni necessarie per stabilire un'associazione in un'applicazione distribuita quando lo si sviluppa.</span><span class="sxs-lookup"><span data-stu-id="89ba4-130">You can write all of the information needed to establish a binding into a distributed application when you develop it.</span></span> <span data-ttu-id="89ba4-131">Il client può specificare l'endpoint noto direttamente in una stringa, chiamare [**errore in RpcStringBindingCompose**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) per creare una stringa che contiene tutte le informazioni di binding e fornire questa stringa alla funzione [**errore in RpcBindingFromStringBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) per ottenere un handle.</span><span class="sxs-lookup"><span data-stu-id="89ba4-131">The client can specify the well-known endpoint directly in a string, call [**RpcStringBindingCompose**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) to create a string that contains all the binding information, and supply this string to the function [**RpcBindingFromStringBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) to obtain a handle.</span></span> <span data-ttu-id="89ba4-132">Il client e il server possono essere hardcoded per utilizzare un endpoint noto o scritti in modo che le informazioni dell'endpoint provengano dalla riga di comando, da un file di dati, da un file di configurazione o dal file IDL.</span><span class="sxs-lookup"><span data-stu-id="89ba4-132">The client and server can be hard-coded to use a well-known endpoint, or written so that the endpoint information comes from the command line, a data file, a configuration file, or the IDL file.</span></span>

<span data-ttu-id="89ba4-133">L'applicazione client può anche eseguire una query su un database del servizio dei nomi per ottenere informazioni note sugli endpoint.</span><span class="sxs-lookup"><span data-stu-id="89ba4-133">Your client application can also query a name service database for well-known endpoint information.</span></span>

## <a name="using-dynamic-endpoints"></a><span data-ttu-id="89ba4-134">Uso di endpoint dinamici</span><span class="sxs-lookup"><span data-stu-id="89ba4-134">Using Dynamic Endpoints</span></span>

<span data-ttu-id="89ba4-135">Il numero di endpoint per un determinato server e una particolare sequenza di protocollo sono in genere limitati.</span><span class="sxs-lookup"><span data-stu-id="89ba4-135">The number of endpoints for a particular server and a particular protocol sequence are usually limited.</span></span> <span data-ttu-id="89ba4-136">Ad esempio, quando si utilizza la sequenza di protocollo [ \_ \_ TCP IP ncacn](/windows/desktop/Midl/ncacn-ip-tcp) , che indica che la comunicazione di rete RPC viene eseguita utilizzando TCP/IP, sono disponibili solo un numero limitato di porte (la maggior parte dei sistemi ha aperto solo l'intervallo da 1025 a 5000).</span><span class="sxs-lookup"><span data-stu-id="89ba4-136">For example, when you use the [ncacn\_ip\_tcp](/windows/desktop/Midl/ncacn-ip-tcp) protocol sequence, indicating that RPC network communication occurs using TCP/IP, only a limited number of ports are available (most systems have only the range 1025 through 5000 opened).</span></span> <span data-ttu-id="89ba4-137">Le librerie di runtime RPC consentono di assegnare gli endpoint in modo dinamico, in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="89ba4-137">The RPC run-time libraries allow you to assign endpoints dynamically, as needed.</span></span> <span data-ttu-id="89ba4-138">Poiché il numero degli UUID di interfaccia possibili è praticamente illimitato, l'uso dell'UUID dell'interfaccia per indirizzare la chiamata offre più spazio per l'espansione e una maggiore flessibilità.</span><span class="sxs-lookup"><span data-stu-id="89ba4-138">Since the number of possible interface UUIDs is practically unlimited, using the interface UUID to direct the call offers more room for expansion and more flexibility.</span></span>

<span data-ttu-id="89ba4-139">Per impostazione predefinita, le funzioni della libreria di runtime RPC eseguono la ricerca di informazioni sull'endpoint quando eseguono una query su un database del servizio.</span><span class="sxs-lookup"><span data-stu-id="89ba4-139">By default, the RPC run-time library functions search for endpoint information when they query a name service database.</span></span> <span data-ttu-id="89ba4-140">Se l'endpoint è dinamico, il database del servizio nomi non conterrà informazioni sull'endpoint.</span><span class="sxs-lookup"><span data-stu-id="89ba4-140">If the endpoint is dynamic, the name service database will not contain endpoint information.</span></span> <span data-ttu-id="89ba4-141">Tuttavia, la query fornirà al programma client il nome di un server.</span><span class="sxs-lookup"><span data-stu-id="89ba4-141">However, the query will give your client program the name of a server.</span></span> <span data-ttu-id="89ba4-142">Può quindi eseguire la ricerca nella mappa dell'endpoint del server.</span><span class="sxs-lookup"><span data-stu-id="89ba4-142">It can then search the server's endpoint map.</span></span>

<span data-ttu-id="89ba4-143">Se il client deve eseguire una chiamata di procedura remota utilizzando un endpoint dinamico, il metodo preferito consiste nel effettuare la chiamata su un handle di associazione parzialmente associato.</span><span class="sxs-lookup"><span data-stu-id="89ba4-143">If the client needs to make a remote procedure call using a dynamic endpoint, the preferred method is to make the call on a partially bound binding handle.</span></span> <span data-ttu-id="89ba4-144">Il runtime RPC risolve l'endpoint in modo trasparente.</span><span class="sxs-lookup"><span data-stu-id="89ba4-144">The RPC run time resolves the endpoint transparently.</span></span> <span data-ttu-id="89ba4-145">Questo metodo è superiore all'uso della funzione [**RpcEpResolveBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) , in quanto consente meccanismi avanzati di memorizzazione nella cache in fase di esecuzione RPC.</span><span class="sxs-lookup"><span data-stu-id="89ba4-145">This method is superior to using the [**RpcEpResolveBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) function, as it allows advanced caching mechanisms in the RPC run time.</span></span>

<span data-ttu-id="89ba4-146">Se è necessario un controllo più specifico sulla selezione dell'endpoint, i client possono cercare l'endpoint mappare una voce alla volta chiamando le funzioni [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), [**RpcMgmtEpEltInqNext**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext)e [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) .</span><span class="sxs-lookup"><span data-stu-id="89ba4-146">If more specific control over endpoint selection is required, clients can search the endpoint map one entry at a time by calling the [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), [**RpcMgmtEpEltInqNext**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext), and [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) functions.</span></span>

## <a name="exporting-well-known-endpoints-into-the-endpoint-map-database"></a><span data-ttu-id="89ba4-147">Esportazione di endpoint noti nel database di mapping degli endpoint</span><span class="sxs-lookup"><span data-stu-id="89ba4-147">Exporting Well-known Endpoints into the Endpoint Map Database</span></span>

<span data-ttu-id="89ba4-148">È possibile combinare i due approcci per trovare gli endpoint, soprattutto quando un sistema distribuito esegue la transizione da un modello di endpoint noto a un modello di endpoint dinamico.</span><span class="sxs-lookup"><span data-stu-id="89ba4-148">It is possible to mix the two approaches to finding endpoints, especially when a distributed system is transitioning from a well-known endpoint model to a dynamic endpoint model.</span></span> <span data-ttu-id="89ba4-149">In tali transizioni, una versione intermedia del server utilizzerà un endpoint noto, ma registrerà anche l'endpoint noto con il database di mapping degli endpoint.</span><span class="sxs-lookup"><span data-stu-id="89ba4-149">In such transitions, an intermediate version of the server will use a well-known endpoint, but it will also register the well-known endpoint with the endpoint map database.</span></span> <span data-ttu-id="89ba4-150">Questo approccio consente ai client che utilizzano endpoint e client noti che utilizzano un endpoint dinamico di connettersi.</span><span class="sxs-lookup"><span data-stu-id="89ba4-150">This approach allows clients that use well known endpoint and clients that use a dynamic endpoint to connect.</span></span> <span data-ttu-id="89ba4-151">Una volta che tutti i server sono stati aggiornati, è possibile distribuire una nuova versione del client che usa solo endpoint dinamici.</span><span class="sxs-lookup"><span data-stu-id="89ba4-151">Once all servers are upgraded, a new client version can be deployed that uses dynamic endpoints only.</span></span> <span data-ttu-id="89ba4-152">Una volta che tutti i client sono stati aggiornati, una versione finale del server può arrestare l'uso di endpoint noti e iniziare a usare solo gli endpoint dinamici.</span><span class="sxs-lookup"><span data-stu-id="89ba4-152">Once all clients are upgraded, a final server version can stop using well-known endpoints and begin using dynamic endpoints only.</span></span>

<span data-ttu-id="89ba4-153">Questo approccio consente un percorso di transizione per le applicazioni che sono state avviate con un endpoint noto, ma che desiderano eseguire la migrazione a un endpoint dinamico senza richiedere un aggiornamento simultaneo di tutti i server e i client.</span><span class="sxs-lookup"><span data-stu-id="89ba4-153">This approach allows a transition path for applications that have started with a well-known endpoint but want to migrate to a dynamic endpoint without requiring a simultaneous update of all servers and clients.</span></span>

 

 