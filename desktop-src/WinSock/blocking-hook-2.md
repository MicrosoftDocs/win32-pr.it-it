---
description: Sebbene questo meccanismo sia sufficiente per le applicazioni semplici, non può supportare i requisiti complessi per l'invio di messaggi di applicazioni più avanzate, ad esempio quelle che utilizzano il modello MDI (Multiple Document Interface).
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: Hook di blocco
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/07/2021
ms.locfileid: "106307042"
---
# <a name="blocking-hook"></a><span data-ttu-id="7e0ee-103">Hook di blocco</span><span class="sxs-lookup"><span data-stu-id="7e0ee-103">Blocking Hook</span></span>

<span data-ttu-id="7e0ee-104">Sebbene questo meccanismo sia sufficiente per le applicazioni semplici, non può supportare i requisiti complessi per l'invio di messaggi di applicazioni più avanzate, ad esempio quelle che utilizzano il modello MDI (Multiple Document Interface).</span><span class="sxs-lookup"><span data-stu-id="7e0ee-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="7e0ee-105">Per tali applicazioni, l'applicazione può installare un hook di blocco specifico del thread.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="7e0ee-106">Questa operazione verrà chiamata dal provider di servizi anziché dall'hook di blocco predefinito descritto nell'oggetto precedente.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="7e0ee-107">Un provider di servizi deve recuperare un puntatore all'hook di blocco per thread dal32.dll WS2 chiamando \_ [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span><span class="sxs-lookup"><span data-stu-id="7e0ee-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="7e0ee-108">Se l'applicazione non ha installato il proprio hook di blocco, verrà restituito un puntatore alla funzione di hook di blocco predefinita.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="7e0ee-109">Un provider di servizi Windows Sockets non può presupporre che un hook di blocco fornito dall'applicazione consenta la continuazione dell'elaborazione dei messaggi in quanto l'hook di blocco predefinito.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="7e0ee-110">Alcune applicazioni non possono tollerare la possibilità di messaggi rientranti mentre un'operazione di blocco è in attesa.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="7e0ee-111">Questa funzione hook di blocco di un'applicazione restituisce semplicemente **false**.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="7e0ee-112">Se un provider di servizi dipende dai messaggi per l'operazione interna, può eseguire **PeekMessage**(hMyWnd...) prima di eseguire l'hook di blocco dell'applicazione in modo che possa ottenere i propri messaggi senza influire sul resto del sistema.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="7e0ee-113">Non è installato alcun hook di blocco predefinito nelle versioni di Windows preemptive con multithreading.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="7e0ee-114">Ciò è dovuto al fatto che altri processi non verranno bloccati se una singola applicazione è in attesa del completamento di un'operazione (e, di conseguenza, non chiama **PeekMessage** o **GetMessage** , che fa sì che l'applicazione restituisca il processore in finestre non preemptive).</span><span class="sxs-lookup"><span data-stu-id="7e0ee-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="7e0ee-115">Quando il provider di servizi chiama [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) , viene restituito un puntatore null che indica che il provider deve usare funzioni native di blocco del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="7e0ee-116">Tuttavia, per mantenere la compatibilità con le versioni precedenti, è comunque possibile installare un hook di blocco fornito dall'applicazione per thread in Windows.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="7e0ee-117">Il provider di servizi Winsock chiama l'hook di blocco solo se si verificano tutte le condizioni seguenti: la routine è una che è definita come in grado di bloccarsi, il socket specificato è un socket di blocco e la richiesta non può essere completata immediatamente.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="7e0ee-118">Se vengono usati solo socket non di blocco e [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) anziché [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) , l'hook di blocco non verrà mai chiamato.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="7e0ee-119">Se, durante il periodo in cui viene usato pseudoblocking per bloccare un thread, viene ricevuto un messaggio di Windows per il thread, esiste il rischio che il thread tenti di emettere un'altra chiamata Winsock.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="7e0ee-120">A causa della difficoltà di gestire questa condizione in modo sicuro, la specifica di Windows Sockets 1,1 non consente questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="7e0ee-121">Non è consentito per un determinato thread effettuare più chiamate di funzione Winsock nidificate.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="7e0ee-122">È consentita una sola chiamata di funzione in attesa per un thread specifico.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="7e0ee-123">Qualsiasi chiamata di funzione Winsock nidificata ha esito negativo con l'errore WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="7e0ee-124">È opportuno sottolineare che questa restrizione si applica alle operazioni di blocco e non blocco, ma solo negli ambienti Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="7e0ee-125">Esistono alcune eccezioni a questa regola, incluse due funzioni che consentono a un'applicazione di determinare se un'operazione pseudoblocking è effettivamente in corso e di annullare tale operazione, se necessario.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="7e0ee-126">Questi elementi sono descritti di seguito.</span><span class="sxs-lookup"><span data-stu-id="7e0ee-126">These are described in the following.</span></span>

 

 

 
