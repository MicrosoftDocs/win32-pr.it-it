---
description: Un problema principale del porting di applicazioni da un ambiente Berkeley Sockets a un ambiente Windows prevede il blocco. ovvero richiamando una funzione che non restituisce un valore fino a quando l'operazione associata non viene completata.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Routine di blocco di Windows Sockets 1,1 e EINPROGRESS
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/07/2021
ms.locfileid: "106308869"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="aa8f7-103">Routine di blocco di Windows Sockets 1,1 e EINPROGRESS</span><span class="sxs-lookup"><span data-stu-id="aa8f7-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="aa8f7-104">Un problema principale del porting di applicazioni da un ambiente Berkeley Sockets a un ambiente Windows prevede il blocco. ovvero richiamando una funzione che non restituisce un valore fino a quando l'operazione associata non viene completata.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="aa8f7-105">Un problema si verifica quando l'operazione richiede un tempo arbitrariamente lungo per il completamento: un esempio è una funzione [**ricezione**](/windows/desktop/api/winsock/nf-winsock-recv) che può bloccarsi fino a quando i dati non sono stati ricevuti dal sistema peer.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="aa8f7-106">Il comportamento predefinito all'interno del modello di socket Berkeley prevede che un socket funzioni in modalità di blocco a meno che il programmatore non richieda esplicitamente che le operazioni vengano considerate come non bloccanti.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="aa8f7-107">Gli ambienti Windows Sockets 1,1 non possono presupporre la pianificazione di tipo preemptive.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="aa8f7-108">Pertanto, è consigliabile che i programmatori usino le operazioni non bloccanti (asincrone) se possibile con Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="aa8f7-109">Poiché questo non è sempre possibile, sono state fornite le funzionalità di pseudo-blocco descritte nei seguenti elementi.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="aa8f7-110">Windows Sockets 2 viene eseguito solo su sistemi operativi a 32 bit preemptive in cui i deadlock non rappresentano un problema.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="aa8f7-111">Le procedure di programmazione consigliate per Windows Sockets 1,1 non sono necessarie in Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="aa8f7-112">Anche in un socket di blocco, alcune funzioni, ovvero [**Bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)e [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) , ad esempio, vengono completate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="aa8f7-113">Non esiste alcuna differenza tra un blocco e un'operazione non di blocco per queste funzioni.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="aa8f7-114">Altre operazioni, ad esempio [**ricezione**](/windows/desktop/api/winsock/nf-winsock-recv), possono essere completate immediatamente o richiedere un tempo arbitrario per il completamento, a seconda delle diverse condizioni di trasporto.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="aa8f7-115">Quando vengono applicati a un socket di blocco, queste operazioni sono denominate operazioni di blocco.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="aa8f7-116">Le funzioni seguenti possono bloccare:</span><span class="sxs-lookup"><span data-stu-id="aa8f7-116">The following functions can block:</span></span>

-   [<span data-ttu-id="aa8f7-117">**ricezione**</span><span class="sxs-lookup"><span data-stu-id="aa8f7-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="aa8f7-118">**recvfrom**</span><span class="sxs-lookup"><span data-stu-id="aa8f7-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="aa8f7-119">**Invia**</span><span class="sxs-lookup"><span data-stu-id="aa8f7-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="aa8f7-120">**SendTo**</span><span class="sxs-lookup"><span data-stu-id="aa8f7-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="aa8f7-121">Con Windows Sockets 1,1 a 16 bit, un'operazione di blocco che non può essere completata immediatamente viene gestita dallo pseudo-blocco come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="aa8f7-122">Il provider di servizi avvia l'operazione, quindi immette un ciclo in cui invia tutti i messaggi di Windows (cedendo il processore a un altro thread, se necessario), quindi controlla il completamento della funzione Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="aa8f7-123">Se la funzione è stata completata o se [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) è stato richiamato, la funzione di blocco viene completata con un risultato appropriato.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="aa8f7-124">Un provider di servizi deve consentire l'installazione di una funzione hook di blocco che non elabora i messaggi per evitare la possibilità di messaggi rientranti mentre un'operazione di blocco è in attesa.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="aa8f7-125">La funzione di hook di blocco più semplice restituisce **false**.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="aa8f7-126">Se una DLL Windows Sockets dipende dai messaggi per l'operazione interna, può eseguire **PeekMessage**(**hMyWnd**...) prima di eseguire l'hook di blocco dell'applicazione in modo che possa ricevere i messaggi senza influire sul resto del sistema.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="aa8f7-127">In un ambiente Windows Sockets 1,1 a 16 bit, se viene ricevuto un messaggio di Windows per un processo per cui è in corso un'operazione di blocco, esiste il rischio che l'applicazione tenti di emettere un'altra chiamata di Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="aa8f7-128">A causa della difficoltà nella gestione sicura di questa condizione, Windows Sockets 1,1 non supporta tale comportamento dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="aa8f7-129">Un'applicazione non è autorizzata a eseguire più di una chiamata di funzione Windows Sockets nidificata.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="aa8f7-130">Per una determinata attività è consentita una sola chiamata di funzione in attesa.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="aa8f7-131">Le uniche eccezioni sono due funzioni fornite per supportare il programmatore in questa situazione: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) e [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span><span class="sxs-lookup"><span data-stu-id="aa8f7-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="aa8f7-132">La funzione [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) può essere chiamata in qualsiasi momento per determinare se è in corso una chiamata di blocco di Windows sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="aa8f7-133">Analogamente, la funzione [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) può essere chiamata in qualsiasi momento per annullare una chiamata di blocco in corso.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="aa8f7-134">Qualsiasi altra annidamento di funzioni Windows Sockets ha esito negativo con l'errore WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="aa8f7-135">È opportuno sottolineare che questa restrizione si applica alle operazioni di blocco e non blocco.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="aa8f7-136">Per le applicazioni Windows Sockets 2 che negoziano la versione 2,0 o una versione successiva al momento della chiamata a [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), non viene chiusa alcuna restrizione sull'annidamento delle operazioni.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="aa8f7-137">Le operazioni possono essere annidate in rare circostanze, ad esempio durante un callback di accettazione condizionale [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) , o se un provider di servizi richiama a sua volta una funzione di Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="aa8f7-138">Sebbene questo meccanismo sia sufficiente per le applicazioni semplici, non può supportare i requisiti complessi per l'invio di messaggi di applicazioni più avanzate, ad esempio quelli che usano il modello MDI.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="aa8f7-139">Per tali applicazioni, l'API di Windows Sockets include la funzione [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), che consente all'applicazione di specificare una routine speciale che può essere chiamata al posto della routine di invio dei messaggi predefinita descritta nella discussione precedente.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="aa8f7-140">Il provider Windows Sockets chiama l'hook di blocco solo se si verificano tutte le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="aa8f7-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="aa8f7-141">La routine è quella definita come in grado di bloccarsi.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="aa8f7-142">Il socket specificato è un socket di blocco.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="aa8f7-143">La richiesta non può essere completata immediatamente.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="aa8f7-144">Un socket è impostato su blocking per impostazione predefinita, ma la funzione [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) con l'IOCTL **FIONBIO** o la funzione [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) può impostare un socket sulla modalità di non blocco.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="aa8f7-145">L'hook di blocco non viene mai chiamato e non è necessario che l'applicazione sia interessata dai problemi di riapertura che possono essere introdotti dall'hook di blocco, se un'applicazione rispetta le linee guida seguenti:</span><span class="sxs-lookup"><span data-stu-id="aa8f7-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="aa8f7-146">USA solo socket non bloccati.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="aa8f7-147">Usa le routine [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) e/o **WSAAsyncGetXByY** anziché le routine [**Select**](/windows/desktop/api/Winsock2/nf-winsock2-select) e **getXbyY** .</span><span class="sxs-lookup"><span data-stu-id="aa8f7-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="aa8f7-148">Se un'applicazione Windows Sockets 1,1 richiama un'operazione asincrona o non bloccata che accetta un puntatore a un oggetto memoria (ad esempio, un buffer o una variabile globale), è responsabilità dell'applicazione garantire che l'oggetto sia disponibile per Windows Sockets durante l'operazione.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="aa8f7-149">L'applicazione non deve richiamare alcuna funzione di Windows che potrebbe influire sul mapping o affrontare la redditività della memoria in questione.</span><span class="sxs-lookup"><span data-stu-id="aa8f7-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



