---
description: Ogni sviluppatore che crea applicazioni in tempo reale che usano grafica 3D è preoccupato per l'ottimizzazione delle prestazioni. In questa sezione vengono fornite le linee guida per ottenere le migliori prestazioni dal codice.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Ottimizzazioni delle prestazioni (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4d42be994522f0d83e36387b1a5866b3eee10df3
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/06/2021
ms.locfileid: "104480692"
---
# <a name="performance-optimizations-direct3d-9"></a><span data-ttu-id="5d3a0-104">Ottimizzazioni delle prestazioni (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="5d3a0-104">Performance Optimizations (Direct3D 9)</span></span>

<span data-ttu-id="5d3a0-105">Ogni sviluppatore che crea applicazioni in tempo reale che usano grafica 3D è preoccupato per l'ottimizzazione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-105">Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization.</span></span> <span data-ttu-id="5d3a0-106">In questa sezione vengono fornite le linee guida per ottenere le migliori prestazioni dal codice.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-106">This section provides guidelines for getting the best performance from your code.</span></span>

-   [<span data-ttu-id="5d3a0-107">Suggerimenti generali sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="5d3a0-107">General Performance Tips</span></span>](#general-performance-tips)
-   [<span data-ttu-id="5d3a0-108">Database ed eliminazione</span><span class="sxs-lookup"><span data-stu-id="5d3a0-108">Databases and Culling</span></span>](#databases-and-culling)
-   [<span data-ttu-id="5d3a0-109">Primitive di batch</span><span class="sxs-lookup"><span data-stu-id="5d3a0-109">Batching Primitives</span></span>](#batching-primitives)
-   [<span data-ttu-id="5d3a0-110">Suggerimenti per l'illuminazione</span><span class="sxs-lookup"><span data-stu-id="5d3a0-110">Lighting Tips</span></span>](#lighting-tips)
-   [<span data-ttu-id="5d3a0-111">Dimensioni trama</span><span class="sxs-lookup"><span data-stu-id="5d3a0-111">Texture Size</span></span>](#texture-size)
-   [<span data-ttu-id="5d3a0-112">Trasformazioni con matrice</span><span class="sxs-lookup"><span data-stu-id="5d3a0-112">Matrix Transforms</span></span>](#matrix-transforms)
-   [<span data-ttu-id="5d3a0-113">Uso di trame dinamiche</span><span class="sxs-lookup"><span data-stu-id="5d3a0-113">Using Dynamic Textures</span></span>](#using-dynamic-textures)
-   [<span data-ttu-id="5d3a0-114">Uso dei buffer di indice e vertex dinamici</span><span class="sxs-lookup"><span data-stu-id="5d3a0-114">Using Dynamic Vertex and Index Buffers</span></span>](#using-dynamic-vertex-and-index-buffers)
-   [<span data-ttu-id="5d3a0-115">Uso di mesh</span><span class="sxs-lookup"><span data-stu-id="5d3a0-115">Using Meshes</span></span>](#using-meshes)
-   [<span data-ttu-id="5d3a0-116">Prestazioni del buffer Z</span><span class="sxs-lookup"><span data-stu-id="5d3a0-116">Z-Buffer Performance</span></span>](#z-buffer-performance)

## <a name="general-performance-tips"></a><span data-ttu-id="5d3a0-117">Suggerimenti generali sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="5d3a0-117">General Performance Tips</span></span>

-   <span data-ttu-id="5d3a0-118">Deselezionare solo quando è necessario.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-118">Clear only when you must.</span></span>
-   <span data-ttu-id="5d3a0-119">Ridurre al minimo le modifiche di stato e raggruppare le modifiche dello stato rimanenti.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-119">Minimize state changes and group the remaining state changes.</span></span>
-   <span data-ttu-id="5d3a0-120">Se possibile, utilizzare trame più piccole.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-120">Use smaller textures, if you can do so.</span></span>
-   <span data-ttu-id="5d3a0-121">Consente di creare oggetti nella scena dalla parte anteriore a quella posteriore.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-121">Draw objects in your scene from front to back.</span></span>
-   <span data-ttu-id="5d3a0-122">Usare le strisce di triangolo anziché gli elenchi e le ventole.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-122">Use triangle strips instead of lists and fans.</span></span> <span data-ttu-id="5d3a0-123">Per ottimizzare le prestazioni della cache dei vertici, disponi le strisce per riutilizzare i vertici del triangolo prima, anziché più tardi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-123">For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.</span></span>
-   <span data-ttu-id="5d3a0-124">Si riducono normalmente gli effetti speciali che richiedono una condivisione sproporzionata delle risorse di sistema.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-124">Gracefully degrade special effects that require a disproportionate share of system resources.</span></span>
-   <span data-ttu-id="5d3a0-125">Verifica costantemente le prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-125">Constantly test your application's performance.</span></span>
-   <span data-ttu-id="5d3a0-126">Ridurre al minimo le opzioni del buffer del vertice.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-126">Minimize vertex buffer switches.</span></span>
-   <span data-ttu-id="5d3a0-127">Usare i buffer dei vertici statici laddove possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-127">Use static vertex buffers where possible.</span></span>
-   <span data-ttu-id="5d3a0-128">Usare un buffer di vertex statico di grandi dimensioni per ogni FVF per gli oggetti statici, anziché uno per ogni oggetto.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-128">Use one large static vertex buffer per FVF for static objects, rather than one per object.</span></span>
-   <span data-ttu-id="5d3a0-129">Se l'applicazione richiede l'accesso casuale al buffer dei vertici nella memoria AGP, scegliere una dimensione del formato del vertice che corrisponde a un multiplo di 32 byte.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-129">If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes.</span></span> <span data-ttu-id="5d3a0-130">In caso contrario, selezionare il formato più piccolo appropriato.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-130">Otherwise, select the smallest appropriate format.</span></span>
-   <span data-ttu-id="5d3a0-131">Viene disegnato usando le primitive indicizzate.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-131">Draw using indexed primitives.</span></span> <span data-ttu-id="5d3a0-132">Ciò può consentire una memorizzazione nella cache dei vertici più efficiente all'interno dell'hardware.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-132">This can allow for more efficient vertex caching within hardware.</span></span>
-   <span data-ttu-id="5d3a0-133">Se il formato del buffer di profondità contiene un canale dello stencil, deselezionare sempre la profondità e i canali dello stencil nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-133">If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.</span></span>
-   <span data-ttu-id="5d3a0-134">Combinare l'istruzione dello shader e l'output dei dati laddove possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-134">Combine the shader instruction and the data output where possible.</span></span> <span data-ttu-id="5d3a0-135">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="5d3a0-135">For example:</span></span>
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a><span data-ttu-id="5d3a0-136">Database ed eliminazione</span><span class="sxs-lookup"><span data-stu-id="5d3a0-136">Databases and Culling</span></span>

<span data-ttu-id="5d3a0-137">La creazione di un database affidabile degli oggetti nel mondo è fondamentale per prestazioni ottimali in Direct3D.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-137">Building a reliable database of the objects in your world is key to excellent performance in Direct3D.</span></span> <span data-ttu-id="5d3a0-138">È più importante dei miglioramenti apportati alla rasterizzazione o all'hardware.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-138">It is more important than improvements to rasterization or hardware.</span></span>

<span data-ttu-id="5d3a0-139">È necessario mantenere il numero minimo di poligoni che è possibile gestire.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-139">You should maintain the lowest polygon count you can possibly manage.</span></span> <span data-ttu-id="5d3a0-140">Progettare per un numero ridotto di poligoni compilando i modelli a poligono basso dall'inizio.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-140">Design for a low polygon count by building low-polygon models from the start.</span></span> <span data-ttu-id="5d3a0-141">Aggiungere poligoni se è possibile farlo senza sacrificare le prestazioni in un secondo momento nel processo di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-141">Add polygons if you can do so without sacrificing performance later in the development process.</span></span> <span data-ttu-id="5d3a0-142">Tenere presente che i poligoni più veloci sono quelli che non vengono disegnati.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-142">Remember, the fastest polygons are the ones you don't draw.</span></span>

## <a name="batching-primitives"></a><span data-ttu-id="5d3a0-143">Primitive di batch</span><span class="sxs-lookup"><span data-stu-id="5d3a0-143">Batching Primitives</span></span>

<span data-ttu-id="5d3a0-144">Per ottenere le migliori prestazioni di rendering durante l'esecuzione, provare a usare le primitive in batch e a limitare il numero di modifiche apportate allo stato di rendering al più basso possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-144">To get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible.</span></span> <span data-ttu-id="5d3a0-145">Se, ad esempio, si dispone di un oggetto con due trame, raggruppare i triangoli che usano la prima trama e seguirli con lo stato di rendering necessario per modificare la trama.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-145">For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture.</span></span> <span data-ttu-id="5d3a0-146">Quindi raggruppare tutti i triangoli che usano la seconda trama.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-146">Then group all the triangles that use the second texture.</span></span> <span data-ttu-id="5d3a0-147">Il supporto hardware più semplice per Direct3D viene chiamato con batch di Stati di rendering e batch di primitive tramite hardware abstraction layer (HAL).</span><span class="sxs-lookup"><span data-stu-id="5d3a0-147">The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL).</span></span> <span data-ttu-id="5d3a0-148">Più efficacemente vengono eseguite le istruzioni in batch, il minor numero di chiamate di HAL viene eseguito durante l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-148">The more effectively the instructions are batched, the fewer HAL calls are performed during execution.</span></span>

## <a name="lighting-tips"></a><span data-ttu-id="5d3a0-149">Suggerimenti per l'illuminazione</span><span class="sxs-lookup"><span data-stu-id="5d3a0-149">Lighting Tips</span></span>

<span data-ttu-id="5d3a0-150">Poiché le luci aggiungono un costo per ogni vertice a ogni frame sottoposto a rendering, è possibile migliorare significativamente le prestazioni facendo attenzione a come vengono usate nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-150">Because lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application.</span></span> <span data-ttu-id="5d3a0-151">La maggior parte dei suggerimenti seguenti deriva dalla massima "il codice più veloce è il codice che non viene mai chiamato".</span><span class="sxs-lookup"><span data-stu-id="5d3a0-151">Most of the following tips derive from the maxim, "the fastest code is code that is never called."</span></span>

-   <span data-ttu-id="5d3a0-152">Usare il minor numero di fonti di luce possibili.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-152">Use as few light sources as possible.</span></span> <span data-ttu-id="5d3a0-153">Per aumentare il livello di illuminazione generale, ad esempio, usare la luce di ambiente anziché aggiungere una nuova sorgente di luce.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-153">To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.</span></span>
-   <span data-ttu-id="5d3a0-154">Le luci direzionali sono più efficienti rispetto alle luci puntiformi o ai faretti.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-154">Directional lights are more efficient than point lights or spotlights.</span></span> <span data-ttu-id="5d3a0-155">Per le luci direzionali, la direzione verso la luce è fissa e non deve essere calcolata in base al vertice.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-155">For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.</span></span>
-   <span data-ttu-id="5d3a0-156">I Spotlight possono essere più efficienti delle luci puntiformi, in quanto l'area esterna al cono di luce viene calcolata rapidamente.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-156">Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly.</span></span> <span data-ttu-id="5d3a0-157">Se i Spotlight sono più efficienti o meno, dipende dalla quantità di scena accesa da Spotlight.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-157">Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.</span></span>
-   <span data-ttu-id="5d3a0-158">Usare il parametro Range per limitare le luci solo alle parti della scena che è necessario illuminare.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-158">Use the range parameter to limit your lights to only the parts of the scene you need to illuminate.</span></span> <span data-ttu-id="5d3a0-159">Tutti i tipi di luce terminano abbastanza presto quando sono fuori intervallo.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-159">All the light types exit fairly early when they are out of range.</span></span>
-   <span data-ttu-id="5d3a0-160">Le evidenziazioni speculari quasi il costo di una luce.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-160">Specular highlights almost double the cost of a light.</span></span> <span data-ttu-id="5d3a0-161">Usarli solo quando è necessario.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-161">Use them only when you must.</span></span> <span data-ttu-id="5d3a0-162">Impostare lo \_ stato di rendering SPECULARENABLE di D3DRS su 0, il valore predefinito, laddove possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-162">Set the D3DRS\_SPECULARENABLE render state to 0, the default value, whenever possible.</span></span> <span data-ttu-id="5d3a0-163">Quando si definiscono i materiali, è necessario impostare il valore di potenza speculare su zero per disattivare le evidenziazioni speculari per quel materiale; Basta impostare il colore speculare su 0, 0, 0 non è sufficiente.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-163">When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.</span></span>

## <a name="texture-size"></a><span data-ttu-id="5d3a0-164">Dimensioni trama</span><span class="sxs-lookup"><span data-stu-id="5d3a0-164">Texture Size</span></span>

<span data-ttu-id="5d3a0-165">Le prestazioni di mapping delle trame sono molto dipendenti dalla velocità di memoria.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-165">Texture-mapping performance is heavily dependent on the speed of memory.</span></span> <span data-ttu-id="5d3a0-166">Esistono diversi modi per ottimizzare le prestazioni della cache delle trame dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-166">There are a number of ways to maximize the cache performance of your application's textures.</span></span>

-   <span data-ttu-id="5d3a0-167">Mantieni le trame di piccole dimensioni.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-167">Keep the textures small.</span></span> <span data-ttu-id="5d3a0-168">Le trame più piccole sono, la probabilità migliore di essere mantenute nella cache secondaria principale della CPU.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-168">The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.</span></span>
-   <span data-ttu-id="5d3a0-169">Non modificare le trame in base alla primitiva.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-169">Do not change the textures on a per-primitive basis.</span></span> <span data-ttu-id="5d3a0-170">Provare a gestire i poligoni in base all'ordine delle trame usate.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-170">Try to keep polygons grouped in order of the textures they use.</span></span>
-   <span data-ttu-id="5d3a0-171">Usare le trame quadre laddove possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-171">Use square textures whenever possible.</span></span> <span data-ttu-id="5d3a0-172">Le trame le cui dimensioni sono 256x256 sono le più veloci.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-172">Textures whose dimensions are 256x256 are the fastest.</span></span> <span data-ttu-id="5d3a0-173">Se l'applicazione usa quattro trame 128x128, ad esempio, provare a verificare che usino la stessa tavolozza e posizionarli tutti in una trama 256x256.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-173">If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture.</span></span> <span data-ttu-id="5d3a0-174">Questa tecnica riduce anche la quantità di swapping della trama.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-174">This technique also reduces the amount of texture swapping.</span></span> <span data-ttu-id="5d3a0-175">Naturalmente, è consigliabile non usare le trame 256x256, a meno che l'applicazione non richieda una maggiore texturing perché, come indicato, le trame devono essere mantenute il più piccolo possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-175">Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.</span></span>

## <a name="matrix-transforms"></a><span data-ttu-id="5d3a0-176">Trasformazioni con matrice</span><span class="sxs-lookup"><span data-stu-id="5d3a0-176">Matrix Transforms</span></span>

<span data-ttu-id="5d3a0-177">Direct3D usa le matrici World e View impostate per configurare diverse strutture di dati interne.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-177">Direct3D uses the world and view matrices that you set to configure several internal data structures.</span></span> <span data-ttu-id="5d3a0-178">Ogni volta che si imposta una nuova matrice World o View, il sistema ricalcola le strutture interne associate.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-178">Each time you set a new world or view matrix, the system recalculates the associated internal structures.</span></span> <span data-ttu-id="5d3a0-179">L'impostazione frequente di queste matrici, ad esempio migliaia di volte per fotogramma, richiede molto tempo.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-179">Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming.</span></span> <span data-ttu-id="5d3a0-180">È possibile ridurre al minimo il numero di calcoli necessari concatenando il mondo e visualizzare le matrici in una matrice di visualizzazione globale impostata come matrice globale e quindi impostando la matrice di visualizzazione sull'identità.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-180">You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity.</span></span> <span data-ttu-id="5d3a0-181">Conserva le copie memorizzate nella cache di singole matrici e visualizza le matrici in modo che sia possibile modificare, concatenare e reimpostare la matrice globale in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-181">Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed.</span></span> <span data-ttu-id="5d3a0-182">Per maggiore chiarezza in questa documentazione, gli esempi di Direct3D utilizzano raramente questa ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-182">For clarity in this documentation, Direct3D samples rarely employ this optimization.</span></span>

## <a name="using-dynamic-textures"></a><span data-ttu-id="5d3a0-183">Uso di trame dinamiche</span><span class="sxs-lookup"><span data-stu-id="5d3a0-183">Using Dynamic Textures</span></span>

<span data-ttu-id="5d3a0-184">Per determinare se il driver supporta le trame dinamiche, controllare il \_ flag D3DCAPS2 DYNAMICTEXTURES della struttura [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) .</span><span class="sxs-lookup"><span data-stu-id="5d3a0-184">To find out if the driver supports dynamic textures, check the D3DCAPS2\_DYNAMICTEXTURES flag of the [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) structure.</span></span>

<span data-ttu-id="5d3a0-185">Quando si utilizzano trame dinamiche, tenere presenti le considerazioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-185">Keep the following things in mind when working with dynamic textures.</span></span>

-   <span data-ttu-id="5d3a0-186">Non possono essere gestite.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-186">They cannot be managed.</span></span> <span data-ttu-id="5d3a0-187">Il pool, ad esempio, non può essere \_ gestito D3DPOOL.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-187">For example, their pool cannot be D3DPOOL\_MANAGED.</span></span>
-   <span data-ttu-id="5d3a0-188">Le trame dinamiche possono essere bloccate, anche se vengono create in D3DPOOL \_ default.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-188">Dynamic textures can be locked, even if they are created in D3DPOOL\_DEFAULT.</span></span>
-   <span data-ttu-id="5d3a0-189">D3DLOCK \_ scarto è un flag di blocco valido per le trame dinamiche.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-189">D3DLOCK\_DISCARD is a valid lock flag for dynamic textures.</span></span>

<span data-ttu-id="5d3a0-190">È consigliabile creare una sola trama dinamica per ogni formato e possibilmente per dimensione.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-190">It is a good idea to create only one dynamic texture per format and possibly per size.</span></span> <span data-ttu-id="5d3a0-191">Non è consigliabile usare mipmap, cubi e volumi dinamici a causa dell'overhead aggiuntivo per il blocco di ogni livello.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-191">Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level.</span></span> <span data-ttu-id="5d3a0-192">Per mipmap, l' \_ eliminazione D3DLOCK è consentita solo al primo livello.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-192">For mipmaps, D3DLOCK\_DISCARD is allowed only on the top level.</span></span> <span data-ttu-id="5d3a0-193">Tutti i livelli vengono eliminati bloccando solo il primo livello.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-193">All levels are discarded by locking just the top level.</span></span> <span data-ttu-id="5d3a0-194">Questo comportamento è identico per volumi e cubi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-194">This behavior is the same for volumes and cubes.</span></span> <span data-ttu-id="5d3a0-195">Per i cubi, il primo livello e il volto 0 sono bloccati.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-195">For cubes, the top level and face 0 are locked.</span></span>

<span data-ttu-id="5d3a0-196">Nello pseudocodice seguente viene illustrato un esempio di utilizzo di una trama dinamica.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-196">The following pseudocode shows an example of using a dynamic texture.</span></span>


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a><span data-ttu-id="5d3a0-197">Uso dei buffer di indice e vertex dinamici</span><span class="sxs-lookup"><span data-stu-id="5d3a0-197">Using Dynamic Vertex and Index Buffers</span></span>

<span data-ttu-id="5d3a0-198">Il blocco di un buffer di vertex statico mentre il processore grafico sta utilizzando il buffer può comportare una riduzione significativa delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-198">Locking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty.</span></span> <span data-ttu-id="5d3a0-199">La chiamata di blocco deve attendere il completamento della lettura dei dati vertex o index dal buffer da parte del processore di grafica prima che sia possibile tornare all'applicazione chiamante, un ritardo significativo.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-199">The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay.</span></span> <span data-ttu-id="5d3a0-200">Il blocco e il rendering da un buffer statico più volte per fotogramma impedisce inoltre al processore grafico di memorizzare nel buffer i comandi di rendering, dal momento che è necessario completare i comandi prima di restituire il puntatore di blocco.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-200">Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer.</span></span> <span data-ttu-id="5d3a0-201">Senza i comandi memorizzati nel buffer, il processore di grafica rimane inattivo fino al termine dell'esecuzione del riempimento del buffer di vertex o dell'indice e genera un comando di rendering.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-201">Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.</span></span>

<span data-ttu-id="5d3a0-202">Idealmente, i dati dei vertici o degli indici non cambiano mai, ma ciò non è sempre possibile.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-202">Ideally the vertex or index data would never change, however this is not always possible.</span></span> <span data-ttu-id="5d3a0-203">Esistono molte situazioni in cui l'applicazione deve modificare i dati dei vertici o degli indici ogni frame, probabilmente anche più volte per fotogramma.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-203">There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame.</span></span> <span data-ttu-id="5d3a0-204">Per queste situazioni, è necessario creare un vertex o un buffer di indice con D3DUSAGE \_ Dynamic.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-204">For these situations, the vertex or index buffer should be created with D3DUSAGE\_DYNAMIC.</span></span> <span data-ttu-id="5d3a0-205">Questo flag di utilizzo consente a Direct3D di ottimizzare le operazioni di blocco frequenti.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-205">This usage flag causes Direct3D to optimize for frequent lock operations.</span></span> <span data-ttu-id="5d3a0-206">\_La dinamica D3DUSAGE è utile solo quando il buffer è bloccato di frequente; i dati che rimangono costanti devono essere inseriti in un vertex buffer statico o in un buffer di indice.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-206">D3DUSAGE\_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.</span></span>

<span data-ttu-id="5d3a0-207">Per ottenere un miglioramento delle prestazioni quando si usano i buffer dei vertici dinamici, l'applicazione deve chiamare [**IDirect3DVertexBuffer9:: Lock**](/windows/desktop/api) o [**IDirect3DIndexBuffer9:: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) con i flag appropriati.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-207">To receive a performance improvement when using dynamic vertex buffers, the application must call [**IDirect3DVertexBuffer9::Lock**](/windows/desktop/api) or [**IDirect3DIndexBuffer9::Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) with the appropriate flags.</span></span> <span data-ttu-id="5d3a0-208">D3DLOCK \_ scarto indica che non è necessario che l'applicazione mantenga i dati del vertice o dell'indice precedente nel buffer.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-208">D3DLOCK\_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer.</span></span> <span data-ttu-id="5d3a0-209">Se il processore grafico usa ancora il buffer quando il blocco viene chiamato con D3DLOCK \_ scarto, viene restituito un puntatore a una nuova area di memoria invece dei dati del buffer obsoleti.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-209">If the graphics processor is still using the buffer when lock is called with D3DLOCK\_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data.</span></span> <span data-ttu-id="5d3a0-210">Questo consente al processore di grafica di continuare a usare i dati precedenti mentre l'applicazione inserisce i dati nel nuovo buffer.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-210">This allows the graphics processor to continue using the old data while the application places data in the new buffer.</span></span> <span data-ttu-id="5d3a0-211">Nell'applicazione non è necessaria alcuna gestione della memoria aggiuntiva. il buffer precedente viene riutilizzato o eliminato automaticamente al termine dell'elaborazione grafica.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-211">No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it.</span></span> <span data-ttu-id="5d3a0-212">Si noti che il blocco di un buffer con D3DLOCK \_ scarta sempre l'intero buffer, specificando un offset diverso da zero o un campo con dimensioni limitate non mantiene le informazioni nelle aree sbloccate del buffer.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-212">Note that locking a buffer with D3DLOCK\_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.</span></span>

<span data-ttu-id="5d3a0-213">Esistono casi in cui la quantità di dati che l'applicazione deve archiviare per blocco è ridotta, ad esempio l'aggiunta di quattro vertici per il rendering di uno sprite.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-213">There are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite.</span></span> <span data-ttu-id="5d3a0-214">D3DLOCK \_ nowrite indica che l'applicazione non sovrascriverà i dati già in uso nel buffer dinamico.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-214">D3DLOCK\_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer.</span></span> <span data-ttu-id="5d3a0-215">La chiamata di blocco restituirà un puntatore ai dati obsoleti, consentendo all'applicazione di aggiungere nuovi dati in aree inutilizzate del vertex buffer o dell'indice.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-215">The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer.</span></span> <span data-ttu-id="5d3a0-216">L'applicazione non deve modificare i vertici o gli indici usati in un'operazione di estrazione, perché potrebbero essere ancora usati dal processore di grafica.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-216">The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor.</span></span> <span data-ttu-id="5d3a0-217">L'applicazione deve quindi usare D3DLOCK \_ scarto dopo che il buffer dinamico è pieno per ricevere una nuova area di memoria, rimuovendo i dati del vertice o dell'indice precedenti al termine del processore di grafica.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-217">The application should then use D3DLOCK\_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.</span></span>

<span data-ttu-id="5d3a0-218">Il meccanismo di query asincrono è utile per determinare se i vertici sono ancora in uso da parte del processore di grafica.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-218">The asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor.</span></span> <span data-ttu-id="5d3a0-219">Eseguire una query di tipo \_ evento D3DQUERYTYPE dopo l'ultima chiamata DrawPrimitive che usa i vertici.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-219">Issue a query of type D3DQUERYTYPE\_EVENT after the last DrawPrimitive call that uses the vertices.</span></span> <span data-ttu-id="5d3a0-220">I vertici non vengono più usati quando [**IDirect3DQuery9:: GetData**](/windows/desktop/api) restituisce S \_ OK.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-220">The vertices are no longer in use when [**IDirect3DQuery9::GetData**](/windows/desktop/api) returns S\_OK.</span></span> <span data-ttu-id="5d3a0-221">Il blocco di un buffer con D3DLOCK \_ scartare o nessun flag garantisce sempre che i vertici siano sincronizzati correttamente con il processore grafico. Tuttavia, l'uso del blocco senza flag comporterà la riduzione delle prestazioni descritta in precedenza.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-221">Locking a buffer with D3DLOCK\_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier.</span></span> <span data-ttu-id="5d3a0-222">Altre chiamate API, ad esempio [**IDirect3DDevice9:: BeginScene**](/windows/desktop/api), [**IDirect3DDevice9:: EndScene**](/windows/desktop/api)e [**IDirect3DDevice9::P**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) reinviate, non garantiscono che il processore grafico abbia terminato di usare i vertici.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-222">Other API calls such as [**IDirect3DDevice9::BeginScene**](/windows/desktop/api), [**IDirect3DDevice9::EndScene**](/windows/desktop/api), and [**IDirect3DDevice9::Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) do not guarantee the graphics processor is finished using vertices.</span></span>

<span data-ttu-id="5d3a0-223">Di seguito sono riportati i modi per usare i buffer dinamici e i flag di blocco appropriati.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-223">Below are ways to use dynamic buffers and the proper lock flags.</span></span>


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a><span data-ttu-id="5d3a0-224">Uso di mesh</span><span class="sxs-lookup"><span data-stu-id="5d3a0-224">Using Meshes</span></span>

<span data-ttu-id="5d3a0-225">È possibile ottimizzare le mesh usando triangoli indicizzati Direct3D anziché le strisce triangolari indicizzate.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-225">You can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips.</span></span> <span data-ttu-id="5d3a0-226">L'hardware scoprirà che il 95% dei triangoli successivi effettivamente forma le strisce e si adatta di conseguenza.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-226">The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly.</span></span> <span data-ttu-id="5d3a0-227">Molti driver eseguono questa operazione anche per i componenti hardware meno recenti.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-227">Many drivers do this for older hardware also.</span></span>

<span data-ttu-id="5d3a0-228">Gli oggetti mesh D3DX possono avere ogni triangolo, o volto, contrassegnato con un valore DWORD, denominato attributo della faccia.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-228">D3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face.</span></span> <span data-ttu-id="5d3a0-229">La semantica del valore DWORD è definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-229">The semantics of the DWORD are user-defined.</span></span> <span data-ttu-id="5d3a0-230">Vengono usati da D3DX per classificare la mesh in subset.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-230">They are used by D3DX to classify the mesh into subsets.</span></span> <span data-ttu-id="5d3a0-231">L'applicazione imposta gli attributi per volto usando la chiamata [**ID3DXMesh:: LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) .</span><span class="sxs-lookup"><span data-stu-id="5d3a0-231">The application sets per-face attributes using the [**ID3DXMesh::LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) call.</span></span> <span data-ttu-id="5d3a0-232">Il metodo [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md) dispone di un'opzione per raggruppare i vertici mesh e i visi sugli attributi usando l' \_ opzione ATTRSORT di D3DXMESHOPT.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-232">The [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT\_ATTRSORT option.</span></span> <span data-ttu-id="5d3a0-233">Al termine di questa operazione, l'oggetto mesh calcola una tabella degli attributi che può essere ottenuta dall'applicazione chiamando [**ID3DXBaseMesh:: GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span><span class="sxs-lookup"><span data-stu-id="5d3a0-233">When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling [**ID3DXBaseMesh::GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span></span> <span data-ttu-id="5d3a0-234">Questa chiamata restituisce 0 se la mesh non è ordinata in base agli attributi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-234">This call returns 0 if the mesh is not sorted by attributes.</span></span> <span data-ttu-id="5d3a0-235">Per un'applicazione non è possibile impostare una tabella di attributi perché viene generata dal metodo **ID3DXMesh:: Optimize** .</span><span class="sxs-lookup"><span data-stu-id="5d3a0-235">There is no way for an application to set an attribute table because it is generated by the **ID3DXMesh::Optimize** method.</span></span> <span data-ttu-id="5d3a0-236">L'ordinamento dell'attributo è sensibile ai dati, pertanto se l'applicazione sa che una mesh è ordinata per l'attributo, è comunque necessario chiamare **ID3DXMesh:: Optimize** per generare la tabella degli attributi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-236">The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call **ID3DXMesh::Optimize** to generate the attribute table.</span></span>

<span data-ttu-id="5d3a0-237">Negli argomenti seguenti vengono descritti i diversi attributi di una rete mesh.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-237">The following topics describe the different attributes of a mesh.</span></span>

### <a name="attribute-id"></a><span data-ttu-id="5d3a0-238">ID attributo</span><span class="sxs-lookup"><span data-stu-id="5d3a0-238">Attribute ID</span></span>

<span data-ttu-id="5d3a0-239">Un ID di attributo è un valore che associa un gruppo di visi a un gruppo di attributi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-239">An attribute id is a value that associates a group of faces with an attribute group.</span></span> <span data-ttu-id="5d3a0-240">Questo ID descrive il subset di visi [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) deve essere disegnato.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-240">This id describes which subset of faces [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) should draw.</span></span> <span data-ttu-id="5d3a0-241">Gli ID attributo sono specificati per i visi nel buffer dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-241">Attribute ids are specified for the faces in the attribute buffer.</span></span> <span data-ttu-id="5d3a0-242">I valori effettivi degli ID degli attributi possono essere qualsiasi elemento che si trovi in 32 bit, ma è normale usare 0 per n dove n è il numero di attributi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-242">The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.</span></span>

### <a name="attribute-buffer"></a><span data-ttu-id="5d3a0-243">Buffer degli attributi</span><span class="sxs-lookup"><span data-stu-id="5d3a0-243">Attribute Buffer</span></span>

<span data-ttu-id="5d3a0-244">Il buffer dell'attributo è una matrice di DWORD (uno per volto) che specifica il gruppo di attributi a cui ogni face appartiene.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-244">The attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in.</span></span> <span data-ttu-id="5d3a0-245">Questo buffer viene inizializzato su zero durante la creazione di una mesh, ma viene compilato dalle routine di caricamento oppure deve essere compilato dall'utente se si desidera più di un attributo con ID 0.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-245">This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired.</span></span> <span data-ttu-id="5d3a0-246">Questo buffer contiene le informazioni utilizzate per ordinare la mesh in base agli attributi in [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md).</span><span class="sxs-lookup"><span data-stu-id="5d3a0-246">This buffer contains the information that is used to sort the mesh based on attributes in [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md).</span></span> <span data-ttu-id="5d3a0-247">Se non è presente alcuna tabella degli attributi, [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md) analizza questo buffer per selezionare i visi dell'attributo specificato da creare.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-247">If no attribute table is present, [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) scans this buffer to select the faces of the given attribute to draw.</span></span>

### <a name="attribute-table"></a><span data-ttu-id="5d3a0-248">Tabella di attributi</span><span class="sxs-lookup"><span data-stu-id="5d3a0-248">Attribute Table</span></span>

<span data-ttu-id="5d3a0-249">La tabella attribute è una struttura di proprietà e gestita dalla mesh.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-249">The attribute table is a structure owned and maintained by the mesh.</span></span> <span data-ttu-id="5d3a0-250">L'unico modo per generarne uno è chiamando [**ID3DXMesh:: Optimize**](id3dxmesh--optimize.md) con l'ordinamento degli attributi o l'ottimizzazione più avanzata abilitata.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-250">The only way for one to be generated is by calling [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) with attribute sorting or stronger optimization enabled.</span></span> <span data-ttu-id="5d3a0-251">La tabella attribute viene usata per avviare rapidamente una singola chiamata primitiva di estrazione a [**ID3DXBaseMesh::D rawsubset**](id3dxbasemesh--drawsubset.md).</span><span class="sxs-lookup"><span data-stu-id="5d3a0-251">The attribute table is used to quickly initiate a single draw primitive call to [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md).</span></span> <span data-ttu-id="5d3a0-252">L'unico altro uso è che l'avanzamento delle mesh gestisce anche questa struttura, quindi è possibile vedere quali visi e vertici sono attivi al livello di dettaglio corrente.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-252">The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.</span></span>

## <a name="z-buffer-performance"></a><span data-ttu-id="5d3a0-253">Prestazioni del buffer Z</span><span class="sxs-lookup"><span data-stu-id="5d3a0-253">Z-Buffer Performance</span></span>

<span data-ttu-id="5d3a0-254">Le applicazioni possono migliorare le prestazioni quando si usano il buffering z e la texturing garantendo il rendering delle scene dalla parte anteriore a quella posteriore.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-254">Applications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back.</span></span> <span data-ttu-id="5d3a0-255">Le primitive con buffer z con trama vengono pretestate rispetto al buffer z in base a una linea di analisi.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-255">Textured z-buffered primitives are pretested against the z-buffer on a scan line basis.</span></span> <span data-ttu-id="5d3a0-256">Se una riga di analisi è nascosta da un poligono di cui è stato eseguito il rendering in precedenza, il sistema lo respinge in modo rapido ed efficiente.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-256">If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently.</span></span> <span data-ttu-id="5d3a0-257">Il buffer Z può migliorare le prestazioni, ma la tecnica risulta particolarmente utile quando una scena disegna gli stessi pixel più di una volta.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-257">Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once.</span></span> <span data-ttu-id="5d3a0-258">Questo è difficile da calcolare esattamente, ma è spesso possibile creare un'approssimazione vicina.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-258">This is difficult to calculate exactly, but you can often make a close approximation.</span></span> <span data-ttu-id="5d3a0-259">Se gli stessi pixel vengono disegnati meno di due volte, è possibile ottenere prestazioni ottimali disattivando il buffer z ed eseguendo il rendering della scena dal retro all'inizio.</span><span class="sxs-lookup"><span data-stu-id="5d3a0-259">If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5d3a0-260">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="5d3a0-260">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="5d3a0-261">Suggerimenti per la programmazione</span><span class="sxs-lookup"><span data-stu-id="5d3a0-261">Programming Tips</span></span>](programming-tips.md)
</dt> </dl>

 

 
