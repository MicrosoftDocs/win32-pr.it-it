---
description: Quando si dispone di un'applicazione Microsoft Direct3D funzionale e si desidera migliorare le prestazioni, in genere si usa uno strumento di profilatura fuori programma o una tecnica di misurazione personalizzata per misurare il tempo necessario per eseguire una o più chiamate di Application Programming Interface (API). Se questa operazione è stata eseguita ma si ricevono risultati temporali che variano da una sequenza di rendering a quella successiva o si eseguono ipotesi che non mantengono i risultati effettivi dell'esperimento, le informazioni seguenti possono essere utili per comprendere il motivo.
ms.assetid: f969be42-d541-4e8d-aec4-eb9508bcc7cf
title: Profilatura precisa delle chiamate API Direct3D (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdb6d60fcc1b3ace4112dbf7028d91e2c9c8b345
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/07/2021
ms.locfileid: "103748738"
---
# <a name="accurately-profiling-direct3d-api-calls-direct3d-9"></a><span data-ttu-id="0b703-104">Profilatura precisa delle chiamate API Direct3D (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="0b703-104">Accurately Profiling Direct3D API Calls (Direct3D 9)</span></span>

-   [<span data-ttu-id="0b703-105">Il profiling accurato di Direct3D è difficile</span><span class="sxs-lookup"><span data-stu-id="0b703-105">Accurately Profiling Direct3D Is Difficult</span></span>](#accurately-profiling-direct3d-is-difficult)
-   [<span data-ttu-id="0b703-106">Come profilare accuratamente una sequenza di rendering Direct3D</span><span class="sxs-lookup"><span data-stu-id="0b703-106">How to Accurately Profile a Direct3D Render Sequence</span></span>](#how-to-accurately-profile-a-direct3d-render-sequence)
-   [<span data-ttu-id="0b703-107">Profilatura delle modifiche dello stato Direct3D</span><span class="sxs-lookup"><span data-stu-id="0b703-107">Profiling Direct3D State Changes</span></span>](#profiling-direct3d-state-changes)
-   [<span data-ttu-id="0b703-108">Summary</span><span class="sxs-lookup"><span data-stu-id="0b703-108">Summary</span></span>](#summary)
-   [<span data-ttu-id="0b703-109">Appendice</span><span class="sxs-lookup"><span data-stu-id="0b703-109">Appendix</span></span>](#appendix)

<span data-ttu-id="0b703-110">Quando si dispone di un'applicazione Microsoft Direct3D funzionale e si desidera migliorare le prestazioni, in genere si usa uno strumento di profilatura fuori programma o una tecnica di misurazione personalizzata per misurare il tempo necessario per eseguire una o più chiamate di Application Programming Interface (API).</span><span class="sxs-lookup"><span data-stu-id="0b703-110">Once you have a functional Microsoft Direct3D application and you want to improve its performance, you generally use an off-the-shelf profiling tool or some custom measurement technique to measure the time it takes to execute one or more application programming interface (API) calls.</span></span> <span data-ttu-id="0b703-111">Se questa operazione è stata eseguita ma si ricevono risultati temporali che variano da una sequenza di rendering a quella successiva o si eseguono ipotesi che non mantengono i risultati effettivi dell'esperimento, le informazioni seguenti possono essere utili per comprendere il motivo.</span><span class="sxs-lookup"><span data-stu-id="0b703-111">If you have done this but are getting timing results that vary from one render sequence to the next, or you are making hypotheses that do not hold up to actual experiment results, the following information may help you to understand why.</span></span>

<span data-ttu-id="0b703-112">Le informazioni fornite in questo articolo si basano sul presupposto che l'utente abbia familiarità e abbia esperienza con quanto segue:</span><span class="sxs-lookup"><span data-stu-id="0b703-112">The information provided here is based upon the assumption that you have knowledge of and experience with the following:</span></span>

-   <span data-ttu-id="0b703-113">Programmazione C/C++</span><span class="sxs-lookup"><span data-stu-id="0b703-113">C/C++ programming</span></span>
-   <span data-ttu-id="0b703-114">Programmazione dell'API Direct3D</span><span class="sxs-lookup"><span data-stu-id="0b703-114">Direct3D API programming</span></span>
-   <span data-ttu-id="0b703-115">Misurazione della temporizzazione delle API</span><span class="sxs-lookup"><span data-stu-id="0b703-115">Measuring API timing</span></span>
-   <span data-ttu-id="0b703-116">Scheda video e driver software</span><span class="sxs-lookup"><span data-stu-id="0b703-116">The video card and its software driver</span></span>
-   <span data-ttu-id="0b703-117">Possibili risultati inspiegabili della precedente esperienza di profilatura</span><span class="sxs-lookup"><span data-stu-id="0b703-117">Possible unexplainable results from previous profiling experience</span></span>

## <a name="accurately-profiling-direct3d-is-difficult"></a><span data-ttu-id="0b703-118">Il profiling accurato di Direct3D è difficile</span><span class="sxs-lookup"><span data-stu-id="0b703-118">Accurately Profiling Direct3D Is Difficult</span></span>

<span data-ttu-id="0b703-119">Un profiler segnala la quantità di tempo impiegato in ogni chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-119">A profiler reports on the amount of time spent in each API call.</span></span> <span data-ttu-id="0b703-120">Questa operazione consente di migliorare le prestazioni individuando e ottimizzando le aree sensibili.</span><span class="sxs-lookup"><span data-stu-id="0b703-120">This is done to improve performance by finding and tuning away hot spots.</span></span> <span data-ttu-id="0b703-121">Esistono diversi tipi di Profiler e tecniche di profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-121">There are different kinds of profilers and profiling techniques.</span></span>

-   <span data-ttu-id="0b703-122">Un profiler di campionamento si trova in una fase di inattività, riattivando a intervalli specifici di esempio (o per registrare) le funzioni in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="0b703-122">A sampling profiler sits idle much of the time, awakening at specific intervals to sample (or to record) the functions being executed.</span></span> <span data-ttu-id="0b703-123">Restituisce la percentuale di tempo trascorso in ogni chiamata.</span><span class="sxs-lookup"><span data-stu-id="0b703-123">It returns the percentage of time spent in each call.</span></span> <span data-ttu-id="0b703-124">In genere, un profiler di campionamento non è molto invasivo per l'applicazione e ha un impatto minimo sul sovraccarico per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-124">Generally, a sampling profiler is not very invasive to the application and has minimal impact on the overhead for the application.</span></span>
-   <span data-ttu-id="0b703-125">Un profiler di strumentazione misura il tempo effettivo necessario per la restituzione di una chiamata.</span><span class="sxs-lookup"><span data-stu-id="0b703-125">An instrumenting profiler measures the actual time it takes for a call to return.</span></span> <span data-ttu-id="0b703-126">Richiede la compilazione di delimitatori di avvio e di arresto in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-126">It requires compiling start and stop delimiters into an application.</span></span> <span data-ttu-id="0b703-127">Un profiler di strumentazione è relativamente più invasive per un'applicazione rispetto a un profiler di campionamento.</span><span class="sxs-lookup"><span data-stu-id="0b703-127">An instrumenting profiler is comparatively more invasive to an application than a sampling profiler.</span></span>
-   <span data-ttu-id="0b703-128">È anche possibile usare una tecnica di profilatura personalizzata con un timer a prestazioni elevate.</span><span class="sxs-lookup"><span data-stu-id="0b703-128">It is also possible to use a custom profiling technique with a high-performance timer.</span></span> <span data-ttu-id="0b703-129">Questa operazione produce risultati molto simili a quelli di un profiler di strumentazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-129">This produces results very much like an instrumenting profiler.</span></span>

<span data-ttu-id="0b703-130">Il tipo di Profiler o la tecnica di profilatura utilizzata fa solo parte della richiesta di generazione di misurazioni accurate.</span><span class="sxs-lookup"><span data-stu-id="0b703-130">The type of profiler or profiling technique used is only part of the challenge of generating accurate measurements.</span></span>

<span data-ttu-id="0b703-131">La profilatura offre risposte che consentono di ottenere un budget per le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="0b703-131">Profiling gives you answers that help you budget performance.</span></span> <span data-ttu-id="0b703-132">Si supponga, ad esempio, che un'API chiami la media di 1000 cicli di clock da eseguire.</span><span class="sxs-lookup"><span data-stu-id="0b703-132">For instance, suppose you know that an API call averages one thousand clock cycles to execute.</span></span> <span data-ttu-id="0b703-133">È possibile dichiarare alcune conclusioni sulle prestazioni, come le seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-133">You can assert some conclusions about performance such as the following:</span></span>

-   <span data-ttu-id="0b703-134">Una CPU a 2 GHz, che dedica il 50% del rendering del tempo, è limitata alla chiamata a questa API 1 milione volte al secondo.</span><span class="sxs-lookup"><span data-stu-id="0b703-134">A 2 GHz CPU (which spends 50 percent of its time rendering) is limited to calling this API 1 million times a second.</span></span>
-   <span data-ttu-id="0b703-135">Per ottenere 30 fotogrammi al secondo, non è possibile chiamare l'API più di 33.000 volte per frame.</span><span class="sxs-lookup"><span data-stu-id="0b703-135">To achieve 30 frames per second, you cannot call this API more than 33,000 times per frame.</span></span>
-   <span data-ttu-id="0b703-136">È possibile eseguire il rendering solo di 3.3 K oggetti per fotogramma (presupponendo 10 di queste chiamate API per la sequenza di rendering di ogni oggetto).</span><span class="sxs-lookup"><span data-stu-id="0b703-136">You can only render 3.3K objects per frame (assuming 10 of these API calls for each object's render sequence).</span></span>

<span data-ttu-id="0b703-137">In altre parole, se si dispone di tempo sufficiente per ogni chiamata API, è possibile rispondere a una domanda di budget, ad esempio il numero di primitive di cui è possibile eseguire il rendering in modo interattivo.</span><span class="sxs-lookup"><span data-stu-id="0b703-137">In other words, if you had sufficient time per API call, you could answer a budgeting question such as the number of primitives that can be rendered interactively.</span></span> <span data-ttu-id="0b703-138">Tuttavia, i numeri non elaborati restituiti da un profiler di strumentazione non rispondono in modo accurato alle domande di budget.</span><span class="sxs-lookup"><span data-stu-id="0b703-138">But the raw numbers returned by an instrumenting profiler will not accurately answer the budgeting questions.</span></span> <span data-ttu-id="0b703-139">Ciò è dovuto al fatto che la pipeline grafica presenta problemi di progettazione complessi, ad esempio il numero di componenti che devono funzionare, il numero di processori che controllano il flusso di lavoro tra i componenti e le strategie di ottimizzazione implementate in fase di esecuzione e in un driver progettato per rendere la pipeline più efficiente.</span><span class="sxs-lookup"><span data-stu-id="0b703-139">This is because the graphics pipeline has complex design issues such as the number of components that need to do work, the number of processors that control how the work flows between components, and optimization strategies implemented in the runtime and in a driver that are designed to make the pipeline more efficient.</span></span>

### <a name="each-api-call-goes-through-several-components"></a><span data-ttu-id="0b703-140">Ogni chiamata API passa attraverso diversi componenti</span><span class="sxs-lookup"><span data-stu-id="0b703-140">Each API Call Goes through Several Components</span></span>

<span data-ttu-id="0b703-141">Ogni chiamata viene elaborata da diversi componenti dal punto di forza dell'applicazione alla scheda video.</span><span class="sxs-lookup"><span data-stu-id="0b703-141">Each call is processed by several components on its way from the application to the video card.</span></span> <span data-ttu-id="0b703-142">Si consideri, ad esempio, la sequenza di rendering seguente che contiene due chiamate per il disegno di un singolo triangolo:</span><span class="sxs-lookup"><span data-stu-id="0b703-142">For instance, consider the following render sequence containing two calls for drawing a single triangle:</span></span>


```
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
```



<span data-ttu-id="0b703-143">Il diagramma concettuale seguente mostra i diversi componenti attraverso i quali le chiamate devono essere superate.</span><span class="sxs-lookup"><span data-stu-id="0b703-143">The following conceptual diagram shows the different components through which the calls must pass.</span></span>

![diagramma dei componenti grafici che passano dalle chiamate API](images/microbenchmarkinstructionflow2.png)

<span data-ttu-id="0b703-145">L'applicazione richiama Direct3D che controlla la scena, gestisce le interazioni dell'utente e determina il modo in cui viene eseguito il rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-145">The application invokes Direct3D which controls the scene, handles user interactions, and determines how rendering is done.</span></span> <span data-ttu-id="0b703-146">Tutte queste operazioni vengono specificate nella sequenza di rendering, che viene inviata al runtime tramite chiamate API Direct3D.</span><span class="sxs-lookup"><span data-stu-id="0b703-146">All of this work is specified in the render sequence, which is sent to the runtime using Direct3D API calls.</span></span> <span data-ttu-id="0b703-147">La sequenza di rendering è virtualmente indipendente dall'hardware, ovvero le chiamate API sono indipendenti dall'hardware, ma un'applicazione è in grado di conoscere le funzionalità supportate da una scheda video.</span><span class="sxs-lookup"><span data-stu-id="0b703-147">The render sequence is virtually hardware independent (that is, the API calls are hardware independent but an application has knowledge of what features a video card supports).</span></span>

<span data-ttu-id="0b703-148">Il runtime converte queste chiamate in un formato indipendente dal dispositivo.</span><span class="sxs-lookup"><span data-stu-id="0b703-148">The runtime converts these calls into a device-independent format.</span></span> <span data-ttu-id="0b703-149">Il runtime gestisce tutte le comunicazioni tra l'applicazione e il driver, in modo che un'applicazione venga eseguita su più componenti hardware compatibili (a seconda delle funzionalità necessarie).</span><span class="sxs-lookup"><span data-stu-id="0b703-149">The runtime handles all the communication between the application and the driver, so that an application will run on more than one compatible piece of hardware (depending on the features required).</span></span> <span data-ttu-id="0b703-150">Quando si misura una chiamata di funzione, un profiler di strumentazione misura il tempo trascorso in una funzione e il tempo necessario per la restituzione della funzione.</span><span class="sxs-lookup"><span data-stu-id="0b703-150">When measuring a function call, an instrumenting profiler measures the time it spent in a function as well as the time for the function to return.</span></span> <span data-ttu-id="0b703-151">Una limitazione di un profiler di strumentazione è che potrebbe non includere il tempo impiegato da un driver per inviare il lavoro risultante alla scheda video e il tempo necessario alla scheda video per elaborare il lavoro.</span><span class="sxs-lookup"><span data-stu-id="0b703-151">One limitation of an instrumenting profiler is that it may not include the time it takes a driver to send the resulting work to the video card nor the time for the video card to process the work.</span></span> <span data-ttu-id="0b703-152">In altre parole, un profiler di strumentazione fuori piano non riesce a attribuire tutto il lavoro associato a ogni chiamata di funzione.</span><span class="sxs-lookup"><span data-stu-id="0b703-152">In other words, an off-the-shelf instrumenting profiler fails to attribute all of the work associated with each function call.</span></span>

<span data-ttu-id="0b703-153">Il driver software utilizza informazioni specifiche dell'hardware sulla scheda video per convertire i comandi indipendenti dal dispositivo in una sequenza di comandi di schede video.</span><span class="sxs-lookup"><span data-stu-id="0b703-153">The software driver uses hardware specific knowledge about the video card to convert the device-independent commands into a sequence of video card commands.</span></span> <span data-ttu-id="0b703-154">I driver possono anche ottimizzare la sequenza di comandi inviati alla scheda video, in modo che il rendering sulla scheda video venga eseguito in modo efficiente.</span><span class="sxs-lookup"><span data-stu-id="0b703-154">Drivers may also optimize the sequence of commands that are sent to the video card, so that rendering on the video card is done efficiently.</span></span> <span data-ttu-id="0b703-155">Queste ottimizzazioni possono causare problemi di profilatura perché la quantità di lavoro eseguita non corrisponde a quanto sembra (potrebbe essere necessario comprendere le ottimizzazioni da tenere in considerazione).</span><span class="sxs-lookup"><span data-stu-id="0b703-155">These optimizations can cause profiling problems because the amount of work done is not what it appears to be (you may need to understand the optimizations to account for them).</span></span> <span data-ttu-id="0b703-156">Il driver restituisce in genere il controllo al runtime prima che la scheda video abbia terminato l'elaborazione di tutti i comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-156">The driver typically returns control to the runtime before the video card has finished processing all the commands.</span></span>

<span data-ttu-id="0b703-157">La scheda video esegue la maggior parte del rendering combinando i dati dai buffer dei vertici e degli indici, le trame, le informazioni sullo stato di rendering e i comandi grafici.</span><span class="sxs-lookup"><span data-stu-id="0b703-157">The video card performs the majority of the rendering by combining data from the vertex and index buffers, textures, render state information, and the graphics commands.</span></span> <span data-ttu-id="0b703-158">Quando la scheda video termina il rendering, il lavoro creato dalla sequenza di rendering è completo.</span><span class="sxs-lookup"><span data-stu-id="0b703-158">When the video card finishes rendering, the work created from the render sequence is complete.</span></span>

<span data-ttu-id="0b703-159">Ogni chiamata all'API Direct3D deve essere elaborata da ogni componente (il runtime, il driver e la scheda video) per eseguire il rendering di qualsiasi elemento.</span><span class="sxs-lookup"><span data-stu-id="0b703-159">Each Direct3D API call must be processed by each component (the runtime, the driver, and the video card) to render anything.</span></span>

### <a name="there-is-more-than-one-processor-controlling-the-components"></a><span data-ttu-id="0b703-160">È presente più di un processore che controlla i componenti</span><span class="sxs-lookup"><span data-stu-id="0b703-160">There Is More than One Processor Controlling the Components</span></span>

<span data-ttu-id="0b703-161">La relazione tra questi componenti è ancora più complessa, poiché l'applicazione, il runtime e il driver sono controllati da un processore e la scheda video è controllata da un processore separato.</span><span class="sxs-lookup"><span data-stu-id="0b703-161">The relationship between these components is even more complex, because the application, runtime, and the driver are controlled by one processor and the video card is controlled by a separate processor.</span></span> <span data-ttu-id="0b703-162">Il diagramma seguente mostra due tipi di processori: un'unità di elaborazione centrale (CPU) e una GPU (Graphics Processing Unit).</span><span class="sxs-lookup"><span data-stu-id="0b703-162">The following diagram shows two kinds of processors: a central processing unit (CPU) and a graphics processing unit (GPU).</span></span>

![diagramma di una CPU e di una GPU e dei relativi componenti](images/microbenchmarkprocessors.png)

<span data-ttu-id="0b703-164">I sistemi PC hanno almeno una CPU e una GPU, ma possono avere più di uno dei due o entrambi.</span><span class="sxs-lookup"><span data-stu-id="0b703-164">PC systems have at least one CPU and one GPU, but can have more than one of either or both.</span></span> <span data-ttu-id="0b703-165">Le CPU si trovano sulla scheda madre e le GPU si trovano sulla scheda madre o sulla scheda video.</span><span class="sxs-lookup"><span data-stu-id="0b703-165">The CPUs are located on the motherboard, and the GPUs are located either on the motherboard or on the video card.</span></span> <span data-ttu-id="0b703-166">La velocità della CPU è determinata da un chip di clock sulla scheda madre e la velocità della GPU è determinata da un chip di clock separato.</span><span class="sxs-lookup"><span data-stu-id="0b703-166">The speed of the CPU is determined by a clock chip on the motherboard, and the speed of the GPU is determined by a separate clock chip.</span></span> <span data-ttu-id="0b703-167">Il clock della CPU controlla la velocità del lavoro eseguito dall'applicazione, dal runtime e dal driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-167">The CPU clock controls the speed of the work done by the application, the runtime, and the driver.</span></span> <span data-ttu-id="0b703-168">L'applicazione invia il lavoro alla GPU tramite il runtime e il driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-168">The application sends work to the GPU via the runtime and the driver.</span></span>

<span data-ttu-id="0b703-169">La CPU e la GPU vengono in genere eseguite a velocità diverse, indipendenti l'una dall'altra.</span><span class="sxs-lookup"><span data-stu-id="0b703-169">The CPU and the GPU generally run at different speeds, independent of one another.</span></span> <span data-ttu-id="0b703-170">La GPU può rispondere al lavoro non appena il lavoro è disponibile (presupponendo che la GPU abbia terminato l'elaborazione del lavoro precedente).</span><span class="sxs-lookup"><span data-stu-id="0b703-170">The GPU may respond to the work as soon as the work is available (assuming the GPU has finished processing previous work).</span></span> <span data-ttu-id="0b703-171">Il lavoro della GPU viene eseguito in parallelo con il lavoro della CPU evidenziato dalla linea curva nella figura precedente.</span><span class="sxs-lookup"><span data-stu-id="0b703-171">The GPU work is done in parallel with the CPU work as highlighted by the curved line in the figure above.</span></span> <span data-ttu-id="0b703-172">Un profiler in genere misura le prestazioni della CPU, non della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-172">A profiler generally measures the performance of the CPU, not the GPU.</span></span> <span data-ttu-id="0b703-173">Ciò rende difficoltosa la profilatura, perché le misurazioni eseguite da un profiler di strumentazione includono il tempo della CPU, ma potrebbero non includere il tempo della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-173">This makes profiling challenging, because the measurements made by an instrumenting profiler include the CPU time but may not include the GPU time.</span></span>

<span data-ttu-id="0b703-174">Lo scopo della GPU è quello di non caricare l'elaborazione dalla CPU a un processore appositamente progettato per il lavoro della grafica.</span><span class="sxs-lookup"><span data-stu-id="0b703-174">The purpose of the GPU is to off-load processing from the CPU to a processor specifically designed for graphics work.</span></span> <span data-ttu-id="0b703-175">Sulle schede video moderne la GPU sostituisce gran parte del lavoro di trasformazione e illuminazione nella pipeline dalla CPU alla GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-175">On modern video cards, the GPU replaces much of the transform and lighting work in the pipeline from the CPU to the GPU.</span></span> <span data-ttu-id="0b703-176">Questo riduce notevolmente il carico di lavoro della CPU, lasciando più cicli di CPU disponibili per altre elaborazioni.</span><span class="sxs-lookup"><span data-stu-id="0b703-176">This greatly reduces the CPU workload, leaving more CPU cycles available for other processing.</span></span> <span data-ttu-id="0b703-177">Per ottimizzare un'applicazione grafica per le prestazioni ottimali, è necessario misurare le prestazioni della CPU e della GPU e bilanciare il lavoro tra i due tipi di processori.</span><span class="sxs-lookup"><span data-stu-id="0b703-177">To tune a graphical application for peak performance, you need to measure the performance of both the CPU and the GPU, and balance the work between the two types of processors.</span></span>

<span data-ttu-id="0b703-178">In questo documento non vengono trattati gli argomenti relativi alla misurazione delle prestazioni della GPU o al bilanciamento del lavoro tra la CPU e la GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-178">This document does not cover topics related to measuring the performance of the GPU or balancing the work between the CPU and the GPU.</span></span> <span data-ttu-id="0b703-179">Per comprendere meglio le prestazioni di una GPU (o una scheda video specifica), visitare il sito Web del fornitore per cercare ulteriori informazioni sulle prestazioni della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-179">If you want to better understand the performance of a GPU (or a particular video card), visit the vendor's web site to look for more information about GPU performance.</span></span> <span data-ttu-id="0b703-180">Al contrario, questo documento è incentrato sul lavoro svolto dal runtime e dal driver riducendo il lavoro della GPU a una quantità trascurabile.</span><span class="sxs-lookup"><span data-stu-id="0b703-180">Instead, this document focuses on the work done by the runtime and the driver by reducing the GPU work to a negligible amount.</span></span> <span data-ttu-id="0b703-181">Questo è in parte basato sull'esperienza che le applicazioni che hanno riscontrato problemi di prestazioni sono in genere limitate alla CPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-181">This is, in part, based on experience that applications experiencing performance problems are generally CPU-limited.</span></span>

### <a name="runtime-and-driver-optimizations-can-mask-api-measurements"></a><span data-ttu-id="0b703-182">Le ottimizzazioni di runtime e driver possono mascherare le misurazioni API</span><span class="sxs-lookup"><span data-stu-id="0b703-182">Runtime and Driver Optimizations Can Mask API Measurements</span></span>

<span data-ttu-id="0b703-183">Nel runtime è incorporata un'ottimizzazione delle prestazioni che può sovraccaricare la misurazione di una singola chiamata.</span><span class="sxs-lookup"><span data-stu-id="0b703-183">The runtime has a performance optimization built into it that can overwhelm the measurement of an individual call.</span></span> <span data-ttu-id="0b703-184">Ecco uno scenario di esempio che illustra questo problema.</span><span class="sxs-lookup"><span data-stu-id="0b703-184">Here's an example scenario that demonstrates this problem.</span></span> <span data-ttu-id="0b703-185">Si consideri la seguente sequenza di rendering:</span><span class="sxs-lookup"><span data-stu-id="0b703-185">Consider the following render sequence:</span></span>


```
  BeginScene();
    ...
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    ...
  EndScene();
  Present();
```



<span data-ttu-id="0b703-186">Esempio 1: sequenza di rendering semplice</span><span class="sxs-lookup"><span data-stu-id="0b703-186">Example 1: Simple Render Sequence</span></span>

<span data-ttu-id="0b703-187">Esaminando i risultati per le due chiamate nella sequenza di rendering, un profiler di strumentazione può restituire risultati simili ai seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-187">Looking at the results for the two calls in the render sequence, an instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture       : 100
Number of cycles for DrawPrimitive    : 950,500
```



<span data-ttu-id="0b703-188">Il profiler restituisce il numero di cicli della CPU necessari per elaborare il lavoro associato a ogni chiamata. tenere presente che la GPU non è inclusa in questi numeri perché la GPU non ha ancora iniziato a usare questi comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-188">The profiler returns the number of CPU cycles required to process the work associated with each call (remember that the GPU isn't included in these numbers because the GPU hasn't started working on these commands yet).</span></span> <span data-ttu-id="0b703-189">Poiché [**IDirect3DDevice9::D rawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) richiedeva quasi un milione di cicli per l'elaborazione, è possibile concludere che non è molto efficiente.</span><span class="sxs-lookup"><span data-stu-id="0b703-189">Because [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) required almost a million cycles to process, you could conclude that it is not very efficient.</span></span> <span data-ttu-id="0b703-190">Tuttavia, si noterà presto il motivo per cui questa conclusione non è corretta e come è possibile generare risultati che possono essere utilizzati per il budget.</span><span class="sxs-lookup"><span data-stu-id="0b703-190">However, you'll soon see why this conclusion is incorrect and how you can generate results that can be used for budgeting.</span></span>

### <a name="measuring-state-changes-requires-careful-render-sequences"></a><span data-ttu-id="0b703-191">La misurazione delle modifiche di stato richiede un'attenta sequenza di rendering</span><span class="sxs-lookup"><span data-stu-id="0b703-191">Measuring State Changes Requires Careful Render Sequences</span></span>

<span data-ttu-id="0b703-192">Tutte le chiamate diverse da [**IDirect3DDevice9::D rawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)o [**Clear**](/windows/desktop/api) (ad esempio, [**setrame**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api)e [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) producono una modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-192">All calls other than [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), or [**Clear**](/windows/desktop/api) (such as [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api), and [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) produce a state change.</span></span> <span data-ttu-id="0b703-193">Ogni modifica di stato imposta lo stato della pipeline che controlla il modo in cui verrà eseguito il rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-193">Each state change sets pipeline state that controls how rendering will be done.</span></span>

<span data-ttu-id="0b703-194">Le ottimizzazioni in fase di esecuzione e/o il driver sono progettate per velocizzare il rendering riducendo la quantità di lavoro necessario.</span><span class="sxs-lookup"><span data-stu-id="0b703-194">Optimizations in the runtime and/or the driver are designed to speed up rendering by reducing the amount of work required.</span></span> <span data-ttu-id="0b703-195">Di seguito sono riportate alcune ottimizzazioni di modifica dello stato che potrebbero inquinare le medie del profilo:</span><span class="sxs-lookup"><span data-stu-id="0b703-195">The following are a couple of state change optimizations that may pollute profile averages:</span></span>

-   <span data-ttu-id="0b703-196">Un driver (o il Runtime) può salvare una modifica di stato come stato locale.</span><span class="sxs-lookup"><span data-stu-id="0b703-196">A driver (or the runtime) could save a state change as a local state.</span></span> <span data-ttu-id="0b703-197">Poiché il driver potrebbe funzionare in un algoritmo "Lazy" (posticipando il lavoro fino a quando non è assolutamente necessario), il lavoro associato ad alcune modifiche di stato potrebbe essere ritardato.</span><span class="sxs-lookup"><span data-stu-id="0b703-197">Because the driver could operate in a "lazy" algorithm (postponing work until it is absolutely necessary), work associated with some state changes could get delayed.</span></span>
-   <span data-ttu-id="0b703-198">Il runtime (o un driver) può rimuovere le modifiche dello stato ottimizzando.</span><span class="sxs-lookup"><span data-stu-id="0b703-198">The runtime (or a driver) may remove state changes by optimizing.</span></span> <span data-ttu-id="0b703-199">Un esempio potrebbe essere quello di rimuovere una modifica di stato ridondante che disabilita l'illuminazione perché l'illuminazione è stata precedentemente disabilitata.</span><span class="sxs-lookup"><span data-stu-id="0b703-199">An example of this might be to remove a redundant state change that disables lighting because lighting has previously been disabled.</span></span>

<span data-ttu-id="0b703-200">Non esiste un modo infallibile per esaminare una sequenza di rendering e concludere quali modifiche di stato consentiranno di impostare un bit dirty e rinviare il lavoro oppure verranno semplicemente rimosse dall'ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-200">There is no foolproof way to look at a render sequence and conclude which state changes will set a dirty bit and defer work, or will simply be removed by optimization.</span></span> <span data-ttu-id="0b703-201">Anche se è possibile identificare le modifiche dello stato ottimizzate nel runtime o nel driver odierno, è probabile che il runtime o il driver di domani venga aggiornato.</span><span class="sxs-lookup"><span data-stu-id="0b703-201">Even if you could identify optimized state changes in today's runtime or driver, tomorrow's runtime or driver is likely to be updated.</span></span> <span data-ttu-id="0b703-202">Non si conosce neanche facilmente lo stato precedente, quindi è difficile identificare le modifiche di stato ridondanti.</span><span class="sxs-lookup"><span data-stu-id="0b703-202">You also don't readily know what the previous state was so it is difficult to identify redundant state changes.</span></span> <span data-ttu-id="0b703-203">L'unico modo per verificare il costo di una modifica di stato consiste nel misurare la sequenza di rendering che include le modifiche dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-203">The only way to verify the cost of a state change is to measure the render sequence that includes the state changes.</span></span>

<span data-ttu-id="0b703-204">Come si può notare, le complicazioni provocate dalla presenza di più processori, comandi elaborati da più di un componente e ottimizzazioni incorporate nei componenti rendono difficile la stima della profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-204">As you can see, the complications caused by having multiple processors, commands being processed by more than one component, and optimizations built into the components make profiling difficult to predict.</span></span> <span data-ttu-id="0b703-205">Nella sezione successiva verranno affrontate le eventuali problemi di profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-205">In the next section, each of these profiling challenges will be addressed.</span></span> <span data-ttu-id="0b703-206">Verranno visualizzate le sequenze di rendering Direct3D di esempio, con le tecniche di misurazione associate.</span><span class="sxs-lookup"><span data-stu-id="0b703-206">Sample Direct3D render sequences will be shown, with the accompanying measurement techniques.</span></span> <span data-ttu-id="0b703-207">Con queste informazioni, sarà possibile generare misurazioni accurate e ripetibili sulle singole chiamate.</span><span class="sxs-lookup"><span data-stu-id="0b703-207">With this knowledge, you will be able to generate accurate, repeatable measurements on individual calls.</span></span>

## <a name="how-to-accurately-profile-a-direct3d-render-sequence"></a><span data-ttu-id="0b703-208">Come profilare accuratamente una sequenza di rendering Direct3D</span><span class="sxs-lookup"><span data-stu-id="0b703-208">How to Accurately Profile a Direct3D Render Sequence</span></span>

<span data-ttu-id="0b703-209">Ora che sono state evidenziate alcune delle problemi di profilatura, in questa sezione verranno illustrate le tecniche che consentono di generare misure di profilo che possono essere utilizzate per il budget.</span><span class="sxs-lookup"><span data-stu-id="0b703-209">Now that some of the profiling challenges have been highlighted, this section will show you techniques that will help you generate profile measurements that can be used for budgeting.</span></span> <span data-ttu-id="0b703-210">Le misurazioni di profilatura accurate e ripetibili sono possibili se si conosce la relazione tra i componenti controllati dalla CPU e come evitare le ottimizzazioni delle prestazioni implementate dal runtime e dal driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-210">Accurate, repeatable profiling measurements are possible if you understand the relationship between the components controlled by the CPU, and how to avoid performance optimizations implemented by the runtime and the driver.</span></span>

<span data-ttu-id="0b703-211">Per iniziare, è necessario essere in grado di misurare accuratamente il tempo di esecuzione di una singola chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-211">To begin, you need to be able to accurately measure the execution time of a single API call.</span></span>

### <a name="pick-an-accurate-measurement-tool-like-queryperformancecounter"></a><span data-ttu-id="0b703-212">Selezionare uno strumento di misurazione accurato come QueryPerformanceCounter</span><span class="sxs-lookup"><span data-stu-id="0b703-212">Pick an Accurate Measurement Tool Like QueryPerformanceCounter</span></span>

<span data-ttu-id="0b703-213">Il sistema operativo Microsoft Windows include un timer ad alta risoluzione che può essere usato per misurare i tempi di risoluzione elevata.</span><span class="sxs-lookup"><span data-stu-id="0b703-213">The Microsoft Windows operating system includes a high-resolution timer that can be used to measure high-resolution elapsed times.</span></span> <span data-ttu-id="0b703-214">Il valore corrente di uno di questi timer può essere restituito usando [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span><span class="sxs-lookup"><span data-stu-id="0b703-214">The current value of one such timer can be returned using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span></span> <span data-ttu-id="0b703-215">Dopo aver richiamato **QueryPerformanceCounter** per restituire i valori di inizio e di arresto, la differenza tra i due valori può essere convertita nel tempo effettivo trascorso (in secondi) usando **QueryPerformanceCounter**.</span><span class="sxs-lookup"><span data-stu-id="0b703-215">After invoking **QueryPerformanceCounter** to return start and stop values, the difference between the two values can be converted to the actual elapsed time (in seconds) using **QueryPerformanceCounter**.</span></span>

<span data-ttu-id="0b703-216">I vantaggi dell'uso di [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) sono che sono disponibili in Windows ed è facile da usare.</span><span class="sxs-lookup"><span data-stu-id="0b703-216">The advantages of using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) are that it is available in Windows and it is easy to use.</span></span> <span data-ttu-id="0b703-217">È sufficiente racchiudere le chiamate con una chiamata **QueryPerformanceCounter** e salvare i valori di inizio e di fine.</span><span class="sxs-lookup"><span data-stu-id="0b703-217">Simply surround the calls with a **QueryPerformanceCounter** call and save the start and stop values.</span></span> <span data-ttu-id="0b703-218">Pertanto, in questo documento viene illustrato come utilizzare **QueryPerformanceCounter** per profilare i tempi di esecuzione, in modo analogo al modo in cui un profiler di strumentazione lo misura.</span><span class="sxs-lookup"><span data-stu-id="0b703-218">Therefore, this paper will demonstrate how to use **QueryPerformanceCounter** to profile execution times, similar to the way an instrumenting profiler would measure it.</span></span> <span data-ttu-id="0b703-219">Di seguito è riportato un esempio che illustra come incorporare **QueryPerformanceCounter** nel codice sorgente:</span><span class="sxs-lookup"><span data-stu-id="0b703-219">Here's an example that shows how to embed **QueryPerformanceCounter** in your source code:</span></span>


```
  BeginScene();
    ...
    // Start profiling
    LARGE_INTEGER start, stop, freq;
    QueryPerformanceCounter(&start);

    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1); 

    QueryPerformanceCounter(&stop);
    stop.QuadPart -= start.QuadPart;
    QueryPerformanceFrequency(&freq);
    // Stop profiling
    ...
  EndScene();
  Present();
```



<span data-ttu-id="0b703-220">Esempio 2: implementazione della profilatura personalizzata con QPC</span><span class="sxs-lookup"><span data-stu-id="0b703-220">Example 2: Custom Profiling Implementation with QPC</span></span>

<span data-ttu-id="0b703-221">Start e stop sono due numeri interi di grandi dimensioni che conterranno i valori di inizio e di arresto restituiti dal timer a prestazioni elevate.</span><span class="sxs-lookup"><span data-stu-id="0b703-221">start and stop are two large integers that will hold the start and stop values returned by the high-performance timer.</span></span> <span data-ttu-id="0b703-222">Si noti che QueryPerformanceCounter (&Start) viene chiamato immediatamente [**prima di**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) QueryPerformanceCounter (&stop) viene chiamato subito dopo [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="0b703-222">Notice that QueryPerformanceCounter(&start) is called just before [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and QueryPerformanceCounter(&stop) is called just after [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="0b703-223">Dopo aver ricevuto il valore di arresto, viene chiamato QueryPerformanceFrequency per restituire freq, che corrisponde alla frequenza del timer ad alta risoluzione.</span><span class="sxs-lookup"><span data-stu-id="0b703-223">After getting the stop value, QueryPerformanceFrequency is called to return freq, which is the frequency of the high-resolution timer.</span></span> <span data-ttu-id="0b703-224">In questo esempio ipotetico si supponga di ottenere i risultati seguenti per Start, stop e FREQ:</span><span class="sxs-lookup"><span data-stu-id="0b703-224">In this hypothetical example, suppose you get the following results for start, stop, and freq:</span></span>



| <span data-ttu-id="0b703-225">Variabile locale</span><span class="sxs-lookup"><span data-stu-id="0b703-225">Local Variable</span></span> | <span data-ttu-id="0b703-226">Numero di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-226">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="0b703-227">start</span><span class="sxs-lookup"><span data-stu-id="0b703-227">start</span></span>          | <span data-ttu-id="0b703-228">1792998845094</span><span class="sxs-lookup"><span data-stu-id="0b703-228">1792998845094</span></span>   |
| <span data-ttu-id="0b703-229">stop</span><span class="sxs-lookup"><span data-stu-id="0b703-229">stop</span></span>           | <span data-ttu-id="0b703-230">1792998845102</span><span class="sxs-lookup"><span data-stu-id="0b703-230">1792998845102</span></span>   |
| <span data-ttu-id="0b703-231">freq</span><span class="sxs-lookup"><span data-stu-id="0b703-231">freq</span></span>           | <span data-ttu-id="0b703-232">3579545</span><span class="sxs-lookup"><span data-stu-id="0b703-232">3579545</span></span>         |



 

<span data-ttu-id="0b703-233">È possibile convertire questi valori nel numero di cicli necessari per eseguire le chiamate API, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="0b703-233">You could convert these values to the number of cycles it takes to execute the API calls like this:</span></span>


```
# ticks = (stop - start) = 1792998845102 - 1792998845094 = 8 ticks

# cycles = CPU speed * number of ticks / QPF
# 4568   = 2 GHz      * 8              / 3,579,545
```



<span data-ttu-id="0b703-234">In altre parole, sono necessari circa 4568 cicli di clock per elaborare la [**trama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) e [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) in questo computer da 2 GHz.</span><span class="sxs-lookup"><span data-stu-id="0b703-234">In other words, it takes about 4568 clock cycles to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) on this 2 GHz machine.</span></span> <span data-ttu-id="0b703-235">È possibile convertire questi valori nel tempo effettivo richiesto per eseguire tutte le chiamate come segue:</span><span class="sxs-lookup"><span data-stu-id="0b703-235">You could convert these values to the actual time it took to execute all the calls like this:</span></span>


```
(stop - start)/ freq = elapsed time
8 ticks / 3,579,545 = 2.2E-6 seconds or between 2 and 3 microseconds.
```



<span data-ttu-id="0b703-236">L'uso di QueryPerformanceCounter richiede l'aggiunta di misure di avvio e interruzione alla sequenza di rendering e l'uso di QueryPerformanceFrequency per convertire la differenza (numero di cicli) nel numero di cicli della CPU o nel tempo effettivo.</span><span class="sxs-lookup"><span data-stu-id="0b703-236">Using QueryPerformanceCounter requires that you add start and stop measurements to your render sequence and use QueryPerformanceFrequency to convert the difference (number of ticks) to the number of CPU cycles or to actual time.</span></span> <span data-ttu-id="0b703-237">Identificare la tecnica di misurazione è un inizio efficace per lo sviluppo di un'implementazione di profilatura personalizzata.</span><span class="sxs-lookup"><span data-stu-id="0b703-237">Identifying the measurement technique is a good start for developing a custom profiling implementation.</span></span> <span data-ttu-id="0b703-238">Tuttavia, prima di iniziare a eseguire le misurazioni, è necessario capire come gestire la scheda video.</span><span class="sxs-lookup"><span data-stu-id="0b703-238">But before you jump in and start making measurements, you need to know how to deal with the video card.</span></span>

### <a name="focus-on-cpu-measurements"></a><span data-ttu-id="0b703-239">Concentrarsi sulle misurazioni della CPU</span><span class="sxs-lookup"><span data-stu-id="0b703-239">Focus on CPU Measurements</span></span>

<span data-ttu-id="0b703-240">Come indicato in precedenza, la CPU e la GPU funzionano in parallelo per elaborare il lavoro generato dalle chiamate API.</span><span class="sxs-lookup"><span data-stu-id="0b703-240">As stated earlier, the CPU and the GPU work in parallel to process the work generated by the API calls.</span></span> <span data-ttu-id="0b703-241">Un'applicazione reale richiede la profilatura di entrambi i tipi di processori per verificare se l'applicazione è limitata a livello di CPU o GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-241">A real world application requires profiling both types of processors to find out if your application is CPU-limited or GPU-limited.</span></span> <span data-ttu-id="0b703-242">Poiché le prestazioni della GPU sono specifiche del fornitore, è molto difficile produrre i risultati in questo documento che coprono la varietà di schede video disponibili.</span><span class="sxs-lookup"><span data-stu-id="0b703-242">Since GPU performance is vendor specific, it would be very challenging to produce results in this paper that cover the variety of video cards available.</span></span>

<span data-ttu-id="0b703-243">Al contrario, questo documento è incentrato solo sulla profilatura del lavoro eseguito dalla CPU utilizzando una tecnica personalizzata per misurare il funzionamento del runtime e del driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-243">Instead, this paper will focus only on profiling the work performed by the CPU by using a custom technique for measuring the runtime and driver work.</span></span> <span data-ttu-id="0b703-244">Il lavoro della GPU verrà ridotto a un importo non significativo, in modo che i risultati della CPU risultino più visibili.</span><span class="sxs-lookup"><span data-stu-id="0b703-244">The GPU work will be reduced to an insignificant amount, so that CPU results are more visible.</span></span> <span data-ttu-id="0b703-245">Un vantaggio di questo approccio è che questa tecnica restituisce i risultati nell'appendice che dovrebbe essere in grado di correlare con le misurazioni.</span><span class="sxs-lookup"><span data-stu-id="0b703-245">One benefit of this approach is that this technique yields results in the Appendix that you should be able to correlate with your measurements.</span></span> <span data-ttu-id="0b703-246">Per ridurre il lavoro richiesto dalla scheda video a un livello non significativo, è sufficiente ridurre il lavoro di rendering al minor numero possibile.</span><span class="sxs-lookup"><span data-stu-id="0b703-246">To reduce the work required by the video card to an insignificant level, simply reduce the rendering work to the least amount possible.</span></span> <span data-ttu-id="0b703-247">Questa operazione può essere eseguita limitando le chiamate di disegnare per eseguire il rendering di un singolo triangolo e può essere ulteriormente vincolato in modo che ogni triangolo contenga solo un pixel.</span><span class="sxs-lookup"><span data-stu-id="0b703-247">This can be accomplished by limiting draw calls to render a single triangle, and can be further constrained so that each triangle only contains one pixel.</span></span>

<span data-ttu-id="0b703-248">L'unità di misura utilizzata in questo documento per misurare il lavoro della CPU sarà il numero di cicli di clock della CPU anziché il tempo effettivo.</span><span class="sxs-lookup"><span data-stu-id="0b703-248">The unit of measure used in this paper for measuring CPU work will be the number of CPU clock cycles rather than actual time.</span></span> <span data-ttu-id="0b703-249">I cicli di clock della CPU hanno il vantaggio di essere più portabili (per applicazioni limitate alla CPU) rispetto al tempo trascorso effettivo tra computer con velocità di CPU diverse.</span><span class="sxs-lookup"><span data-stu-id="0b703-249">CPU clock cycles has the advantage that it is more portable (for CPU-limited applications) than actual elapsed time across machines with different CPU speeds.</span></span> <span data-ttu-id="0b703-250">Questa operazione può essere facilmente convertita in un momento effettivo se lo si desidera.</span><span class="sxs-lookup"><span data-stu-id="0b703-250">This can easily be converted to actual time if desired.</span></span>

<span data-ttu-id="0b703-251">In questo documento non vengono trattati gli argomenti relativi al bilanciamento del carico di lavoro tra la CPU e la GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-251">This document does not cover topics related to balancing the work load between the CPU and the GPU.</span></span> <span data-ttu-id="0b703-252">Tenere presente che l'obiettivo di questo documento non è misurare le prestazioni complessive di un'applicazione, ma per illustrare come misurare accuratamente il tempo impiegato dal runtime e dal driver per elaborare le chiamate API.</span><span class="sxs-lookup"><span data-stu-id="0b703-252">Remember, the goal of this paper is not to measure the overall performance of an application, but to show you how to accurately measure the time it takes the runtime and the driver to process API calls.</span></span> <span data-ttu-id="0b703-253">Con queste misurazioni accurate, è possibile eseguire l'attività di budget della CPU per comprendere determinati scenari di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="0b703-253">With these accurate measurements, you can take on the task of budgeting the CPU to understand certain performance scenarios.</span></span>

### <a name="controlling-runtime-and-driver-optimizations"></a><span data-ttu-id="0b703-254">Controllo delle ottimizzazioni di runtime e driver</span><span class="sxs-lookup"><span data-stu-id="0b703-254">Controlling Runtime and Driver Optimizations</span></span>

<span data-ttu-id="0b703-255">Con una tecnica di misurazione identificata e una strategia per ridurre il lavoro della GPU, il passaggio successivo consiste nel comprendere le ottimizzazioni del runtime e dei driver che vengono eseguite durante la profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-255">With a measurement technique identified, and a strategy for reducing GPU work, the next step is to understand the runtime and driver optimizations that get in the way when you are profiling.</span></span>

<span data-ttu-id="0b703-256">Il lavoro della CPU può essere suddiviso in tre bucket: il lavoro dell'applicazione, il funzionamento del runtime e il funzionamento del driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-256">The CPU work can be divided into three buckets: the application work, the runtime work, and the driver work.</span></span> <span data-ttu-id="0b703-257">Ignorare il lavoro dell'applicazione perché è sotto il controllo del programmatore.</span><span class="sxs-lookup"><span data-stu-id="0b703-257">Ignore the application work since this is under programmer control.</span></span> <span data-ttu-id="0b703-258">Dal punto di vista dell'applicazione, il runtime e il driver sono come le caselle nere, perché l'applicazione non ha alcun controllo sugli elementi implementati.</span><span class="sxs-lookup"><span data-stu-id="0b703-258">From the application's standpoint, the runtime and the driver are like black boxes, as the application has no control over what is implemented in them.</span></span> <span data-ttu-id="0b703-259">La chiave consiste nel comprendere le tecniche di ottimizzazione che possono essere implementate nel runtime e nel driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-259">The key is to understand the optimization techniques that may be implemented in the runtime and the driver.</span></span> <span data-ttu-id="0b703-260">Se non si conoscono queste ottimizzazioni, è molto facile passare alla conclusione sbagliata sulla quantità di lavoro eseguita dalla CPU in base alle misurazioni del profilo.</span><span class="sxs-lookup"><span data-stu-id="0b703-260">If you don't understand these optimizations, it is very easy to jump to the wrong conclusion about the amount of work the CPU is doing based on the profile measurements.</span></span> <span data-ttu-id="0b703-261">In particolare, esistono due argomenti correlati a un elemento denominato buffer dei comandi e le operazioni che possono essere eseguite per offuscare la profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-261">In particular, there are two topics related to something called the command buffer and what it can do to obfuscate profiling.</span></span> <span data-ttu-id="0b703-262">tra cui:</span><span class="sxs-lookup"><span data-stu-id="0b703-262">These topics are:</span></span>

-   <span data-ttu-id="0b703-263">Ottimizzazione del runtime con il buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-263">Runtime optimization with the Command Buffer.</span></span> <span data-ttu-id="0b703-264">Il buffer dei comandi è un'ottimizzazione del runtime che riduce l'effetto di una transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-264">The command buffer is a runtime optimization that reduces the impact of a mode transition.</span></span> <span data-ttu-id="0b703-265">Per controllare l'intervallo di transizione della modalità, vedere [controllo del buffer dei comandi](#controlling-the-command-buffer).</span><span class="sxs-lookup"><span data-stu-id="0b703-265">To control the timing of the mode transition, see [Controlling the Command Buffer](#controlling-the-command-buffer).</span></span>
-   <span data-ttu-id="0b703-266">Negazione degli effetti temporali del buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-266">Negating the timing effects of the Command Buffer.</span></span> <span data-ttu-id="0b703-267">Il tempo trascorso di una transizione in modalità può avere un notevole effetto sulle misurazioni di profiling.</span><span class="sxs-lookup"><span data-stu-id="0b703-267">The elapsed time of a mode transition can have a big impact on profiling measurements.</span></span> <span data-ttu-id="0b703-268">La strategia consiste nel [rendere la sequenza di rendering grande rispetto alla transizione della modalità](#make-the-render-sequence-large-compared-to-the-mode-transition).</span><span class="sxs-lookup"><span data-stu-id="0b703-268">The strategy for this is to [Make the Render Sequence Large Compared to the Mode Transition](#make-the-render-sequence-large-compared-to-the-mode-transition).</span></span>

### <a name="controlling-the-command-buffer"></a><span data-ttu-id="0b703-269">Controllo del buffer dei comandi</span><span class="sxs-lookup"><span data-stu-id="0b703-269">Controlling the Command Buffer</span></span>

<span data-ttu-id="0b703-270">Quando un'applicazione esegue una chiamata API, il runtime converte la chiamata API in un formato indipendente dal dispositivo (che verrà chiamato da un comando) e lo archivia nel buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-270">When an application makes an API call, the runtime converts the API call to a device-independent format (which we will call a command), and stores it in the command buffer.</span></span> <span data-ttu-id="0b703-271">Il buffer dei comandi viene aggiunto al diagramma seguente.</span><span class="sxs-lookup"><span data-stu-id="0b703-271">The command buffer is added to the following diagram.</span></span>

![diagramma dei componenti della CPU, incluso un buffer dei comandi](images/microbenchmarkcommandbuffer2.png)

<span data-ttu-id="0b703-273">Ogni volta che l'applicazione esegue un'altra chiamata API, il runtime ripete questa sequenza e aggiunge un altro comando al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-273">Each time the application makes another API call, the runtime repeats this sequence and adds another command to the command buffer.</span></span> <span data-ttu-id="0b703-274">A un certo punto, il runtime svuota il buffer (inviando i comandi al driver).</span><span class="sxs-lookup"><span data-stu-id="0b703-274">At some point, the runtime empties the buffer (sending the commands to the driver).</span></span> <span data-ttu-id="0b703-275">In Windows XP, lo svuotamento del buffer dei comandi provoca una transizione in modalità come il sistema operativo passa dal runtime (in esecuzione in modalità utente) al driver (in esecuzione in modalità kernel), come illustrato nel diagramma seguente.</span><span class="sxs-lookup"><span data-stu-id="0b703-275">In Windows XP, emptying the command buffer causes a mode transition as the operating system switches from the runtime (running in user mode) to the driver (running in kernel mode), as shown in the following diagram.</span></span>

-   <span data-ttu-id="0b703-276">modalità utente: la modalità del processore senza privilegi che esegue il codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-276">user mode - The non-privileged processor mode that executes application code.</span></span> <span data-ttu-id="0b703-277">Le applicazioni in modalità utente non possono accedere ai dati di sistema tranne che tramite i servizi di sistema.</span><span class="sxs-lookup"><span data-stu-id="0b703-277">User-mode applications cannot gain access to system data except through system services.</span></span>
-   <span data-ttu-id="0b703-278">modalità kernel: la modalità di elaborazione con privilegi in cui viene eseguito il codice Executive basato su Windows.</span><span class="sxs-lookup"><span data-stu-id="0b703-278">kernel mode - The privileged processor mode in which Windows-based executive code runs.</span></span> <span data-ttu-id="0b703-279">Un driver o un thread in esecuzione in modalità kernel può accedere a tutta la memoria di sistema, l'accesso diretto all'hardware e le istruzioni della CPU per l'esecuzione di operazioni di I/O con l'hardware.</span><span class="sxs-lookup"><span data-stu-id="0b703-279">A driver or thread running in kernel mode has access to all system memory, direct access to hardware, and the CPU instructions to perform I/O with the hardware.</span></span>

![diagramma delle transizioni tra la modalità utente e la modalità kernel](images/microbenchmarkcommandbuffer3.png)

<span data-ttu-id="0b703-281">La transizione si verifica ogni volta che la CPU passa dall'utente alla modalità kernel (e viceversa) e il numero di cicli richiesti è grande rispetto a una singola chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-281">The transition happens each time the CPU switches from user to kernel mode (and vice versa) and the number of cycles it requires is large compared to an individual API call.</span></span> <span data-ttu-id="0b703-282">Se il runtime ha inviato ogni chiamata API al driver quando è stato richiamato, ogni chiamata API comporterebbe il costo di una transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-282">If the runtime sent each API call to the driver when it was invoked, every API call would incur the cost of a mode transition.</span></span>

<span data-ttu-id="0b703-283">Il buffer dei comandi è invece un'ottimizzazione del Runtime progettata per ridurre il costo effettivo della transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-283">Instead, the command buffer is a runtime optimization designed to reduce the effective cost of the mode transition.</span></span> <span data-ttu-id="0b703-284">Il buffer dei comandi Accoda molti comandi driver in preparazione per una singola transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-284">The command buffer queues many driver commands in preparation for a single mode transition.</span></span> <span data-ttu-id="0b703-285">Quando il runtime aggiunge un comando al buffer dei comandi, il controllo viene restituito all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-285">When the runtime adds a command to the command buffer, control is returned to the application.</span></span> <span data-ttu-id="0b703-286">Un profiler non è in grado di sapere che i comandi del driver non sono stati ancora inviati al driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-286">A profiler has no way of knowing that the driver commands have probably not even been sent to the driver yet.</span></span> <span data-ttu-id="0b703-287">Di conseguenza, i numeri restituiti da un profiler di strumentazione fuori piano sono fuorvianti, perché misura il lavoro di runtime ma non il driver associato.</span><span class="sxs-lookup"><span data-stu-id="0b703-287">As a result, the numbers returned by an off-the-shelf instrumenting profiler are misleading since it measures the runtime work but not the associated driver work.</span></span>

### <a name="profile-results-without-a-mode-transition"></a><span data-ttu-id="0b703-288">Risultati del profilo senza una transizione in modalità</span><span class="sxs-lookup"><span data-stu-id="0b703-288">Profile Results without a Mode Transition</span></span>

<span data-ttu-id="0b703-289">Utilizzando la sequenza di rendering dell'esempio 2, di seguito sono riportate alcune misurazioni di intervallo tipiche che illustrano la grandezza di una transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-289">Using the render sequence from example 2, here are some typical timing measurements that illustrate the magnitude of a mode transition.</span></span> <span data-ttu-id="0b703-290">Supponendo che le chiamate a [**Setrame**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) e [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) non causino una transizione in modalità, un profiler instrumentato non ripiano può restituire risultati simili ai seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-290">Assuming that [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls do not cause a mode transition, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
```



<span data-ttu-id="0b703-291">Ognuno di questi numeri è la quantità di tempo impiegato dal runtime per aggiungere queste chiamate al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-291">Each of these numbers are the amount of time it takes for the runtime to add these calls to the command buffer.</span></span> <span data-ttu-id="0b703-292">Poiché non è presente alcuna transizione in modalità, il driver non ha ancora eseguito alcun lavoro.</span><span class="sxs-lookup"><span data-stu-id="0b703-292">Since there is no mode transition, the driver has not done any work yet.</span></span> <span data-ttu-id="0b703-293">I risultati del profiler sono accurati, ma non misurano tutte le operazioni che la sequenza di rendering provocherà alla fine della CPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-293">The profiler results are accurate, but they do not measure all of the work that the render sequence will eventually cause the CPU to perform.</span></span>

### <a name="profile-results-with-a-mode-transition"></a><span data-ttu-id="0b703-294">Risultati del profilo con una transizione in modalità</span><span class="sxs-lookup"><span data-stu-id="0b703-294">Profile Results with a Mode Transition</span></span>

<span data-ttu-id="0b703-295">A questo punto, osservare cosa accade per lo stesso esempio quando si verifica una transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-295">Now, look at what happens for the same example when a mode transition occurs.</span></span> <span data-ttu-id="0b703-296">Questa volta, si [**supponga che**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) causi una transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-296">This time, assume [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) cause a mode transition.</span></span> <span data-ttu-id="0b703-297">Ancora una volta, un profiler instrumentato fuori piano può restituire risultati simili ai seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-297">Once again, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 98 
Number of cycles for DrawPrimitive        : 946,900
```



<span data-ttu-id="0b703-298">Il tempo misurato per la [**detrama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) è lo stesso, tuttavia, il notevole aumento della quantità di tempo impiegato in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) è dovuto alla transizione della modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-298">The time measured for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about the same, however, the dramatic increase in the amount of time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is due to the mode transition.</span></span> <span data-ttu-id="0b703-299">Ecco cosa accade:</span><span class="sxs-lookup"><span data-stu-id="0b703-299">Here's what is happening:</span></span>

1.  <span data-ttu-id="0b703-300">Si supponga che il buffer dei comandi disponga di spazio per un comando prima dell'avvio della sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-300">Assume the command buffer has room for one command before our render sequence starts.</span></span>
2.  <span data-ttu-id="0b703-301">La [**trama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) viene convertita in un formato indipendente dal dispositivo e aggiunta al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is converted to a device-independent format and added to the command buffer.</span></span> <span data-ttu-id="0b703-302">In questo scenario, questa chiamata riempie il buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-302">In this scenario, this call fills the command buffer.</span></span>
3.  <span data-ttu-id="0b703-303">Il runtime tenta di aggiungere [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) al buffer dei comandi, ma non può perché è pieno.</span><span class="sxs-lookup"><span data-stu-id="0b703-303">The runtime tries to add [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to the command buffer but cannot, because it is full.</span></span> <span data-ttu-id="0b703-304">Al contrario, il runtime svuota il buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-304">Instead, the runtime empties the command buffer.</span></span> <span data-ttu-id="0b703-305">Questa operazione causa la transizione in modalità kernel.</span><span class="sxs-lookup"><span data-stu-id="0b703-305">This causes the kernel-mode transition.</span></span> <span data-ttu-id="0b703-306">Si supponga che la transizione riprenda circa 5000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-306">Assume the transition takes about 5000 cycles.</span></span> <span data-ttu-id="0b703-307">Questo tempo contribuisce al tempo dedicato a **DrawPrimitive**.</span><span class="sxs-lookup"><span data-stu-id="0b703-307">This time contributes to time spent in **DrawPrimitive**.</span></span>
4.  <span data-ttu-id="0b703-308">Il driver elabora quindi il lavoro associato a tutti i comandi che sono stati svuotati dal buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-308">The driver then processes the work associated with all the commands that were emptied from the command buffer.</span></span> <span data-ttu-id="0b703-309">Si supponga che l'ora del driver per elaborare i comandi che hanno quasi riempito il buffer dei comandi sia pari a circa 935.000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-309">Assume that the driver time to process the commands that nearly filled the command buffer is about 935,000 cycles.</span></span> <span data-ttu-id="0b703-310">Si supponga che il funzionamento del driver associato a [**Setrame**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) sia pari a circa 2750 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-310">Assume that the driver work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2750 cycles.</span></span> <span data-ttu-id="0b703-311">Questo tempo contribuisce al tempo dedicato a [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="0b703-311">This time contributes to time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>
5.  <span data-ttu-id="0b703-312">Quando il driver termina il lavoro, la transizione in modalità utente restituisce il controllo al runtime.</span><span class="sxs-lookup"><span data-stu-id="0b703-312">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="0b703-313">Il buffer dei comandi è ora vuoto.</span><span class="sxs-lookup"><span data-stu-id="0b703-313">The command buffer is now empty.</span></span> <span data-ttu-id="0b703-314">Si supponga che la transizione riprenda circa 5000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-314">Assume the transition takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="0b703-315">La sequenza di rendering termina convertendo [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) e aggiungendolo al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-315">The render sequence finishes by converting [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) and adding it to the command buffer.</span></span> <span data-ttu-id="0b703-316">Si supponga che questa operazione contenga circa 900 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-316">Assume this takes about 900 cycles.</span></span> <span data-ttu-id="0b703-317">Questo tempo contribuisce al tempo dedicato a **DrawPrimitive**.</span><span class="sxs-lookup"><span data-stu-id="0b703-317">This time contributes to time spent in **DrawPrimitive**.</span></span>

<span data-ttu-id="0b703-318">Riepilogando i risultati, viene visualizzato quanto segue:</span><span class="sxs-lookup"><span data-stu-id="0b703-318">Summarizing the results, you see:</span></span>


```
DrawPrimitive = kernel-transition + driver work    + user-transition + runtime work
DrawPrimitive = 5000              + 935,000 + 2750 + 5000            + 900
DrawPrimitive = 947,950  
```



<span data-ttu-id="0b703-319">Analogamente alla misurazione per [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) senza la transizione della modalità (900 cicli), la misurazione per **DrawPrimitive** con la transizione della modalità (947.950 cicli) è precisa ma inutile in termini di budget per il lavoro della CPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-319">Just like the measurement for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) without the mode transition (900 cycles), the measurement for **DrawPrimitive** with the mode transition (947,950 cycles) is accurate but useless in terms of budgeting CPU work.</span></span> <span data-ttu-id="0b703-320">Il risultato contiene il corretto funzionamento del runtime, il driver funziona per la funzione di [**detrama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), il driver funziona per tutti i comandi che precedono la **trama** e due transizioni in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-320">The result contains the correct runtime work, the driver work for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), the driver work for any commands that preceded **SetTexture**, and two mode transitions.</span></span> <span data-ttu-id="0b703-321">Tuttavia, la misurazione manca il funzionamento del driver **DrawPrimitive** .</span><span class="sxs-lookup"><span data-stu-id="0b703-321">However, the measurement is missing the **DrawPrimitive** driver work.</span></span>

<span data-ttu-id="0b703-322">Una transizione in modalità potrebbe verificarsi in risposta a qualsiasi chiamata.</span><span class="sxs-lookup"><span data-stu-id="0b703-322">A mode transition could happen in response to any call.</span></span> <span data-ttu-id="0b703-323">Dipende da ciò che in precedenza era presente nel buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-323">It depends on what was previously in the command buffer.</span></span> <span data-ttu-id="0b703-324">È necessario controllare la transizione della modalità per comprendere la quantità di lavoro della CPU (Runtime e driver) associata a ogni chiamata.</span><span class="sxs-lookup"><span data-stu-id="0b703-324">You need to control the mode transition to understand how much CPU work (runtime and driver) is associated with each call.</span></span> <span data-ttu-id="0b703-325">A tale scopo, è necessario un meccanismo per controllare il buffer dei comandi e l'intervallo di transizione della modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-325">To do that, you need a mechanism for controlling the command buffer and the timing of the mode transition.</span></span>

### <a name="the-query-mechanism"></a><span data-ttu-id="0b703-326">Meccanismo di query</span><span class="sxs-lookup"><span data-stu-id="0b703-326">The Query Mechanism</span></span>

<span data-ttu-id="0b703-327">Il meccanismo di query di Microsoft Direct3D 9 è stato progettato per consentire al runtime di eseguire query sulla GPU per lo stato di avanzamento e restituire determinati dati dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-327">The query mechanism in Microsoft Direct3D 9 was designed to allow the runtime to query the GPU for progress and return certain data from the GPU.</span></span> <span data-ttu-id="0b703-328">Durante la profilatura, se il lavoro della GPU è ridotto al minimo, in modo da avere un effetto trascurabile sulle prestazioni, è possibile restituire lo stato dalla GPU per misurare il lavoro del driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-328">While profiling, if the GPU work is minimized so that it has a negligible impact on performance, you can return status from the GPU to help measure the driver work.</span></span> <span data-ttu-id="0b703-329">Dopo tutto, il lavoro del driver è completo quando la GPU ha visto i comandi del driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-329">After all, the driver work is complete when the GPU has seen the driver commands.</span></span> <span data-ttu-id="0b703-330">Inoltre, il meccanismo di query può essere persuaso a controllare due caratteristiche del buffer dei comandi importanti per la profilatura: quando il buffer dei comandi viene svuotato e la quantità di lavoro nel buffer.</span><span class="sxs-lookup"><span data-stu-id="0b703-330">Additionally, the query mechanism can be coaxed into controlling two command buffer characteristics that are important to profiling: when the command buffer empties and how much work is in the buffer.</span></span>

<span data-ttu-id="0b703-331">Di seguito è illustrata la stessa sequenza di rendering con il meccanismo di query:</span><span class="sxs-lookup"><span data-stu-id="0b703-331">Here's the same render sequence using the query mechanism:</span></span>


```
// 1. Create an event query from the current device
IDirect3DQuery9* pEvent;
m_pD3DDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEvent);

// 2. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 3. Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

// 4. Start profiling
LARGE_INTEGER start, stop;
QueryPerformanceCounter(&start);

// 5. Invoke the API calls to be profiled.
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

// 6. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 7. Force the driver to execute the commands from the command buffer.
// Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
    
// 8. End profiling
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="0b703-332">Esempio 3: utilizzo di una query per controllare il buffer dei comandi</span><span class="sxs-lookup"><span data-stu-id="0b703-332">Example 3: Using a Query to Control the Command Buffer</span></span>

<span data-ttu-id="0b703-333">Ecco una spiegazione più dettagliata di ognuna di queste righe di codice:</span><span class="sxs-lookup"><span data-stu-id="0b703-333">Here is a more detailed explanation of each of these lines of code:</span></span>

1.  <span data-ttu-id="0b703-334">Creare una query di eventi creando un oggetto query con \_ evento D3DQUERYTYPE.</span><span class="sxs-lookup"><span data-stu-id="0b703-334">Create an event query by creating a query object with D3DQUERYTYPE\_EVENT.</span></span>
2.  <span data-ttu-id="0b703-335">Aggiungere un marcatore dell'evento di query al buffer dei comandi chiamando [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE \_ end**](d3dissue-end.md)).</span><span class="sxs-lookup"><span data-stu-id="0b703-335">Add a query event marker to the command buffer by calling [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE\_END**](d3dissue-end.md)).</span></span> <span data-ttu-id="0b703-336">Questo marcatore indica al driver di rilevare quando la GPU termina l'esecuzione di qualsiasi comando preceduto dal marcatore.</span><span class="sxs-lookup"><span data-stu-id="0b703-336">This marker tells the driver to track when the GPU finishes executing whatever commands preceded the marker.</span></span>
3.  <span data-ttu-id="0b703-337">La prima chiamata svuota il buffer dei comandi perché la chiamata di [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con lo [**\_ svuotamento D3DGETDATA**](d3dgetdata-flush.md) forza il svuotamento del buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-337">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="0b703-338">Ogni chiamata successiva sta controllando la GPU per vedere quando viene completata l'elaborazione di tutte le operazioni del buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-338">Each subsequent call is checking the GPU to see when it finishes processing all the command-buffer work.</span></span> <span data-ttu-id="0b703-339">Questo ciclo non restituisce S \_ OK fino a quando la GPU non è inattiva.</span><span class="sxs-lookup"><span data-stu-id="0b703-339">This loop does not return S\_OK until the GPU is idle.</span></span>
4.  <span data-ttu-id="0b703-340">Campionare l'ora di inizio.</span><span class="sxs-lookup"><span data-stu-id="0b703-340">Sample the start time.</span></span>
5.  <span data-ttu-id="0b703-341">Richiamare le chiamate API profilate.</span><span class="sxs-lookup"><span data-stu-id="0b703-341">Invoke the API calls being profiled.</span></span>
6.  <span data-ttu-id="0b703-342">Aggiungere un secondo marcatore dell'evento di query al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-342">Add a second query event marker to the command buffer.</span></span> <span data-ttu-id="0b703-343">Questo marcatore verrà usato per tenere traccia del completamento delle chiamate.</span><span class="sxs-lookup"><span data-stu-id="0b703-343">This marker will be used to track the completion of the calls.</span></span>
7.  <span data-ttu-id="0b703-344">La prima chiamata svuota il buffer dei comandi perché la chiamata di [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con lo [**\_ svuotamento D3DGETDATA**](d3dgetdata-flush.md) forza il svuotamento del buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-344">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="0b703-345">Quando la GPU completa l'elaborazione di tutte le operazioni del buffer dei comandi, **GetData** restituisce S \_ OK e il ciclo viene terminato perché la GPU è inattiva.</span><span class="sxs-lookup"><span data-stu-id="0b703-345">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
8.  <span data-ttu-id="0b703-346">Campionare l'ora di arresto.</span><span class="sxs-lookup"><span data-stu-id="0b703-346">Sample the stop time.</span></span>

<span data-ttu-id="0b703-347">Di seguito sono riportati i risultati misurati con QueryPerformanceCounter e QueryPerformanceFrequency:</span><span class="sxs-lookup"><span data-stu-id="0b703-347">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="0b703-348">Variabile locale</span><span class="sxs-lookup"><span data-stu-id="0b703-348">Local Variable</span></span> | <span data-ttu-id="0b703-349">Numero di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-349">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="0b703-350">start</span><span class="sxs-lookup"><span data-stu-id="0b703-350">start</span></span>          | <span data-ttu-id="0b703-351">1792998845060</span><span class="sxs-lookup"><span data-stu-id="0b703-351">1792998845060</span></span>   |
| <span data-ttu-id="0b703-352">stop</span><span class="sxs-lookup"><span data-stu-id="0b703-352">stop</span></span>           | <span data-ttu-id="0b703-353">1792998845090</span><span class="sxs-lookup"><span data-stu-id="0b703-353">1792998845090</span></span>   |
| <span data-ttu-id="0b703-354">freq</span><span class="sxs-lookup"><span data-stu-id="0b703-354">freq</span></span>           | <span data-ttu-id="0b703-355">3579545</span><span class="sxs-lookup"><span data-stu-id="0b703-355">3579545</span></span>         |



 

<span data-ttu-id="0b703-356">Conversione di cicli in cicli di nuovo (in un computer a 2 GHz):</span><span class="sxs-lookup"><span data-stu-id="0b703-356">Converting ticks to cycles once again (on a 2 GHz machine):</span></span>


```
# ticks  = (stop - start) = 1792998845090 - 1792998845060 = 30 ticks
# cycles = CPU speed * number of ticks / QPF
# 16,450 = 2 GHz      * 30             / 3,579,545
```



<span data-ttu-id="0b703-357">Di seguito è illustrata la suddivisione del numero di cicli per chiamata:</span><span class="sxs-lookup"><span data-stu-id="0b703-357">Here is the breakdown of the number of cycles per call:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
Number of cycles for Issue                : 200
Number of cycles for GetData              : 16,450
```



<span data-ttu-id="0b703-358">Il meccanismo di query ci ha consentito di controllare il runtime e il lavoro dei driver misurati.</span><span class="sxs-lookup"><span data-stu-id="0b703-358">The query mechanism has allowed us to control the runtime and the driver work that is being measured.</span></span> <span data-ttu-id="0b703-359">Per comprendere ognuno di questi numeri, ecco cosa accade in risposta a ogni chiamata API, insieme ai tempi stimati:</span><span class="sxs-lookup"><span data-stu-id="0b703-359">To understand each of these numbers, here's what is happening in response to each of the API calls, along with the estimated timings:</span></span>

1.  <span data-ttu-id="0b703-360">La prima chiamata svuota il buffer dei comandi chiamando [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) con [**D3DGETDATA \_ Flush**](d3dgetdata-flush.md).</span><span class="sxs-lookup"><span data-stu-id="0b703-360">The first call empties the command buffer by calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md).</span></span> <span data-ttu-id="0b703-361">Quando la GPU completa l'elaborazione di tutte le operazioni del buffer dei comandi, **GetData** restituisce S \_ OK e il ciclo viene terminato perché la GPU è inattiva.</span><span class="sxs-lookup"><span data-stu-id="0b703-361">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
2.  <span data-ttu-id="0b703-362">La sequenza di rendering inizia con la conversione di [**texture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) in un formato indipendente dal dispositivo e l'aggiunta al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-362">The render sequence starts by converting [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to a device-independent format and adding it to the command buffer.</span></span> <span data-ttu-id="0b703-363">Si supponga che questa operazione contenga circa 100 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-363">Assume this takes about 100 cycles.</span></span>
3.  <span data-ttu-id="0b703-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) viene convertito e aggiunto al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is converted and added to the command buffer.</span></span> <span data-ttu-id="0b703-365">Si supponga che questa operazione contenga circa 900 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-365">Assume this takes about 900 cycles.</span></span>
4.  <span data-ttu-id="0b703-366">Il [**problema**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) aggiunge un marcatore di query al buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-366">[**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) adds a query marker to the command buffer.</span></span> <span data-ttu-id="0b703-367">Si supponga che questa operazione contenga circa 200 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-367">Assume this takes about 200 cycles.</span></span>
5.  <span data-ttu-id="0b703-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) causa il svuotamento del buffer dei comandi che impone la transizione in modalità kernel.</span><span class="sxs-lookup"><span data-stu-id="0b703-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) causes the command buffer to be emptied which forces the kernel-mode transition.</span></span> <span data-ttu-id="0b703-369">Si supponga che questa operazione contenga circa 5000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-369">Assume this takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="0b703-370">Il driver elabora quindi il lavoro associato a tutte e quattro le chiamate.</span><span class="sxs-lookup"><span data-stu-id="0b703-370">The driver then processes the work associated with all four calls.</span></span> <span data-ttu-id="0b703-371">Si supponga che il tempo del driver per elaborare la [**trama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) sia pari a circa 2964 cicli, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) è di circa 3600 cicli, il [**problema**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) è circa 200 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-371">Assume that the driver time to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2964 cycles, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is about 3600 cycles, [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) is about 200 cycles.</span></span> <span data-ttu-id="0b703-372">Il tempo totale dei driver per tutti e quattro i comandi è quindi pari a circa 6450 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-372">So the total driver time for all four commands is about 6450 cycles.</span></span>
    > [!Note]  
    > <span data-ttu-id="0b703-373">Il driver richiede anche un po' di tempo per visualizzare lo stato della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-373">The driver also takes a little time to see what the status of the GPU is.</span></span> <span data-ttu-id="0b703-374">Poiché il lavoro della GPU è semplice, la GPU dovrebbe essere già stata eseguita.</span><span class="sxs-lookup"><span data-stu-id="0b703-374">Because the GPU work is trivial, the GPU should be done already.</span></span> <span data-ttu-id="0b703-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) restituirà S \_ OK in base alla probabilità che la GPU sia stata completata.</span><span class="sxs-lookup"><span data-stu-id="0b703-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) will return S\_OK based on the likelihood that the GPU is finished.</span></span>

     

7.  <span data-ttu-id="0b703-376">Quando il driver termina il lavoro, la transizione in modalità utente restituisce il controllo al runtime.</span><span class="sxs-lookup"><span data-stu-id="0b703-376">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="0b703-377">Il buffer dei comandi è ora vuoto.</span><span class="sxs-lookup"><span data-stu-id="0b703-377">The command buffer is now empty.</span></span> <span data-ttu-id="0b703-378">Si supponga che questa operazione contenga circa 5000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-378">Assume this takes about 5000 cycles.</span></span>

<span data-ttu-id="0b703-379">I numeri per [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) includono:</span><span class="sxs-lookup"><span data-stu-id="0b703-379">The numbers for [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) include:</span></span>


```
GetData = kernel-transition + driver work + user-transition
GetData = 5000              + 6450        + 5000           
GetData = 16,450  

driver work = SetTexture + DrawPrimitive + Issue = 
driver work = 2964       + 3600          + 200   = 6450 cycles 
```



<span data-ttu-id="0b703-380">Il meccanismo di query utilizzato in combinazione con QueryPerformanceCounter misura tutto il lavoro della CPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-380">The query mechanism used in combination with QueryPerformanceCounter measures all of the CPU work.</span></span> <span data-ttu-id="0b703-381">Questa operazione viene eseguita con una combinazione di marcatori di query e confronto dello stato delle query.</span><span class="sxs-lookup"><span data-stu-id="0b703-381">This is done with a combination of query markers, and query status comparisons.</span></span> <span data-ttu-id="0b703-382">I marcatori di query di avvio e arresto aggiunti al buffer dei comandi vengono usati per controllare la quantità di lavoro presente nel buffer.</span><span class="sxs-lookup"><span data-stu-id="0b703-382">Start and stop query markers added to the command buffer are used to control how much work is in the buffer.</span></span> <span data-ttu-id="0b703-383">Attendendo che venga restituito il codice restituito corretto, la misurazione iniziale viene eseguita subito prima dell'avvio di una sequenza di rendering pulita e la misurazione dell'arresto viene eseguita subito dopo il completamento del lavoro associato al contenuto del buffer dei comandi.</span><span class="sxs-lookup"><span data-stu-id="0b703-383">By waiting until the right return code is returned, the start measurement is made just before a clean render sequence starts, and the stop measurement is made just after the driver has finished the work associated with the command buffer contents.</span></span> <span data-ttu-id="0b703-384">Questo consente di acquisire efficacemente il lavoro della CPU eseguito dal runtime e dal driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-384">This effectively captures the CPU work done by the runtime as well as the driver.</span></span>

<span data-ttu-id="0b703-385">Ora che si conosce il buffer dei comandi e l'effetto che può avere sulla profilatura, è necessario sapere che esistono alcune altre condizioni che possono causare il svuotamento del buffer dei comandi da parte del runtime.</span><span class="sxs-lookup"><span data-stu-id="0b703-385">Now that you know about the command buffer and the effect it can have on profiling, you should know that there are a few other conditions that can cause the runtime to empty the command buffer.</span></span> <span data-ttu-id="0b703-386">È necessario tenerli sotto controllo nelle sequenze di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-386">You need to watch out for these in your render sequences.</span></span> <span data-ttu-id="0b703-387">Alcune di queste condizioni sono in risposta alle chiamate API, altre sono in risposta alle modifiche delle risorse nel Runtime.</span><span class="sxs-lookup"><span data-stu-id="0b703-387">Some of these conditions are in response to API calls, others are in response to resource changes in the runtime.</span></span> <span data-ttu-id="0b703-388">Una delle condizioni seguenti determinerà una transizione in modalità:</span><span class="sxs-lookup"><span data-stu-id="0b703-388">Any of the following conditions will cause a mode transition:</span></span>

-   <span data-ttu-id="0b703-389">Quando uno dei metodi di blocco ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) viene chiamato su un vertex buffer, un buffer di indice o una trama (in determinate condizioni con determinati flag).</span><span class="sxs-lookup"><span data-stu-id="0b703-389">When one of the lock methods ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) is called on a vertex buffer, index buffer, or texture (under certain conditions with certain flags).</span></span>
-   <span data-ttu-id="0b703-390">Quando viene creato un dispositivo o un vertex buffer, un buffer di indice o una trama.</span><span class="sxs-lookup"><span data-stu-id="0b703-390">When a device or vertex buffer, index buffer, or texture is created.</span></span>
-   <span data-ttu-id="0b703-391">Quando un dispositivo o un vertex buffer, un buffer di indice o una trama viene eliminato definitivamente dall'ultima versione.</span><span class="sxs-lookup"><span data-stu-id="0b703-391">When a device or vertex buffer, index buffer, or texture is destroyed by the last release.</span></span>
-   <span data-ttu-id="0b703-392">Quando viene chiamato [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) .</span><span class="sxs-lookup"><span data-stu-id="0b703-392">When [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) is called.</span></span>
-   <span data-ttu-id="0b703-393">Quando [**present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="0b703-393">When [**Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) is called.</span></span>
-   <span data-ttu-id="0b703-394">Quando il buffer dei comandi si riempie.</span><span class="sxs-lookup"><span data-stu-id="0b703-394">When the command buffer fills up.</span></span>
-   <span data-ttu-id="0b703-395">Quando [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) viene chiamato con lo \_ scaricamento di D3DGETDATA.</span><span class="sxs-lookup"><span data-stu-id="0b703-395">When [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) is called with D3DGETDATA\_FLUSH.</span></span>

<span data-ttu-id="0b703-396">Prestare attenzione a controllare queste condizioni nelle sequenze di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-396">Be careful to watch for these conditions in your render sequences.</span></span> <span data-ttu-id="0b703-397">Ogni volta che viene aggiunta una transizione in modalità, 10.000 cicli di lavoro dei driver verranno aggiunti alle misurazioni della profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-397">Every time a mode transition is added, 10,000 cycles of driver work will be added to your profiling measurements.</span></span> <span data-ttu-id="0b703-398">Il buffer dei comandi non è inoltre dimensionato in modo statico.</span><span class="sxs-lookup"><span data-stu-id="0b703-398">In addition, the command buffer is not statically sized.</span></span> <span data-ttu-id="0b703-399">Il runtime può modificare le dimensioni del buffer in risposta alla quantità di lavoro generata dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-399">The runtime may change the buffer's size in response to the amount of work that is being generated by the application.</span></span> <span data-ttu-id="0b703-400">Si tratta ancora di un'altra ottimizzazione che dipende da una sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-400">This is yet another optimization that is dependent on a render sequence.</span></span>

<span data-ttu-id="0b703-401">Prestare attenzione a controllare le transizioni della modalità durante la profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-401">So be careful to control mode transitions during profiling.</span></span> <span data-ttu-id="0b703-402">Il meccanismo di query offre un metodo efficace per svuotare il buffer dei comandi, in modo da poter controllare i tempi della transizione della modalità e la quantità di lavoro contenuto nel buffer.</span><span class="sxs-lookup"><span data-stu-id="0b703-402">The query mechanism offers a robust method for emptying the command buffer so that you can control the timing of the mode transition as well as the amount of work the buffer contains.</span></span> <span data-ttu-id="0b703-403">Tuttavia, anche questa tecnica può essere migliorata riducendo il tempo di transizione della modalità per renderlo non significativo rispetto al risultato misurato.</span><span class="sxs-lookup"><span data-stu-id="0b703-403">However, even this technique can be improved by reducing the mode transition time to make it insignificant with respect to the measured result.</span></span>

### <a name="make-the-render-sequence-large-compared-to-the-mode-transition"></a><span data-ttu-id="0b703-404">Rendere la sequenza di rendering grande rispetto alla transizione della modalità</span><span class="sxs-lookup"><span data-stu-id="0b703-404">Make the Render Sequence Large Compared to the Mode Transition</span></span>

<span data-ttu-id="0b703-405">Nell'esempio precedente, l'opzione della modalità kernel e l'opzione della modalità utente utilizzano circa 10.000 cicli che non hanno nulla a che fare con il lavoro di runtime e driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-405">In the previous example, the kernel-mode switch and the user-mode switch consume about 10,000 cycles that have nothing to do with runtime and driver work.</span></span> <span data-ttu-id="0b703-406">Poiché la transizione della modalità è incorporata nel sistema operativo, non è possibile ridurla a zero.</span><span class="sxs-lookup"><span data-stu-id="0b703-406">Since the mode transition is built into the operating system, it cannot be reduced to zero.</span></span> <span data-ttu-id="0b703-407">Per rendere la transizione della modalità non significativa, è necessario modificare la sequenza di rendering in modo che il driver e il lavoro di runtime siano un ordine di grandezza maggiore rispetto a quello delle opzioni di modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-407">To make the mode transition insignificant, the render sequence needs to adjusted so that the driver and runtime work are an order of magnitude larger than the mode switches.</span></span> <span data-ttu-id="0b703-408">È possibile provare a eseguire una sottrazione per rimuovere le transizioni, ma il costo di una sequenza di rendering notevolmente maggiore è più affidabile.</span><span class="sxs-lookup"><span data-stu-id="0b703-408">You could try to do a subtraction to remove the transitions, but amortizing the cost over a much larger render sequence cost is more reliable.</span></span>

<span data-ttu-id="0b703-409">La strategia per ridurre la transizione della modalità fino a quando non diventa irrilevante consiste nell'aggiungere un ciclo alla sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-409">The strategy for reducing the mode transition until it becomes insignificant is to add a loop to the render sequence.</span></span> <span data-ttu-id="0b703-410">È ad esempio possibile esaminare i risultati della profilatura se viene aggiunto un ciclo che ripete la sequenza di rendering 1500 volte:</span><span class="sxs-lookup"><span data-stu-id="0b703-410">For example, let look at the profiling results if a loop is added that will repeat the render sequence 1500 times:</span></span>


```
// Initialize the array with two textures, same size, same format
IDirect3DTexture* texArray[2];

CreateQuery(D3DQUERYTYPE_EVENT, pEvent);
pEvent->Issue(D3DISSUE_END);
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

LARGE_INTEGER start, stop;
// Now start counting because the video card is ready
QueryPerformanceCounter(&start);

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  SetTexture(taxArray[i%2]);
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

pEvent->Issue(D3DISSUE_END);

while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="0b703-411">Esempio 4: aggiungere un ciclo alla sequenza di rendering</span><span class="sxs-lookup"><span data-stu-id="0b703-411">Example 4: Add a Loop to the Render Sequence</span></span>

<span data-ttu-id="0b703-412">Di seguito sono riportati i risultati misurati con QueryPerformanceCounter e QueryPerformanceFrequency:</span><span class="sxs-lookup"><span data-stu-id="0b703-412">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="0b703-413">Variabile locale</span><span class="sxs-lookup"><span data-stu-id="0b703-413">Local Variable</span></span> | <span data-ttu-id="0b703-414">Numero di TIC</span><span class="sxs-lookup"><span data-stu-id="0b703-414">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="0b703-415">start</span><span class="sxs-lookup"><span data-stu-id="0b703-415">start</span></span>          | <span data-ttu-id="0b703-416">1792998845000</span><span class="sxs-lookup"><span data-stu-id="0b703-416">1792998845000</span></span>  |
| <span data-ttu-id="0b703-417">stop</span><span class="sxs-lookup"><span data-stu-id="0b703-417">stop</span></span>           | <span data-ttu-id="0b703-418">1792998847084</span><span class="sxs-lookup"><span data-stu-id="0b703-418">1792998847084</span></span>  |
| <span data-ttu-id="0b703-419">freq</span><span class="sxs-lookup"><span data-stu-id="0b703-419">freq</span></span>           | <span data-ttu-id="0b703-420">3579545</span><span class="sxs-lookup"><span data-stu-id="0b703-420">3579545</span></span>        |



 

<span data-ttu-id="0b703-421">L'uso di QueryPerformanceCounter misura 2.840 ora.</span><span class="sxs-lookup"><span data-stu-id="0b703-421">Using QueryPerformanceCounter measures 2,840 ticks now.</span></span> <span data-ttu-id="0b703-422">La conversione di cicli in cicli è uguale a quella già visualizzata:</span><span class="sxs-lookup"><span data-stu-id="0b703-422">Converting ticks to cycles is the same as we have already shown:</span></span>


```
# ticks  = (stop - start) = 1792998847084 - 1792998845000 = 2840 ticks
# cycles    = machine speed * number of ticks / QPF
# 6,900,000 = 2 GHz          * 2840           / 3,579,545
```



<span data-ttu-id="0b703-423">In altre parole, sono necessari circa 6,9 milioni cicli in questo computer a 2 GHz per elaborare le chiamate 1500 nel ciclo di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-423">In other words, it takes about 6.9 million cycles on this 2 GHz machine to process the 1500 calls in the render loop.</span></span> <span data-ttu-id="0b703-424">Dei cicli 6,9 milioni, la quantità di tempo nelle transizioni della modalità è approssimativamente di 10.000, quindi i risultati del profilo sono quasi interamente misurabili al lavoro associato a [**Setrame**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) e [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="0b703-424">Of the 6.9 million cycles, the amount of time in the mode transitions is approximately 10k, so now the profile results are almost entirely measuring work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>

<span data-ttu-id="0b703-425">Si noti che l'esempio di codice richiede una matrice di due trame.</span><span class="sxs-lookup"><span data-stu-id="0b703-425">Notice that the code sample requires an array of two textures.</span></span> <span data-ttu-id="0b703-426">Per evitare un'ottimizzazione del runtime che rimuoverebbe la [**texture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) se imposta lo stesso puntatore di trama ogni volta che viene chiamato, è sufficiente usare una matrice di due trame.</span><span class="sxs-lookup"><span data-stu-id="0b703-426">To avoid a runtime optimization that would remove [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) if it sets the same texture pointer every time it is called, simply use an array of two textures.</span></span> <span data-ttu-id="0b703-427">In questo modo, ogni volta attraverso il ciclo, viene modificato il puntatore di trama e viene eseguito il lavoro completo associato a **Setrame** .</span><span class="sxs-lookup"><span data-stu-id="0b703-427">That way, each time through the loop, the texture pointer changes, and the full work associated with **SetTexture** is performed.</span></span> <span data-ttu-id="0b703-428">Assicurarsi che entrambe le trame abbiano le stesse dimensioni e il formato, in modo che nessun altro stato cambierà quando viene eseguita la trama.</span><span class="sxs-lookup"><span data-stu-id="0b703-428">Be sure that both textures are the same size and format, so that no other state will change when the texture does.</span></span>

<span data-ttu-id="0b703-429">Ora è disponibile una tecnica per la profilatura di Direct3D.</span><span class="sxs-lookup"><span data-stu-id="0b703-429">And now you have a technique for profiling Direct3D.</span></span> <span data-ttu-id="0b703-430">Si basa sul contatore delle prestazioni elevate (QueryPerformanceCounter) per registrare il numero di cicli che richiede la CPU per elaborare il lavoro.</span><span class="sxs-lookup"><span data-stu-id="0b703-430">It relies on the high performance counter (QueryPerformanceCounter) to record the number of ticks it takes the CPU to process work.</span></span> <span data-ttu-id="0b703-431">Il lavoro viene controllato attentamente in modo da essere il runtime e il lavoro dei driver associati alle chiamate API usando il meccanismo di query.</span><span class="sxs-lookup"><span data-stu-id="0b703-431">The work is carefully controlled to be the runtime and driver work associated with API calls using the query mechanism.</span></span> <span data-ttu-id="0b703-432">Una query fornisce due metodi di controllo: innanzitutto per svuotare il buffer dei comandi prima dell'avvio della sequenza di rendering e, in secondo luogo, per restituire al termine del lavoro della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-432">A query provides two means of control: first to empty the command buffer before the render sequence starts, and secondly to return when the GPU work is finished.</span></span>

<span data-ttu-id="0b703-433">Finora, in questo documento è stato illustrato come profilare una sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-433">So far, this paper has shown how to profile a render sequence.</span></span> <span data-ttu-id="0b703-434">Ogni sequenza di rendering è stata abbastanza semplice e contiene una singola chiamata [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) e una chiamata di [**setrama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) .</span><span class="sxs-lookup"><span data-stu-id="0b703-434">Each render sequence has been fairly simple, containing a single [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call and a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) call.</span></span> <span data-ttu-id="0b703-435">Questa operazione è stata eseguita per concentrarsi sul buffer dei comandi e sull'uso del meccanismo di query per controllarlo.</span><span class="sxs-lookup"><span data-stu-id="0b703-435">This was done to focus on the command buffer and the use of the query mechanism to control it.</span></span> <span data-ttu-id="0b703-436">Di seguito è riportato un breve riepilogo di come profilare una sequenza di rendering arbitraria:</span><span class="sxs-lookup"><span data-stu-id="0b703-436">Here is a brief summary of how to profile an arbitrary render sequence:</span></span>

-   <span data-ttu-id="0b703-437">Usare un contatore delle prestazioni elevato come QueryPerformanceCounter per misurare il tempo necessario per elaborare ogni chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-437">Use a high performance counter like QueryPerformanceCounter to measure the time it takes to process each API call.</span></span> <span data-ttu-id="0b703-438">Usare QueryPerformanceFrequency e la frequenza di clock della CPU per convertirla nel numero di cicli della CPU per ogni chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-438">Use QueryPerformanceFrequency and the CPU clock rate to convert this to the number of CPU cycles per API call.</span></span>
-   <span data-ttu-id="0b703-439">Ridurre al minimo la quantità di lavoro della GPU eseguendo il rendering degli elenchi di triangolo, in cui ogni triangolo contiene un pixel.</span><span class="sxs-lookup"><span data-stu-id="0b703-439">Minimize the amount of GPU work by rendering triangle lists, where each triangle contains one pixel.</span></span>
-   <span data-ttu-id="0b703-440">Utilizzare il meccanismo di query per svuotare il buffer dei comandi prima della sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-440">Use the query mechanism to empty the command buffer before the render sequence.</span></span> <span data-ttu-id="0b703-441">Ciò garantisce che la profilatura catturerà la quantità corretta di lavoro di runtime e driver associata alla sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-441">This guarantees that profiling will capturing the correct amount of runtime and driver work associated with the render sequence.</span></span>
-   <span data-ttu-id="0b703-442">Controllare la quantità di lavoro aggiunto al buffer dei comandi con marcatori degli eventi di query.</span><span class="sxs-lookup"><span data-stu-id="0b703-442">Control the amount of work added to the command buffer with query event markers.</span></span> <span data-ttu-id="0b703-443">Questa stessa query rileva quando la GPU termina il lavoro.</span><span class="sxs-lookup"><span data-stu-id="0b703-443">This same query detects when the GPU finishes its work.</span></span> <span data-ttu-id="0b703-444">Poiché il lavoro della GPU è semplice, questo è praticamente equivalente alla misurazione del completamento del lavoro del driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-444">Since the GPU work is trivial, this is virtually equivalent to measuring when the driver work is completed.</span></span>

<span data-ttu-id="0b703-445">Tutte queste tecniche vengono utilizzate per profilare le modifiche di stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-445">All of these techniques are used to profile state changes.</span></span> <span data-ttu-id="0b703-446">Supponendo di aver letto e compreso come controllare il buffer dei comandi e avere completato le misurazioni di base in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), è possibile aggiungere modifiche di stato alle sequenze di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-446">Assuming that you have read and understood how to control the command buffer, and have successfully completed baseline measurements on [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), you are ready to add state changes to your render sequences.</span></span> <span data-ttu-id="0b703-447">Quando si aggiungono modifiche di stato a una sequenza di rendering, si verificano alcuni problemi di profilatura aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="0b703-447">There are a few additional profiling challenges when adding state changes to a render sequence.</span></span> <span data-ttu-id="0b703-448">Se si intende aggiungere modifiche di stato alle sequenze di rendering, assicurarsi di continuare con la sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="0b703-448">If you intend to add state changes to your render sequences, be sure to continue into the next section.</span></span>

## <a name="profiling-direct3d-state-changes"></a><span data-ttu-id="0b703-449">Profilatura delle modifiche dello stato Direct3D</span><span class="sxs-lookup"><span data-stu-id="0b703-449">Profiling Direct3D State Changes</span></span>

<span data-ttu-id="0b703-450">Direct3D usa molti Stati di rendering per controllare quasi tutti gli aspetti della pipeline.</span><span class="sxs-lookup"><span data-stu-id="0b703-450">Direct3D uses many render states to control almost every aspect of the pipeline.</span></span> <span data-ttu-id="0b703-451">Le API che provocano modifiche di stato includono qualsiasi funzione o metodo diverso dalle \* chiamate primitive di estrazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-451">The APIs that cause state changes include any function or method other than the Draw\*Primitive calls.</span></span>

<span data-ttu-id="0b703-452">Le modifiche di stato sono complesse perché potrebbe non essere possibile visualizzare il costo di una modifica di stato senza rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-452">State changes are tricky because you may not be able to see the cost of a state change without rendering.</span></span> <span data-ttu-id="0b703-453">Si tratta di un risultato dell'algoritmo Lazy utilizzato dal driver e dalla GPU per rinviare il lavoro fino a quando non è assolutamente necessario eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="0b703-453">This is a result of the lazy algorithm that the driver and the GPU use to defer work until it absolutely has to be done.</span></span> <span data-ttu-id="0b703-454">In generale, attenersi alla procedura seguente per misurare una singola modifica dello stato:</span><span class="sxs-lookup"><span data-stu-id="0b703-454">In general, you should follow these steps to measure a single state change:</span></span>

1.  <span data-ttu-id="0b703-455">Profilare prima [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="0b703-455">Profile [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) first.</span></span>
2.  <span data-ttu-id="0b703-456">Aggiungere una modifica di stato alla sequenza di rendering e profilare la nuova sequenza.</span><span class="sxs-lookup"><span data-stu-id="0b703-456">Add one state change to the render sequence and profile the new sequence.</span></span>
3.  <span data-ttu-id="0b703-457">Sottrarre la differenza tra le due sequenze per ottenere il costo della modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-457">Subtract the difference between the two sequences to get the cost of the state change.</span></span>

<span data-ttu-id="0b703-458">Naturalmente, tutto ciò che si è appreso sull'uso del meccanismo di query e l'inserimento della sequenza di rendering in un ciclo per negare il costo della transizione della modalità si applica ancora.</span><span class="sxs-lookup"><span data-stu-id="0b703-458">Naturally, everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

### <a name="profiling-a-simple-state-change"></a><span data-ttu-id="0b703-459">Profilatura di una semplice modifica dello stato</span><span class="sxs-lookup"><span data-stu-id="0b703-459">Profiling a Simple State Change</span></span>

<span data-ttu-id="0b703-460">A partire da una sequenza di rendering che contiene [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), di seguito è illustrata la sequenza di codice per misurare il costo di aggiunta di una [**trama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span><span class="sxs-lookup"><span data-stu-id="0b703-460">Starting with a render sequence that contains [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), here is the code sequence for measuring the cost of adding [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span></span>


```
// Get the start counter value as shown in Example 4 

// Initialize a texture array as shown in Example 4
IDirect3DTexture* texArray[2];

// Render sequence loop 
for(int i = 0; i < 1500; i++)
{
  SetTexture(0, texArray[i%2];
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="0b703-461">Esempio 5: misurazione di una chiamata API di modifica dello stato</span><span class="sxs-lookup"><span data-stu-id="0b703-461">Example 5: Measuring One State Change API Call</span></span>

<span data-ttu-id="0b703-462">Si noti che il ciclo contiene due chiamate, [**Setrame**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) e [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="0b703-462">Notice that the loop contains two calls, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="0b703-463">La sequenza di rendering esegue il ciclo di 1500 volte e genera risultati simili ai seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-463">The render sequence loops 1500 times and generates results similar to these:</span></span>



| <span data-ttu-id="0b703-464">Variabile locale</span><span class="sxs-lookup"><span data-stu-id="0b703-464">Local Variable</span></span> | <span data-ttu-id="0b703-465">Numero di TIC</span><span class="sxs-lookup"><span data-stu-id="0b703-465">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="0b703-466">start</span><span class="sxs-lookup"><span data-stu-id="0b703-466">start</span></span>          | <span data-ttu-id="0b703-467">1792998860000</span><span class="sxs-lookup"><span data-stu-id="0b703-467">1792998860000</span></span>  |
| <span data-ttu-id="0b703-468">stop</span><span class="sxs-lookup"><span data-stu-id="0b703-468">stop</span></span>           | <span data-ttu-id="0b703-469">1792998870260</span><span class="sxs-lookup"><span data-stu-id="0b703-469">1792998870260</span></span>  |
| <span data-ttu-id="0b703-470">freq</span><span class="sxs-lookup"><span data-stu-id="0b703-470">freq</span></span>           | <span data-ttu-id="0b703-471">3579545</span><span class="sxs-lookup"><span data-stu-id="0b703-471">3579545</span></span>        |



 

<span data-ttu-id="0b703-472">La conversione di cicli in cicli di nuovo produce:</span><span class="sxs-lookup"><span data-stu-id="0b703-472">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998870260 - 1792998860000 = 10,260 ticks
# cycles    = machine speed * number of ticks / QPF
5,775,000   = 2 GHz          * 10,260         / 3,579,545
```



<span data-ttu-id="0b703-473">La divisione per il numero di iterazioni nel ciclo produce:</span><span class="sxs-lookup"><span data-stu-id="0b703-473">Dividing by the number of iterations in the loop yields:</span></span>


```
5,775,000 cycles / 1500 iterations = 3850 cycles for one iteration
```



<span data-ttu-id="0b703-474">Ogni iterazione del ciclo contiene una modifica di stato e una chiamata di progetto.</span><span class="sxs-lookup"><span data-stu-id="0b703-474">Each iteration of the loop contains a state change and a draw call.</span></span> <span data-ttu-id="0b703-475">La sottrazione del risultato della sequenza di rendering [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) lascia:</span><span class="sxs-lookup"><span data-stu-id="0b703-475">Subtracting out the result of the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence leaves:</span></span>


```
3850 - 1100 = 2750 cycles for SetTexture
```



<span data-ttu-id="0b703-476">Il numero medio di cicli per aggiungere la [**texture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) a questa sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-476">This is the average number of cycles to add [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to this render sequence.</span></span> <span data-ttu-id="0b703-477">Questa stessa tecnica può essere applicata ad altre modifiche di stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-477">This same technique can be applied to other state changes.</span></span>

<span data-ttu-id="0b703-478">Perché la [**texture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) è una modifica di stato semplice?</span><span class="sxs-lookup"><span data-stu-id="0b703-478">Why is [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) called a simple state change?</span></span> <span data-ttu-id="0b703-479">Poiché lo stato impostato è vincolato in modo che la pipeline abbia la stessa quantità di lavoro ogni volta che lo stato viene modificato.</span><span class="sxs-lookup"><span data-stu-id="0b703-479">Because the state that is being set is constrained so that the pipeline does the same amount of work each time the state is changed.</span></span> <span data-ttu-id="0b703-480">La limitazione di entrambe le trame allo stesso formato e alle stesse dimensioni garantisce la stessa quantità di lavoro per ogni chiamata di **setrama** .</span><span class="sxs-lookup"><span data-stu-id="0b703-480">Constraining both textures to the same size and format assures the same amount of work for each **SetTexture** call.</span></span>

### <a name="profiling-a-state-change-that-needs-to-be-toggled"></a><span data-ttu-id="0b703-481">Profilatura di una modifica di stato che deve essere attivata/disabilitata</span><span class="sxs-lookup"><span data-stu-id="0b703-481">Profiling a State Change that Needs to Be Toggled</span></span>

<span data-ttu-id="0b703-482">Sono presenti altre modifiche di stato che provocano la modifica della quantità di lavoro eseguita dalla pipeline grafica per ogni iterazione del ciclo di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-482">There are other state changes that cause the amount of work performed by the graphics pipeline to change for every iteration of the render loop.</span></span> <span data-ttu-id="0b703-483">Se, ad esempio, il test z è abilitato, ogni colore pixel aggiorna una destinazione di rendering solo dopo che il valore z del nuovo pixel viene testato rispetto al valore z del pixel esistente.</span><span class="sxs-lookup"><span data-stu-id="0b703-483">For example, if z-testing is enabled, each pixel color updates a render target only after the new pixel's z value is tested against the z-value for the existing pixel.</span></span> <span data-ttu-id="0b703-484">Se il test z è disabilitato, questo test per pixel non viene eseguito e l'output viene scritto molto più velocemente.</span><span class="sxs-lookup"><span data-stu-id="0b703-484">If z-testing is disabled, this per-pixel test is not done and the output is written much faster.</span></span> <span data-ttu-id="0b703-485">L'abilitazione o la disabilitazione dello stato dei test z modifica in modo significativo la quantità di lavoro eseguita (dalla CPU e dalla GPU) durante il rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-485">Enabling or disabling the z-test state dramatically changes the amount of work done (by the CPU as well as the GPU) during rendering.</span></span>

<span data-ttu-id="0b703-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) richiede un particolare stato di rendering e un valore di stato per abilitare o disabilitare il test z.</span><span class="sxs-lookup"><span data-stu-id="0b703-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requires a particular render state and a state value to enable or disable z-testing.</span></span> <span data-ttu-id="0b703-487">Il valore di stato specifico viene valutato in fase di esecuzione per determinare la quantità di lavoro necessaria.</span><span class="sxs-lookup"><span data-stu-id="0b703-487">The particular state value is evaluated at runtime to determine how much work is necessary.</span></span> <span data-ttu-id="0b703-488">È difficile misurare questa modifica dello stato in un ciclo di rendering e precondizionare comunque lo stato della pipeline in modo che cambi.</span><span class="sxs-lookup"><span data-stu-id="0b703-488">It is difficult to measure this state change in a render loop and still precondition the pipeline state so that it switches.</span></span> <span data-ttu-id="0b703-489">L'unica soluzione consiste nell'impostare la modifica dello stato durante la sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-489">The only solution is to toggle the state change during the render sequence.</span></span>

<span data-ttu-id="0b703-490">Ad esempio, la tecnica di profilatura deve essere ripetuta due volte come segue:</span><span class="sxs-lookup"><span data-stu-id="0b703-490">For example, the profiling technique needs to be repeated twice as follows:</span></span>

1.  <span data-ttu-id="0b703-491">Per iniziare, profilare la sequenza di rendering [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="0b703-491">Start by profiling the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence.</span></span> <span data-ttu-id="0b703-492">Chiamare questa linea di base.</span><span class="sxs-lookup"><span data-stu-id="0b703-492">Call this the baseline.</span></span>
2.  <span data-ttu-id="0b703-493">Profilare una seconda sequenza di rendering che consente di disabilitare la modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-493">Profile a second render sequence that toggles the state change.</span></span> <span data-ttu-id="0b703-494">Il ciclo della sequenza di rendering contiene:</span><span class="sxs-lookup"><span data-stu-id="0b703-494">The render sequence loop contains:</span></span>
    -   <span data-ttu-id="0b703-495">Una modifica dello stato per impostare lo stato in una condizione "false".</span><span class="sxs-lookup"><span data-stu-id="0b703-495">A state change to set the state into a "false" condition.</span></span>
    -   <span data-ttu-id="0b703-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) proprio come la sequenza originale.</span><span class="sxs-lookup"><span data-stu-id="0b703-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) just like the original sequence.</span></span>
    -   <span data-ttu-id="0b703-497">Una modifica dello stato per impostare lo stato in una condizione "true".</span><span class="sxs-lookup"><span data-stu-id="0b703-497">A state change to set the state into a "true" condition.</span></span>
    -   <span data-ttu-id="0b703-498">Secondo [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) per forzare la realizzazione della seconda modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-498">A second [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to force the second state change to be realized.</span></span>
3.  <span data-ttu-id="0b703-499">Trovare la differenza tra le due sequenze di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-499">Find the difference between the two render sequences.</span></span> <span data-ttu-id="0b703-500">Questa operazione viene eseguita da:</span><span class="sxs-lookup"><span data-stu-id="0b703-500">This is done by:</span></span>
    -   <span data-ttu-id="0b703-501">Moltiplicare la sequenza di [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) di base per 2 perché sono presenti due chiamate **DrawPrimitive** nella nuova sequenza.</span><span class="sxs-lookup"><span data-stu-id="0b703-501">Multiply the baseline [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sequence by 2 because there are two **DrawPrimitive** calls in the new sequence.</span></span>
    -   <span data-ttu-id="0b703-502">Sottrae il risultato della nuova sequenza dalla sequenza originale.</span><span class="sxs-lookup"><span data-stu-id="0b703-502">Subtract the result of the new sequence from the original sequence.</span></span>
    -   <span data-ttu-id="0b703-503">Dividere il risultato per 2 per ottenere il costo medio della modifica dello stato "false" e "true".</span><span class="sxs-lookup"><span data-stu-id="0b703-503">Divide the result by 2 to get the average cost of both the "false" and the "true" state change.</span></span>

<span data-ttu-id="0b703-504">Con la tecnica di ciclo usata nella sequenza di rendering, è necessario misurare il costo della modifica dello stato della pipeline passando lo stato da "true" a una condizione "false" e viceversa per ogni iterazione nella sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-504">With the looping technique used in the render sequence, the cost of changing pipeline state needs to be measured by toggling the state from a "true" to a "false" condition and vice versa, for each iteration in the render sequence.</span></span> <span data-ttu-id="0b703-505">Il significato di "true" e "false" qui non è un valore letterale. Ciò significa semplicemente che lo stato deve essere impostato in condizioni opposte.</span><span class="sxs-lookup"><span data-stu-id="0b703-505">The meaning of "true" and "false" here are not literal, this simply means that the state needs to be set into opposing conditions.</span></span> <span data-ttu-id="0b703-506">In questo modo verranno misurate entrambe le modifiche dello stato durante la profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-506">This causes both state changes to be measured during profiling.</span></span> <span data-ttu-id="0b703-507">Naturalmente, tutto ciò che si è appreso sull'uso del meccanismo di query e l'inserimento della sequenza di rendering in un ciclo per negare il costo della transizione della modalità si applica ancora.</span><span class="sxs-lookup"><span data-stu-id="0b703-507">Of course everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

<span data-ttu-id="0b703-508">Ecco ad esempio la sequenza di codice per misurare il costo di attivazione o disattivazione del test z:</span><span class="sxs-lookup"><span data-stu-id="0b703-508">For example, here is the code sequence for measuring the cost of toggling z-testing on or off:</span></span>


```
// Get the start counter value as shown in Example 4 

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the "false" condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Set the pipeline state to the "true" condition
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="0b703-509">Esempio 5: misurazione di una modifica dello stato di attivazione</span><span class="sxs-lookup"><span data-stu-id="0b703-509">Example 5: Measuring a Toggling State Change</span></span>

<span data-ttu-id="0b703-510">Il ciclo commuta lo stato eseguendo due chiamate [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) .</span><span class="sxs-lookup"><span data-stu-id="0b703-510">The loop toggles the state by executing two [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) calls.</span></span> <span data-ttu-id="0b703-511">La prima chiamata di **SetRenderState** Disabilita il test z e il secondo **SetRenderState** Abilita il test z.</span><span class="sxs-lookup"><span data-stu-id="0b703-511">The first **SetRenderState** call disables z-testing and the second **SetRenderState** enables z-testing.</span></span> <span data-ttu-id="0b703-512">Ogni **SetRenderState** è seguito da [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , in modo che il lavoro associato alla modifica dello stato venga elaborato dal driver anziché impostare solo un bit dirty nel driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-512">Each **SetRenderState** is followed by [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) so that the work associated with the state change is processed by the driver instead of only setting a dirty bit in the driver.</span></span>

<span data-ttu-id="0b703-513">Questi numeri sono ragionevoli per questa sequenza di rendering:</span><span class="sxs-lookup"><span data-stu-id="0b703-513">These numbers are reasonable for this render sequence:</span></span>



| <span data-ttu-id="0b703-514">Variabile locale</span><span class="sxs-lookup"><span data-stu-id="0b703-514">Local Variable</span></span> | <span data-ttu-id="0b703-515">Numero di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-515">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="0b703-516">start</span><span class="sxs-lookup"><span data-stu-id="0b703-516">start</span></span>          | <span data-ttu-id="0b703-517">1792998845000</span><span class="sxs-lookup"><span data-stu-id="0b703-517">1792998845000</span></span>   |
| <span data-ttu-id="0b703-518">stop</span><span class="sxs-lookup"><span data-stu-id="0b703-518">stop</span></span>           | <span data-ttu-id="0b703-519">1792998861740</span><span class="sxs-lookup"><span data-stu-id="0b703-519">1792998861740</span></span>   |
| <span data-ttu-id="0b703-520">freq</span><span class="sxs-lookup"><span data-stu-id="0b703-520">freq</span></span>           | <span data-ttu-id="0b703-521">3579545</span><span class="sxs-lookup"><span data-stu-id="0b703-521">3579545</span></span>         |



 

<span data-ttu-id="0b703-522">La conversione di cicli in cicli di nuovo produce:</span><span class="sxs-lookup"><span data-stu-id="0b703-522">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998861740 - 1792998845000 = 15,120 ticks
# cycles    = machine speed * number of ticks / QPF
 9,300,000  = 2 GHz          * 16,740         / 3,579,545
```



<span data-ttu-id="0b703-523">La divisione per il numero di iterazioni nel ciclo produce:</span><span class="sxs-lookup"><span data-stu-id="0b703-523">Dividing by the number of iterations in the loop yields:</span></span>


```
9,300,000 cycles / 1500 iterations = 6200 cycles for one iteration
```



<span data-ttu-id="0b703-524">Ogni iterazione del ciclo contiene due modifiche di stato e due chiamate di progetto.</span><span class="sxs-lookup"><span data-stu-id="0b703-524">Each iteration of the loop contains two state changes and two draw calls.</span></span> <span data-ttu-id="0b703-525">La sottrazione delle chiamate di estrazione (presupponendo 1100 cicli) lascia:</span><span class="sxs-lookup"><span data-stu-id="0b703-525">Subtracting out the draw calls (assuming 1100 cycles) leaves:</span></span>


```
6200 - 1100 - 1100 = 4000 cycles for both state changes
```



<span data-ttu-id="0b703-526">Il numero medio di cicli per entrambe le modifiche di stato, quindi il tempo medio per ogni modifica dello stato è:</span><span class="sxs-lookup"><span data-stu-id="0b703-526">This is the average number of cycles for both state changes so the average time for each state change is:</span></span>


```
4000 / 2  = 2000 cycles for each state change
```



<span data-ttu-id="0b703-527">Pertanto, il numero medio di cicli per abilitare o disabilitare il test z è 2000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-527">Therefore, the average number of cycles to enable or disable z-testing is 2000 cycles.</span></span> <span data-ttu-id="0b703-528">Vale la pena notare che QueryPerformanceCounter sta misurando la metà del tempo e la disabilitazione della z per la metà del tempo.</span><span class="sxs-lookup"><span data-stu-id="0b703-528">It is worth noting that QueryPerformanceCounter is measuring z-enable half the time and z-disable half of the time.</span></span> <span data-ttu-id="0b703-529">Questa tecnica misura effettivamente la media di entrambe le modifiche di stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-529">This technique actually measures the average of both state changes.</span></span> <span data-ttu-id="0b703-530">In altre parole, si sta misurando il tempo necessario per abilitare o disabilitare uno stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-530">In other words, you are measuring the time to toggle a state.</span></span> <span data-ttu-id="0b703-531">Utilizzando questa tecnica, non è possibile sapere se le ore di abilitazione e disabilitazione sono equivalenti poiché è stata misurata la media di entrambe.</span><span class="sxs-lookup"><span data-stu-id="0b703-531">Using this technique, you have no way of knowing if the enable and disable times are equivalent since you have measured the average of both of them.</span></span> <span data-ttu-id="0b703-532">Tuttavia, si tratta di un numero ragionevole da usare quando si imposta un budget per uno stato di attivazione/disattivazione come un'applicazione che causa questa modifica dello stato solo attivando questo stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-532">Nevertheless, this is a reasonable number to use when budgeting a toggling state as an application that causes this state change can only do so by toggling this state.</span></span>

<span data-ttu-id="0b703-533">Ora è possibile applicare queste tecniche e profilare tutte le modifiche dello stato desiderate, giusto?</span><span class="sxs-lookup"><span data-stu-id="0b703-533">So now you can apply these techniques and profile all the state changes you want, right?</span></span> <span data-ttu-id="0b703-534">Risposta errata.</span><span class="sxs-lookup"><span data-stu-id="0b703-534">Not quite.</span></span> <span data-ttu-id="0b703-535">È comunque necessario prestare particolare attenzione alle ottimizzazioni progettate per ridurre la quantità di lavoro che deve essere eseguita.</span><span class="sxs-lookup"><span data-stu-id="0b703-535">You still need to be careful about optimizations that are designed to reduce the amount of work that needs to be done.</span></span> <span data-ttu-id="0b703-536">Quando si progettano le sequenze di rendering, è necessario tenere presenti due tipi di ottimizzazioni.</span><span class="sxs-lookup"><span data-stu-id="0b703-536">There are two types of optimizations that you should be aware of when designing your render sequences.</span></span>

### <a name="watch-out-for-state-change-optimizations"></a><span data-ttu-id="0b703-537">Guarda le ottimizzazioni di modifica dello stato</span><span class="sxs-lookup"><span data-stu-id="0b703-537">Watch Out for State Change Optimizations</span></span>

<span data-ttu-id="0b703-538">Nella sezione precedente viene illustrato come profilare entrambi i tipi di modifiche di stato, ovvero una semplice modifica dello stato vincolata a generare la stessa quantità di lavoro per ogni iterazione e una modifica dello stato di attivazione e modifica che modifica in modo significativo la quantità di lavoro eseguita.</span><span class="sxs-lookup"><span data-stu-id="0b703-538">The previous section show how to profile both kinds of state changes: a simple state change that is constrained to generate the same amount of work for each iteration, and a toggling state change that dramatically changes the amount of work done.</span></span> <span data-ttu-id="0b703-539">Cosa accade se si accetta la sequenza di rendering precedente e si aggiunge un'altra modifica allo stato?</span><span class="sxs-lookup"><span data-stu-id="0b703-539">What happens if you take the previous render sequence and add another state change to it?</span></span> <span data-ttu-id="0b703-540">Ad esempio, in questo esempio viene accettata la sequenza di rendering z>-Enable e viene aggiunto un confronto z-Func:</span><span class="sxs-lookup"><span data-stu-id="0b703-540">For instance, this example takes the z>-enable render sequence and adds a z-func comparison to it:</span></span>


```
// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZFUNC, D3DCMP_NEVER);

  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}
```



<span data-ttu-id="0b703-541">Lo stato z-Func imposta il livello di confronto durante la scrittura nel buffer z (tra il valore z di un pixel corrente e il valore z di un pixel nel buffer di profondità).</span><span class="sxs-lookup"><span data-stu-id="0b703-541">The z-func state sets the comparison level when writing to the z-buffer (between the z-value of a current pixel with the z-value of a pixel in the depth buffer).</span></span> <span data-ttu-id="0b703-542">D3DCMP \_ non disattiva mai il confronto di test z mentre D3DCMP \_ imposta sempre il confronto in modo che avvenga ogni volta che viene eseguito il test z.</span><span class="sxs-lookup"><span data-stu-id="0b703-542">D3DCMP\_NEVER turns off the z-testing comparison while D3DCMP\_ALWAYS sets the comparison to happen every time z-testing is done.</span></span>

<span data-ttu-id="0b703-543">La profilatura di una di queste modifiche di stato in una sequenza di rendering con [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) genera risultati simili ai seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-543">Profiling either one of these state changes in a render sequence with [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) generates results similar to these:</span></span>



| <span data-ttu-id="0b703-544">Modifica dello stato singolo</span><span class="sxs-lookup"><span data-stu-id="0b703-544">Single State Change</span></span> | <span data-ttu-id="0b703-545">Numero medio di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-545">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="0b703-546">\_Solo ZENABLE D3DRS</span><span class="sxs-lookup"><span data-stu-id="0b703-546">D3DRS\_ZENABLE only</span></span> | <span data-ttu-id="0b703-547">2000</span><span class="sxs-lookup"><span data-stu-id="0b703-547">2000</span></span>                     |



 

<span data-ttu-id="0b703-548">oppure</span><span class="sxs-lookup"><span data-stu-id="0b703-548">or</span></span>



| <span data-ttu-id="0b703-549">Modifica dello stato singolo</span><span class="sxs-lookup"><span data-stu-id="0b703-549">Single State Change</span></span> | <span data-ttu-id="0b703-550">Numero medio di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-550">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="0b703-551">\_Solo ZFUNC D3DRS</span><span class="sxs-lookup"><span data-stu-id="0b703-551">D3DRS\_ZFUNC only</span></span>   | <span data-ttu-id="0b703-552">600</span><span class="sxs-lookup"><span data-stu-id="0b703-552">600</span></span>                      |



 

<span data-ttu-id="0b703-553">Tuttavia, se si esegue il profiling \_ di D3DRS ZENABLE e D3DRS \_ ZFUNC nella stessa sequenza di rendering, è possibile visualizzare risultati simili ai seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-553">But, if you profile both D3DRS\_ZENABLE and D3DRS\_ZFUNC in the same render sequence you could see results like these:</span></span>



| <span data-ttu-id="0b703-554">Entrambe le modifiche di stato</span><span class="sxs-lookup"><span data-stu-id="0b703-554">Both State Changes</span></span>            | <span data-ttu-id="0b703-555">Numero medio di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-555">Average Number of Cycles</span></span> |
|-------------------------------|--------------------------|
| <span data-ttu-id="0b703-556">D3DRS \_ ZENABLE + D3DRS \_ ZFUNC</span><span class="sxs-lookup"><span data-stu-id="0b703-556">D3DRS\_ZENABLE + D3DRS\_ZFUNC</span></span> | <span data-ttu-id="0b703-557">2000</span><span class="sxs-lookup"><span data-stu-id="0b703-557">2000</span></span>                     |



 

<span data-ttu-id="0b703-558">È possibile prevedere che il risultato sia la somma dei cicli 2000 e 600 (o 2600) perché il driver esegue tutte le operazioni associate all'impostazione di entrambi gli Stati di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-558">You could expect the result to be to be the sum of 2000 and 600 (or 2600) cycles because the driver is doing all the work associated with setting both render states.</span></span> <span data-ttu-id="0b703-559">La media è invece di 2000 cicli.</span><span class="sxs-lookup"><span data-stu-id="0b703-559">Instead, the average is 2000 cycles.</span></span>

<span data-ttu-id="0b703-560">Questo risultato riflette un'ottimizzazione della modifica dello stato implementata nel runtime, nel driver o nella GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-560">This result reflects a state change optimization implemented in the runtime, the driver, or the GPU.</span></span> <span data-ttu-id="0b703-561">In questo caso, il driver potrebbe vedere il primo [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) e impostare uno stato dirty che posticipa il lavoro fino a un momento successivo.</span><span class="sxs-lookup"><span data-stu-id="0b703-561">In this case, the driver could see the first [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) and set a dirty state which would postpone the work until later.</span></span> <span data-ttu-id="0b703-562">Quando il driver rileva il secondo **SetRenderState**, lo stesso stato dirty potrebbe essere impostato in modo ridondante e lo stesso lavoro verrà posticipato ancora una volta.</span><span class="sxs-lookup"><span data-stu-id="0b703-562">When the driver sees the second **SetRenderState**, the same dirty state could be redundantly set and the same work would be postponed once again.</span></span> <span data-ttu-id="0b703-563">Quando viene chiamato [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , il lavoro associato allo stato dirty viene infine elaborato.</span><span class="sxs-lookup"><span data-stu-id="0b703-563">When [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is called, the work associated with the dirty state is finally processed.</span></span> <span data-ttu-id="0b703-564">Il driver esegue il lavoro una volta, il che significa che le prime due modifiche di stato vengono effettivamente consolidate dal driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-564">The driver executes the work one time, which means that the first two state changes are effectively consolidated by the driver.</span></span> <span data-ttu-id="0b703-565">Analogamente, le modifiche apportate al terzo e al quarto stato vengono consolidate dal driver in una singola modifica dello stato quando viene chiamato il secondo **DrawPrimitive** .</span><span class="sxs-lookup"><span data-stu-id="0b703-565">Similarly, the third and fourth state changes are effectively consolidated by the driver into a single state change when the second **DrawPrimitive** is called.</span></span> <span data-ttu-id="0b703-566">Il risultato finale è che il driver e la GPU elaborano una singola modifica dello stato per ogni chiamata di progetto.</span><span class="sxs-lookup"><span data-stu-id="0b703-566">The net result is that the driver and the GPU process a single state change for each draw call.</span></span>

<span data-ttu-id="0b703-567">Si tratta di un valido esempio di ottimizzazione di driver dipendente dalla sequenza.</span><span class="sxs-lookup"><span data-stu-id="0b703-567">This is a good example of a sequence-dependent driver optimization.</span></span> <span data-ttu-id="0b703-568">Il driver è stato posticipato due volte impostando uno stato dirty, quindi il lavoro viene eseguito una volta per cancellare lo stato modificato.</span><span class="sxs-lookup"><span data-stu-id="0b703-568">The driver postponed work twice by setting a dirty state, and then performed the work once to clear the dirty state.</span></span> <span data-ttu-id="0b703-569">Questo è un buon esempio del tipo di miglioramento dell'efficienza che può avere luogo quando il lavoro viene posticipato fino a quando non è assolutamente necessario.</span><span class="sxs-lookup"><span data-stu-id="0b703-569">This is a good example of the kind of efficiency improvement that can take place when work is deferred until absolutely necessary.</span></span>

<span data-ttu-id="0b703-570">Come è possibile stabilire quali modifiche di stato impostano uno stato dirty internamente e quindi posticipare il lavoro fino a un momento successivo?</span><span class="sxs-lookup"><span data-stu-id="0b703-570">How do you know which state changes set a dirty state internally and therefore postpone work until later?</span></span> <span data-ttu-id="0b703-571">Solo eseguendo il test delle sequenze di rendering (o parlando con writer di driver).</span><span class="sxs-lookup"><span data-stu-id="0b703-571">Only by testing render sequences (or talking to driver writers).</span></span> <span data-ttu-id="0b703-572">I driver vengono aggiornati e migliorati periodicamente, in modo che l'elenco di ottimizzazioni non sia statico.</span><span class="sxs-lookup"><span data-stu-id="0b703-572">Drivers are updated and improved periodically so the list of optimizations is not static.</span></span> <span data-ttu-id="0b703-573">Esiste un solo modo per conoscere perfettamente il costo di una modifica di stato in una determinata sequenza di rendering, in un determinato set di hardware; e in questo modo viene misurato.</span><span class="sxs-lookup"><span data-stu-id="0b703-573">There is only one way to absolutely know what a state change costs in a given render sequence, on a particular set of hardware; and that is to measure it.</span></span>

### <a name="watch-out-for-drawprimitive-optimizations"></a><span data-ttu-id="0b703-574">Guarda le ottimizzazioni DrawPrimitive</span><span class="sxs-lookup"><span data-stu-id="0b703-574">Watch Out for DrawPrimitive Optimizations</span></span>

<span data-ttu-id="0b703-575">Oltre alle ottimizzazioni di modifica dello stato, il runtime tenterà di ottimizzare il numero di chiamate di progetto che devono essere elaborate dal driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-575">In addition to state change optimizations, the runtime will attempt to optimize the number of draw calls that the driver has to process.</span></span> <span data-ttu-id="0b703-576">Si considerino, ad esempio, le chiamate di estrazione back:</span><span class="sxs-lookup"><span data-stu-id="0b703-576">For example, consider these back to back draw calls:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3); // Draw 3 primitives, vertices 0 - 8
DrawPrimitive(D3DPT_TRIANGLELIST, 9, 4); // Draw 4 primitives, vertices 9 - 20
```



<span data-ttu-id="0b703-577">Esempio 5a: due chiamate di progetto</span><span class="sxs-lookup"><span data-stu-id="0b703-577">Example 5a: Two Draw Calls</span></span>

<span data-ttu-id="0b703-578">Questa sequenza contiene due chiamate di richiamo, che il runtime consoliderà in una singola chiamata equivalente a:</span><span class="sxs-lookup"><span data-stu-id="0b703-578">This sequence contains two draw calls, which the runtime will consolidate into a single call equivalent to:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 7); // Draw 7 primitives, vertices 0 - 20
```



<span data-ttu-id="0b703-579">Esempio 5b: una singola chiamata di estrazione concatenata</span><span class="sxs-lookup"><span data-stu-id="0b703-579">Example 5b: A Single Concatenated Draw Call</span></span>

<span data-ttu-id="0b703-580">Il runtime concatenerà entrambe le chiamate di progetto in una singola chiamata, riducendo al contempo il lavoro del driver del 50% perché il driver deve ora elaborare una sola chiamata di progetto.</span><span class="sxs-lookup"><span data-stu-id="0b703-580">The runtime will concatenate both of these particular draw calls into a single call, which reduces the driver work by 50 percent because the driver will now only need to process one draw call.</span></span>

<span data-ttu-id="0b703-581">In generale, il runtime concatenerà due o più chiamate [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) back-to-back quando:</span><span class="sxs-lookup"><span data-stu-id="0b703-581">In general, the runtime will concatenate two or more back-to-back [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls when:</span></span>

1.  <span data-ttu-id="0b703-582">Il tipo primitivo è un elenco di triangoli (triangolare D3DPT \_ ).</span><span class="sxs-lookup"><span data-stu-id="0b703-582">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="0b703-583">Ogni chiamata successiva di [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) deve fare riferimento a vertici consecutivi all'interno del buffer dei vertici.</span><span class="sxs-lookup"><span data-stu-id="0b703-583">Each successive [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call must reference consecutive vertices within the vertex buffer.</span></span>

<span data-ttu-id="0b703-584">Analogamente, le condizioni corrette per la concatenazione di due o più chiamate [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) back-to-back sono:</span><span class="sxs-lookup"><span data-stu-id="0b703-584">Similarly, the right conditions for concatenating two or more back-to-back [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) calls are:</span></span>

1.  <span data-ttu-id="0b703-585">Il tipo primitivo è un elenco di triangoli (triangolare D3DPT \_ ).</span><span class="sxs-lookup"><span data-stu-id="0b703-585">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="0b703-586">Ogni chiamata successiva di [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) deve fare riferimento sequenziale agli indici consecutivi all'interno del buffer dell'indice.</span><span class="sxs-lookup"><span data-stu-id="0b703-586">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must sequential reference consecutive indices within the index buffer.</span></span>
3.  <span data-ttu-id="0b703-587">Ogni chiamata [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) successiva deve usare lo stesso valore per BaseVertexIndex.</span><span class="sxs-lookup"><span data-stu-id="0b703-587">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must use the same value for BaseVertexIndex.</span></span>

<span data-ttu-id="0b703-588">Per evitare la concatenazione durante la profilatura, modificare la sequenza di rendering in modo che il tipo primitivo non sia un elenco di triangolo oppure modificare la sequenza di rendering in modo che non siano presenti chiamate di traccia di tipo back-to-back che usino vertici consecutivi (o indici).</span><span class="sxs-lookup"><span data-stu-id="0b703-588">To prevent concatenation during profiling, modify the render sequence so that the primitive type is not a triangle list, or modify the render sequence so that there are no back-to-back draw calls that use consecutive vertices (or indices).</span></span> <span data-ttu-id="0b703-589">In particolare, il runtime concatenerà anche le chiamate di progetto che soddisfano entrambe le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="0b703-589">More specifically, the runtime will also concatenate draw calls that meet both of the following conditions:</span></span>

-   <span data-ttu-id="0b703-590">Quando la chiamata precedente è [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), se la chiamata di richiamo successiva:</span><span class="sxs-lookup"><span data-stu-id="0b703-590">When the previous call is [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="0b703-591">Usa un elenco di triangolo e</span><span class="sxs-lookup"><span data-stu-id="0b703-591">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="0b703-592">Specifica il StartVertex = precedente StartVertex + precedente PrimitiveCount \* 3</span><span class="sxs-lookup"><span data-stu-id="0b703-592">specifies the StartVertex = previous StartVertex + previous PrimitiveCount \* 3</span></span>
-   <span data-ttu-id="0b703-593">Quando si usa [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), se la chiamata di richiamo successiva:</span><span class="sxs-lookup"><span data-stu-id="0b703-593">When using [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="0b703-594">Usa un elenco di triangolo e</span><span class="sxs-lookup"><span data-stu-id="0b703-594">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="0b703-595">Specifica il startIndex = precedente StartIndex + PrimitiveCount precedente \* 3 e</span><span class="sxs-lookup"><span data-stu-id="0b703-595">specifies the StartIndex = previous StartIndex + previous PrimitiveCount \* 3, AND</span></span>
    -   <span data-ttu-id="0b703-596">Specifica il BaseVertexIndex = BaseVertexIndex precedente</span><span class="sxs-lookup"><span data-stu-id="0b703-596">specifies the BaseVertexIndex = previous BaseVertexIndex</span></span>

<span data-ttu-id="0b703-597">Di seguito è riportato un esempio più delicato di concatenazione delle chiamate di traccia che è facile da ignorare durante la profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-597">Here is a more subtle example of draw call concatenation that is easy to overlook when you are profiling.</span></span> <span data-ttu-id="0b703-598">Si supponga che la sequenza di rendering abbia un aspetto simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="0b703-598">Assume the render sequence looks like this:</span></span>


```
  for(int i = 0; i < 1500; i++)
  {
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="0b703-599">Esempio 5C: una modifica di stato e una chiamata di un progetto</span><span class="sxs-lookup"><span data-stu-id="0b703-599">Example 5c: One State Change and One Draw Call</span></span>

<span data-ttu-id="0b703-600">Il ciclo scorre i triangoli 1500, impostando una trama e disegnando ogni triangolo.</span><span class="sxs-lookup"><span data-stu-id="0b703-600">The loop iterates through 1500 triangles, setting a texture and drawing each triangle.</span></span> <span data-ttu-id="0b703-601">Questo ciclo di rendering richiede circa 2750 cicli per la [**ditrama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) e 1100 cicli per [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , come illustrato nelle sezioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="0b703-601">This render loop takes approximately 2750 cycles for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and 1100 cycles for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) as shown in previous sections.</span></span> <span data-ttu-id="0b703-602">È possibile prevedere in modo intuitivo che lo spostando di una **struttura** all'esterno del ciclo di rendering debba ridurre la quantità di lavoro eseguita dal driver di 1500 \* cicli 2750, ovvero la quantità di lavoro associato alla chiamata di **setrame** 1500 volte.</span><span class="sxs-lookup"><span data-stu-id="0b703-602">You might intuitively expect that moving **SetTexture** outside the render loop should reduce the amount of work done by the driver by 1500 \* 2750 cycles, which is the amount of work associated with calling **SetTexture** 1500 times.</span></span> <span data-ttu-id="0b703-603">Il frammento di codice avrà un aspetto simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="0b703-603">The code snippet would look like this:</span></span>


```
  SetTexture(...); // Set the state outside the loop
  for(int i = 0; i < 1500; i++)
  {
//    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="0b703-604">Esempio 5D: esempio 5C con la modifica dello stato al di fuori del ciclo</span><span class="sxs-lookup"><span data-stu-id="0b703-604">Example 5d: Example 5c with the State Change Outside the Loop</span></span>

<span data-ttu-id="0b703-605">Lo stato di un'operazione di ridimensionamento [**all'esterno del**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) ciclo di rendering comporta una riduzione della quantità di lavoro associato a un oggetto **setexture** poiché viene chiamato una volta anziché 1500 volte.</span><span class="sxs-lookup"><span data-stu-id="0b703-605">Moving [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) outside the render loop does reduce the amount of work associated with **SetTexture** since it is called once instead of 1500 times.</span></span> <span data-ttu-id="0b703-606">Un effetto secondario meno ovvio è che il lavoro per [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) è ridotto anche da 1500 chiamate a 1 chiamata, perché tutte le condizioni per la concatenazione delle chiamate di progetto sono soddisfatte.</span><span class="sxs-lookup"><span data-stu-id="0b703-606">A less obvious secondary effect is that the work for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is also reduced from 1500 calls to 1 call because all of the conditions for concatenating draw calls are satisfied.</span></span> <span data-ttu-id="0b703-607">Quando la sequenza di rendering viene elaborata, il runtime elabora le chiamate 1500 in una singola chiamata al driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-607">When the render sequence is processed, the runtime will process 1500 calls into a single driver call.</span></span> <span data-ttu-id="0b703-608">Spostando questa riga di codice, la quantità di lavoro dei driver è stata ridotta in modo significativo:</span><span class="sxs-lookup"><span data-stu-id="0b703-608">By moving this one line of code, the amount of driver work has been reduced dramatically:</span></span>


```
total work done = runtime + driver work

Example 5c: with SetTexture in the loop:
runtime work = 1500 SetTextures + 1500 DrawPrimitives 
driver  work = 1500 SetTextures + 1500 DrawPrimitives 

Example 5d: with SetTexture outside of the loop:
runtime work = 1 SetTexture + 1 DrawPrimitive + 1499 Concatenated DrawPrimitives 
driver  work = 1 SetTexture + 1 DrawPrimitive 
```



<span data-ttu-id="0b703-609">Questi risultati sono completamente corretti, ma sono molto fuorvianti nel contesto della domanda originale.</span><span class="sxs-lookup"><span data-stu-id="0b703-609">These results are entirely correct, but are very misleading in the context of the original question.</span></span> <span data-ttu-id="0b703-610">L'ottimizzazione della chiamata di richiamo ha causato una riduzione significativa della quantità di lavoro del driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-610">The draw call optimization has caused the amount of driver work to be dramatically reduced.</span></span> <span data-ttu-id="0b703-611">Si tratta di un problema comune quando si esegue la profilatura personalizzata.</span><span class="sxs-lookup"><span data-stu-id="0b703-611">This is a common problem when doing custom profiling.</span></span> <span data-ttu-id="0b703-612">Quando si eliminano le chiamate da una sequenza di rendering, prestare attenzione per evitare la concatenazione di chiamate di richiamo.</span><span class="sxs-lookup"><span data-stu-id="0b703-612">When eliminating calls from a render sequence, be careful to avoid draw call concatenation.</span></span> <span data-ttu-id="0b703-613">In realtà, questo scenario è un esempio potente della quantità di miglioramento delle prestazioni del driver possibile da questa ottimizzazione del runtime.</span><span class="sxs-lookup"><span data-stu-id="0b703-613">In fact, this scenario is a powerful example of the amount of improvement in driver performance possible by this runtime optimization.</span></span>

<span data-ttu-id="0b703-614">A questo punto si è in grado di misurare le modifiche allo stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-614">So now you know how to measure state changes.</span></span> <span data-ttu-id="0b703-615">Per iniziare, eseguire la profilatura di [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="0b703-615">Start by profiling [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="0b703-616">Aggiungere quindi ogni modifica di stato aggiuntiva alla sequenza (in alcuni casi l'aggiunta di una chiamata e in altri casi l'aggiunta di due chiamate) e la misurazione della differenza tra le due sequenze.</span><span class="sxs-lookup"><span data-stu-id="0b703-616">Then add each additional state change to the sequence (in some cases adding one call and in other cases adding two calls) and measure the difference between the two sequences.</span></span> <span data-ttu-id="0b703-617">È possibile convertire i risultati in cicli o cicli o ora.</span><span class="sxs-lookup"><span data-stu-id="0b703-617">You can convert the results to ticks or cycles or time.</span></span> <span data-ttu-id="0b703-618">Analogamente alla misurazione delle sequenze di rendering con QueryPerformanceCounter, la misurazione delle singole modifiche di stato si basa sul meccanismo di query per controllare il buffer dei comandi e l'inserimento delle modifiche allo stato in un ciclo per ridurre al minimo l'effetto delle transizioni in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-618">Just like measuring render sequences with QueryPerformanceCounter, measuring individual state changes relies on the query mechanism to control the command buffer, and putting the state changes in a loop to minimize the impact of the mode transitions.</span></span> <span data-ttu-id="0b703-619">Questa tecnica consente di misurare il costo di attivazione e disattivazione di uno stato, poiché il profiler restituisce la media di abilitazione e disabilitazione dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-619">This technique measures the cost of toggling a state, since the profiler returns the average of enabling and disabling the state.</span></span>

<span data-ttu-id="0b703-620">Grazie a questa funzionalità, è possibile iniziare a generare sequenze di rendering arbitrarie e misurare accuratamente le operazioni di runtime e driver associate.</span><span class="sxs-lookup"><span data-stu-id="0b703-620">With this capability, you can start generating arbitrary rendering sequences and accurately measuring the associated runtime and driver work.</span></span> <span data-ttu-id="0b703-621">I numeri possono quindi essere usati per rispondere a domande relative al budget, ad esempio "quante più chiamate" possono essere apportate nella sequenza di rendering, mantenendo al tempo stesso una frequenza di fotogrammi ragionevole, presumendo scenari limitati dalla CPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-621">The numbers can then be used to answer budgeting questions like "how many more of these calls" can be made in the render sequence while still maintaining a reasonable frame rate, assuming CPU-limited scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="0b703-622">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="0b703-622">Summary</span></span>

<span data-ttu-id="0b703-623">Questo documento illustra come controllare il buffer dei comandi in modo che le singole chiamate possano essere profilate accuratamente.</span><span class="sxs-lookup"><span data-stu-id="0b703-623">This paper demonstrates how to control the command buffer so that individual calls can be accurately profiled.</span></span> <span data-ttu-id="0b703-624">I numeri di profilatura possono essere generati in cicli, cicli o tempo assoluto.</span><span class="sxs-lookup"><span data-stu-id="0b703-624">The profiling numbers can be generated in ticks, cycles, or absolute time.</span></span> <span data-ttu-id="0b703-625">Rappresentano la quantità di operazioni di runtime e driver associate a ogni chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-625">They represent the amount of runtime and driver work associated with each API call.</span></span>

<span data-ttu-id="0b703-626">Iniziare con la profilatura di una \* chiamata primitiva di traccia in una sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-626">Start by profiling a Draw\*Primitive call in a render sequence.</span></span> <span data-ttu-id="0b703-627">Ricordare di:</span><span class="sxs-lookup"><span data-stu-id="0b703-627">Remember to:</span></span>

1.  <span data-ttu-id="0b703-628">Usare QueryPerformanceCounter per misurare il numero di cicli per ogni chiamata API.</span><span class="sxs-lookup"><span data-stu-id="0b703-628">Use QueryPerformanceCounter to measure the number of ticks per API call.</span></span> <span data-ttu-id="0b703-629">Usare QueryPerformanceFrequency per convertire i risultati in cicli o ora se si desidera.</span><span class="sxs-lookup"><span data-stu-id="0b703-629">Use QueryPerformanceFrequency to convert the results to cycles or time if you like.</span></span>
2.  <span data-ttu-id="0b703-630">Utilizzare il meccanismo di query per svuotare il buffer dei comandi prima di avviare.</span><span class="sxs-lookup"><span data-stu-id="0b703-630">Use the query mechanism to empty the command buffer before starting.</span></span>
3.  <span data-ttu-id="0b703-631">Includere la sequenza di rendering in un ciclo per ridurre al minimo l'effetto della transizione in modalità.</span><span class="sxs-lookup"><span data-stu-id="0b703-631">Include the render sequence in a loop to minimize the impact of the mode transition.</span></span>
4.  <span data-ttu-id="0b703-632">Usare il meccanismo di query per misurare il completamento del lavoro della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-632">Use the query mechanism to measure when the GPU has completed its work.</span></span>
5.  <span data-ttu-id="0b703-633">Osservare la concatenazione in fase di esecuzione che avrà un notevole effetto sulla quantità di lavoro svolto.</span><span class="sxs-lookup"><span data-stu-id="0b703-633">Watch out for runtime concatenation that will have a major impact on the amount of work done.</span></span>

<span data-ttu-id="0b703-634">In questo modo vengono fornite le prestazioni di base per [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) che possono essere usate per compilare da.</span><span class="sxs-lookup"><span data-stu-id="0b703-634">This gives you a baseline performance for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) that can be used to build from.</span></span> <span data-ttu-id="0b703-635">Per profilare una modifica di stato, seguire questi suggerimenti aggiuntivi:</span><span class="sxs-lookup"><span data-stu-id="0b703-635">To profile one state change, follow these additional tips:</span></span>

1.  <span data-ttu-id="0b703-636">Aggiungere la modifica di stato a un profilo di sequenza di rendering noto la nuova sequenza.</span><span class="sxs-lookup"><span data-stu-id="0b703-636">Add the state change to a known render sequence profile the new sequence.</span></span> <span data-ttu-id="0b703-637">Poiché il test viene eseguito in un ciclo, è necessario impostare lo stato due volte in valori opposti, come Enable e Disable per instance.</span><span class="sxs-lookup"><span data-stu-id="0b703-637">Since the testing is done in a loop, this requires setting the state twice into opposite values (like enable and disable for instance).</span></span>
2.  <span data-ttu-id="0b703-638">Confrontare la differenza nei tempi di ciclo tra le due sequenze.</span><span class="sxs-lookup"><span data-stu-id="0b703-638">Compare the difference in cycle times between the two sequences.</span></span>
3.  <span data-ttu-id="0b703-639">Per le modifiche di stato che cambiano significativamente la pipeline (ad esempio, la [**trama**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), sottrarre la differenza tra le due sequenze per ottenere l'ora per la modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-639">For state changes that significantly change the pipeline (like [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), subtract the difference between the two sequences to get the time for state change.</span></span>
4.  <span data-ttu-id="0b703-640">Per le modifiche di stato che modificano in modo significativo la pipeline (e pertanto richiedono gli Stati di alternanza come [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), sottrarre la differenza tra le sequenze di rendering e dividere per 2.</span><span class="sxs-lookup"><span data-stu-id="0b703-640">For state changes that significantly change the pipeline (and therefore require toggling states like [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), subtract the difference between the render sequences and divide by 2.</span></span> <span data-ttu-id="0b703-641">Verrà generato il numero medio di cicli per ogni modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-641">This will generate the average number of cycles for each state change.</span></span>

<span data-ttu-id="0b703-642">Tuttavia, prestare attenzione alle ottimizzazioni che causano risultati imprevisti durante la profilatura.</span><span class="sxs-lookup"><span data-stu-id="0b703-642">But be careful of optimizations that cause unexpected results when profiling.</span></span> <span data-ttu-id="0b703-643">Le ottimizzazioni di modifica dello stato possono impostare stati Dirty che causano il rinvio del lavoro.</span><span class="sxs-lookup"><span data-stu-id="0b703-643">State change optimizations may set dirty states which causes work to be deferred.</span></span> <span data-ttu-id="0b703-644">Questo può causare risultati del profilo che non sono intuitivi come previsto.</span><span class="sxs-lookup"><span data-stu-id="0b703-644">This can cause profile results which are not as intuitive as expected.</span></span> <span data-ttu-id="0b703-645">Le chiamate di estrazione concatenate ridurranno notevolmente le attività dei driver che possono causare conclusioni fuorvianti.</span><span class="sxs-lookup"><span data-stu-id="0b703-645">Draw calls that are concatenated will dramatically reduce driver work which can lead to misleading conclusions.</span></span> <span data-ttu-id="0b703-646">Le sequenze di rendering pianificate con attenzione vengono usate per impedire che le concatenazioni di modifiche di stato e di chiamata vengano eseguite.</span><span class="sxs-lookup"><span data-stu-id="0b703-646">Carefully planned render sequences are used to prevent state change and draw call concatenations from occurring.</span></span> <span data-ttu-id="0b703-647">Il trucco consiste nel impedire che le ottimizzazioni avvengano durante la profilatura, in modo che i numeri generati siano numeri di budget ragionevoli.</span><span class="sxs-lookup"><span data-stu-id="0b703-647">The trick is to prevent the optimizations from happening during profiling so that the numbers you generate are reasonable budgeting numbers.</span></span>

> [!Note]  
> <span data-ttu-id="0b703-648">La duplicazione di questa strategia di profilatura in un'applicazione senza il meccanismo di query è più difficile.</span><span class="sxs-lookup"><span data-stu-id="0b703-648">Duplicating this profiling strategy in an application without the query mechanism is more difficult.</span></span> <span data-ttu-id="0b703-649">Prima di Direct3D 9, l'unico modo prevedibile per svuotare il buffer dei comandi consiste nel bloccare una superficie attiva, ad esempio una destinazione di rendering, per attendere fino a quando la GPU non è inattiva.</span><span class="sxs-lookup"><span data-stu-id="0b703-649">Prior to Direct3D 9 the only predictable way to empty the command buffer is to lock an active surface (such as a render target) to wait until the GPU is idle.</span></span> <span data-ttu-id="0b703-650">Questo è dovuto al fatto che il blocco di una superficie impone al runtime di svuotare il buffer dei comandi nel caso in cui siano presenti comandi di rendering nel buffer che dovrebbero aggiornare la superficie prima che venga bloccata, oltre ad attendere il completamento della GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-650">This is because locking a surface forces the runtime to empty the command buffer in case there are any rendering commands in the buffer that should update the surface before it gets locked, in addition to waiting for the GPU to finish.</span></span> <span data-ttu-id="0b703-651">Questa tecnica è funzionale, sebbene sia più intrusiva l'uso del meccanismo di query introdotto in Direct3D 9.</span><span class="sxs-lookup"><span data-stu-id="0b703-651">This technique is functional, although it is more obtrusive that using the query mechanism introduced in Direct3D 9.</span></span>

 

## <a name="appendix"></a><span data-ttu-id="0b703-652">Appendice</span><span class="sxs-lookup"><span data-stu-id="0b703-652">Appendix</span></span>

<span data-ttu-id="0b703-653">I numeri in questa tabella sono un intervallo di approssimazioni per la quantità di operazioni di runtime e driver associate a ognuna di queste modifiche di stato.</span><span class="sxs-lookup"><span data-stu-id="0b703-653">The numbers in this table are a range of approximations for the amount of runtime and driver work associated with each of these state changes.</span></span> <span data-ttu-id="0b703-654">Le approssimazioni sono basate sulle misure effettive effettuate sui driver usando le tecniche illustrate nel documento.</span><span class="sxs-lookup"><span data-stu-id="0b703-654">The approximations are based on actual measurements made on drivers using the techniques shown in the paper.</span></span> <span data-ttu-id="0b703-655">Questi numeri sono stati generati utilizzando il runtime Direct3D 9 e sono dipendenti dal driver.</span><span class="sxs-lookup"><span data-stu-id="0b703-655">These numbers were generated using the Direct3D 9 runtime and are driver-dependent.</span></span>

<span data-ttu-id="0b703-656">Le tecniche descritte in questo documento sono progettate per misurare il funzionamento del driver e del runtime.</span><span class="sxs-lookup"><span data-stu-id="0b703-656">The techniques in this paper are designed to measure runtime and driver work.</span></span> <span data-ttu-id="0b703-657">In generale, non è pratico fornire risultati che corrispondano alle prestazioni della CPU e della GPU in ogni applicazione, perché ciò richiede una matrice completa di sequenze di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-657">In general, it is impractical to provide results that match the performance of the CPU and the GPU in every application as this would require an exhaustive array of render sequences.</span></span> <span data-ttu-id="0b703-658">Inoltre, è particolarmente difficile eseguire il benchmark delle prestazioni della GPU perché dipende in modo elevato dall'impostazione dello stato nella pipeline prima della sequenza di rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-658">In addition, it is particularly difficult to benchmark performance of the GPU because it is highly dependent on the state setup in the pipeline before the render sequence.</span></span> <span data-ttu-id="0b703-659">Ad esempio, l'abilitazione della fusione alfa non influisce sulla quantità di lavoro della CPU necessaria, ma può avere un notevole impatto sulla quantità di lavoro svolto dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-659">For instance, enabling alpha blending does little to affect the amount of CPU work necessary, but can have a big impact on the amount of work done by the GPU.</span></span> <span data-ttu-id="0b703-660">Pertanto, le tecniche di questo documento vincolano il lavoro della GPU alla quantità minima possibile limitando la quantità di dati di cui è necessario eseguire il rendering.</span><span class="sxs-lookup"><span data-stu-id="0b703-660">Therefore, the techniques in this paper constrain the GPU work to the minimum amount possible by limiting the amount of data that needs to be rendered.</span></span> <span data-ttu-id="0b703-661">Ciò significa che i numeri nella tabella corrisponderanno maggiormente ai risultati ottenuti dalle applicazioni con limitazione della CPU, anziché da un'applicazione limitata dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="0b703-661">This means that the numbers in the table will most closely match the results attained from applications that are CPU limited (as opposed to an application that is limited by the GPU).</span></span>

<span data-ttu-id="0b703-662">Si consiglia di usare le tecniche presentate per coprire gli scenari e le configurazioni più importanti per l'utente.</span><span class="sxs-lookup"><span data-stu-id="0b703-662">You are encouraged to use the techniques presented to cover the scenarios and configurations most important to you.</span></span> <span data-ttu-id="0b703-663">I valori nella tabella possono essere utilizzati per il confronto con i numeri generati.</span><span class="sxs-lookup"><span data-stu-id="0b703-663">The values in the table can be used to compare with the numbers you generate.</span></span> <span data-ttu-id="0b703-664">Poiché ogni driver varia, l'unico modo per generare i numeri effettivi è quello di generare i risultati della profilatura usando gli scenari.</span><span class="sxs-lookup"><span data-stu-id="0b703-664">Since each driver varies, the only way to generate the actual numbers you will see is to generate profiling results using your scenarios.</span></span>



| <span data-ttu-id="0b703-665">Chiamata API</span><span class="sxs-lookup"><span data-stu-id="0b703-665">API Call</span></span>                             | <span data-ttu-id="0b703-666">Numero medio di cicli</span><span class="sxs-lookup"><span data-stu-id="0b703-666">Average number of Cycles</span></span> |
|--------------------------------------|--------------------------|
| <span data-ttu-id="0b703-667">SetVertexDeclaration</span><span class="sxs-lookup"><span data-stu-id="0b703-667">SetVertexDeclaration</span></span>                 | <span data-ttu-id="0b703-668">6500-11250</span><span class="sxs-lookup"><span data-stu-id="0b703-668">6500 - 11250</span></span>             |
| <span data-ttu-id="0b703-669">SetFVF</span><span class="sxs-lookup"><span data-stu-id="0b703-669">SetFVF</span></span>                               | <span data-ttu-id="0b703-670">6400-11200</span><span class="sxs-lookup"><span data-stu-id="0b703-670">6400 - 11200</span></span>             |
| <span data-ttu-id="0b703-671">SetVertexShader</span><span class="sxs-lookup"><span data-stu-id="0b703-671">SetVertexShader</span></span>                      | <span data-ttu-id="0b703-672">3000-12100</span><span class="sxs-lookup"><span data-stu-id="0b703-672">3000 - 12100</span></span>             |
| <span data-ttu-id="0b703-673">SetPixelShader</span><span class="sxs-lookup"><span data-stu-id="0b703-673">SetPixelShader</span></span>                       | <span data-ttu-id="0b703-674">6300-7000</span><span class="sxs-lookup"><span data-stu-id="0b703-674">6300 - 7000</span></span>              |
| <span data-ttu-id="0b703-675">SPECULARENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-675">SPECULARENABLE</span></span>                       | <span data-ttu-id="0b703-676">1900-11200</span><span class="sxs-lookup"><span data-stu-id="0b703-676">1900 - 11200</span></span>             |
| <span data-ttu-id="0b703-677">SetRenderTarget</span><span class="sxs-lookup"><span data-stu-id="0b703-677">SetRenderTarget</span></span>                      | <span data-ttu-id="0b703-678">6000-6250</span><span class="sxs-lookup"><span data-stu-id="0b703-678">6000 - 6250</span></span>              |
| <span data-ttu-id="0b703-679">SetPixelShaderConstant (1 costante)</span><span class="sxs-lookup"><span data-stu-id="0b703-679">SetPixelShaderConstant (1 Constant)</span></span>  | <span data-ttu-id="0b703-680">1500-9000</span><span class="sxs-lookup"><span data-stu-id="0b703-680">1500 - 9000</span></span>              |
| <span data-ttu-id="0b703-681">NORMALIZENORMALS</span><span class="sxs-lookup"><span data-stu-id="0b703-681">NORMALIZENORMALS</span></span>                     | <span data-ttu-id="0b703-682">2200-8100</span><span class="sxs-lookup"><span data-stu-id="0b703-682">2200 - 8100</span></span>              |
| <span data-ttu-id="0b703-683">Alleggeribile</span><span class="sxs-lookup"><span data-stu-id="0b703-683">LightEnable</span></span>                          | <span data-ttu-id="0b703-684">1300-9000</span><span class="sxs-lookup"><span data-stu-id="0b703-684">1300 - 9000</span></span>              |
| <span data-ttu-id="0b703-685">SetStreamSource</span><span class="sxs-lookup"><span data-stu-id="0b703-685">SetStreamSource</span></span>                      | <span data-ttu-id="0b703-686">3700-5800</span><span class="sxs-lookup"><span data-stu-id="0b703-686">3700 - 5800</span></span>              |
| <span data-ttu-id="0b703-687">ILLUMINAZIONE</span><span class="sxs-lookup"><span data-stu-id="0b703-687">LIGHTING</span></span>                             | <span data-ttu-id="0b703-688">1700-7500</span><span class="sxs-lookup"><span data-stu-id="0b703-688">1700 - 7500</span></span>              |
| <span data-ttu-id="0b703-689">DIFFUSEMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="0b703-689">DIFFUSEMATERIALSOURCE</span></span>                | <span data-ttu-id="0b703-690">900-8300</span><span class="sxs-lookup"><span data-stu-id="0b703-690">900 - 8300</span></span>               |
| <span data-ttu-id="0b703-691">AMBIENTMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="0b703-691">AMBIENTMATERIALSOURCE</span></span>                | <span data-ttu-id="0b703-692">900-8200</span><span class="sxs-lookup"><span data-stu-id="0b703-692">900 - 8200</span></span>               |
| <span data-ttu-id="0b703-693">COLORVERTEX</span><span class="sxs-lookup"><span data-stu-id="0b703-693">COLORVERTEX</span></span>                          | <span data-ttu-id="0b703-694">800-7800</span><span class="sxs-lookup"><span data-stu-id="0b703-694">800 - 7800</span></span>               |
| <span data-ttu-id="0b703-695">Chiaro</span><span class="sxs-lookup"><span data-stu-id="0b703-695">SetLight</span></span>                             | <span data-ttu-id="0b703-696">2200-5100</span><span class="sxs-lookup"><span data-stu-id="0b703-696">2200 - 5100</span></span>              |
| <span data-ttu-id="0b703-697">SetTransform</span><span class="sxs-lookup"><span data-stu-id="0b703-697">SetTransform</span></span>                         | <span data-ttu-id="0b703-698">3200-3750</span><span class="sxs-lookup"><span data-stu-id="0b703-698">3200 - 3750</span></span>              |
| <span data-ttu-id="0b703-699">SetIndices</span><span class="sxs-lookup"><span data-stu-id="0b703-699">SetIndices</span></span>                           | <span data-ttu-id="0b703-700">900-5600</span><span class="sxs-lookup"><span data-stu-id="0b703-700">900 - 5600</span></span>               |
| <span data-ttu-id="0b703-701">AMBIENTE</span><span class="sxs-lookup"><span data-stu-id="0b703-701">AMBIENT</span></span>                              | <span data-ttu-id="0b703-702">1150-4800</span><span class="sxs-lookup"><span data-stu-id="0b703-702">1150 - 4800</span></span>              |
| <span data-ttu-id="0b703-703">SetTexture</span><span class="sxs-lookup"><span data-stu-id="0b703-703">SetTexture</span></span>                           | <span data-ttu-id="0b703-704">2500-3100</span><span class="sxs-lookup"><span data-stu-id="0b703-704">2500 - 3100</span></span>              |
| <span data-ttu-id="0b703-705">SPECULARMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="0b703-705">SPECULARMATERIALSOURCE</span></span>               | <span data-ttu-id="0b703-706">900-4600</span><span class="sxs-lookup"><span data-stu-id="0b703-706">900 - 4600</span></span>               |
| <span data-ttu-id="0b703-707">EMISSIVEMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="0b703-707">EMISSIVEMATERIALSOURCE</span></span>               | <span data-ttu-id="0b703-708">900-4500</span><span class="sxs-lookup"><span data-stu-id="0b703-708">900 - 4500</span></span>               |
| <span data-ttu-id="0b703-709">Materiali</span><span class="sxs-lookup"><span data-stu-id="0b703-709">SetMaterial</span></span>                          | <span data-ttu-id="0b703-710">1000-3700</span><span class="sxs-lookup"><span data-stu-id="0b703-710">1000 - 3700</span></span>              |
| <span data-ttu-id="0b703-711">ZENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-711">ZENABLE</span></span>                              | <span data-ttu-id="0b703-712">700-3900</span><span class="sxs-lookup"><span data-stu-id="0b703-712">700 - 3900</span></span>               |
| <span data-ttu-id="0b703-713">WRAP0</span><span class="sxs-lookup"><span data-stu-id="0b703-713">WRAP0</span></span>                                | <span data-ttu-id="0b703-714">1600-2700</span><span class="sxs-lookup"><span data-stu-id="0b703-714">1600 - 2700</span></span>              |
| <span data-ttu-id="0b703-715">MINFILTER</span><span class="sxs-lookup"><span data-stu-id="0b703-715">MINFILTER</span></span>                            | <span data-ttu-id="0b703-716">1700-2500</span><span class="sxs-lookup"><span data-stu-id="0b703-716">1700 - 2500</span></span>              |
| <span data-ttu-id="0b703-717">MAGFILTER</span><span class="sxs-lookup"><span data-stu-id="0b703-717">MAGFILTER</span></span>                            | <span data-ttu-id="0b703-718">1700-2400</span><span class="sxs-lookup"><span data-stu-id="0b703-718">1700 - 2400</span></span>              |
| <span data-ttu-id="0b703-719">SetVertexShaderConstant (1 costante)</span><span class="sxs-lookup"><span data-stu-id="0b703-719">SetVertexShaderConstant (1 Constant)</span></span> | <span data-ttu-id="0b703-720">1000-2700</span><span class="sxs-lookup"><span data-stu-id="0b703-720">1000 - 2700</span></span>              |
| <span data-ttu-id="0b703-721">COLOROP</span><span class="sxs-lookup"><span data-stu-id="0b703-721">COLOROP</span></span>                              | <span data-ttu-id="0b703-722">1500-2100</span><span class="sxs-lookup"><span data-stu-id="0b703-722">1500 - 2100</span></span>              |
| <span data-ttu-id="0b703-723">COLORARG2</span><span class="sxs-lookup"><span data-stu-id="0b703-723">COLORARG2</span></span>                            | <span data-ttu-id="0b703-724">1300-2000</span><span class="sxs-lookup"><span data-stu-id="0b703-724">1300 - 2000</span></span>              |
| <span data-ttu-id="0b703-725">COLORARG1</span><span class="sxs-lookup"><span data-stu-id="0b703-725">COLORARG1</span></span>                            | <span data-ttu-id="0b703-726">1300-1980</span><span class="sxs-lookup"><span data-stu-id="0b703-726">1300 - 1980</span></span>              |
| <span data-ttu-id="0b703-727">CULLMODE</span><span class="sxs-lookup"><span data-stu-id="0b703-727">CULLMODE</span></span>                             | <span data-ttu-id="0b703-728">500-2570</span><span class="sxs-lookup"><span data-stu-id="0b703-728">500 - 2570</span></span>               |
| <span data-ttu-id="0b703-729">RITAGLIO</span><span class="sxs-lookup"><span data-stu-id="0b703-729">CLIPPING</span></span>                             | <span data-ttu-id="0b703-730">500-2550</span><span class="sxs-lookup"><span data-stu-id="0b703-730">500 - 2550</span></span>               |
| <span data-ttu-id="0b703-731">DrawIndexedPrimitive</span><span class="sxs-lookup"><span data-stu-id="0b703-731">DrawIndexedPrimitive</span></span>                 | <span data-ttu-id="0b703-732">1200-1400</span><span class="sxs-lookup"><span data-stu-id="0b703-732">1200 - 1400</span></span>              |
| <span data-ttu-id="0b703-733">ADDRESSV</span><span class="sxs-lookup"><span data-stu-id="0b703-733">ADDRESSV</span></span>                             | <span data-ttu-id="0b703-734">1090-1500</span><span class="sxs-lookup"><span data-stu-id="0b703-734">1090 - 1500</span></span>              |
| <span data-ttu-id="0b703-735">ADDRESSU</span><span class="sxs-lookup"><span data-stu-id="0b703-735">ADDRESSU</span></span>                             | <span data-ttu-id="0b703-736">1070-1500</span><span class="sxs-lookup"><span data-stu-id="0b703-736">1070 - 1500</span></span>              |
| <span data-ttu-id="0b703-737">DrawPrimitive</span><span class="sxs-lookup"><span data-stu-id="0b703-737">DrawPrimitive</span></span>                        | <span data-ttu-id="0b703-738">1050-1150</span><span class="sxs-lookup"><span data-stu-id="0b703-738">1050 - 1150</span></span>              |
| <span data-ttu-id="0b703-739">SRGBTEXTURE</span><span class="sxs-lookup"><span data-stu-id="0b703-739">SRGBTEXTURE</span></span>                          | <span data-ttu-id="0b703-740">150-1500</span><span class="sxs-lookup"><span data-stu-id="0b703-740">150 - 1500</span></span>               |
| <span data-ttu-id="0b703-741">STENCILMASK</span><span class="sxs-lookup"><span data-stu-id="0b703-741">STENCILMASK</span></span>                          | <span data-ttu-id="0b703-742">570-700</span><span class="sxs-lookup"><span data-stu-id="0b703-742">570 - 700</span></span>                |
| <span data-ttu-id="0b703-743">STENCILZFAIL</span><span class="sxs-lookup"><span data-stu-id="0b703-743">STENCILZFAIL</span></span>                         | <span data-ttu-id="0b703-744">500-800</span><span class="sxs-lookup"><span data-stu-id="0b703-744">500 - 800</span></span>                |
| <span data-ttu-id="0b703-745">STENCILREF</span><span class="sxs-lookup"><span data-stu-id="0b703-745">STENCILREF</span></span>                           | <span data-ttu-id="0b703-746">550-700</span><span class="sxs-lookup"><span data-stu-id="0b703-746">550 - 700</span></span>                |
| <span data-ttu-id="0b703-747">ALPHABLENDENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-747">ALPHABLENDENABLE</span></span>                     | <span data-ttu-id="0b703-748">550-700</span><span class="sxs-lookup"><span data-stu-id="0b703-748">550 - 700</span></span>                |
| <span data-ttu-id="0b703-749">STENCILFUNC</span><span class="sxs-lookup"><span data-stu-id="0b703-749">STENCILFUNC</span></span>                          | <span data-ttu-id="0b703-750">560-680</span><span class="sxs-lookup"><span data-stu-id="0b703-750">560 - 680</span></span>                |
| <span data-ttu-id="0b703-751">STENCILWRITEMASK</span><span class="sxs-lookup"><span data-stu-id="0b703-751">STENCILWRITEMASK</span></span>                     | <span data-ttu-id="0b703-752">520-700</span><span class="sxs-lookup"><span data-stu-id="0b703-752">520 - 700</span></span>                |
| <span data-ttu-id="0b703-753">STENCILFAIL</span><span class="sxs-lookup"><span data-stu-id="0b703-753">STENCILFAIL</span></span>                          | <span data-ttu-id="0b703-754">500-750</span><span class="sxs-lookup"><span data-stu-id="0b703-754">500 - 750</span></span>                |
| <span data-ttu-id="0b703-755">ZFUNC</span><span class="sxs-lookup"><span data-stu-id="0b703-755">ZFUNC</span></span>                                | <span data-ttu-id="0b703-756">510-700</span><span class="sxs-lookup"><span data-stu-id="0b703-756">510 - 700</span></span>                |
| <span data-ttu-id="0b703-757">ZWRITEENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-757">ZWRITEENABLE</span></span>                         | <span data-ttu-id="0b703-758">520-680</span><span class="sxs-lookup"><span data-stu-id="0b703-758">520 - 680</span></span>                |
| <span data-ttu-id="0b703-759">STENCILENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-759">STENCILENABLE</span></span>                        | <span data-ttu-id="0b703-760">540-650</span><span class="sxs-lookup"><span data-stu-id="0b703-760">540 - 650</span></span>                |
| <span data-ttu-id="0b703-761">STENCILPASS</span><span class="sxs-lookup"><span data-stu-id="0b703-761">STENCILPASS</span></span>                          | <span data-ttu-id="0b703-762">560-630</span><span class="sxs-lookup"><span data-stu-id="0b703-762">560 - 630</span></span>                |
| <span data-ttu-id="0b703-763">SRCBLEND</span><span class="sxs-lookup"><span data-stu-id="0b703-763">SRCBLEND</span></span>                             | <span data-ttu-id="0b703-764">500-685</span><span class="sxs-lookup"><span data-stu-id="0b703-764">500 - 685</span></span>                |
| <span data-ttu-id="0b703-765">StencilMODE a due \_ lati \_</span><span class="sxs-lookup"><span data-stu-id="0b703-765">Two\_Sided\_StencilMODE</span></span>              | <span data-ttu-id="0b703-766">450-590</span><span class="sxs-lookup"><span data-stu-id="0b703-766">450 - 590</span></span>                |
| <span data-ttu-id="0b703-767">ALPHATESTENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-767">ALPHATESTENABLE</span></span>                      | <span data-ttu-id="0b703-768">470-525</span><span class="sxs-lookup"><span data-stu-id="0b703-768">470 - 525</span></span>                |
| <span data-ttu-id="0b703-769">ALPHAREF</span><span class="sxs-lookup"><span data-stu-id="0b703-769">ALPHAREF</span></span>                             | <span data-ttu-id="0b703-770">460-530</span><span class="sxs-lookup"><span data-stu-id="0b703-770">460 - 530</span></span>                |
| <span data-ttu-id="0b703-771">ALPHAFUNC</span><span class="sxs-lookup"><span data-stu-id="0b703-771">ALPHAFUNC</span></span>                            | <span data-ttu-id="0b703-772">450-540</span><span class="sxs-lookup"><span data-stu-id="0b703-772">450 - 540</span></span>                |
| <span data-ttu-id="0b703-773">DESTBLEND</span><span class="sxs-lookup"><span data-stu-id="0b703-773">DESTBLEND</span></span>                            | <span data-ttu-id="0b703-774">475-510</span><span class="sxs-lookup"><span data-stu-id="0b703-774">475 - 510</span></span>                |
| <span data-ttu-id="0b703-775">COLORWRITEENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-775">COLORWRITEENABLE</span></span>                     | <span data-ttu-id="0b703-776">465-515</span><span class="sxs-lookup"><span data-stu-id="0b703-776">465 - 515</span></span>                |
| <span data-ttu-id="0b703-777">CCW \_ STENCILFAIL</span><span class="sxs-lookup"><span data-stu-id="0b703-777">CCW\_STENCILFAIL</span></span>                     | <span data-ttu-id="0b703-778">340-560</span><span class="sxs-lookup"><span data-stu-id="0b703-778">340 - 560</span></span>                |
| <span data-ttu-id="0b703-779">CCW \_ STENCILPASS</span><span class="sxs-lookup"><span data-stu-id="0b703-779">CCW\_STENCILPASS</span></span>                     | <span data-ttu-id="0b703-780">340-545</span><span class="sxs-lookup"><span data-stu-id="0b703-780">340 - 545</span></span>                |
| <span data-ttu-id="0b703-781">CCW \_ STENCILZFAIL</span><span class="sxs-lookup"><span data-stu-id="0b703-781">CCW\_STENCILZFAIL</span></span>                    | <span data-ttu-id="0b703-782">330-495</span><span class="sxs-lookup"><span data-stu-id="0b703-782">330 - 495</span></span>                |
| <span data-ttu-id="0b703-783">SCISSORTESTENABLE</span><span class="sxs-lookup"><span data-stu-id="0b703-783">SCISSORTESTENABLE</span></span>                    | <span data-ttu-id="0b703-784">375-440</span><span class="sxs-lookup"><span data-stu-id="0b703-784">375 - 440</span></span>                |
| <span data-ttu-id="0b703-785">CCW \_ STENCILFUNC</span><span class="sxs-lookup"><span data-stu-id="0b703-785">CCW\_STENCILFUNC</span></span>                     | <span data-ttu-id="0b703-786">250-480</span><span class="sxs-lookup"><span data-stu-id="0b703-786">250 - 480</span></span>                |
| <span data-ttu-id="0b703-787">SetScissorRect</span><span class="sxs-lookup"><span data-stu-id="0b703-787">SetScissorRect</span></span>                       | <span data-ttu-id="0b703-788">150-340</span><span class="sxs-lookup"><span data-stu-id="0b703-788">150 - 340</span></span>                |



 

## <a name="related-topics"></a><span data-ttu-id="0b703-789">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="0b703-789">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="0b703-790">Argomenti avanzati</span><span class="sxs-lookup"><span data-stu-id="0b703-790">Advanced Topics</span></span>](advanced-topics.md)
</dt> </dl>

 

 
