---
title: Uso degli shader in Direct3D 9
description: Uso degli shader in Direct3D 9
ms.assetid: 8d8f5124-fbf3-4af5-8399-43ba28aa6eb9
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 6455b47d24c1c83683ce8b85c48990bb32e221ae
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104993360"
---
# <a name="using-shaders-in-direct3d-9"></a><span data-ttu-id="8f1c0-103">Uso degli shader in Direct3D 9</span><span class="sxs-lookup"><span data-stu-id="8f1c0-103">Using Shaders in Direct3D 9</span></span>

-   [<span data-ttu-id="8f1c0-104">Compilazione di uno shader per hardware specifico</span><span class="sxs-lookup"><span data-stu-id="8f1c0-104">Compiling a Shader for Specific Hardware</span></span>](#compiling-a-shader-for-specific-hardware)
-   [<span data-ttu-id="8f1c0-105">Inizializzazione di costanti shader</span><span class="sxs-lookup"><span data-stu-id="8f1c0-105">Initializing Shader Constants</span></span>](#initializing-shader-constants)
-   [<span data-ttu-id="8f1c0-106">Associazione di un parametro dello shader a un particolare registro</span><span class="sxs-lookup"><span data-stu-id="8f1c0-106">Binding a Shader Parameter to a Particular Register</span></span>](#binding-a-shader-parameter-to-a-particular-register)
-   [<span data-ttu-id="8f1c0-107">Rendering di uno shader programmabile</span><span class="sxs-lookup"><span data-stu-id="8f1c0-107">Rendering a Programmable Shader</span></span>](#rendering-a-programmable-shader)
-   [<span data-ttu-id="8f1c0-108">Debug di shader</span><span class="sxs-lookup"><span data-stu-id="8f1c0-108">Debugging Shaders</span></span>](#debugging-shaders)
-   [<span data-ttu-id="8f1c0-109">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="8f1c0-109">Related topics</span></span>](#related-topics)

## <a name="compiling-a-shader-for-specific-hardware"></a><span data-ttu-id="8f1c0-110">Compilazione di uno shader per hardware specifico</span><span class="sxs-lookup"><span data-stu-id="8f1c0-110">Compiling a Shader for Specific Hardware</span></span>

<span data-ttu-id="8f1c0-111">Gli shader sono stati aggiunti per la prima volta a Microsoft DirectX in DirectX 8,0.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-111">Shaders were first added to Microsoft DirectX in DirectX 8.0.</span></span> <span data-ttu-id="8f1c0-112">A questo punto, sono stati definiti diversi computer di shader virtuali, ognuno approssimativamente corrispondente a un particolare processore grafico prodotto dai principali fornitori di grafica 3D.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-112">At that time, several virtual shader machines were defined, each roughly corresponding to a particular graphics processor produced by the top 3D graphics vendors.</span></span> <span data-ttu-id="8f1c0-113">Per ognuna di queste macchine virtuali shader è stato progettato un linguaggio assembly.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-113">For each of these virtual shader machines, an assembly language was designed.</span></span> <span data-ttu-id="8f1c0-114">I programmi scritti nei modelli shader (nomi rispetto a \_ 1 \_ 1 e PS \_ 1 \_ -PS \_ 1 \_ 4) erano relativamente brevi e sono stati scritti in genere dagli sviluppatori direttamente nel linguaggio assembly appropriato.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-114">Programs written to the shader models (names vs\_1\_1 and ps\_1\_1 - ps\_1\_4) were relatively short and were generally written by developers directly in the appropriate assembly language.</span></span> <span data-ttu-id="8f1c0-115">L'applicazione passa il codice della lingua assembly leggibile alla libreria D3DX usando [**D3DXAssembleShader**](/windows/desktop/direct3d9/d3dxassembleshader) e ottiene una rappresentazione binaria dello shader che a sua volta viene passata usando [**CreateVertexShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader) o [**CreatePixelShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-115">The application would pass this human-readable assembly language code to the D3DX library using [**D3DXAssembleShader**](/windows/desktop/direct3d9/d3dxassembleshader) and get back a binary representation of the shader which would in turn get passed using [**CreateVertexShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader) or [**CreatePixelShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader).</span></span> <span data-ttu-id="8f1c0-116">Per informazioni dettagliate, vedere la Software Development Kit (SDK).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-116">For more detail, see the software development kit (SDK).</span></span>

<span data-ttu-id="8f1c0-117">La situazione in Direct3D 9 è simile.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-117">The situation in Direct3D 9 is similar.</span></span> <span data-ttu-id="8f1c0-118">Un'applicazione passa uno shader HLSL a D3DX usando [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader) e restituisce una rappresentazione binaria dello shader compilato che a sua volta viene passato a Microsoft Direct3D usando [**CreatePixelShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader) o [**CreateVertexShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-118">An application passes an HLSL shader to D3DX using [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader) and gets back a binary representation of the compiled shader which in turn is passed to Microsoft Direct3D using [**CreatePixelShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader) or [**CreateVertexShader**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader).</span></span> <span data-ttu-id="8f1c0-119">Il runtime non è in grado di conoscere HLSL, bensì solo i modelli di shader dell'assembly binario.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-119">The runtime does not know anything about HLSL, only the binary assembly shader models.</span></span> <span data-ttu-id="8f1c0-120">Si tratta di un'operazione interessante perché significa che il compilatore HLSL può essere aggiornato indipendentemente dal runtime Direct3D.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-120">This is nice because it means that the HLSL compiler can be updated independent of the Direct3D runtime.</span></span> <span data-ttu-id="8f1c0-121">È anche possibile compilare shader offline usando [FXC](/windows/desktop/direct3dtools/fxc).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-121">You can also compile shaders offline using [fxc](/windows/desktop/direct3dtools/fxc).</span></span>

<span data-ttu-id="8f1c0-122">Oltre allo sviluppo del compilatore HLSL, in Direct3D 9 sono stati introdotti anche i modelli shader a livello di assembly per esporre la funzionalità dell'ultima generazione di hardware grafico.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-122">In addition to the development of the HLSL compiler, Direct3D 9 also introduced the assembly-level shader models to expose the functionality of the latest generation of graphics hardware.</span></span> <span data-ttu-id="8f1c0-123">Gli sviluppatori di applicazioni possono lavorare nell'assembly per questi nuovi modelli (vs \_ 2 \_ 0, vs \_ 3 \_ 0, PS \_ 2 \_ 0, PS \_ 3 \_ 0), ma si prevede che la maggior parte degli sviluppatori passi a HLSL per lo sviluppo dello shader.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-123">Application developers can work in assembly for these new models (vs\_2\_0, vs\_3\_0, ps\_2\_0, ps\_3\_0) but we expect most developers to move to HLSL for shader development.</span></span>

<span data-ttu-id="8f1c0-124">Naturalmente, la possibilità di scrivere un programma HLSL per esprimere un particolare algoritmo di ombreggiatura non lo abilita automaticamente per l'esecuzione in qualsiasi hardware specifico.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-124">Of course, the ability to write an HLSL program to express a particular shading algorithm does not automatically enable it to run on any given hardware.</span></span> <span data-ttu-id="8f1c0-125">Un'applicazione chiama D3DX per compilare uno shader in codice assembly binario con [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-125">An application calls D3DX to compile a shader into binary assembly code with [**D3DXCompileShader**](/windows/desktop/direct3d9/d3dxcompileshader).</span></span> <span data-ttu-id="8f1c0-126">Una delle limitazioni di questo punto di ingresso è un parametro che definisce quali modelli a livello di assembly (o destinazioni di compilazione) il compilatore HLSL deve usare per esprimere il codice shader finale.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-126">One of the limitations with this entry point is a parameter that defines which of the assembly-level models (or compilation targets) the HLSL compiler should use to express the final shader code.</span></span> <span data-ttu-id="8f1c0-127">Se un'applicazione sta eseguendo la compilazione dello shader HLSL in fase di esecuzione (anziché in fase di compilazione o non in linea), l'applicazione potrebbe esaminare le funzionalità del dispositivo Direct3D e selezionare la destinazione di compilazione di cui trovare la corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-127">If an application is doing HLSL shader compilation at run time (as opposed to compile time or offline), the application could examine the capabilities of the Direct3D device and select the compilation target to match.</span></span> <span data-ttu-id="8f1c0-128">Se l'algoritmo espresso in HLSL shader è troppo complesso per essere eseguito sulla destinazione di compilazione selezionata, la compilazione avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-128">If the algorithm expressed in the HLSL shader is too complex to execute on the selected compilation target, compilation will fail.</span></span> <span data-ttu-id="8f1c0-129">Ciò significa che, anche se HLSL è un enorme vantaggio per lo sviluppo di shader, non libera gli sviluppatori dalla realtà dei giochi di spedizione a destinatari con dispositivi grafici di diverse funzionalità.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-129">This means that while HLSL is a huge benefit to shader development, it does not free developers from the realities of shipping games to a target audience with graphics devices of varying capabilities.</span></span> <span data-ttu-id="8f1c0-130">Gli sviluppatori di giochi devono comunque gestire un approccio a più livelli per gli oggetti visivi. Ciò significa scrivere migliori shader per schede grafiche più idonee e scrivere più versioni di base per le schede meno recenti.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-130">As a game developer, you still have to manage a tiered approach to your visuals; this means writing better shaders for more capable graphics cards and writing more basic versions for older cards.</span></span> <span data-ttu-id="8f1c0-131">Con HLSL ben scritti, tuttavia, questo fardello può essere notevolmente ridotto.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-131">With well written HLSL, however, this burden can be eased significantly.</span></span>

<span data-ttu-id="8f1c0-132">Invece di compilare shader HLSL usando D3DX sul computer del cliente al momento del caricamento dell'applicazione o al primo utilizzo, molti sviluppatori scelgono di compilare il proprio shader da HLSL a codice assembly binario prima di distribuirli.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-132">Rather than compile HLSL shaders using D3DX on the customer's machine at application load time or on first use, many developers choose to compile their shader from HLSL to binary assembly code before they even ship.</span></span> <span data-ttu-id="8f1c0-133">In questo modo, il codice sorgente di HLSL si allontana da sguardi indiscreti e garantisce inoltre che tutti gli shader che la loro applicazione eseguiranno sono passati attraverso il processo interno di controllo della qualità.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-133">This keeps their HLSL source code away from prying eyes and also ensures that all the shaders their application will ever run have gone through their internal quality assurance process.</span></span> <span data-ttu-id="8f1c0-134">Una comoda utilità per la compilazione offline degli shader è [FXC](/windows/desktop/direct3dtools/fxc).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-134">A convenient utility for compiling shaders offline is [fxc](/windows/desktop/direct3dtools/fxc).</span></span> <span data-ttu-id="8f1c0-135">Questo strumento dispone di numerose opzioni che è possibile utilizzare per compilare il codice per la destinazione di compilazione specificata.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-135">This tool has a number of options that you can use to compile code for the specified compile target.</span></span> <span data-ttu-id="8f1c0-136">Lo studio dell'output disassemblato può essere molto istruttivo durante lo sviluppo se si desidera ottimizzare gli shader o solo in genere ottenere informazioni sulle funzionalità del computer Virtual shader a un livello più dettagliato.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-136">Studying the disassembled output can be very educational during development if you want to optimize your shaders or just generally get to know the virtual shader machine's capabilities at a more detailed level.</span></span> <span data-ttu-id="8f1c0-137">Queste opzioni sono riepilogate di seguito:</span><span class="sxs-lookup"><span data-stu-id="8f1c0-137">These options are summarized below:</span></span>

## <a name="initializing-shader-constants"></a><span data-ttu-id="8f1c0-138">Inizializzazione di costanti shader</span><span class="sxs-lookup"><span data-stu-id="8f1c0-138">Initializing Shader Constants</span></span>

<span data-ttu-id="8f1c0-139">Le costanti shader sono contenute nella tabella Constant.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-139">Shader constants are contained in the constant table.</span></span> <span data-ttu-id="8f1c0-140">È possibile accedere a questa operazione con l'interfaccia [**ID3DXConstantTable**](/windows/desktop/direct3d9/id3dxconstanttable) .</span><span class="sxs-lookup"><span data-stu-id="8f1c0-140">This can be accessed with the [**ID3DXConstantTable**](/windows/desktop/direct3d9/id3dxconstanttable) interface.</span></span> <span data-ttu-id="8f1c0-141">Le variabili dello shader globale possono essere inizializzate nel codice dello shader.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-141">Global shader variables can be initialized in shader code.</span></span> <span data-ttu-id="8f1c0-142">Questi vengono inizializzati in fase di esecuzione chiamando i [**valori predefiniti**](/windows/desktop/direct3d9/id3dxconstanttable--setdefaults).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-142">These are initialized at run time by calling [**SetDefaults**](/windows/desktop/direct3d9/id3dxconstanttable--setdefaults).</span></span>

## <a name="binding-a-shader-parameter-to-a-particular-register"></a><span data-ttu-id="8f1c0-143">Associazione di un parametro dello shader a un particolare registro</span><span class="sxs-lookup"><span data-stu-id="8f1c0-143">Binding a Shader Parameter to a Particular Register</span></span>

<span data-ttu-id="8f1c0-144">Il compilatore assegna automaticamente i registri alle variabili globali.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-144">The compiler will automatically assign registers to global variables.</span></span> <span data-ttu-id="8f1c0-145">Il compilatore assegna l'ambiente al campionatore del campionatore S0, SparkleNoise al campionatore Register S1 e k \_ s al registro costante C0 (presupponendo che non siano stati già assegnati altri registri di campionatori o costanti) per le tre variabili globali seguenti:</span><span class="sxs-lookup"><span data-stu-id="8f1c0-145">The compiler would assign Environment to sampler register s0, SparkleNoise to sampler register s1, and k\_s to constant register c0 (assuming no other sampler or constant registers were already assigned) for the following three global variables:</span></span>


```
sampler Environment;
sampler SparkleNoise;
float4 k_s;
```



<span data-ttu-id="8f1c0-146">È anche possibile associare le variabili a un registro specifico.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-146">It is also possible to bind variables to a specific register.</span></span> <span data-ttu-id="8f1c0-147">Per forzare l'assegnazione del compilatore a un particolare registro, usare la sintassi seguente:</span><span class="sxs-lookup"><span data-stu-id="8f1c0-147">To force the compiler to assign to a particular register, use the following syntax:</span></span>


```
register(RegisterName)
```



<span data-ttu-id="8f1c0-148">dove RegisterName è il nome del registro specifico.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-148">where RegisterName is the name of the specific register.</span></span> <span data-ttu-id="8f1c0-149">Negli esempi seguenti viene illustrata la sintassi di assegnazione del registro specifica, in cui l'ambiente campionatore verrà associato al registro campionatore S1, SparkleNoise verrà associato al registro campionatore S0 e k \_ s verrà associato a constant register C12:</span><span class="sxs-lookup"><span data-stu-id="8f1c0-149">The following examples demonstrate the specific register assignment syntax, where the sampler Environment will be bound to sampler register s1, SparkleNoise will be bound to sampler register s0, and k\_s will be bound to constant register c12:</span></span>


```
sampler Environment : register(s1);
sampler SparkleNoise : register(s0);
float4 k_s : register(c12);
```



## <a name="rendering-a-programmable-shader"></a><span data-ttu-id="8f1c0-150">Rendering di uno shader programmabile</span><span class="sxs-lookup"><span data-stu-id="8f1c0-150">Rendering a Programmable Shader</span></span>

<span data-ttu-id="8f1c0-151">Viene eseguito il rendering di uno shader impostando lo shader corrente nel dispositivo, inizializzando le costanti dello shader, indicando il dispositivo da cui provengono i dati di input variabili e infine eseguendo il rendering delle primitive.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-151">A shader is rendered by setting the current shader in the device, initializing the shader constants, telling the device where the varying input data is coming from, and finally rendering the primitives.</span></span> <span data-ttu-id="8f1c0-152">Ognuna di queste operazioni può essere eseguita chiamando rispettivamente i metodi seguenti:</span><span class="sxs-lookup"><span data-stu-id="8f1c0-152">Each of these can be accomplished by calling the following methods respectively:</span></span>

-   [<span data-ttu-id="8f1c0-153">**SetVertexShader**</span><span class="sxs-lookup"><span data-stu-id="8f1c0-153">**SetVertexShader**</span></span>](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshader)
-   [<span data-ttu-id="8f1c0-154">**SetVertexShaderConstantF**</span><span class="sxs-lookup"><span data-stu-id="8f1c0-154">**SetVertexShaderConstantF**</span></span>](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshaderconstantf)
-   [<span data-ttu-id="8f1c0-155">**SetStreamSource**</span><span class="sxs-lookup"><span data-stu-id="8f1c0-155">**SetStreamSource**</span></span>](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setstreamsource)
-   [<span data-ttu-id="8f1c0-156">**DrawPrimitive**</span><span class="sxs-lookup"><span data-stu-id="8f1c0-156">**DrawPrimitive**</span></span>](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-drawprimitive)

## <a name="debugging-shaders"></a><span data-ttu-id="8f1c0-157">Debug di shader</span><span class="sxs-lookup"><span data-stu-id="8f1c0-157">Debugging Shaders</span></span>

<span data-ttu-id="8f1c0-158">L'estensione DirectX per Microsoft Visual Studio .NET fornisce un debugger HLSL completamente integrato all'interno dell'ambiente di sviluppo integrato (IDE) di Visual Studio .NET.</span><span class="sxs-lookup"><span data-stu-id="8f1c0-158">The DirectX extension for Microsoft Visual Studio .NET is provides a fully integrated HLSL debugger within the Visual Studio .NET Integrated Development Environment (IDE).</span></span> <span data-ttu-id="8f1c0-159">Per preparare il debug dello shader, è necessario installare gli strumenti corretti nel computer. vedere [debug di shader in Visual Studio (Direct3D 9)](dx-graphics-hlsl-debug-visual-studio.md).</span><span class="sxs-lookup"><span data-stu-id="8f1c0-159">In order to prepare for shader debugging, you must install the right tools on your machine (see [Debugging Shaders in Visual Studio (Direct3D 9)](dx-graphics-hlsl-debug-visual-studio.md)).</span></span>

## <a name="related-topics"></a><span data-ttu-id="8f1c0-160">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="8f1c0-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8f1c0-161">Guida alla programmazione per HLSL</span><span class="sxs-lookup"><span data-stu-id="8f1c0-161">Programming Guide for HLSL</span></span>](dx-graphics-hlsl-pguide.md)
</dt> </dl>

 

 