---
description: Panoramica del flusso di dati in DirectShow
ms.assetid: a1b30592-5106-44f5-8ee0-577573670167
title: Panoramica del flusso di dati in DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5a34444991d6cba62026935f5ec2d7aa4eba77
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/06/2021
ms.locfileid: "104482260"
---
# <a name="overview-of-data-flow-in-directshow"></a><span data-ttu-id="b316f-103">Panoramica del flusso di dati in DirectShow</span><span class="sxs-lookup"><span data-stu-id="b316f-103">Overview of Data Flow in DirectShow</span></span>

<span data-ttu-id="b316f-104">Questa sezione offre una panoramica generale del funzionamento del flusso di dati in DirectShow.</span><span class="sxs-lookup"><span data-stu-id="b316f-104">This section gives a broad overview of how data flow works in DirectShow.</span></span> <span data-ttu-id="b316f-105">Informazioni dettagliate sono disponibili in altre sezioni della documentazione.</span><span class="sxs-lookup"><span data-stu-id="b316f-105">Details can be found in other sections of the documentation.</span></span>

<span data-ttu-id="b316f-106">I dati vengono conservati nei buffer, che sono semplicemente matrici di byte.</span><span class="sxs-lookup"><span data-stu-id="b316f-106">Data is held in buffers, which are simply arrays of bytes.</span></span> <span data-ttu-id="b316f-107">Ogni buffer è incluso in un oggetto COM denominato *esempio multimediale*, che implementa l'interfaccia [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="b316f-107">Each buffer is wrapped by a COM object called a *media sample*, which implements the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="b316f-108">Gli esempi vengono creati da un altro tipo di oggetto, denominato allocatore, che implementa l'interfaccia [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="b316f-108">Samples are created by another type of object, called an allocator, which implements the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="b316f-109">Un allocatore viene assegnato per ogni connessione pin, sebbene due o più connessioni pin possano condividere lo stesso allocatore.</span><span class="sxs-lookup"><span data-stu-id="b316f-109">An allocator is assigned for every pin connection, although two or more pin connections might share the same allocator.</span></span> <span data-ttu-id="b316f-110">Questo processo è illustrato nella figura seguente.</span><span class="sxs-lookup"><span data-stu-id="b316f-110">The following image illustrates this process.</span></span>

![buffer, esempi e allocatori](images/dataflow.png)

<span data-ttu-id="b316f-112">Ogni allocatore crea un pool di esempi di supporti e alloca i buffer per ogni campione.</span><span class="sxs-lookup"><span data-stu-id="b316f-112">Each allocator creates a pool of media samples and allocates the buffers for each sample.</span></span> <span data-ttu-id="b316f-113">Ogni volta che un filtro deve riempire un buffer con i dati, richiede un campione dall'allocatore chiamando [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="b316f-113">Whenever a filter needs to fill a buffer with data, it requests a sample from the allocator by calling [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="b316f-114">Se l'allocatore contiene esempi che non sono attualmente in uso da un altro filtro, il metodo **GetBuffer** restituisce immediatamente un puntatore all'esempio.</span><span class="sxs-lookup"><span data-stu-id="b316f-114">If the allocator has any samples that are not currently in use by another filter, the **GetBuffer** method returns immediately with a pointer to the sample.</span></span> <span data-ttu-id="b316f-115">Se tutti gli esempi dell'allocatore sono in uso, il metodo si blocca fino a quando non viene reso disponibile un campione.</span><span class="sxs-lookup"><span data-stu-id="b316f-115">If all of the allocator's samples are in use, the method blocks until a sample becomes available.</span></span> <span data-ttu-id="b316f-116">Quando il metodo restituisce un esempio, il filtro inserisce i dati nel buffer, imposta i flag appropriati nell'esempio (incluso un timestamp) e recapita l'esempio downstream.</span><span class="sxs-lookup"><span data-stu-id="b316f-116">When the method does return a sample, the filter puts data into the buffer, sets the appropriate flags on the sample (typically including a time stamp), and delivers the sample downstream.</span></span>

<span data-ttu-id="b316f-117">Quando un filtro renderer riceve un campione, controlla il timestamp e lo include nell'esempio fino a quando l'orologio di riferimento del grafico del filtro non indica che è necessario eseguire il rendering dei dati.</span><span class="sxs-lookup"><span data-stu-id="b316f-117">When a renderer filter receives a sample, it checks the time stamp and holds onto the sample until the filter graph's reference clock indicates that the data should be rendered.</span></span> <span data-ttu-id="b316f-118">Quando il filtro esegue il rendering dei dati, rilascia l'esempio.</span><span class="sxs-lookup"><span data-stu-id="b316f-118">After the filter renders the data, it releases the sample.</span></span> <span data-ttu-id="b316f-119">L'esempio non torna al pool di campioni dell'allocatore fino a quando il conteggio dei riferimenti dell'esempio non è pari a zero, vale a dire che ogni filtro ha rilasciato l'esempio.</span><span class="sxs-lookup"><span data-stu-id="b316f-119">The sample does not go back into the allocator's pool of samples until the sample's reference count is zero, meaning that every filter has released the sample.</span></span> <span data-ttu-id="b316f-120">Questo processo è illustrato nella figura seguente.</span><span class="sxs-lookup"><span data-stu-id="b316f-120">The following image illustrates this process.</span></span>

![decodificatore in attesa di un esempio di supporto libero](images/dataflow2.png)

<span data-ttu-id="b316f-122">Il filtro upstream può essere eseguito in avanti rispetto al renderer, ovvero potrebbe riempire i buffer più velocemente di quanto il renderer li utilizzi.</span><span class="sxs-lookup"><span data-stu-id="b316f-122">The upstream filter might run ahead of the renderer — that is, it might fill buffers faster than the renderer consumes them.</span></span> <span data-ttu-id="b316f-123">Anche in questo caso, gli esempi non vengono sottoposti a rendering in anticipo, perché il renderer include ognuno fino al momento della presentazione.</span><span class="sxs-lookup"><span data-stu-id="b316f-123">Even so, samples do not get rendered early, because the renderer holds each until its presentation time.</span></span> <span data-ttu-id="b316f-124">Inoltre, il filtro upstream non sovrascrive i buffer accidentalmente, perché **GetSample** restituisce solo campioni che non sono altrimenti in uso.</span><span class="sxs-lookup"><span data-stu-id="b316f-124">Moreover, the upstream filter will not overwrite buffers accidentally, because **GetSample** only returns samples that are not otherwise in use.</span></span> <span data-ttu-id="b316f-125">La quantità in base alla quale il filtro upstream può essere eseguito in anticipo è determinato dal numero di campioni nel pool dell'allocatore.</span><span class="sxs-lookup"><span data-stu-id="b316f-125">The amount by which the upstream filter can run ahead is determined by the number of samples in the allocator's pool.</span></span>

<span data-ttu-id="b316f-126">Il diagramma precedente Mostra solo un allocatore, ma in genere sono presenti diversi allocatori per ogni flusso.</span><span class="sxs-lookup"><span data-stu-id="b316f-126">The previous diagram only shows one allocator, but typically there are several allocators per stream.</span></span> <span data-ttu-id="b316f-127">Pertanto, quando il renderer rilascia un campione, può avere un effetto a catena.</span><span class="sxs-lookup"><span data-stu-id="b316f-127">Thus, when the renderer releases a sample, it can have a cascading effect.</span></span> <span data-ttu-id="b316f-128">Il diagramma seguente illustra una situazione in cui un decodificatore contiene un frame video compresso mentre attende che il renderer rilasci un campione.</span><span class="sxs-lookup"><span data-stu-id="b316f-128">The following diagram shows a situation where a decoder holds a compressed video frame while it waits for the renderer to release a sample.</span></span> <span data-ttu-id="b316f-129">Un filtro del parser è anche in attesa del decodificatore per rilasciare un campione.</span><span class="sxs-lookup"><span data-stu-id="b316f-129">A parser filter is also waiting for the decoder to release a sample.</span></span>

![due filtri in attesa di esempi](images/dataflow3.png)

<span data-ttu-id="b316f-131">Quando il renderer rilascia l'esempio, la chiamata in sospeso del decodificatore a **GetBuffer** restituisce.</span><span class="sxs-lookup"><span data-stu-id="b316f-131">When the renderer releases its sample, the decoder's pending call to **GetBuffer** returns.</span></span> <span data-ttu-id="b316f-132">Il decodificatore può quindi decodificare il frame video compresso e rilasciare l'esempio che teneva, sbloccando così la chiamata a **GetBuffer** in sospeso del parser.</span><span class="sxs-lookup"><span data-stu-id="b316f-132">The decoder can then decode the compressed video frame and release the sample it was holding, thereby unblocking the parser's pending **GetBuffer** call.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b316f-133">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="b316f-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b316f-134">Flusso di dati nel grafico del filtro</span><span class="sxs-lookup"><span data-stu-id="b316f-134">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



