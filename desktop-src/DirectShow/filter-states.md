---
description: Stati filtro
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: Stati filtro
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/06/2021
ms.locfileid: "106304199"
---
# <a name="filter-states"></a><span data-ttu-id="13fc8-103">Stati filtro</span><span class="sxs-lookup"><span data-stu-id="13fc8-103">Filter States</span></span>

<span data-ttu-id="13fc8-104">I filtri possono avere tre stati: arrestato, sospeso e in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="13fc8-104">Filters have three possible states: stopped, paused, and running.</span></span> <span data-ttu-id="13fc8-105">Lo scopo dello stato Paused consiste nel cue i dati nel grafico, in modo che un comando Run risponda immediatamente.</span><span class="sxs-lookup"><span data-stu-id="13fc8-105">The purpose of the paused state is to cue data in the graph, so that a run command responds immediately.</span></span> <span data-ttu-id="13fc8-106">Filter Graph Manager controlla tutte le transizioni di stato.</span><span class="sxs-lookup"><span data-stu-id="13fc8-106">The Filter Graph Manager controls all state transitions.</span></span> <span data-ttu-id="13fc8-107">Quando un'applicazione chiama [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)o [**IMediaControl:: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), il gestore del grafico dei filtri chiama il metodo [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) corrispondente su tutti i filtri.</span><span class="sxs-lookup"><span data-stu-id="13fc8-107">When an application calls [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause), or [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), the Filter Graph Manager calls the corresponding [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) method on all of the filters.</span></span> <span data-ttu-id="13fc8-108">Le transizioni tra arrestato e in esecuzione passano sempre attraverso lo stato sospeso, quindi se l'applicazione chiama l' **esecuzione** su un grafico interrotto, il gestore del grafico del filtro sospende il grafo prima di eseguirlo.</span><span class="sxs-lookup"><span data-stu-id="13fc8-108">Transitions between stopped and running always go through the paused state, so if the application calls **Run** on a stopped graph, the Filter Graph Manager pauses the graph before running it.</span></span>

<span data-ttu-id="13fc8-109">Per la maggior parte dei filtri, gli stati in esecuzione e sospesi sono identici.</span><span class="sxs-lookup"><span data-stu-id="13fc8-109">For most filters, the running and paused states are identical.</span></span> <span data-ttu-id="13fc8-110">Si consideri il seguente grafico filtro:</span><span class="sxs-lookup"><span data-stu-id="13fc8-110">Consider the following filter graph:</span></span>

<span data-ttu-id="13fc8-111">Renderer > di origine > trasformazione</span><span class="sxs-lookup"><span data-stu-id="13fc8-111">Source > Transform > Renderer</span></span>

<span data-ttu-id="13fc8-112">Si supponga ora che il filtro di origine non sia un'origine di acquisizione in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="13fc8-112">Assume for now that the source filter is not a live capture source.</span></span> <span data-ttu-id="13fc8-113">Quando il filtro di origine viene sospeso, viene creato un thread che genera nuovi dati e lo scrive in un campione multimediale il più rapidamente possibile.</span><span class="sxs-lookup"><span data-stu-id="13fc8-113">When the source filter pauses, it creates a thread that generates new data and writes it into media samples as quickly as possible.</span></span> <span data-ttu-id="13fc8-114">Il thread esegue il push degli esempi downstream chiamando [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) sul pin di input del filtro di trasformazione.</span><span class="sxs-lookup"><span data-stu-id="13fc8-114">The thread "pushes" the samples downstream by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the transform filter's input pin.</span></span> <span data-ttu-id="13fc8-115">Il filtro di trasformazione riceve gli esempi sul thread del filtro di origine.</span><span class="sxs-lookup"><span data-stu-id="13fc8-115">The transform filter receives the samples on the source filter's thread.</span></span> <span data-ttu-id="13fc8-116">Può usare un thread di lavoro per recapitare gli esempi al renderer, ma in genere li recapita sullo stesso thread.</span><span class="sxs-lookup"><span data-stu-id="13fc8-116">It may use a worker thread to deliver the samples to the renderer, but typically it delivers them on the same thread.</span></span> <span data-ttu-id="13fc8-117">Mentre il renderer viene sospeso, attende la ricezione di un campione.</span><span class="sxs-lookup"><span data-stu-id="13fc8-117">While the renderer is paused, it waits to receive a sample.</span></span> <span data-ttu-id="13fc8-118">Una volta ricevuto, questo campione viene bloccato e archiviato a tempo indefinito.</span><span class="sxs-lookup"><span data-stu-id="13fc8-118">After it receives one, it blocks and holds that sample indefinitely.</span></span> <span data-ttu-id="13fc8-119">Se si tratta di un renderer video, viene visualizzato l'esempio come immagine poster, ridisegnando l'immagine in modo necessario.</span><span class="sxs-lookup"><span data-stu-id="13fc8-119">If it is a video renderer, it displays the sample as a poster image, repainting the image as necessary.</span></span>

<span data-ttu-id="13fc8-120">A questo punto, il flusso è completo e pronto per il rendering.</span><span class="sxs-lookup"><span data-stu-id="13fc8-120">At this point, the stream is fully cued and ready for rendering.</span></span> <span data-ttu-id="13fc8-121">Se il grafo rimane in pausa, gli esempi vengono "ammucchiati" nel grafico dietro il primo campione, fino a quando ogni filtro non è bloccato in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) o [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="13fc8-121">If the graph remains paused, samples will "pile up" in the graph behind the first sample, until every filter is blocked in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="13fc8-122">Tuttavia, non viene perso alcun dato.</span><span class="sxs-lookup"><span data-stu-id="13fc8-122">No data is lost, though.</span></span> <span data-ttu-id="13fc8-123">Quando il thread di origine viene sbloccato, riprende semplicemente dal punto in cui è stato bloccato.</span><span class="sxs-lookup"><span data-stu-id="13fc8-123">Once the source thread is unblocked, it simply resumes from the point where it blocked.</span></span>

<span data-ttu-id="13fc8-124">Il filtro di origine e il filtro di trasformazione ignorano la transizione da sospesa a in esecuzione, ma semplicemente continuano a elaborare i dati il più rapidamente possibile.</span><span class="sxs-lookup"><span data-stu-id="13fc8-124">The source filter and the transform filter ignore the transition from paused to running—they simply continue to process data as fast as possible.</span></span> <span data-ttu-id="13fc8-125">Tuttavia, quando viene eseguito, il renderer avvia il rendering degli esempi.</span><span class="sxs-lookup"><span data-stu-id="13fc8-125">But when the renderer runs, it starts rendering samples.</span></span> <span data-ttu-id="13fc8-126">Esegue prima di tutto il rendering dell'esempio mantenuto mentre era sospeso.</span><span class="sxs-lookup"><span data-stu-id="13fc8-126">First it renders the sample it held while it was paused.</span></span> <span data-ttu-id="13fc8-127">Quindi, ogni volta che viene ricevuto un nuovo esempio, viene calcolata l'ora di presentazione dell'esempio.</span><span class="sxs-lookup"><span data-stu-id="13fc8-127">Then, each time it receives a new sample, it calculates the sample's presentation time.</span></span> <span data-ttu-id="13fc8-128">Per informazioni dettagliate, vedere [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md). Il renderer include ogni campione fino al momento della presentazione, a quel punto viene eseguito il rendering dell'esempio.</span><span class="sxs-lookup"><span data-stu-id="13fc8-128">(For details, see [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md).) The renderer holds each sample until the presentation time, at which point it renders the sample.</span></span> <span data-ttu-id="13fc8-129">Sebbene attenda l'ora di presentazione, si blocca nel metodo [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) o riceve nuovi esempi in un thread di lavoro con una coda.</span><span class="sxs-lookup"><span data-stu-id="13fc8-129">While it waits for the presentation time, it either blocks in the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, or receives new samples on a worker thread with a queue.</span></span> <span data-ttu-id="13fc8-130">I filtri upstream dal renderer non sono interessati dalla pianificazione.</span><span class="sxs-lookup"><span data-stu-id="13fc8-130">Filters upstream from the renderer are not involved in scheduling.</span></span>

<span data-ttu-id="13fc8-131">Le origini live, ad esempio i dispositivi di acquisizione, rappresentano un'eccezione a questa architettura generale.</span><span class="sxs-lookup"><span data-stu-id="13fc8-131">Live sources, such as capture devices, are an exception to this general architecture.</span></span> <span data-ttu-id="13fc8-132">Con un'origine live, non è opportuno riportare i dati in anticipo.</span><span class="sxs-lookup"><span data-stu-id="13fc8-132">With a live source, it is not appropriate to cue any data in advance.</span></span> <span data-ttu-id="13fc8-133">L'applicazione potrebbe sospendere il grafico e attendere molto tempo prima di eseguirlo.</span><span class="sxs-lookup"><span data-stu-id="13fc8-133">The application might pause the graph and then wait for a long time before running it.</span></span> <span data-ttu-id="13fc8-134">Il grafico non deve eseguire il rendering degli esempi "obsoleti".</span><span class="sxs-lookup"><span data-stu-id="13fc8-134">The graph should not render "stale" samples.</span></span> <span data-ttu-id="13fc8-135">Pertanto, un'origine live non produce alcun campione durante la pausa, solo durante l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="13fc8-135">Therefore, a live source produces no samples while paused, only while running.</span></span> <span data-ttu-id="13fc8-136">Per segnalare questo fatto al gestore del grafico dei filtri, il metodo [**IMediaFilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) del filtro di origine restituisce il segnale non può essere di tipo VFW \_ \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="13fc8-136">To signal this fact to the Filter Graph Manager, the source filter's [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) method returns VFW\_S\_CANT\_CUE.</span></span> <span data-ttu-id="13fc8-137">Questo codice restituito indica che il filtro è stato spostato sullo stato sospeso, anche se il renderer non ha ricevuto dati.</span><span class="sxs-lookup"><span data-stu-id="13fc8-137">This return code indicates that the filter has switched to the paused state, even though the renderer did not receive any data.</span></span>

<span data-ttu-id="13fc8-138">Quando si interrompe un filtro, vengono rifiutati tutti gli altri esempi recapitati.</span><span class="sxs-lookup"><span data-stu-id="13fc8-138">When a filter stops, it rejects any more samples delivered to it.</span></span> <span data-ttu-id="13fc8-139">I filtri di origine arrestano i thread di streaming e altri filtri arrestano tutti i thread di lavoro che possono avere creato.</span><span class="sxs-lookup"><span data-stu-id="13fc8-139">Source filters shut down their streaming threads, and other filters shut down any worker threads they may have created.</span></span> <span data-ttu-id="13fc8-140">I pin decommitno gli allocatori.</span><span class="sxs-lookup"><span data-stu-id="13fc8-140">Pins decommit their allocators.</span></span>

### <a name="state-transitions"></a><span data-ttu-id="13fc8-141">Transizioni di stato</span><span class="sxs-lookup"><span data-stu-id="13fc8-141">State Transitions</span></span>

<span data-ttu-id="13fc8-142">Filter Graph Manager esegue tutte le transizioni di stato nell'ordine upstream, a partire dal renderer e procedendo all'indietro rispetto al filtro di origine.</span><span class="sxs-lookup"><span data-stu-id="13fc8-142">The Filter Graph Manager carries out all state transitions in upstream order, starting from the renderer and working backward to the source filter.</span></span> <span data-ttu-id="13fc8-143">Questo ordinamento è necessario per impedire che gli esempi vengano eliminati e impedire il deadlock del grafo.</span><span class="sxs-lookup"><span data-stu-id="13fc8-143">This ordering is necessary to prevent samples from being dropped and to prevent the graph from deadlocking.</span></span> <span data-ttu-id="13fc8-144">Le transizioni di stato più cruciali sono sospese e interrotte:</span><span class="sxs-lookup"><span data-stu-id="13fc8-144">The most crucial state transitions are between paused and stopped:</span></span>

-   <span data-ttu-id="13fc8-145">Arrestato in sospeso: quando ogni filtro viene sospeso, diventa pronto a ricevere esempi dal filtro successivo.</span><span class="sxs-lookup"><span data-stu-id="13fc8-145">Stopped to paused: As each filter pauses, it becomes ready to receive samples from the next filter.</span></span> <span data-ttu-id="13fc8-146">Il filtro di origine è l'ultimo oggetto da sospendere.</span><span class="sxs-lookup"><span data-stu-id="13fc8-146">The source filter is the last to pause.</span></span> <span data-ttu-id="13fc8-147">Crea il thread di streaming e inizia a consegnare gli esempi.</span><span class="sxs-lookup"><span data-stu-id="13fc8-147">It creates the streaming thread and begins delivering samples.</span></span> <span data-ttu-id="13fc8-148">Poiché tutti i filtri downstream sono sospesi, nessun filtro rifiuta alcun campione.</span><span class="sxs-lookup"><span data-stu-id="13fc8-148">Because all of the downstream filters are paused, no filter rejects any samples.</span></span> <span data-ttu-id="13fc8-149">Il gestore del grafo del filtro non completa la transizione fino a quando ogni renderer del grafico non ha ricevuto un campione (ad eccezione delle origini live, come descritto in precedenza).</span><span class="sxs-lookup"><span data-stu-id="13fc8-149">The Filter Graph Manager does not complete the transition until every renderer in the graph has received a sample (with the exception of live sources, as described earlier).</span></span>
-   <span data-ttu-id="13fc8-150">Sospeso in interrotto: quando si arresta un filtro, vengono rilasciati tutti i campioni che include, che sblocca tutti i filtri upstream in attesa in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="13fc8-150">Paused to stopped: When a filter stops, it releases any samples that it holds, which unblocks any upstream filters waiting in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="13fc8-151">Se il filtro è in attesa di una risorsa all'interno del metodo [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , si interrompe in attesa e viene restituito dalla **ricezione**, che sblocca il filtro chiamante.</span><span class="sxs-lookup"><span data-stu-id="13fc8-151">If the filter is waiting for a resource inside the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, it stops waiting and returns from **Receive**, which unblocks the calling filter.</span></span> <span data-ttu-id="13fc8-152">Pertanto, quando il gestore del grafico del filtro arresta il successivo filtro upstream, il filtro non viene bloccato in **GetBuffer** o **Receive** e può rispondere al comando stop.</span><span class="sxs-lookup"><span data-stu-id="13fc8-152">Therefore, when the Filter Graph Manager stops the next upstream filter, that filter is not blocked in either **GetBuffer** or **Receive**, and can respond to the stop command.</span></span> <span data-ttu-id="13fc8-153">Il filtro upstream potrebbe recapitare alcuni esempi aggiuntivi prima di ottenere il comando stop, ma il filtro downstream li rifiuta semplicemente perché è già stato arrestato.</span><span class="sxs-lookup"><span data-stu-id="13fc8-153">The upstream filter might deliver a few extra samples before it gets the stop command, but the downstream filter simply rejects them, because it already stopped.</span></span>

## <a name="related-topics"></a><span data-ttu-id="13fc8-154">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="13fc8-154">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="13fc8-155">Flusso di dati nel grafico del filtro</span><span class="sxs-lookup"><span data-stu-id="13fc8-155">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



