---
description: Questo argomento descrive come scrivere un renderer video personalizzato per DirectShow.
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: Renderer video alternativi
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/06/2021
ms.locfileid: "103747279"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="97a44-103">Renderer video alternativi</span><span class="sxs-lookup"><span data-stu-id="97a44-103">Alternative Video Renderers</span></span>

<span data-ttu-id="97a44-104">Questo argomento descrive come scrivere un renderer video personalizzato per DirectShow.</span><span class="sxs-lookup"><span data-stu-id="97a44-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="97a44-105">Anziché scrivere un renderer video personalizzato, è consigliabile scrivere un plug-in Allocator-Presenter per il renderer video mixing (VMR) o il [**renderer video avanzato**](enhanced-video-renderer-filter.md) (EVR).</span><span class="sxs-lookup"><span data-stu-id="97a44-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="97a44-106">Questo approccio offre tutti i vantaggi di VMR/EVR, incluso il supporto per l'accelerazione video DirectX (DXVA), la deinterlacciamento hardware e l'esecuzione del frame, ed è probabile che sia più affidabile rispetto a un renderer video personalizzato.</span><span class="sxs-lookup"><span data-stu-id="97a44-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="97a44-107">Per altre informazioni, vedere i seguenti argomenti:</span><span class="sxs-lookup"><span data-stu-id="97a44-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="97a44-108">Modalità di riproduzione con rendering VMR (allocatore personalizzato-Presenter)</span><span class="sxs-lookup"><span data-stu-id="97a44-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="97a44-109">Come scrivere un presentatore EVR</span><span class="sxs-lookup"><span data-stu-id="97a44-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="97a44-110">Scrittura di un Renderer alternativo</span><span class="sxs-lookup"><span data-stu-id="97a44-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="97a44-111">Microsoft DirectShow fornisce un renderer video basato su finestra; fornisce inoltre un renderer a schermo intero nell'installazione di run-time.</span><span class="sxs-lookup"><span data-stu-id="97a44-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="97a44-112">È possibile usare le classi base di DirectShow per scrivere renderer video alternativi.</span><span class="sxs-lookup"><span data-stu-id="97a44-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="97a44-113">Affinché i renderer alternativi possano interagire correttamente con le applicazioni basate su DirectShow, i renderer devono rispettare le linee guida descritte in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="97a44-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="97a44-114">È possibile usare le classi [**CBaseRenderer**](cbaserenderer.md) e [**CBaseVideoRenderer**](cbasevideorenderer.md) per seguire queste linee guida durante l'implementazione di un rendering video alternativo.</span><span class="sxs-lookup"><span data-stu-id="97a44-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="97a44-115">A causa dello sviluppo continuo di DirectShow, esaminare periodicamente l'implementazione per assicurarsi che i renderer siano compatibili con la versione più recente di DirectShow.</span><span class="sxs-lookup"><span data-stu-id="97a44-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="97a44-116">In questo argomento vengono descritte molte notifiche che un renderer è responsabile della gestione di.</span><span class="sxs-lookup"><span data-stu-id="97a44-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="97a44-117">Una breve revisione delle notifiche DirectShow potrebbe contribuire a impostare la fase.</span><span class="sxs-lookup"><span data-stu-id="97a44-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="97a44-118">In DirectShow sono essenzialmente presenti tre tipi di notifiche:</span><span class="sxs-lookup"><span data-stu-id="97a44-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="97a44-119">*Notifiche di flusso*, ovvero eventi che si verificano nel flusso multimediale e passati da un filtro a quello successivo.</span><span class="sxs-lookup"><span data-stu-id="97a44-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="97a44-120">Possono essere le notifiche di inizio-svuotamento, di svuotamento finale o di fine flusso e vengono inviate chiamando il metodo appropriato sul pin di input del filtro downstream (ad esempio [**Ipin:: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span><span class="sxs-lookup"><span data-stu-id="97a44-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="97a44-121">*Filtrare le notifiche dei grafici*, ovvero gli eventi inviati da un filtro al gestore del grafico del filtro, ad esempio [**EC \_ complete**](ec-complete.md).</span><span class="sxs-lookup"><span data-stu-id="97a44-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="97a44-122">Questa operazione viene eseguita chiamando il metodo [**IMediaEventSink:: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) in gestione grafico dei filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="97a44-123">*Notifiche dell'applicazione*, che vengono recuperate da Filter Graph Manager dall'applicazione di controllo.</span><span class="sxs-lookup"><span data-stu-id="97a44-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="97a44-124">Un'applicazione chiama il metodo [**IMediaEvent:: GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) su Filter Graph Manager per recuperare questi eventi.</span><span class="sxs-lookup"><span data-stu-id="97a44-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="97a44-125">Spesso, il gestore del grafo dei filtri passa attraverso gli eventi che riceve all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="97a44-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="97a44-126">In questo argomento viene illustrata la responsabilità del filtro renderer per la gestione delle notifiche di flusso ricevute e per l'invio di notifiche del grafico di filtro appropriate.</span><span class="sxs-lookup"><span data-stu-id="97a44-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="97a44-127">Gestione delle notifiche di fine flusso e scaricamento</span><span class="sxs-lookup"><span data-stu-id="97a44-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="97a44-128">Una notifica di fine flusso inizia da un filtro upstream, ad esempio il filtro di origine, quando tale filtro rileva che può inviare altri dati.</span><span class="sxs-lookup"><span data-stu-id="97a44-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="97a44-129">Viene passato attraverso ogni filtro nel grafico e infine termina nel renderer, che è responsabile della successiva invio di una notifica di [**\_ completamento EC**](ec-complete.md) al gestore del grafico dei filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="97a44-130">I renderer hanno responsabilità particolari quando si tratta di gestire queste notifiche.</span><span class="sxs-lookup"><span data-stu-id="97a44-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="97a44-131">Un renderer riceve una notifica di fine flusso quando il metodo [**Ipin:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) del PIN di input viene chiamato dal filtro upstream.</span><span class="sxs-lookup"><span data-stu-id="97a44-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="97a44-132">Un renderer deve prendere nota della notifica e continuare a eseguire il rendering dei dati già ricevuti.</span><span class="sxs-lookup"><span data-stu-id="97a44-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="97a44-133">Una volta ricevuti tutti i dati rimanenti, il renderer deve inviare una notifica di [**\_ completamento EC**](ec-complete.md) al gestore del grafo dei filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="97a44-134">La notifica di **\_ completamento EC** deve essere inviata una sola volta da un renderer ogni volta che raggiunge la fine di un flusso.</span><span class="sxs-lookup"><span data-stu-id="97a44-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="97a44-135">Inoltre, le notifiche **\_ complete EC** non devono mai essere inviate tranne quando il grafico del filtro è in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="97a44-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="97a44-136">Se, pertanto, il grafico del filtro viene sospeso quando un filtro di origine invia una notifica di fine flusso, è necessario che **EC \_ complete** non venga inviato fino a quando non viene infine eseguito il grafico dei filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="97a44-137">Qualsiasi chiamata al metodo [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) o [**IMemInputPin:: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) dopo una notifica di fine del flusso viene segnalata come deve essere rifiutata.</span><span class="sxs-lookup"><span data-stu-id="97a44-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="97a44-138">**E \_** Il messaggio di errore più appropriato da restituire in questo caso è imprevisto.</span><span class="sxs-lookup"><span data-stu-id="97a44-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="97a44-139">Quando un grafico a filtro viene arrestato, eventuali notifiche di fine flusso memorizzate nella cache devono essere cancellate e non inviate nuovamente al successivo avvio.</span><span class="sxs-lookup"><span data-stu-id="97a44-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="97a44-140">Questo è dovuto al fatto che il gestore del grafico dei filtri sospende sempre tutti i filtri immediatamente prima di eseguirli, in modo che si verifichi lo svuotamento appropriato.</span><span class="sxs-lookup"><span data-stu-id="97a44-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="97a44-141">Se, ad esempio, il grafico del filtro è sospeso e viene ricevuta una notifica di fine del flusso, quindi il grafico del filtro viene arrestato, il renderer non deve inviare una notifica di [**\_ completamento EC**](ec-complete.md) quando viene eseguita successivamente.</span><span class="sxs-lookup"><span data-stu-id="97a44-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="97a44-142">Se non si è verificata alcuna ricerca, il filtro di origine invierà automaticamente un'altra notifica di fine flusso durante lo stato di sospensione che precede uno stato di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="97a44-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="97a44-143">Se, invece, si è verificata una ricerca durante l'arresto del grafico del filtro, il filtro di origine potrebbe avere dati da inviare, quindi non invierà una notifica di fine del flusso.</span><span class="sxs-lookup"><span data-stu-id="97a44-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="97a44-144">I renderer video spesso dipendono dalle notifiche di fine flusso per un numero maggiore di notifiche di [**\_ completamento**](ec-complete.md) dell'invio di EC.</span><span class="sxs-lookup"><span data-stu-id="97a44-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="97a44-145">Ad esempio, se un flusso ha terminato la riproduzione, ovvero viene inviata una notifica di fine flusso, e un'altra finestra viene trascinata su una finestra renderer video, verranno generati alcuni messaggi della finestra di [**\_ disegno WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="97a44-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="97a44-146">La procedura tipica per l'esecuzione di renderer video è evitare di ridisegnare il frame corrente alla ricezione dei messaggi di **\_ disegno WM** (in base al presupposto che venga ricevuto un altro frame da disegnare).</span><span class="sxs-lookup"><span data-stu-id="97a44-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="97a44-147">Tuttavia, quando è stata inviata la notifica di fine flusso, il renderer è in uno stato di attesa. è ancora in esecuzione, ma è consapevole del mancato ricevimento di dati aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="97a44-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="97a44-148">In queste circostanze, il renderer disegna normalmente l'area di riproduzione nera.</span><span class="sxs-lookup"><span data-stu-id="97a44-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="97a44-149">La gestione dello svuotamento è una complicazione aggiuntiva per i renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="97a44-150">Lo scaricamento viene eseguito tramite una coppia di metodi [**Ipin**](/windows/desktop/api/Strmif/nn-strmif-ipin) denominati [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) e [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="97a44-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="97a44-151">Lo svuotamento è essenzialmente uno stato aggiuntivo che deve essere gestito dal renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="97a44-152">Non è consentito per un filtro di origine chiamare **BeginFlush** senza chiamare **EndFlush**, quindi è possibile che lo stato sia breve e discreto; Tuttavia, il renderer deve gestire correttamente i dati o le notifiche ricevute durante la transizione di svuotamento.</span><span class="sxs-lookup"><span data-stu-id="97a44-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="97a44-153">Qualsiasi dato ricevuto dopo la chiamata a [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) deve essere rifiutato immediatamente restituendo **S \_ false**.</span><span class="sxs-lookup"><span data-stu-id="97a44-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="97a44-154">Inoltre, qualsiasi notifica di fine flusso memorizzata nella cache deve essere cancellata anche quando viene scaricato un renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="97a44-155">Un renderer viene in genere scaricato in risposta a una ricerca.</span><span class="sxs-lookup"><span data-stu-id="97a44-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="97a44-156">Lo scaricamento garantisce che i dati obsoleti vengano cancellati dal grafico filtro prima che vengano inviati nuovi esempi.</span><span class="sxs-lookup"><span data-stu-id="97a44-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="97a44-157">In genere, la riproduzione di due sezioni di un flusso, una dopo l'altra, viene gestita in modo ottimale tramite comandi posticipati invece di attendere il completamento di una sezione e quindi di emettere un comando seek.</span><span class="sxs-lookup"><span data-stu-id="97a44-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="97a44-158">Gestione delle modifiche di stato e completamento della sospensione</span><span class="sxs-lookup"><span data-stu-id="97a44-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="97a44-159">Un filtro renderer si comporta allo stesso modo di qualsiasi altro filtro nel grafico filtro quando viene modificato lo stato, con la seguente eccezione.</span><span class="sxs-lookup"><span data-stu-id="97a44-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="97a44-160">Dopo la sospensione, il renderer avrà alcuni dati in coda, pronti per essere sottoposti a rendering quando vengono eseguiti successivamente.</span><span class="sxs-lookup"><span data-stu-id="97a44-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="97a44-161">Quando il renderer video viene arrestato, lo utilizza per i dati in coda.</span><span class="sxs-lookup"><span data-stu-id="97a44-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="97a44-162">Si tratta di un'eccezione alla regola DirectShow che non deve essere mantenuta da filtri quando il grafico del filtro viene arrestato.</span><span class="sxs-lookup"><span data-stu-id="97a44-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="97a44-163">Il motivo di questa eccezione è che, mantenendo le risorse, il renderer avrà sempre un'immagine con cui ridisegnare la finestra se riceve un messaggio di [**\_ disegno WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="97a44-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="97a44-164">Dispone inoltre di un'immagine per soddisfare i metodi, ad esempio [**CBaseControlVideo:: GetStaticImage**](cbasecontrolvideo-getstaticimage.md), che richiedono una copia dell'immagine corrente.</span><span class="sxs-lookup"><span data-stu-id="97a44-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="97a44-165">Un altro effetto del contenimento delle risorse consiste nel fatto che l'allocazione dell'allocatore si interrompe, il che a sua volta rende più veloce la modifica dello stato successivo perché i buffer delle immagini sono già allocati.</span><span class="sxs-lookup"><span data-stu-id="97a44-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="97a44-166">Un renderer video deve eseguire il rendering e rilasciare campioni solo durante l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="97a44-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="97a44-167">Durante la pausa, il filtro potrebbe eseguirne il rendering, ad esempio durante il disegno di un'immagine del poster statica in una finestra, ma non deve essere rilasciata.</span><span class="sxs-lookup"><span data-stu-id="97a44-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="97a44-168">I renderer audio non eseguiranno il rendering mentre sono sospesi (anche se possono eseguire altre attività, ad esempio la preparazione del dispositivo Wave).</span><span class="sxs-lookup"><span data-stu-id="97a44-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="97a44-169">L'ora in cui deve essere eseguito il rendering degli esempi viene ottenuta combinando l'ora del flusso nell'esempio con l'ora di riferimento passata come parametro al metodo [**IMediaControl:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) .</span><span class="sxs-lookup"><span data-stu-id="97a44-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="97a44-170">I renderer devono rifiutare campioni con orari di inizio inferiori o uguali a quelli di fine.</span><span class="sxs-lookup"><span data-stu-id="97a44-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="97a44-171">Quando un'applicazione sospende un grafico di filtro, il grafico del filtro non restituisce alcun risultato dal metodo [**IMediaControl::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) fino a quando non sono presenti dati in coda nei renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="97a44-172">Per garantire questo aspetto, quando un renderer viene sospeso, deve restituire S \_ false se non sono presenti dati in attesa di essere sottoposti a rendering.</span><span class="sxs-lookup"><span data-stu-id="97a44-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="97a44-173">Se sono presenti dati in coda, può restituire **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="97a44-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="97a44-174">Filter Graph Manager controlla tutti i valori restituiti durante la sospensione di un grafico di filtro per assicurarsi che i renderer dispongano di dati in coda.</span><span class="sxs-lookup"><span data-stu-id="97a44-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="97a44-175">Se uno o più filtri non sono pronti, il gestore del grafico dei filtri esegue il polling dei filtri nel grafico chiamando [**IMediaFilter:: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span><span class="sxs-lookup"><span data-stu-id="97a44-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="97a44-176">Il metodo **GetState** accetta un parametro di timeout.</span><span class="sxs-lookup"><span data-stu-id="97a44-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="97a44-177">Un filtro (in genere un renderer) che è ancora in attesa dell'arrivo dei dati prima di completare la modifica dello stato restituisce l' **\_ \_ \_ intermediario dello stato VFW S** se il metodo **GetState** scade.</span><span class="sxs-lookup"><span data-stu-id="97a44-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="97a44-178">Quando i dati arrivano al renderer, **GetState** deve essere restituito immediatamente con **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="97a44-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="97a44-179">Sia nello stato intermedio che completato lo stato del filtro indicato sarà \_ sospeso.</span><span class="sxs-lookup"><span data-stu-id="97a44-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="97a44-180">Solo il valore restituito indica se il filtro è effettivamente pronto o meno.</span><span class="sxs-lookup"><span data-stu-id="97a44-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="97a44-181">Se, mentre un renderer è in attesa dell'arrivo dei dati, il relativo filtro di origine invia una notifica di fine flusso, che dovrebbe anche completare la modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="97a44-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="97a44-182">Quando tutti i filtri hanno effettivamente dati in attesa di essere sottoposti a rendering, il grafico del filtro completerà la modifica dello stato di sospensione.</span><span class="sxs-lookup"><span data-stu-id="97a44-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="97a44-183">Gestione della terminazione</span><span class="sxs-lookup"><span data-stu-id="97a44-183">Handling Termination</span></span>

<span data-ttu-id="97a44-184">I renderer video devono gestire correttamente gli eventi di terminazione dall'utente.</span><span class="sxs-lookup"><span data-stu-id="97a44-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="97a44-185">Ciò implica la corretta mascheramento della finestra e la conoscenza delle operazioni da eseguire se successivamente viene forzata la visualizzazione di una finestra.</span><span class="sxs-lookup"><span data-stu-id="97a44-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="97a44-186">Inoltre, i renderer video devono notificare a Filter Graph Manager quando la finestra viene distrutta (o più accuratamente quando il renderer viene rimosso dal grafico di filtro) per liberare risorse.</span><span class="sxs-lookup"><span data-stu-id="97a44-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="97a44-187">Se l'utente chiude la finestra del video (ad esempio premendo ALT + F4), la convenzione consiste nel nascondere immediatamente la finestra e inviare una notifica di [**\_ USERABORT EC**](ec-userabort.md) a Filter Graph Manager.</span><span class="sxs-lookup"><span data-stu-id="97a44-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="97a44-188">Questa notifica viene passata all'applicazione, in modo da arrestare la riproduzione del grafo.</span><span class="sxs-lookup"><span data-stu-id="97a44-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="97a44-189">Dopo l'invio di **\_ USERABORT EC**, un renderer video deve rifiutare eventuali altri esempi recapitati.</span><span class="sxs-lookup"><span data-stu-id="97a44-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="97a44-190">Il flag arrestato dal grafico deve rimanere attivo dal renderer fino a quando non viene arrestato, quindi deve essere reimpostato in modo che un'applicazione possa eseguire l'override dell'azione dell'utente e continuare a riprodurre il grafico se lo desidera.</span><span class="sxs-lookup"><span data-stu-id="97a44-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="97a44-191">Se si preme ALT + F4 mentre è in esecuzione il video, la finestra sarà nascosta e tutti gli altri campioni recapitati verranno rifiutati.</span><span class="sxs-lookup"><span data-stu-id="97a44-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="97a44-192">Se successivamente viene visualizzata la finestra (ad esempio tramite [**IVideoWindow::p UT \_ visibile**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), non è necessario generare alcuna notifica di [**\_ Repaint EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="97a44-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="97a44-193">Il renderer video deve anche inviare la notifica della [**\_ finestra EC \_ distrutta**](ec-window-destroyed.md) al grafico del filtro quando il renderer video viene terminato.</span><span class="sxs-lookup"><span data-stu-id="97a44-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="97a44-194">In realtà, è consigliabile gestire questa situazione quando il metodo [**IBaseFilter:: JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) del renderer viene chiamato con un parametro null (che indica che il renderer sta per essere rimosso dal grafico di filtro), anziché attendere che la finestra video effettiva venga distrutta.</span><span class="sxs-lookup"><span data-stu-id="97a44-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="97a44-195">L'invio di questa notifica consente al server di distribuzione dei plug-in di filtrare Graph Manager di passare le risorse che dipendono dallo stato attivo della finestra ad altri filtri, ad esempio i dispositivi audio.</span><span class="sxs-lookup"><span data-stu-id="97a44-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="97a44-196">Gestione delle modifiche al formato dinamico</span><span class="sxs-lookup"><span data-stu-id="97a44-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="97a44-197">In alcuni casi, il filtro upstream del renderer potrebbe provare a modificare il formato video durante la riproduzione del video.</span><span class="sxs-lookup"><span data-stu-id="97a44-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="97a44-198">Spesso è il decompressore video che avvia una modifica di formato dinamico.</span><span class="sxs-lookup"><span data-stu-id="97a44-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="97a44-199">Un filtro upstream che tenta di modificare i formati in modo dinamico deve sempre chiamare il metodo [**Ipin:: QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) sul pin di input del renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="97a44-200">Un renderer video ha alcuni margini relativi ai tipi di modifiche del formato dinamico che deve supportare.</span><span class="sxs-lookup"><span data-stu-id="97a44-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="97a44-201">Come minimo, deve consentire al filtro upstream di modificare le tavolozze.</span><span class="sxs-lookup"><span data-stu-id="97a44-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="97a44-202">Quando un filtro upstream modifica i tipi di supporto, collega il tipo di supporto al primo campione fornito nel nuovo formato.</span><span class="sxs-lookup"><span data-stu-id="97a44-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="97a44-203">Se il renderer include esempi in una coda per il rendering, non dovrebbe modificare il formato fino a quando non viene eseguito il rendering dell'esempio con la modifica del tipo.</span><span class="sxs-lookup"><span data-stu-id="97a44-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="97a44-204">Un renderer video può anche richiedere una modifica di formato dal decodificatore.</span><span class="sxs-lookup"><span data-stu-id="97a44-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="97a44-205">Ad esempio, potrebbe chiedere al decodificatore di fornire un formato compatibile con DirectDraw con una **bialtezza** negativa.</span><span class="sxs-lookup"><span data-stu-id="97a44-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="97a44-206">Quando il renderer viene sospeso, deve chiamare [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) sul pin upstream per vedere quali formati possono essere forniti dal decodificatore.</span><span class="sxs-lookup"><span data-stu-id="97a44-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="97a44-207">Il decodificatore potrebbe non enumerare tutti i tipi che è in grado di accettare, quindi il renderer dovrebbe offrire alcuni tipi anche se il decodificatore non li annuncia.</span><span class="sxs-lookup"><span data-stu-id="97a44-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="97a44-208">Se il decodificatore può passare al formato richiesto, restituisce **S \_ OK** da [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span><span class="sxs-lookup"><span data-stu-id="97a44-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="97a44-209">Il renderer connette quindi il nuovo tipo di supporto all'esempio multimediale successivo nell'allocatore upstream.</span><span class="sxs-lookup"><span data-stu-id="97a44-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="97a44-210">Per funzionare, il renderer deve fornire un allocatore personalizzato che implementi un metodo privato per il fissaggio del tipo di supporto all'esempio successivo.</span><span class="sxs-lookup"><span data-stu-id="97a44-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="97a44-211">(All'interno di questo metodo privato, chiamare [**IMediaSample:: SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) per impostare il tipo).</span><span class="sxs-lookup"><span data-stu-id="97a44-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="97a44-212">Il pin di input del renderer deve restituire l'allocatore personalizzato del renderer nel metodo [**IMemInputPin:: Getallocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) .</span><span class="sxs-lookup"><span data-stu-id="97a44-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="97a44-213">Eseguire l'override di [**IMemInputPin:: NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) in modo che abbia esito negativo se il filtro upstream non usa l'allocatore del renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="97a44-214">Con alcuni decodificatori, l'impostazione di **biHeight** su un numero positivo sui tipi YUV fa sì che il decodificatore disegni l'immagine capovolto.</span><span class="sxs-lookup"><span data-stu-id="97a44-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="97a44-215">(Questo non è corretto e deve essere considerato un bug nel decodificatore).</span><span class="sxs-lookup"><span data-stu-id="97a44-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="97a44-216">Ogni volta che viene rilevata una modifica del formato dal renderer video, deve inviare una notifica di [**\_ \_ modifica della visualizzazione della EC**](ec-display-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="97a44-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="97a44-217">La maggior parte dei renderer video sceglie un formato durante la connessione in modo da poter disegnare il formato in modo efficiente tramite GDI.</span><span class="sxs-lookup"><span data-stu-id="97a44-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="97a44-218">Se l'utente modifica la modalità di visualizzazione corrente senza riavviare il computer, un renderer potrebbe trovarsi in una connessione con formato di immagine non valido e deve inviare la notifica.</span><span class="sxs-lookup"><span data-stu-id="97a44-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="97a44-219">Il primo parametro deve essere il pin che richiede la riconnessione.</span><span class="sxs-lookup"><span data-stu-id="97a44-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="97a44-220">Il gestore del grafico del filtro disporrà l'arresto del grafico del filtro e la riconnessione del PIN.</span><span class="sxs-lookup"><span data-stu-id="97a44-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="97a44-221">Durante la successiva riconnessione, il renderer può accettare un formato più appropriato.</span><span class="sxs-lookup"><span data-stu-id="97a44-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="97a44-222">Ogni volta che un renderer video rileva una modifica della tavolozza nel flusso, deve inviare la notifica di modifica della [**\_ \_ tavolozza EC**](ec-palette-changed.md) alla gestione del grafo del filtro.</span><span class="sxs-lookup"><span data-stu-id="97a44-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="97a44-223">I renderer video DirectShow rilevano se una tavolozza è effettivamente cambiata in formato dinamico o meno.</span><span class="sxs-lookup"><span data-stu-id="97a44-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="97a44-224">I renderer video eseguono questa operazione non solo per filtrare il numero di notifiche **di \_ \_ modifica della tavolozza EC** inviate ma anche per ridurre la quantità di creazione, installazione ed eliminazione della tavolozza necessaria.</span><span class="sxs-lookup"><span data-stu-id="97a44-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="97a44-225">Infine, il renderer video potrebbe rilevare anche che la dimensione del video è cambiata, nel qual caso deve inviare la notifica di [**modifica delle \_ \_ dimensioni del \_ video EC**](ec-video-size-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="97a44-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="97a44-226">Questa notifica può essere utilizzata da un'applicazione per negoziare lo spazio in un documento composto.</span><span class="sxs-lookup"><span data-stu-id="97a44-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="97a44-227">Le dimensioni effettive del video sono disponibili tramite l'interfaccia di controllo [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) .</span><span class="sxs-lookup"><span data-stu-id="97a44-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="97a44-228">I renderer DirectShow rilevano se la dimensione del video è effettivamente cambiata o meno prima dell'invio di questi eventi.</span><span class="sxs-lookup"><span data-stu-id="97a44-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="97a44-229">Gestione delle proprietà permanenti</span><span class="sxs-lookup"><span data-stu-id="97a44-229">Handling Persistent Properties</span></span>

<span data-ttu-id="97a44-230">Tutte le proprietà impostate tramite le interfacce [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) e [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) sono destinate a essere persistenti tra le connessioni.</span><span class="sxs-lookup"><span data-stu-id="97a44-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="97a44-231">Pertanto, la disconnessione e la riconnessione di un renderer non dovrebbero mostrare effetti sulle dimensioni, sulla posizione o sugli stili della finestra.</span><span class="sxs-lookup"><span data-stu-id="97a44-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="97a44-232">Tuttavia, se le dimensioni del video cambiano tra le connessioni, il renderer deve reimpostare i rettangoli di origine e di destinazione sulle impostazioni predefinite.</span><span class="sxs-lookup"><span data-stu-id="97a44-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="97a44-233">Le posizioni di origine e di destinazione vengono impostate tramite l'interfaccia **IBasicVideo** .</span><span class="sxs-lookup"><span data-stu-id="97a44-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="97a44-234">Sia [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) che [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) forniscono un accesso sufficiente alle proprietà per consentire a un'applicazione di salvare e ripristinare tutti i dati nell'interfaccia in un formato permanente.</span><span class="sxs-lookup"><span data-stu-id="97a44-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="97a44-235">Questa operazione sarà utile per le applicazioni che devono salvare la configurazione e le proprietà esatte dei grafici di filtro durante una sessione di modifica e ripristinarle in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="97a44-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="97a44-236">Gestione delle \_ notifiche di ridisegno EC</span><span class="sxs-lookup"><span data-stu-id="97a44-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="97a44-237">La notifica di [**\_ ridisegno EC**](ec-repaint.md) viene inviata solo quando il renderer viene sospeso o arrestato.</span><span class="sxs-lookup"><span data-stu-id="97a44-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="97a44-238">Questa notifica segnala al gestore di filtri Graph che il renderer necessita di dati.</span><span class="sxs-lookup"><span data-stu-id="97a44-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="97a44-239">Se il grafico del filtro viene arrestato quando riceve una di queste notifiche, sospenderà il grafico del filtro, attenderà la ricezione dei dati da parte di tutti i filtri (chiamando [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), quindi verrà arrestato nuovamente.</span><span class="sxs-lookup"><span data-stu-id="97a44-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="97a44-240">Quando viene arrestato, un renderer video deve rimanere in attesa dell'immagine in modo che i messaggi di [**\_ disegno WM**](/windows/desktop/gdi/wm-paint) successivi possano essere gestiti.</span><span class="sxs-lookup"><span data-stu-id="97a44-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="97a44-241">Pertanto, se un renderer video riceve un messaggio di [**\_ disegno WM**](/windows/desktop/gdi/wm-paint) quando viene arrestato o sospeso e non ha nulla con cui disegnare la finestra, deve inviare il [**\_ ridisegno EC**](ec-repaint.md) al gestore del grafico del filtro.</span><span class="sxs-lookup"><span data-stu-id="97a44-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="97a44-242">Se viene ricevuta una notifica di **\_ ridisegno EC** mentre è in pausa, il gestore del grafo del filtro chiama [**IMediaPosition::p UT \_ currentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) con la posizione corrente, ovvero cerca la posizione corrente.</span><span class="sxs-lookup"><span data-stu-id="97a44-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="97a44-243">In questo modo, i filtri di origine scaricano il grafico del filtro e generano nuovi dati da inviare tramite il grafico dei filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="97a44-244">Un renderer deve inviare solo una di queste notifiche alla volta.</span><span class="sxs-lookup"><span data-stu-id="97a44-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="97a44-245">Pertanto, una volta che il renderer invia una notifica, è necessario assicurarsi che non vengano più inviati fino a quando alcuni campioni non vengono recapitati.</span><span class="sxs-lookup"><span data-stu-id="97a44-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="97a44-246">Il modo convenzionale per eseguire questa operazione è avere un flag per indicare che è possibile inviare un Repaint, che è disattivato dopo l'invio di una notifica di [**\_ Repaint EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="97a44-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="97a44-247">Questo flag deve essere reimpostato quando i dati vengono recapitati o quando viene scaricato il pin di input, ma non se la fine del flusso viene segnalata sul pin di input.</span><span class="sxs-lookup"><span data-stu-id="97a44-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="97a44-248">Se il renderer non monitora le notifiche [**di \_ ridisegno EC**](ec-repaint.md) , comporterà la gestione del grafo del filtro con le richieste di **\_ ridisegno EC** (relativamente costose da elaborare).</span><span class="sxs-lookup"><span data-stu-id="97a44-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="97a44-249">Se, ad esempio, un renderer non ha un'immagine da disegnare e un'altra finestra viene trascinata nella finestra del renderer in un'operazione di trascinamento completo, il renderer riceve più messaggi di [**\_ disegno WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="97a44-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="97a44-250">Solo il primo di questi deve generare una notifica degli eventi di **\_ Repaint EC** dal renderer al gestore del grafico dei filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="97a44-251">Un renderer deve inviare il pin di input come primo parametro alla notifica [**di \_ ridisegno EC**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="97a44-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="97a44-252">In tal caso, verrà eseguita una query sul pin di output associato per [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink)e, se supportato, la notifica di **\_ ridisegno EC** verrà inviata prima.</span><span class="sxs-lookup"><span data-stu-id="97a44-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="97a44-253">Questo consente ai pin di output di gestire i ridisegnamenti prima che il grafico di filtro debba essere toccato.</span><span class="sxs-lookup"><span data-stu-id="97a44-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="97a44-254">Questa operazione non verrà eseguita se il grafo del filtro viene arrestato, perché non sono disponibili buffer dall'allocatore renderer di cui è stato eseguito il commit.</span><span class="sxs-lookup"><span data-stu-id="97a44-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="97a44-255">Se il pin di output non è in grado di gestire la richiesta e il grafico del filtro è in esecuzione, la notifica di [**\_ ridisegno EC**](ec-repaint.md) verrà ignorata.</span><span class="sxs-lookup"><span data-stu-id="97a44-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="97a44-256">Un pin di output deve restituire **S \_ OK** da [**IMediaEventSink:: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) per segnalare che la richiesta di ridisegno è stata elaborata correttamente.</span><span class="sxs-lookup"><span data-stu-id="97a44-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="97a44-257">Il pin di output verrà chiamato sul thread di lavoro Filter Graph Manager, evitando che il renderer chiami direttamente il pin di output, quindi elude eventuali problemi di deadlock.</span><span class="sxs-lookup"><span data-stu-id="97a44-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="97a44-258">Se il grafico del filtro viene arrestato o sospeso e l'output non gestisce la richiesta, viene eseguita l'elaborazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="97a44-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="97a44-259">Gestione delle notifiche in modalità Full-Screen</span><span class="sxs-lookup"><span data-stu-id="97a44-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="97a44-260">Il server di distribuzione plug-in [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) (PID) nel grafico del filtro gestisce la riproduzione a schermo intero.</span><span class="sxs-lookup"><span data-stu-id="97a44-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="97a44-261">Verrà scambiato un renderer video per un renderer a schermo intero specializzato, si estenderà una finestra di un renderer a schermo intero oppure il renderer implementerà direttamente la riproduzione a schermo intero.</span><span class="sxs-lookup"><span data-stu-id="97a44-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="97a44-262">Per interagire con i protocolli a schermo intero, un renderer video deve inviare una notifica di [**\_ attivazione EC**](ec-activate.md) ogni volta che la finestra viene attivata o disattivata.</span><span class="sxs-lookup"><span data-stu-id="97a44-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="97a44-263">In altre parole, deve essere inviata una notifica di **\_ attivazione EC** per ogni \_ messaggio WM ACTIVATEAPP ricevuto da un renderer.</span><span class="sxs-lookup"><span data-stu-id="97a44-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="97a44-264">Quando un renderer viene usato in modalità schermo intero, queste notifiche gestiscono l'invio e la disattivazione della modalità schermo intero.</span><span class="sxs-lookup"><span data-stu-id="97a44-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="97a44-265">La disattivazione della finestra si verifica in genere quando un utente preme ALT + TAB per passare a un'altra finestra, che il renderer a schermo intero DirectShow USA come spunto per tornare alla modalità di rendering tipica.</span><span class="sxs-lookup"><span data-stu-id="97a44-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="97a44-266">Quando la notifica di [**\_ attivazione della EC**](ec-activate.md) viene inviata a Filter Graph Manager quando si esce dalla modalità a schermo intero, Filter Graph Manager invia una notifica a schermo intero [**EC \_ \_ persa**](ec-fullscreen-lost.md) per l'applicazione di controllo.</span><span class="sxs-lookup"><span data-stu-id="97a44-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="97a44-267">L'applicazione può usare questa notifica per ripristinare lo stato di un pulsante a schermo intero, ad esempio.</span><span class="sxs-lookup"><span data-stu-id="97a44-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="97a44-268">Le notifiche di **\_ attivazione EC** vengono utilizzate internamente da DirectShow per gestire l'attivazione a schermo intero di suggerimenti dai renderer video.</span><span class="sxs-lookup"><span data-stu-id="97a44-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="97a44-269">Riepilogo delle notifiche</span><span class="sxs-lookup"><span data-stu-id="97a44-269">Summary of Notifications</span></span>

<span data-ttu-id="97a44-270">In questa sezione sono elencate le notifiche del grafico di filtro che un renderer può inviare.</span><span class="sxs-lookup"><span data-stu-id="97a44-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="97a44-271">Notifica degli eventi</span><span class="sxs-lookup"><span data-stu-id="97a44-271">Event notification</span></span>                                        | <span data-ttu-id="97a44-272">Descrizione</span><span class="sxs-lookup"><span data-stu-id="97a44-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="97a44-273">**\_attivazione EC**</span><span class="sxs-lookup"><span data-stu-id="97a44-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="97a44-274">Inviato dai renderer video in modalità di rendering a schermo intero per ogni \_ messaggio WM ACTIVATEAPP ricevuto.</span><span class="sxs-lookup"><span data-stu-id="97a44-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="97a44-275">**EC \_ completato**</span><span class="sxs-lookup"><span data-stu-id="97a44-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="97a44-276">Inviato dai renderer dopo che è stato eseguito il rendering di tutti i dati.</span><span class="sxs-lookup"><span data-stu-id="97a44-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="97a44-277">**visualizzazione di EC \_ \_ modificata**</span><span class="sxs-lookup"><span data-stu-id="97a44-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="97a44-278">Inviato dai renderer video quando cambia il formato di visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="97a44-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="97a44-279">**\_tavolozza EC \_ modificata**</span><span class="sxs-lookup"><span data-stu-id="97a44-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="97a44-280">Inviato ogni volta che un renderer video rileva una modifica della tavolozza nel flusso.</span><span class="sxs-lookup"><span data-stu-id="97a44-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="97a44-281">**ridisegno EC \_**</span><span class="sxs-lookup"><span data-stu-id="97a44-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="97a44-282">Inviato dai renderer video interrotti o sospesi quando \_ viene ricevuto un messaggio di disegno WM e non sono presenti dati da visualizzare.</span><span class="sxs-lookup"><span data-stu-id="97a44-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="97a44-283">In questo modo, il gestore del grafico dei filtri genera un frame da disegnare sullo schermo.</span><span class="sxs-lookup"><span data-stu-id="97a44-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="97a44-284">**\_USERABORT EC**</span><span class="sxs-lookup"><span data-stu-id="97a44-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="97a44-285">Inviato dai renderer video per segnalare una chiusura richiesta dall'utente, ad esempio un utente che chiude la finestra del video.</span><span class="sxs-lookup"><span data-stu-id="97a44-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="97a44-286">**\_dimensioni del video EC \_ \_ modificate**</span><span class="sxs-lookup"><span data-stu-id="97a44-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="97a44-287">Inviato dai renderer video ogni volta che viene rilevata una modifica nelle dimensioni del video nativo.</span><span class="sxs-lookup"><span data-stu-id="97a44-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="97a44-288">**\_finestra EC \_ distrutta**</span><span class="sxs-lookup"><span data-stu-id="97a44-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="97a44-289">Inviato dai renderer video quando il filtro viene rimosso o eliminato in modo che le risorse che dipendono dallo stato attivo della finestra possano essere passate ad altri filtri.</span><span class="sxs-lookup"><span data-stu-id="97a44-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="97a44-290">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="97a44-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="97a44-291">Scrittura di renderer video</span><span class="sxs-lookup"><span data-stu-id="97a44-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
