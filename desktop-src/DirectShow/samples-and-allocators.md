---
description: Esempi e allocatori
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: Esempi e allocatori
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/06/2021
ms.locfileid: "104555751"
---
# <a name="samples-and-allocators"></a><span data-ttu-id="1dbd8-103">Esempi e allocatori</span><span class="sxs-lookup"><span data-stu-id="1dbd8-103">Samples and Allocators</span></span>

<span data-ttu-id="1dbd8-104">Quando un pin recapita i dati multimediali a un altro pin, non passa un puntatore diretto al buffer di memoria.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-104">When a pin delivers media data to another pin, it does not pass a direct pointer to the memory buffer.</span></span> <span data-ttu-id="1dbd8-105">Fornisce invece un puntatore a un oggetto COM che gestisce la memoria.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-105">Instead, it delivers a pointer to a COM object that manages the memory.</span></span> <span data-ttu-id="1dbd8-106">Questo oggetto, denominato *esempio multimediale*, espone l'interfaccia [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="1dbd8-106">This object, called a *media sample*, exposes the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="1dbd8-107">Il pin di ricezione accede al buffer di memoria chiamando i metodi **IMediaSample** , ad esempio [**IMediaSample:: getpointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample:: GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)e [**IMediaSample:: GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span><span class="sxs-lookup"><span data-stu-id="1dbd8-107">The receiving pin accesses the memory buffer by calling **IMediaSample** methods, such as [**IMediaSample::GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize), and [**IMediaSample::GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span></span>

<span data-ttu-id="1dbd8-108">Gli esempi viaggiano sempre a valle, dal pin di output al pin di input.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-108">Samples always travel downstream, from output pin to input pin.</span></span> <span data-ttu-id="1dbd8-109">Nel modello push il pin di output recapita un esempio chiamando [**IMemInputPin:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) sul pin di input.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-109">In the push model, the output pin delivers a sample by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the input pin.</span></span> <span data-ttu-id="1dbd8-110">Il pin di input elabora i dati in modo sincrono (ovvero completamente all'interno del metodo **Receive** ) o li elabora in modo asincrono in un thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-110">The input pin will either process the data synchronously (that is, completely inside the **Receive** method), or process it asynchronously on a worker thread.</span></span> <span data-ttu-id="1dbd8-111">Il pin di input può essere bloccato all'interno del metodo **Receive** , se è necessario attendere le risorse.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-111">The input pin is allowed to block within the **Receive** method, if it needs to wait for resources.</span></span>

<span data-ttu-id="1dbd8-112">Un altro oggetto COM, denominato *allocatore*, è responsabile della creazione e della gestione degli esempi di supporti.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-112">Another COM object, called an *allocator*, is responsible for creating and managing media samples.</span></span> <span data-ttu-id="1dbd8-113">Gli allocatori espongono l'interfaccia [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="1dbd8-113">Allocators expose the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="1dbd8-114">Ogni volta che un filtro necessita di un campione multimediale con un buffer vuoto, chiama il metodo [**IMemAllocator:: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , che restituisce un puntatore all'esempio.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-114">Whenever a filter needs a media sample with an empty buffer, it calls the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, which returns a pointer to the sample.</span></span> <span data-ttu-id="1dbd8-115">Ogni connessione pin condivide un allocatore.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-115">Every pin connection shares one allocator.</span></span> <span data-ttu-id="1dbd8-116">Quando due pin si connettono, decidono quale filtro fornirà l'allocatore.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-116">When two pins connect, they decide which filter will provide the allocator.</span></span> <span data-ttu-id="1dbd8-117">I pin impostano inoltre le proprietà nell'allocatore, ad esempio il numero di buffer e le dimensioni di ogni buffer.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-117">The pins also set properties on the allocator, such as the number of buffers and the size of each buffer.</span></span> <span data-ttu-id="1dbd8-118">Per informazioni dettagliate, vedere [How filters Connect](how-filters-connect.md) and [negotiating allocator](negotiating-allocators.md).</span><span class="sxs-lookup"><span data-stu-id="1dbd8-118">(For details, see [How Filters Connect](how-filters-connect.md) and [Negotiating Allocators](negotiating-allocators.md).)</span></span>

<span data-ttu-id="1dbd8-119">Nella figura seguente sono illustrate le relazioni tra l'allocatore, gli esempi di supporti e il filtro.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-119">The following illustration shows the relationships among the allocator, the media samples, and the filter.</span></span>

![esempi di supporti e allocatori](images/mediasamples.png)

<span data-ttu-id="1dbd8-121">**Conteggio riferimenti di esempio multimediale**</span><span class="sxs-lookup"><span data-stu-id="1dbd8-121">**Media Sample Reference Counts**</span></span>

<span data-ttu-id="1dbd8-122">Un allocatore crea un pool finito di esempi.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-122">An allocator creates a finite pool of samples.</span></span> <span data-ttu-id="1dbd8-123">In qualsiasi momento, è possibile che alcuni esempi siano in uso, mentre altri sono disponibili per le chiamate a **GetBuffer** .</span><span class="sxs-lookup"><span data-stu-id="1dbd8-123">At any time, some samples may be in use, while others are available for **GetBuffer** calls.</span></span> <span data-ttu-id="1dbd8-124">L'allocatore usa il conteggio dei riferimenti per tenere traccia degli esempi.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-124">The allocator uses reference counting to keep track of the samples.</span></span> <span data-ttu-id="1dbd8-125">Il metodo **GetBuffer** restituisce un campione con un conteggio dei riferimenti pari a 1.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-125">The **GetBuffer** method returns a sample with a reference count of 1.</span></span> <span data-ttu-id="1dbd8-126">Se il conteggio dei riferimenti va a zero, l'esempio torna al pool dell'allocatore, dove può essere usato nella chiamata a **GetBuffer** successiva.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-126">If the reference count goes to zero, the sample goes back into the allocator's pool, where it can be used in the next **GetBuffer** call.</span></span> <span data-ttu-id="1dbd8-127">Fino a quando il conteggio dei riferimenti rimane superiore a zero, l'esempio non è disponibile per **GetBuffer**.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-127">As long as the reference count remains above zero, the sample is not available to **GetBuffer**.</span></span> <span data-ttu-id="1dbd8-128">Se ogni esempio appartenente all'allocatore è in uso, il metodo **GetBuffer** si blocca fino a quando non viene reso disponibile un campione.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-128">If every sample belonging to the allocator is in use, the **GetBuffer** method blocks until a sample becomes available.</span></span>

<span data-ttu-id="1dbd8-129">Si supponga, ad esempio, che un pin di input riceva un campione.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-129">For example, suppose that an input pin receives a sample.</span></span> <span data-ttu-id="1dbd8-130">Se l'esempio viene elaborato in modo sincrono, all'interno del metodo **Receive** , il conteggio dei riferimenti non viene incrementato.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-130">If it processes the sample synchronously, inside the **Receive** method, it does not increment the reference count.</span></span> <span data-ttu-id="1dbd8-131">Dopo la restituzione di **Receive** , il pin di output rilascia l'esempio, il conteggio dei riferimenti va a zero e l'esempio ritorna al pool dell'allocatore.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-131">After **Receive** returns, the output pin releases the sample, the reference count goes to zero, and the sample returns to the allocator's pool.</span></span> <span data-ttu-id="1dbd8-132">D'altra parte, se il pin di input elabora l'esempio in un thread di lavoro, incrementa il conteggio dei riferimenti prima di lasciare il metodo **Receive** .</span><span class="sxs-lookup"><span data-stu-id="1dbd8-132">On the other hand, if the input pin processes the sample on a worker thread, it increments the reference count before leaving the **Receive** method.</span></span> <span data-ttu-id="1dbd8-133">Il conteggio dei riferimenti è ora 2.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-133">The reference count is now 2.</span></span> <span data-ttu-id="1dbd8-134">Quando il pin di output rilascia l'esempio, il conteggio va a 1. Nell'esempio non viene ancora restituito al pool.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-134">When the output pin releases the sample, the count goes to 1; the sample does not yet return to the pool.</span></span> <span data-ttu-id="1dbd8-135">Al termine dell'esempio, il thread di lavoro chiama **Release** per liberare l'esempio.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-135">After the worker thread is done with the sample, it calls **Release** to free the sample.</span></span> <span data-ttu-id="1dbd8-136">A questo punto, l'esempio ritorna al pool.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-136">Now the sample returns to the pool.</span></span>

<span data-ttu-id="1dbd8-137">Quando un pin riceve un campione, può copiare i dati in un altro esempio oppure può modificare l'esempio originale e recapitarlo al filtro successivo.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-137">When a pin receives a sample, it can copy the data to another sample, or it can modify the original sample and deliver that one to the next filter.</span></span> <span data-ttu-id="1dbd8-138">Potenzialmente, un campione può attraversare l'intera lunghezza del grafo, ogni filtro che chiama **AddRef** e **Release** a sua volta.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-138">Potentially, a sample can travel the entire length of the graph, each filter calling **AddRef** and **Release** in turn.</span></span> <span data-ttu-id="1dbd8-139">Il pin di output, quindi, non deve mai riutilizzare un campione dopo la chiamata di **Receive**, perché un filtro downstream può utilizzare l'esempio.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-139">Therefore, the output pin must never re-use a sample after it calls **Receive**, because a downstream filter may be using the sample.</span></span> <span data-ttu-id="1dbd8-140">Il pin di output deve sempre chiamare **GetBuffer** per ottenere un nuovo campione.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-140">The output pin must always call **GetBuffer** to get a new sample.</span></span>

<span data-ttu-id="1dbd8-141">Questo meccanismo riduce la quantità di allocazione di memoria, perché i filtri riutilizzano gli stessi buffer.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-141">This mechanism reduces the amount of memory allocation, because filters re-use the same buffers.</span></span> <span data-ttu-id="1dbd8-142">Impedisce inoltre ai filtri di scrivere accidentalmente sui dati che non sono stati elaborati, poiché l'allocatore gestisce un elenco di esempi disponibili.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-142">It also prevents filters from accidentally writing over data that has not been processed, because the allocator maintains a list of available samples.</span></span>

<span data-ttu-id="1dbd8-143">Un filtro può utilizzare allocatori distinti per l'input e l'output.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-143">A filter can use separate allocators for input and output.</span></span> <span data-ttu-id="1dbd8-144">Questa operazione può essere eseguita se espande i dati di input (ad esempio, decomprimendo).</span><span class="sxs-lookup"><span data-stu-id="1dbd8-144">It might do this if it expands the input data (for example, by decompressing it).</span></span> <span data-ttu-id="1dbd8-145">Se l'output non è maggiore dell'input, un filtro potrebbe elaborare i dati sul posto, senza copiarli in un nuovo esempio.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-145">If the output is no larger than the input, a filter might process the data in place, without copying it to a new sample.</span></span> <span data-ttu-id="1dbd8-146">In tal caso, due o più connessioni pin possono condividere un allocatore.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-146">In that case, two or more pin connections can share one allocator.</span></span>

<span data-ttu-id="1dbd8-147">**Commit e decommit di allocatori**</span><span class="sxs-lookup"><span data-stu-id="1dbd8-147">**Committing and Decommitting Allocators**</span></span>

<span data-ttu-id="1dbd8-148">Quando un filtro crea prima un allocatore, l'allocatore non ha riservato alcun buffer di memoria.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-148">When a filter first creates an allocator, the allocator has not reserved any memory buffers.</span></span> <span data-ttu-id="1dbd8-149">A questo punto, tutte le chiamate al metodo **GetBuffer** avranno esito negativo.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-149">At this point, any calls to the **GetBuffer** method will fail.</span></span> <span data-ttu-id="1dbd8-150">Quando viene avviato il flusso, il pin di output chiama [**IMemAllocator:: commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), che esegue il commit dell'allocatore, causando l'allocazione della memoria.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-150">When streaming starts, the output pin calls [**IMemAllocator::Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), which commits the allocator, causing it to allocate memory.</span></span> <span data-ttu-id="1dbd8-151">I pin ora possono chiamare **GetBuffer**.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-151">Pins can now call **GetBuffer**.</span></span>

<span data-ttu-id="1dbd8-152">Quando il flusso viene interrotto, il pin chiama [**IMemAllocator::D ecommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), che esegue il commit dell'allocatore.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-152">When streaming stops, the pin calls [**IMemAllocator::Decommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), which decommits the allocator.</span></span> <span data-ttu-id="1dbd8-153">Tutte le chiamate successive a **GetBuffer** hanno esito negativo fino a quando non viene eseguito il commit dell'allocatore</span><span class="sxs-lookup"><span data-stu-id="1dbd8-153">All subsequent calls to **GetBuffer** fail until the allocator is committed again.</span></span> <span data-ttu-id="1dbd8-154">Se, inoltre, le chiamate a **GetBuffer** sono attualmente bloccate in attesa di un campione, restituiscono immediatamente un codice di errore.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-154">Also, if any calls to **GetBuffer** are currently blocked waiting for a sample, they immediately return a failure code.</span></span> <span data-ttu-id="1dbd8-155">Il metodo di **decommit** può o non liberare la memoria, a seconda dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-155">The **Decommit** method may or may not free the memory, depending on the implementation.</span></span> <span data-ttu-id="1dbd8-156">La classe [**CMemAllocator**](cmemallocator.md) , ad esempio, attende fino a quando il metodo del distruttore non libera la memoria.</span><span class="sxs-lookup"><span data-stu-id="1dbd8-156">For example, the [**CMemAllocator**](cmemallocator.md) class waits until its destructor method to free memory.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1dbd8-157">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="1dbd8-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="1dbd8-158">Flusso di dati nel grafico del filtro</span><span class="sxs-lookup"><span data-stu-id="1dbd8-158">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
