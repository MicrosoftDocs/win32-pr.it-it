---
description: Un consumer fisico è un oggetto COM che implementa l'interfaccia IWbemUnboundObjectSink.
ms.assetid: 497457dc-61ca-4527-89fd-2af0383de5e9
ms.tgt_platform: multiple
title: Implementazione di un consumer fisico
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: af0a9530ed7a98ce19b3b39f2f5a1fe52f3b0631
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106315222"
---
# <a name="implementing-a-physical-consumer"></a><span data-ttu-id="22a2a-103">Implementazione di un consumer fisico</span><span class="sxs-lookup"><span data-stu-id="22a2a-103">Implementing a Physical Consumer</span></span>

<span data-ttu-id="22a2a-104">Un consumer fisico è un oggetto COM che implementa l'interfaccia [**IWbemUnboundObjectSink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) .</span><span class="sxs-lookup"><span data-stu-id="22a2a-104">A physical consumer is a COM object that implements the [**IWbemUnboundObjectSink**](/windows/desktop/api/Wbemprov/nn-wbemprov-iwbemunboundobjectsink) interface.</span></span> <span data-ttu-id="22a2a-105">WMI carica il consumer fisico e passa gli eventi tramite **IWbemUnboundObjectSink** in risposta a uno o più eventi, in base a quanto definito dal consumer logico associato.</span><span class="sxs-lookup"><span data-stu-id="22a2a-105">WMI loads your physical consumer and passes events through **IWbemUnboundObjectSink** in response to one or more events, as defined by the associated logical consumer.</span></span> <span data-ttu-id="22a2a-106">I consumer permanenti hanno requisiti di sicurezza speciali.</span><span class="sxs-lookup"><span data-stu-id="22a2a-106">Permanent consumers have special security requirements.</span></span> <span data-ttu-id="22a2a-107">Per ulteriori informazioni, vedere [protezione degli eventi WMI](securing-wmi-events.md).</span><span class="sxs-lookup"><span data-stu-id="22a2a-107">For more information, see [Securing WMI Events](securing-wmi-events.md).</span></span>

<span data-ttu-id="22a2a-108">Nella procedura seguente viene descritto come implementare un consumer fisico per un consumer di eventi permanenti.</span><span class="sxs-lookup"><span data-stu-id="22a2a-108">The following procedure describes how to implement a physical consumer for a permanent event consumer.</span></span>

<span data-ttu-id="22a2a-109">**Per implementare un consumer fisico per un consumer di eventi permanenti**</span><span class="sxs-lookup"><span data-stu-id="22a2a-109">**To implement a physical consumer for a permanent event consumer**</span></span>

1.  <span data-ttu-id="22a2a-110">Creare un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="22a2a-110">Create a COM object.</span></span>

    <span data-ttu-id="22a2a-111">È necessario implementare un consumer fisico come server locale o remoto utilizzando il protocollo COM.</span><span class="sxs-lookup"><span data-stu-id="22a2a-111">You must implement a physical consumer as a local or remote server using the COM protocol.</span></span>

2.  <span data-ttu-id="22a2a-112">Determinare se si desidera supportare la notifica di eventi sincroni o asincroni.</span><span class="sxs-lookup"><span data-stu-id="22a2a-112">Determine if you want to support synchronous or asynchronous event notification.</span></span>

    <span data-ttu-id="22a2a-113">Con la notifica asincrona degli eventi, il thread di invio non è correlato al thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="22a2a-113">With asynchronous event notification, the sending thread is unrelated to the receiving thread.</span></span> <span data-ttu-id="22a2a-114">Pertanto, né WMI né il provider di eventi vengono bloccati mentre WMI invia una notifica a qualsiasi utente registrato per ricevere l'evento.</span><span class="sxs-lookup"><span data-stu-id="22a2a-114">Therefore, neither WMI nor the event provider gets blocked while WMI delivers a notification to any consumer registered to receive the event.</span></span> <span data-ttu-id="22a2a-115">Lo svantaggio del recapito asincrono è che si verifica un cambio di contesto tra il momento in cui il provider produce l'evento e il momento in cui il consumer riceve l'evento.</span><span class="sxs-lookup"><span data-stu-id="22a2a-115">The disadvantage to asynchronous delivery is that a context switch occurs between the time the provider produces the event and the time the consumer receives the event.</span></span> <span data-ttu-id="22a2a-116">Per ulteriori informazioni sull'utilizzo asincrono, vedere l'argomento [nozioni fondamentali su com](../com/guide.md) nella sezione com di Microsoft Windows Software Development Kit (SDK).</span><span class="sxs-lookup"><span data-stu-id="22a2a-116">For more information about working asynchronously, see the [COM Fundamentals](../com/guide.md) topic in the COM section of the Microsoft Windows Software Development Kit (SDK).</span></span> <span data-ttu-id="22a2a-117">Per ulteriori informazioni sulle opzioni di contesto, vedere l'argomento [cambi di contesto](../procthread/context-switches.md) nella sezione dll, processi e thread della Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="22a2a-117">For more information about context switches, see the [Context Switches](../procthread/context-switches.md) topic in the DLLs, Processes, and Threads section of the Windows SDK.</span></span>

    > [!Note]  
    > <span data-ttu-id="22a2a-118">Poiché il callback al sink potrebbe non essere restituito allo stesso livello di autenticazione richiesto dal client, è consigliabile utilizzare semisincrono anziché la comunicazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="22a2a-118">Because the callback to the sink might not be returned at the same authentication level as the client requires, it is recommended that you use semisynchronous instead of asynchronous communication.</span></span> <span data-ttu-id="22a2a-119">Per ulteriori informazioni, vedere [chiamata a un metodo](calling-a-method.md).</span><span class="sxs-lookup"><span data-stu-id="22a2a-119">For more information, see [Calling a Method](calling-a-method.md).</span></span>

     

    <span data-ttu-id="22a2a-120">Con la notifica sincrona, WMI recapita la notifica sullo stesso thread utilizzato dal provider di eventi per recapitare l'evento a WMI.</span><span class="sxs-lookup"><span data-stu-id="22a2a-120">With synchronous notification, WMI delivers the notification on the same thread that the event provider used to deliver the event to WMI.</span></span> <span data-ttu-id="22a2a-121">In questo caso, quando un provider di eventi invia una notifica, il provider di eventi viene bloccato da WMI finché WMI non recapita la notifica.</span><span class="sxs-lookup"><span data-stu-id="22a2a-121">In this case, when an event provider sends a notification, the event provider is blocked by WMI until WMI delivers the notification.</span></span> <span data-ttu-id="22a2a-122">Solo se il consumer è estremamente veloce ed è in grado di elaborare un evento in microsecondi 100 o meno, è consigliabile supportare la notifica sincrona.</span><span class="sxs-lookup"><span data-stu-id="22a2a-122">Only if your consumer is extremely fast and can process an event in 100 microseconds or less should you consider supporting synchronous notification.</span></span> <span data-ttu-id="22a2a-123">I consumer sincroni che importano troppo tempo per elaborare gli eventi possono rallentare seriamente il recapito degli eventi a tutti gli altri utenti.</span><span class="sxs-lookup"><span data-stu-id="22a2a-123">Synchronous consumers that take too long to process events can seriously slow the delivery of events to all other consumers.</span></span> <span data-ttu-id="22a2a-124">Inoltre, possono bloccare inavvertitamente il provider.</span><span class="sxs-lookup"><span data-stu-id="22a2a-124">Furthermore, they can inadvertently block the provider.</span></span> <span data-ttu-id="22a2a-125">Per ulteriori informazioni, vedere [associazione di un filtro eventi a un consumer logico](binding-an-event-filter-with-a-logical-consumer.md).</span><span class="sxs-lookup"><span data-stu-id="22a2a-125">For more information, see [Binding an Event Filter with a Logical Consumer](binding-an-event-filter-with-a-logical-consumer.md).</span></span>

3.  <span data-ttu-id="22a2a-126">Implementare la funzione [**IWbemUnboundObjectSink:: IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) .</span><span class="sxs-lookup"><span data-stu-id="22a2a-126">Implement the [**IWbemUnboundObjectSink::IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function.</span></span>

    <span data-ttu-id="22a2a-127">WMI utilizza la funzione [**IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) per passare i puntatori e gli eventi necessari al consumer fisico per le comunicazioni sincrone e asincrone.</span><span class="sxs-lookup"><span data-stu-id="22a2a-127">WMI uses the [**IndicateToConsumer**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemunboundobjectsink-indicatetoconsumer) function to pass the necessary pointers and events to your physical consumer for both synchronous and asynchronous communications.</span></span> <span data-ttu-id="22a2a-128">L'implementazione di **IndicateToConsumer** deve contenere tutto il codice necessario per rispondere a un evento.</span><span class="sxs-lookup"><span data-stu-id="22a2a-128">Your implementation of **IndicateToConsumer** should contain all of the necessary code to respond to an event.</span></span>

    <span data-ttu-id="22a2a-129">Diversamente da un consumer di eventi temporaneo, non è necessario chiamare l'interfaccia [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) per contattare WMI.</span><span class="sxs-lookup"><span data-stu-id="22a2a-129">Unlike a temporary event consumer, you do not need to call the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface to contact WMI.</span></span> <span data-ttu-id="22a2a-130">Al contrario, WMI individua un puntatore al consumer tramite il provider di consumer di eventi.</span><span class="sxs-lookup"><span data-stu-id="22a2a-130">Instead, WMI locates a pointer to your consumer through the event consumer provider.</span></span> <span data-ttu-id="22a2a-131">Per ulteriori informazioni, vedere [scrittura di un provider di consumer di eventi](writing-an-event-consumer-provider.md).</span><span class="sxs-lookup"><span data-stu-id="22a2a-131">For more information, see [Writing an Event Consumer Provider](writing-an-event-consumer-provider.md).</span></span>

    <span data-ttu-id="22a2a-132">Tuttavia, se si desidera richiamarlo in WMI, utilizzare le interfacce [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) e [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) .</span><span class="sxs-lookup"><span data-stu-id="22a2a-132">However, if you wish to call back into WMI, use the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) and [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) interfaces.</span></span> <span data-ttu-id="22a2a-133">Il metodo tradizionale per la connessione a WMI è durante il processo di inizializzazione dell'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="22a2a-133">The traditional method for connecting to WMI is during the initialization process of your COM object.</span></span> <span data-ttu-id="22a2a-134">Per ulteriori informazioni, vedere [creazione di un'applicazione o di uno script WMI](creating-a-wmi-application-or-script.md).</span><span class="sxs-lookup"><span data-stu-id="22a2a-134">For more information, see [Creating a WMI Application or Script](creating-a-wmi-application-or-script.md).</span></span>

    <span data-ttu-id="22a2a-135">Se il consumer fisico viene implementato come server COM in-process e si esegue la connessione a WMI separatamente dal processo di inizializzazione, è necessario utilizzare l'identificatore di classe **CLSID \_ WbemAdministrativeLocator** per accedere all'interfaccia [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) nella chiamata a [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="22a2a-135">If you implement your physical consumer as an in-process COM server and connect to WMI separately from the initialization process, you must use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface in the call to [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

    <span data-ttu-id="22a2a-136">Nell'esempio seguente viene illustrato come utilizzare l'identificatore di classe **CLSID \_ WbemAdministrativeLocator** per accedere all'interfaccia [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) .</span><span class="sxs-lookup"><span data-stu-id="22a2a-136">The following example shows how to use the **CLSID\_WbemAdministrativeLocator** class identifier to access the [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface.</span></span>

    ```C++
    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, 0, 
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
    ```

    

    <span data-ttu-id="22a2a-137">L'interfaccia [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) ottiene il puntatore iniziale dello spazio dei nomi a WMI in un determinato computer host.</span><span class="sxs-lookup"><span data-stu-id="22a2a-137">The [**IWbemLocator**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemlocator) interface obtains the initial namespace pointer to WMI on a particular host computer.</span></span> <span data-ttu-id="22a2a-138">Se non si utilizza l'identificatore **CLSID \_ WbemAdministrativeLocator** nella chiamata [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) , viene restituito un errore di accesso negato.</span><span class="sxs-lookup"><span data-stu-id="22a2a-138">Failure to use the **CLSID\_WbemAdministrativeLocator** identifier in the [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) call results in an "access denied" error.</span></span>

    <span data-ttu-id="22a2a-139">In circostanze normali, WMI recapita gli eventi asincroni al client uno alla volta.</span><span class="sxs-lookup"><span data-stu-id="22a2a-139">Under usual circumstances, WMI delivers asynchronous events to the client one at a time.</span></span> <span data-ttu-id="22a2a-140">Tuttavia, se un client non è in grado di ricevere notifiche di eventi asincrone con la stessa velocità con cui arrivano gli eventi, WMI inizia a eseguire automaticamente il batch degli eventi in una singola chiamata.</span><span class="sxs-lookup"><span data-stu-id="22a2a-140">However, if a client cannot receive asynchronous event notifications as fast as the events arrive, WMI starts to automatically batch events into a single call.</span></span> <span data-ttu-id="22a2a-141">L'invio in batch automatico aiuta se i tempi di round trip rappresentano un problema, come spesso accade negli scenari con velocità effettiva elevata.</span><span class="sxs-lookup"><span data-stu-id="22a2a-141">Automatic batching helps if the round-trip times are a problem, as is often the case in high-throughput scenarios.</span></span> <span data-ttu-id="22a2a-142">Tuttavia, l'invio in batch non migliora le prestazioni del sistema se il client o la larghezza di banda di rete sono in errore.</span><span class="sxs-lookup"><span data-stu-id="22a2a-142">However, batching does not improve system performance if the client or the network bandwidth are at fault.</span></span>

 

 
