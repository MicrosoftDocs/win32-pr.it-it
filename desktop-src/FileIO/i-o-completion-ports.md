---
description: Le porte di completamento i/O forniscono un modello di threading efficiente per l'elaborazione di più richieste di I/O asincrone in un sistema multiprocessore.
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: Porte di completamento I/O
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 882363ef99821a0b0b40810f45d609c5b5f7760c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106317783"
---
# <a name="io-completion-ports"></a><span data-ttu-id="f4a68-103">Porte di completamento I/O</span><span class="sxs-lookup"><span data-stu-id="f4a68-103">I/O Completion Ports</span></span>

<span data-ttu-id="f4a68-104">Le porte di completamento i/O forniscono un modello di threading efficiente per l'elaborazione di più richieste di I/O asincrone in un sistema multiprocessore.</span><span class="sxs-lookup"><span data-stu-id="f4a68-104">I/O completion ports provide an efficient threading model for processing multiple asynchronous I/O requests on a multiprocessor system.</span></span> <span data-ttu-id="f4a68-105">Quando un processo crea una porta di completamento di I/O, il sistema crea un oggetto Queue associato per le richieste il cui unico scopo è quello di soddisfare tali richieste.</span><span class="sxs-lookup"><span data-stu-id="f4a68-105">When a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to service these requests.</span></span> <span data-ttu-id="f4a68-106">I processi che gestiscono molte richieste di I/O asincrone simultanee possono eseguire questa operazione in modo più rapido ed efficiente usando le porte di completamento I/O insieme a un pool di thread preallocato rispetto alla creazione di thread al momento della ricezione di una richiesta di I/O.</span><span class="sxs-lookup"><span data-stu-id="f4a68-106">Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by using I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O request.</span></span>

## <a name="how-io-completion-ports-work"></a><span data-ttu-id="f4a68-107">Funzionamento delle porte di completamento I/O</span><span class="sxs-lookup"><span data-stu-id="f4a68-107">How I/O Completion Ports Work</span></span>

<span data-ttu-id="f4a68-108">La funzione [**CreateIoCompletionPort**](createiocompletionport.md) crea una porta di completamento di I/o e associa uno o più handle di file a tale porta.</span><span class="sxs-lookup"><span data-stu-id="f4a68-108">The [**CreateIoCompletionPort**](createiocompletionport.md) function creates an I/O completion port and associates one or more file handles with that port.</span></span> <span data-ttu-id="f4a68-109">Quando viene completata un'operazione di I/O asincrona su uno di questi handle di file, un pacchetto di completamento I/O viene accodato in ordine FIFO (First-in-First-out) alla porta di completamento I/O associata.</span><span class="sxs-lookup"><span data-stu-id="f4a68-109">When an asynchronous I/O operation on one of these file handles completes, an I/O completion packet is queued in first-in-first-out (FIFO) order to the associated I/O completion port.</span></span> <span data-ttu-id="f4a68-110">Un utilizzo efficace di questo meccanismo consiste nel combinare il punto di sincronizzazione per più handle di file in un singolo oggetto, sebbene ci siano anche altre applicazioni utili.</span><span class="sxs-lookup"><span data-stu-id="f4a68-110">One powerful use for this mechanism is to combine the synchronization point for multiple file handles into a single object, although there are also other useful applications.</span></span> <span data-ttu-id="f4a68-111">Si noti che mentre i pacchetti sono accodati in ordine FIFO, è possibile che vengano rimossi dalla coda in un ordine diverso.</span><span class="sxs-lookup"><span data-stu-id="f4a68-111">Please note that while the packets are queued in FIFO order they may be dequeued in a different order.</span></span>

> [!Note]
>
> <span data-ttu-id="f4a68-112">Il termine *handle di file* usato qui si riferisce a un'astrazione di sistema che rappresenta un endpoint I/O sovrapposto, non solo a un file su disco.</span><span class="sxs-lookup"><span data-stu-id="f4a68-112">The term *file handle* as used here refers to a system abstraction representing an overlapped I/O endpoint, not only a file on disk.</span></span> <span data-ttu-id="f4a68-113">Può ad esempio essere un endpoint di rete, un socket TCP, un named pipe o uno slot di posta elettronica.</span><span class="sxs-lookup"><span data-stu-id="f4a68-113">For example, it can be a network endpoint, TCP socket, named pipe, or mail slot.</span></span> <span data-ttu-id="f4a68-114">È possibile utilizzare qualsiasi oggetto di sistema che supporta I/O sovrapposti.</span><span class="sxs-lookup"><span data-stu-id="f4a68-114">Any system object that supports overlapped I/O can be used.</span></span> <span data-ttu-id="f4a68-115">Per un elenco delle funzioni di I/O correlate, vedere la fine di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f4a68-115">For a list of related I/O functions, see the end of this topic.</span></span>

 

<span data-ttu-id="f4a68-116">Quando un handle di file è associato a una porta di completamento, il blocco di stato passato in non verrà aggiornato finché il pacchetto non verrà rimosso dalla porta di completamento.</span><span class="sxs-lookup"><span data-stu-id="f4a68-116">When a file handle is associated with a completion port, the status block passed in will not be updated until the packet is removed from the completion port.</span></span> <span data-ttu-id="f4a68-117">L'unica eccezione è rappresentata dal caso in cui l'operazione originale restituisce in modo sincrono un errore.</span><span class="sxs-lookup"><span data-stu-id="f4a68-117">The only exception is if the original operation returns synchronously with an error.</span></span> <span data-ttu-id="f4a68-118">Un thread (uno creato dal thread principale o il thread principale stesso) usa la funzione [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) per attendere che un pacchetto di completamento venga accodato alla porta di completamento i/o, anziché attendere il completamento dell'i/o asincrono.</span><span class="sxs-lookup"><span data-stu-id="f4a68-118">A thread (either one created by the main thread or the main thread itself) uses the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to wait for a completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete.</span></span> <span data-ttu-id="f4a68-119">I thread che bloccano l'esecuzione su una porta di completamento di I/O vengono rilasciati nell'ordine LIFO (Last-in-First-out) e il pacchetto di completamento successivo viene estratto dalla coda FIFO della porta di completamento I/O per quel thread.</span><span class="sxs-lookup"><span data-stu-id="f4a68-119">Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order, and the next completion packet is pulled from the I/O completion port's FIFO queue for that thread.</span></span> <span data-ttu-id="f4a68-120">Ciò significa che, quando un pacchetto di completamento viene rilasciato a un thread, il sistema rilascia l'ultimo thread (più recente) associato a tale porta, passando le informazioni di completamento per il completamento I/O meno recente.</span><span class="sxs-lookup"><span data-stu-id="f4a68-120">This means that, when a completion packet is released to a thread, the system releases the last (most recent) thread associated with that port, passing it the completion information for the oldest I/O completion.</span></span>

<span data-ttu-id="f4a68-121">Sebbene un numero qualsiasi di thread possa chiamare [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) per una porta di completamento di i/o specificata, quando un thread specificato chiama **GetQueuedCompletionStatus** la prima volta, diventa associato alla porta di completamento di i/o specificata fino a quando non si verifica una delle tre situazioni seguenti: il thread viene chiuso, specifica una porta di completamento di i/o diversa o chiude la porta di completamento i/o.</span><span class="sxs-lookup"><span data-stu-id="f4a68-121">Although any number of threads can call [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) for a specified I/O completion port, when a specified thread calls **GetQueuedCompletionStatus** the first time, it becomes associated with the specified I/O completion port until one of three things occurs: The thread exits, specifies a different I/O completion port, or closes the I/O completion port.</span></span> <span data-ttu-id="f4a68-122">In altre parole, un singolo thread può essere associato, al massimo, una porta di completamento di I/O.</span><span class="sxs-lookup"><span data-stu-id="f4a68-122">In other words, a single thread can be associated with, at most, one I/O completion port.</span></span>

<span data-ttu-id="f4a68-123">Quando un pacchetto di completamento viene accodato a una porta di completamento di I/O, il sistema controlla prima di tutto il numero di thread associati alla porta in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="f4a68-123">When a completion packet is queued to an I/O completion port, the system first checks how many threads associated with that port are running.</span></span> <span data-ttu-id="f4a68-124">Se il numero di thread in esecuzione è inferiore al valore di concorrenza (descritto nella sezione successiva), uno dei thread in attesa (quello più recente) può elaborare il pacchetto di completamento.</span><span class="sxs-lookup"><span data-stu-id="f4a68-124">If the number of threads running is less than the concurrency value (discussed in the next section), one of the waiting threads (the most recent one) is allowed to process the completion packet.</span></span> <span data-ttu-id="f4a68-125">Quando un thread in esecuzione ne completa l'elaborazione, in genere chiama di nuovo [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , a quel punto restituisce con il pacchetto di completamento successivo o resta in attesa se la coda è vuota.</span><span class="sxs-lookup"><span data-stu-id="f4a68-125">When a running thread completes its processing, it typically calls [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) again, at which point it either returns with the next completion packet or waits if the queue is empty.</span></span>

<span data-ttu-id="f4a68-126">I thread possono utilizzare la funzione [**PostQueuedCompletionStatus ha provocato**](postqueuedcompletionstatus.md) per inserire i pacchetti di completamento in una coda della porta di completamento I/O.</span><span class="sxs-lookup"><span data-stu-id="f4a68-126">Threads can use the [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) function to place completion packets in an I/O completion port's queue.</span></span> <span data-ttu-id="f4a68-127">In questo modo, è possibile usare la porta di completamento per ricevere le comunicazioni da altri thread del processo, oltre a ricevere pacchetti di completamento I/O dal sistema I/O.</span><span class="sxs-lookup"><span data-stu-id="f4a68-127">By doing so, the completion port can be used to receive communications from other threads of the process, in addition to receiving I/O completion packets from the I/O system.</span></span> <span data-ttu-id="f4a68-128">La funzione **PostQueuedCompletionStatus ha provocato** consente a un'applicazione di accodare i propri pacchetti di completamento per scopi specifici alla porta di completamento i/o senza avviare un'operazione di i/o asincrona.</span><span class="sxs-lookup"><span data-stu-id="f4a68-128">The **PostQueuedCompletionStatus** function allows an application to queue its own special-purpose completion packets to the I/O completion port without starting an asynchronous I/O operation.</span></span> <span data-ttu-id="f4a68-129">Questa operazione è utile per inviare notifiche ai thread di lavoro degli eventi esterni, ad esempio.</span><span class="sxs-lookup"><span data-stu-id="f4a68-129">This is useful for notifying worker threads of external events, for example.</span></span>

<span data-ttu-id="f4a68-130">Il punto di controllo della porta di completamento I/O e ogni handle di file associato alla porta di completamento I/O specifica sono noti come *riferimenti alla porta di completamento i/o*.</span><span class="sxs-lookup"><span data-stu-id="f4a68-130">The I/O completion port handle and every file handle associated with that particular I/O completion port are known as *references to the I/O completion port*.</span></span> <span data-ttu-id="f4a68-131">La porta di completamento I/O viene rilasciata quando non vi sono altri riferimenti.</span><span class="sxs-lookup"><span data-stu-id="f4a68-131">The I/O completion port is released when there are no more references to it.</span></span> <span data-ttu-id="f4a68-132">È pertanto necessario chiudere correttamente tutti questi handle per rilasciare la porta di completamento I/O e le risorse di sistema associate.</span><span class="sxs-lookup"><span data-stu-id="f4a68-132">Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources.</span></span> <span data-ttu-id="f4a68-133">Una volta soddisfatte queste condizioni, un'applicazione deve chiudere l'handle della porta di completamento I/O chiamando la funzione [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .</span><span class="sxs-lookup"><span data-stu-id="f4a68-133">After these conditions are satisfied, an application should close the I/O completion port handle by calling the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>

> [!Note]
>
> <span data-ttu-id="f4a68-134">Una porta di completamento I/O è associata al processo che lo ha creato e non è condivisibile tra i processi.</span><span class="sxs-lookup"><span data-stu-id="f4a68-134">An I/O completion port is associated with the process that created it and is not sharable between processes.</span></span> <span data-ttu-id="f4a68-135">Tuttavia, un singolo handle è condivisibile tra i thread nello stesso processo.</span><span class="sxs-lookup"><span data-stu-id="f4a68-135">However, a single handle is sharable between threads in the same process.</span></span>

 

## <a name="threads-and-concurrency"></a><span data-ttu-id="f4a68-136">Thread e concorrenza</span><span class="sxs-lookup"><span data-stu-id="f4a68-136">Threads and Concurrency</span></span>

<span data-ttu-id="f4a68-137">La proprietà più importante di una porta di completamento I/O da considerare con attenzione è il valore di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="f4a68-137">The most important property of an I/O completion port to consider carefully is the concurrency value.</span></span> <span data-ttu-id="f4a68-138">Il valore di concorrenza di una porta di completamento viene specificato quando viene creato con [**CreateIoCompletionPort**](createiocompletionport.md) tramite il parametro *NumberOfConcurrentThreads* .</span><span class="sxs-lookup"><span data-stu-id="f4a68-138">The concurrency value of a completion port is specified when it is created with [**CreateIoCompletionPort**](createiocompletionport.md) via the *NumberOfConcurrentThreads* parameter.</span></span> <span data-ttu-id="f4a68-139">Questo valore limita il numero di thread eseguibili associati alla porta di completamento.</span><span class="sxs-lookup"><span data-stu-id="f4a68-139">This value limits the number of runnable threads associated with the completion port.</span></span> <span data-ttu-id="f4a68-140">Quando il numero totale di thread eseguibili associati alla porta di completamento raggiunge il valore di concorrenza, il sistema blocca l'esecuzione di tutti i thread successivi associati alla porta di completamento finché il numero di thread eseguibili scende sotto il valore di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="f4a68-140">When the total number of runnable threads associated with the completion port reaches the concurrency value, the system blocks the execution of any subsequent threads associated with that completion port until the number of runnable threads drops below the concurrency value.</span></span>

<span data-ttu-id="f4a68-141">Lo scenario più efficiente si verifica quando i pacchetti di completamento sono in attesa nella coda, ma non è possibile soddisfare le attese perché la porta ha raggiunto il limite di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="f4a68-141">The most efficient scenario occurs when there are completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit.</span></span> <span data-ttu-id="f4a68-142">Si consideri cosa accade con un valore di concorrenza di uno e più thread in attesa nella chiamata di funzione [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) .</span><span class="sxs-lookup"><span data-stu-id="f4a68-142">Consider what happens with a concurrency value of one and multiple threads waiting in the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function call.</span></span> <span data-ttu-id="f4a68-143">In questo caso, se la coda include sempre pacchetti di completamento in attesa, quando il thread in esecuzione chiama **GetQueuedCompletionStatus**, l'esecuzione non verrà bloccata perché, come indicato in precedenza, la coda di thread è LIFO.</span><span class="sxs-lookup"><span data-stu-id="f4a68-143">In this case, if the queue always has completion packets waiting, when the running thread calls **GetQueuedCompletionStatus**, it will not block execution because, as mentioned earlier, the thread queue is LIFO.</span></span> <span data-ttu-id="f4a68-144">Al contrario, il thread rileverà immediatamente il successivo pacchetto di completamento in coda.</span><span class="sxs-lookup"><span data-stu-id="f4a68-144">Instead, this thread will immediately pick up the next queued completion packet.</span></span> <span data-ttu-id="f4a68-145">Non si verificheranno commutazioni di contesto dei thread perché il thread in esecuzione continua a raccogliere i pacchetti di completamento e gli altri thread non possono essere eseguiti.</span><span class="sxs-lookup"><span data-stu-id="f4a68-145">No thread context switches will occur, because the running thread is continually picking up completion packets and the other threads are unable to run.</span></span>

> [!Note]
>
> <span data-ttu-id="f4a68-146">Nell'esempio precedente, i thread aggiuntivi sembrano inutili e non vengono mai eseguiti, ma ciò presuppone che il thread in esecuzione non venga mai inserito in uno stato di attesa da un altro meccanismo, termina o chiude la porta di completamento di I/O associata.</span><span class="sxs-lookup"><span data-stu-id="f4a68-146">In the previous example, the extra threads appear to be useless and never run, but that assumes that the running thread never gets put in a wait state by some other mechanism, terminates, or otherwise closes its associated I/O completion port.</span></span> <span data-ttu-id="f4a68-147">Prendere in considerazione tutte le ramificazioni di esecuzione dei thread durante la progettazione dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f4a68-147">Consider all such thread execution ramifications when designing the application.</span></span>

 

<span data-ttu-id="f4a68-148">Il valore massimo complessivo migliore da selezionare per il valore di concorrenza è il numero di CPU nel computer.</span><span class="sxs-lookup"><span data-stu-id="f4a68-148">The best overall maximum value to pick for the concurrency value is the number of CPUs on the computer.</span></span> <span data-ttu-id="f4a68-149">Se la transazione richiede un calcolo lungo, un valore di concorrenza maggiore consentirà l'esecuzione di più thread.</span><span class="sxs-lookup"><span data-stu-id="f4a68-149">If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run.</span></span> <span data-ttu-id="f4a68-150">Ogni pacchetto di completamento potrebbe richiedere più tempo, ma più pacchetti di completamento verranno elaborati contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="f4a68-150">Each completion packet may take longer to finish, but more completion packets will be processed at the same time.</span></span> <span data-ttu-id="f4a68-151">È possibile provare a usare il valore di concorrenza insieme agli strumenti di profilatura per ottenere l'effetto migliore per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f4a68-151">You can experiment with the concurrency value in conjunction with profiling tools to achieve the best effect for your application.</span></span>

<span data-ttu-id="f4a68-152">Il sistema consente inoltre a un thread in attesa di [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) di elaborare un pacchetto di completamento se un altro thread in esecuzione associato alla stessa porta di completamento di I/O entra in uno stato di attesa per altri motivi, ad esempio la funzione [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) .</span><span class="sxs-lookup"><span data-stu-id="f4a68-152">The system also allows a thread waiting in [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) to process a completion packet if another running thread associated with the same I/O completion port enters a wait state for other reasons, for example the [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) function.</span></span> <span data-ttu-id="f4a68-153">Quando inizia a eseguire di nuovo il thread nello stato di attesa, potrebbe verificarsi un breve periodo di tempo in cui il numero di thread attivi supera il valore di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="f4a68-153">When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the concurrency value.</span></span> <span data-ttu-id="f4a68-154">Tuttavia, il sistema riduce rapidamente questo numero non consentendo alcun nuovo thread attivo fino a quando il numero di thread attivi non scende al di sotto del valore di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="f4a68-154">However, the system quickly reduces this number by not allowing any new active threads until the number of active threads falls below the concurrency value.</span></span> <span data-ttu-id="f4a68-155">Questo è uno dei motivi per cui l'applicazione crea più thread nel pool di thread rispetto al valore di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="f4a68-155">This is one reason to have your application create more threads in its thread pool than the concurrency value.</span></span> <span data-ttu-id="f4a68-156">La gestione dei pool di thread esula dall'ambito di questo argomento, ma una regola empirica consiste nel disporre di un minimo di due volte il numero di thread nel pool di thread, perché sono presenti processori nel sistema.</span><span class="sxs-lookup"><span data-stu-id="f4a68-156">Thread pool management is beyond the scope of this topic, but a good rule of thumb is to have a minimum of twice as many threads in the thread pool as there are processors on the system.</span></span> <span data-ttu-id="f4a68-157">Per ulteriori informazioni sul pool di thread, vedere [pool di thread](/windows/desktop/ProcThread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="f4a68-157">For additional information about thread pooling, see [Thread Pools](/windows/desktop/ProcThread/thread-pools).</span></span>

## <a name="supported-io-functions"></a><span data-ttu-id="f4a68-158">Funzioni di I/O supportate</span><span class="sxs-lookup"><span data-stu-id="f4a68-158">Supported I/O Functions</span></span>

<span data-ttu-id="f4a68-159">Le funzioni seguenti possono essere utilizzate per avviare le operazioni di I/O che vengono completate utilizzando le porte di completamento I/O.</span><span class="sxs-lookup"><span data-stu-id="f4a68-159">The following functions can be used to start I/O operations that complete by using I/O completion ports.</span></span> <span data-ttu-id="f4a68-160">È necessario passare alla funzione un'istanza della struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) e un handle di file precedentemente associato a una porta di completamento i/o (tramite una chiamata a [**CreateIoCompletionPort**](createiocompletionport.md)) per abilitare il meccanismo della porta di completamento i/o:</span><span class="sxs-lookup"><span data-stu-id="f4a68-160">You must pass the function an instance of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure and a file handle previously associated with an I/O completion port (by a call to [**CreateIoCompletionPort**](createiocompletionport.md)) to enable the I/O completion port mechanism:</span></span>

-   [<span data-ttu-id="f4a68-161">**ConnectNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="f4a68-161">**ConnectNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [<span data-ttu-id="f4a68-162">**DeviceIoControl**</span><span class="sxs-lookup"><span data-stu-id="f4a68-162">**DeviceIoControl**</span></span>](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [<span data-ttu-id="f4a68-163">**LockFileEx**</span><span class="sxs-lookup"><span data-stu-id="f4a68-163">**LockFileEx**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [<span data-ttu-id="f4a68-164">**ReadDirectoryChangesW**</span><span class="sxs-lookup"><span data-stu-id="f4a68-164">**ReadDirectoryChangesW**</span></span>](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [<span data-ttu-id="f4a68-165">**ReadFile**</span><span class="sxs-lookup"><span data-stu-id="f4a68-165">**ReadFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [<span data-ttu-id="f4a68-166">**TransactNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="f4a68-166">**TransactNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [<span data-ttu-id="f4a68-167">**WaitCommEvent**</span><span class="sxs-lookup"><span data-stu-id="f4a68-167">**WaitCommEvent**</span></span>](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [<span data-ttu-id="f4a68-168">**WriteFile**</span><span class="sxs-lookup"><span data-stu-id="f4a68-168">**WriteFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [<span data-ttu-id="f4a68-169">**WSASendMsg**</span><span class="sxs-lookup"><span data-stu-id="f4a68-169">**WSASendMsg**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [<span data-ttu-id="f4a68-170">**WSASendTo**</span><span class="sxs-lookup"><span data-stu-id="f4a68-170">**WSASendTo**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [<span data-ttu-id="f4a68-171">**WSASend**</span><span class="sxs-lookup"><span data-stu-id="f4a68-171">**WSASend**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [<span data-ttu-id="f4a68-172">**WSARecvFrom**</span><span class="sxs-lookup"><span data-stu-id="f4a68-172">**WSARecvFrom**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [<span data-ttu-id="f4a68-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span><span class="sxs-lookup"><span data-stu-id="f4a68-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span></span>](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [<span data-ttu-id="f4a68-174">**WSARecv**</span><span class="sxs-lookup"><span data-stu-id="f4a68-174">**WSARecv**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a><span data-ttu-id="f4a68-175">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="f4a68-175">Related topics</span></span>

<dl> <span data-ttu-id="f4a68-176"><dt>


</dt> <dt></span><span class="sxs-lookup"><span data-stu-id="f4a68-176"><dt>


</dt> <dt></span></span>

[<span data-ttu-id="f4a68-177">Informazioni su processi e thread</span><span class="sxs-lookup"><span data-stu-id="f4a68-177">About Processes and Threads</span></span>](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[<span data-ttu-id="f4a68-178">**BindIoCompletionCallback ha provocato**</span><span class="sxs-lookup"><span data-stu-id="f4a68-178">**BindIoCompletionCallback**</span></span>](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[<span data-ttu-id="f4a68-179">**CreateIoCompletionPort**</span><span class="sxs-lookup"><span data-stu-id="f4a68-179">**CreateIoCompletionPort**</span></span>](createiocompletionport.md)
</dt> <dt>

[<span data-ttu-id="f4a68-180">**GetQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="f4a68-180">**GetQueuedCompletionStatus**</span></span>](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[<span data-ttu-id="f4a68-181">**GetQueuedCompletionStatusEx**</span><span class="sxs-lookup"><span data-stu-id="f4a68-181">**GetQueuedCompletionStatusEx**</span></span>](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[<span data-ttu-id="f4a68-182">**PostQueuedCompletionStatus ha provocato**</span><span class="sxs-lookup"><span data-stu-id="f4a68-182">**PostQueuedCompletionStatus**</span></span>](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
