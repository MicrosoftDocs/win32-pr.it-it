---
description: Un'operazione di clonazione a blocchi indica al file system di copiare un intervallo di byte di file per conto di un'applicazione.
ms.assetid: E18E8D79-3985-40B8-A4C5-A73A21E5C527
title: Clonazione del blocco
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b33aa1c1eee693b6ed4b502aedc6da6176ece3e9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "104530007"
---
# <a name="block-cloning"></a><span data-ttu-id="c198f-103">Clonazione del blocco</span><span class="sxs-lookup"><span data-stu-id="c198f-103">Block Cloning</span></span>

<span data-ttu-id="c198f-104">Un'operazione di *clonazione a blocchi* indica al file System di copiare un intervallo di byte di file per conto di un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="c198f-104">A *block clone* operation instructs the file system to copy a range of file bytes on behalf of an application.</span></span> <span data-ttu-id="c198f-105">Il file di destinazione può essere uguale o diverso da quello del file di origine.</span><span class="sxs-lookup"><span data-stu-id="c198f-105">The destination file may be the same as, or different from, the source file.</span></span>

<span data-ttu-id="c198f-106">Un file system gestisce i mapping di [cluster ed extent](clusters-and-extents.md)e può essere in grado di eseguire la copia modificando il numero di cluster virtuale (VCN) in mapping del numero di cluster logico (LCN) come operazione di metadati a basso costo, anziché leggere e scrivere i dati di file sottostanti.</span><span class="sxs-lookup"><span data-stu-id="c198f-106">A file system manages the mappings of [Clusters and Extents](clusters-and-extents.md), and may be able to perform the copy by altering the virtual cluster number (VCN) to logical cluster number (LCN) mappings as a low-cost metadata operation, rather than reading and writing the underlying file data.</span></span> <span data-ttu-id="c198f-107">In questo modo la copia viene completata più velocemente e genera un minor numero di I/O nell'archivio sottostante.</span><span class="sxs-lookup"><span data-stu-id="c198f-107">This allows the copy to complete faster and generates less I/O to the underlying storage.</span></span> <span data-ttu-id="c198f-108">Inoltre, più file possono ora condividere i cluster logici dopo il clone del blocco, salvando la capacità senza archiviare cluster identici più volte su disco.</span><span class="sxs-lookup"><span data-stu-id="c198f-108">Moreover, multiple files may now share logical clusters after the block clone, saving capacity by not storing identical clusters multiple times on disk.</span></span>

<span data-ttu-id="c198f-109">Un'operazione di clonazione A blocchi non interrompe l'isolamento fornito tra i file.</span><span class="sxs-lookup"><span data-stu-id="c198f-109">A block clone operation does not break the isolation provided between files.</span></span> <span data-ttu-id="c198f-110">Al termine di un clone del blocco, le scritture nel file di origine non vengono visualizzate nella destinazione o viceversa.</span><span class="sxs-lookup"><span data-stu-id="c198f-110">After a block clone completes, writes to the source file do not appear in the destination, or vice versa.</span></span>

<span data-ttu-id="c198f-111">La clonazione a blocchi è disponibile solo nel tipo di [file System refs](/windows/desktop/w8cookbook/resilient-file-system--refs-) a partire da Windows Server 2016.</span><span class="sxs-lookup"><span data-stu-id="c198f-111">Block cloning is available only on the [ReFS file system](/windows/desktop/w8cookbook/resilient-file-system--refs-) type beginning with Windows Server 2016.</span></span>

## <a name="block-cloning-on-refs"></a><span data-ttu-id="c198f-112">Blocca la clonazione su ReFS</span><span class="sxs-lookup"><span data-stu-id="c198f-112">Block Cloning on ReFS</span></span>

<span data-ttu-id="c198f-113">ReFS in Windows Server 2016 implementa la clonazione del blocco mediante la modifica del mapping dei cluster logici (ovvero percorsi fisici su un volume) dall'area di origine all'area di destinazione.</span><span class="sxs-lookup"><span data-stu-id="c198f-113">ReFS on Windows Server 2016 implements block cloning by remapping logical clusters (that is, physical locations on a volume) from the source region to the destination region.</span></span> <span data-ttu-id="c198f-114">USA quindi un meccanismo di allocazione in scrittura per garantire l'isolamento tra tali aree.</span><span class="sxs-lookup"><span data-stu-id="c198f-114">It then uses an allocate-on-write mechanism to ensure isolation between those regions.</span></span> <span data-ttu-id="c198f-115">Le aree di origine e di destinazione possono trovarsi nello stesso file o in file diversi.</span><span class="sxs-lookup"><span data-stu-id="c198f-115">The source and destination regions may be in the same, or different, files.</span></span>

<span data-ttu-id="c198f-116">Questa implementazione richiede che gli offset del file iniziale e finale siano allineati ai limiti del cluster.</span><span class="sxs-lookup"><span data-stu-id="c198f-116">This implementation requires that the starting and ending file offsets be aligned to cluster boundaries.</span></span> <span data-ttu-id="c198f-117">In ReFS in Windows Server 2016, le dimensioni dei cluster sono 4KB per impostazione predefinita, ma è possibile impostare facoltativamente 64KB.</span><span class="sxs-lookup"><span data-stu-id="c198f-117">In ReFS on Windows Server 2016, clusters are 4KB in size by default, but can optionally be set to 64KB.</span></span> <span data-ttu-id="c198f-118">Le dimensioni del cluster sono un set di parametri a livello di volume in fase di formattazione.</span><span class="sxs-lookup"><span data-stu-id="c198f-118">The cluster size is a volume-wide parameter set at format time.</span></span>

## <a name="restrictions-and-remarks"></a><span data-ttu-id="c198f-119">Restrizioni e osservazioni</span><span class="sxs-lookup"><span data-stu-id="c198f-119">Restrictions and Remarks</span></span>

-   <span data-ttu-id="c198f-120">Le aree di origine e di destinazione devono iniziare e terminare in corrispondenza di un limite del cluster.</span><span class="sxs-lookup"><span data-stu-id="c198f-120">The source and destination regions must begin and end at a cluster boundary.</span></span>
-   <span data-ttu-id="c198f-121">L'area clonata deve avere una lunghezza minore di 4 GB.</span><span class="sxs-lookup"><span data-stu-id="c198f-121">The cloned region must be less than 4GB in length.</span></span>
-   <span data-ttu-id="c198f-122">L'area di destinazione non deve estendersi oltre la fine del file.</span><span class="sxs-lookup"><span data-stu-id="c198f-122">The destination region must not extend past the end of file.</span></span> <span data-ttu-id="c198f-123">Se l'applicazione desidera estendere la destinazione con dati clonati, deve prima chiamare [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span><span class="sxs-lookup"><span data-stu-id="c198f-123">If the application wishes to extend the destination with cloned data, it must first call [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span></span>
-   <span data-ttu-id="c198f-124">Se le aree di origine e di destinazione si trovano nello stesso file, non si devono sovrapporre.</span><span class="sxs-lookup"><span data-stu-id="c198f-124">If the source and destination regions are in the same file, they must not overlap.</span></span> <span data-ttu-id="c198f-125">(L'applicazione può procedere suddividendo l'operazione di clonazione del blocco in più cloni di blocco che non si sovrappongono più.)</span><span class="sxs-lookup"><span data-stu-id="c198f-125">(The application may able to proceed by splitting up the block clone operation into multiple block clones that no longer overlap.)</span></span>
-   <span data-ttu-id="c198f-126">I file di origine e di destinazione devono essere nello stesso volume ReFS.</span><span class="sxs-lookup"><span data-stu-id="c198f-126">The source and destination files must be on the same ReFS volume.</span></span>
-   <span data-ttu-id="c198f-127">I file di origine e di destinazione devono avere la stessa impostazione dei [**flussi di integrità**](file-attribute-constants.md) , ovvero i flussi di integrità devono essere abilitati in entrambi i file o disabilitati in entrambi i file.</span><span class="sxs-lookup"><span data-stu-id="c198f-127">The source and destination files must have the same [**Integrity Streams**](file-attribute-constants.md) setting (that is, Integrity Streams must be enabled in both files, or disabled in both files).</span></span>
-   <span data-ttu-id="c198f-128">Se il file di origine è un file sparse, anche il file di destinazione deve essere sparse.</span><span class="sxs-lookup"><span data-stu-id="c198f-128">If the source file is sparse, the destination file must also be sparse.</span></span>
-   <span data-ttu-id="c198f-129">L'operazione di clonazione del blocco interrompe i blocchi opportunistici condivisi (noti anche come [blocchi opportunistici di livello 2](types-of-opportunistic-locks.md)).</span><span class="sxs-lookup"><span data-stu-id="c198f-129">The block clone operation will break Shared Opportunistic Locks (also known as [Level 2 Opportunistic Locks](types-of-opportunistic-locks.md)).</span></span>
-   <span data-ttu-id="c198f-130">Il volume ReFS deve essere stato formattato con Windows Server 2016 e se è in uso il clustering di failover di Windows, il livello di funzionalità del clustering deve essere Windows Server 2016 o versione successiva al momento del formato.</span><span class="sxs-lookup"><span data-stu-id="c198f-130">The ReFS volume must have been formatted with Windows Server 2016, and if Windows Failover Clustering is in use, the Clustering Functional Level must have been Windows Server 2016 or later at format time.</span></span>

## <a name="example"></a><span data-ttu-id="c198f-131">Esempio</span><span class="sxs-lookup"><span data-stu-id="c198f-131">Example</span></span>

<span data-ttu-id="c198f-132">Si supponga di avere due file, X e Y, in cui ogni file è composto da tre aree distinte.</span><span class="sxs-lookup"><span data-stu-id="c198f-132">Suppose we have two files, X and Y, where each file is composed of 3 distinct regions.</span></span> <span data-ttu-id="c198f-133">Ogni area del file è archiviata in un'area distinta del volume.</span><span class="sxs-lookup"><span data-stu-id="c198f-133">Each file region is stored on a distinct region of the volume.</span></span> <span data-ttu-id="c198f-134">Il file system archivia le informazioni a cui viene fatto riferimento a ognuna di queste aree del volume in un'area del file:</span><span class="sxs-lookup"><span data-stu-id="c198f-134">The file system stores the knowledge that each of those volume regions is referenced in one file region:</span></span>

![prima del clone](images/before-clone.png)

<span data-ttu-id="c198f-136">Si supponga ora che un'applicazione verifichi un'operazione di clonazione a blocchi dal file X, sulle aree dei file A e B, al file Y in corrispondenza dell'offset in cui E attualmente è.</span><span class="sxs-lookup"><span data-stu-id="c198f-136">Now suppose an application issues a block clone operation from File X, over file regions A and B, to File Y at the offset where E currently is.</span></span> <span data-ttu-id="c198f-137">Viene generato lo stato di file system seguente:</span><span class="sxs-lookup"><span data-stu-id="c198f-137">The following file system state would result:</span></span>

![dopo clone](images/after-clone.png)

<span data-ttu-id="c198f-139">I dati nelle aree A e B sono stati duplicati in modo efficace dal file X al file Y modificando i mapping di VCN in LCN all'interno del volume ReFS.</span><span class="sxs-lookup"><span data-stu-id="c198f-139">The data in regions A and B were effectively duplicated from File X to File Y by altering the VCN to LCN mappings within the ReFS volume.</span></span> <span data-ttu-id="c198f-140">Gli extent del disco che fanno parte delle aree A e B non sono stati letti, né gli extent del disco che eseguono il backup delle aree precedenti e e F sovrascritti durante l'operazione.</span><span class="sxs-lookup"><span data-stu-id="c198f-140">The disk extents backing regions A and B were not read, nor were the disk extents backing the old regions E and F overwritten during the operation.</span></span>

<span data-ttu-id="c198f-141">I file X e Y ora condividono i cluster logici su disco.</span><span class="sxs-lookup"><span data-stu-id="c198f-141">Files X and Y now share logical clusters on disk.</span></span> <span data-ttu-id="c198f-142">Questa operazione viene riflessa nei conteggi dei riferimenti indicati nella tabella.</span><span class="sxs-lookup"><span data-stu-id="c198f-142">This is reflected in the reference counts shown in the table.</span></span> <span data-ttu-id="c198f-143">La condivisione comporta un consumo più basso della capacità del volume rispetto alle aree A e B duplicate nel volume sottostante.</span><span class="sxs-lookup"><span data-stu-id="c198f-143">The sharing results in lower volume capacity consumption than if regions A and B were duplicated on the underlying volume.</span></span>

<span data-ttu-id="c198f-144">A questo punto, si supponga che l'applicazione sovrascriva l'area A nel file X. ReFS crea una copia duplicata di un, che ora chiameremo G. ReFS, quindi esegue il mapping di G nel file X e applica la modifica.</span><span class="sxs-lookup"><span data-stu-id="c198f-144">Now, suppose the application overwrites region A in File X. ReFS makes a duplicate copy of A, which we’ll now call G. ReFS then maps G into File X, and applies the modification.</span></span> <span data-ttu-id="c198f-145">In questo modo viene mantenuto l'isolamento dei file.</span><span class="sxs-lookup"><span data-stu-id="c198f-145">This ensures that isolation between the files is preserved.</span></span> <span data-ttu-id="c198f-146">I conteggi dei riferimenti vengono aggiornati in modo appropriato:</span><span class="sxs-lookup"><span data-stu-id="c198f-146">Reference counts are updated appropriately:</span></span>

![Dopo la modifica della scrittura](images/after-modifying-write.png)

<span data-ttu-id="c198f-148">Dopo la modifica della scrittura, l'area B è ancora condivisa sul disco.</span><span class="sxs-lookup"><span data-stu-id="c198f-148">After the modifying write, region B is still shared on disk.</span></span> <span data-ttu-id="c198f-149">Notare che se l'area A fosse stata più grande di un cluster, sarebbe stato duplicato solo il cluster modificato e la parte rimanente sarebbe rimasta condivisa.</span><span class="sxs-lookup"><span data-stu-id="c198f-149">Note that if region A were larger than a cluster, only the modified cluster would have been duplicated, and the remaining portion would have remained shared.</span></span>

## <a name="related-topics"></a><span data-ttu-id="c198f-150">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="c198f-150">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="c198f-151">**\_dati extent duplicati \_**</span><span class="sxs-lookup"><span data-stu-id="c198f-151">**DUPLICATE\_EXTENTS\_DATA**</span></span>](/windows/desktop/api/WinIoCtl/ns-winioctl-duplicate_extents_data)
</dt> <dt>

[<span data-ttu-id="c198f-152">**FSCTL \_ gli \_ extent duplicati \_ nel \_ file**</span><span class="sxs-lookup"><span data-stu-id="c198f-152">**FSCTL\_DUPLICATE\_EXTENTS\_TO\_FILE**</span></span>](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)
</dt> </dl>

 

 
