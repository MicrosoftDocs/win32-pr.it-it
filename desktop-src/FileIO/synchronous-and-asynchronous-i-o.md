---
description: "Esistono due tipi di sincronizzazione di input/output (I/O): I/o sincrono e I/O asincrono. L'I/O asincrono è noto anche come I/O sovrapposto."
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: I/O sincrono e asincrono
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/20/2021
ms.locfileid: "106323901"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="09881-104">I/O sincrono e asincrono</span><span class="sxs-lookup"><span data-stu-id="09881-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="09881-105">Vedere anche [applicazioni di esempio correlate all'I/O](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span><span class="sxs-lookup"><span data-stu-id="09881-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="09881-106">Esistono due tipi di sincronizzazione di input/output (I/O): I/o sincrono e I/O asincrono.</span><span class="sxs-lookup"><span data-stu-id="09881-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="09881-107">L'I/O asincrono è noto anche come I/O sovrapposto.</span><span class="sxs-lookup"><span data-stu-id="09881-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="09881-108">Nell' *I/o di file sincrono*, un thread avvia un'operazione di i/o e immette immediatamente uno stato di attesa fino al completamento della richiesta di i/o.</span><span class="sxs-lookup"><span data-stu-id="09881-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="09881-109">Un thread che esegue l' *i/o di file asincrono* invia una richiesta di i/o al kernel chiamando una funzione appropriata.</span><span class="sxs-lookup"><span data-stu-id="09881-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="09881-110">Se la richiesta viene accettata dal kernel, il thread chiamante continua a elaborare un altro processo finché il kernel non segnala al thread che l'operazione di I/O è stata completata.</span><span class="sxs-lookup"><span data-stu-id="09881-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="09881-111">Interrompe quindi il processo corrente ed elabora i dati dall'operazione di I/O, se necessario.</span><span class="sxs-lookup"><span data-stu-id="09881-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="09881-112">Nella figura seguente sono illustrati i due tipi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="09881-112">The two synchronization types are illustrated in the following figure.</span></span>

![i/o sincrono e asincrono](images/fig2bedit.png)

<span data-ttu-id="09881-114">Nelle situazioni in cui una richiesta di I/O richiede una quantità di tempo elevata, ad esempio un aggiornamento o un backup di un database di grandi dimensioni o di un collegamento di comunicazione lenta, l'I/O asincrono è in genere un metodo efficace per ottimizzare l'efficienza di elaborazione.</span><span class="sxs-lookup"><span data-stu-id="09881-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="09881-115">Tuttavia, per le operazioni di I/O relativamente veloci, l'overhead dell'elaborazione delle richieste di I/o del kernel e dei segnali del kernel può rendere meno vantaggioso l'I/O asincrono, in particolare se è necessario eseguire molte operazioni di I/O rapide.</span><span class="sxs-lookup"><span data-stu-id="09881-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="09881-116">In questo caso, l'I/O sincrono sarebbe migliore.</span><span class="sxs-lookup"><span data-stu-id="09881-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="09881-117">I meccanismi e i dettagli di implementazione di come eseguire queste attività variano a seconda del tipo di handle di dispositivo usato e delle esigenze specifiche dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="09881-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="09881-118">In altre parole, esistono in genere diversi modi per risolvere il problema.</span><span class="sxs-lookup"><span data-stu-id="09881-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="09881-119">Considerazioni sui/O sincrone e asincrone</span><span class="sxs-lookup"><span data-stu-id="09881-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="09881-120">Se un file o un dispositivo viene aperto per l'I/O sincrono (ovvero, il **\_ flag file \_ sovrapposto** non è specificato), le chiamate successive a funzioni come [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) possono bloccare l'esecuzione del thread chiamante fino a quando non si verifica uno degli eventi seguenti:</span><span class="sxs-lookup"><span data-stu-id="09881-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="09881-121">L'operazione di I/O è stata completata, in questo esempio una scrittura di dati.</span><span class="sxs-lookup"><span data-stu-id="09881-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="09881-122">Si è verificato un errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="09881-122">An I/O error occurs.</span></span> <span data-ttu-id="09881-123">Ad esempio, la pipe viene chiusa dall'altra estremità.</span><span class="sxs-lookup"><span data-stu-id="09881-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="09881-124">Si è verificato un errore nella chiamata stessa (ad esempio, uno o più parametri non sono validi).</span><span class="sxs-lookup"><span data-stu-id="09881-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="09881-125">Un altro thread del processo chiama la funzione [**CancelSynchronousIo**](cancelsynchronousio-func.md) usando l'handle di thread del thread bloccato, che termina l'i/o per quel thread, in caso di errore dell'operazione di i/o.</span><span class="sxs-lookup"><span data-stu-id="09881-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="09881-126">Il thread bloccato viene terminato dal sistema. ad esempio, il processo stesso viene terminato o un altro thread chiama la funzione [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) usando l'handle del thread bloccato.</span><span class="sxs-lookup"><span data-stu-id="09881-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="09881-127">Si tratta in genere di un'ultima soluzione e non di una corretta progettazione delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="09881-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="09881-128">In alcuni casi, questo ritardo può essere inaccettabile per la progettazione e lo scopo dell'applicazione, quindi i progettisti di applicazioni devono prendere in considerazione l'utilizzo di I/O asincrono con gli oggetti di sincronizzazione dei thread appropriati, ad esempio le [porte di completamento i/o](i-o-completion-ports.md).</span><span class="sxs-lookup"><span data-stu-id="09881-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="09881-129">Per ulteriori informazioni sulla sincronizzazione dei thread, vedere [informazioni sulla sincronizzazione](/windows/desktop/Sync/about-synchronization).</span><span class="sxs-lookup"><span data-stu-id="09881-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="09881-130">Un processo apre un file per l'I/O asincrono nella chiamata a [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) specificando il **flag \_ file \_ sovrapposto** nel parametro *dwFlagsAndAttributes* .</span><span class="sxs-lookup"><span data-stu-id="09881-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="09881-131">Se **il \_ flag di file \_ sovrapposto** non è specificato, il file viene aperto per l'i/O sincrono.</span><span class="sxs-lookup"><span data-stu-id="09881-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="09881-132">Quando il file è stato aperto per l'I/O asincrono, un puntatore a una struttura [**sovrapposta**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) viene passato nella chiamata a [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) e [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="09881-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="09881-133">Quando si eseguono operazioni di I/O sincrone, questa struttura non è obbligatoria nelle chiamate a **ReadFile** e **WriteFile**.</span><span class="sxs-lookup"><span data-stu-id="09881-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="09881-134">Se un file o un dispositivo viene aperto per l'I/O asincrono, le chiamate successive a funzioni come [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) che usano tale handle in genere restituiscono immediatamente, ma possono anche comportarsi in modo sincrono rispetto all'esecuzione bloccata.</span><span class="sxs-lookup"><span data-stu-id="09881-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="09881-135">Per altre informazioni, vedere [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span><span class="sxs-lookup"><span data-stu-id="09881-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="09881-136">Sebbene [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) sia la funzione più comune da usare per l'apertura di file, volumi di dischi, pipe anonime e altri dispositivi simili, le operazioni di I/O possono essere eseguite anche usando un handle *typecast* da altri oggetti di sistema, ad esempio un socket creato dal [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) o da funzioni [**Accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) .</span><span class="sxs-lookup"><span data-stu-id="09881-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="09881-137">Gli handle per gli oggetti directory vengono ottenuti chiamando la funzione [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) con l'attributo della **\_ \_ \_ semantica di backup del flag di file** .</span><span class="sxs-lookup"><span data-stu-id="09881-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="09881-138">Gli handle di directory non vengono mai usati. le applicazioni di backup sono una delle poche applicazioni che li utilizzeranno in genere.</span><span class="sxs-lookup"><span data-stu-id="09881-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="09881-139">Dopo l'apertura dell'oggetto file per l'I/O asincrono, è necessario creare, inizializzare e passare correttamente una struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) a ogni chiamata a funzioni quali [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) e [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="09881-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="09881-140">Quando si utilizza la struttura [**sovrapposta**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) nelle operazioni di lettura e scrittura asincrone, tenere presente quanto segue:</span><span class="sxs-lookup"><span data-stu-id="09881-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="09881-141">Non deallocare o modificare la struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) o il buffer di dati finché non sono state completate tutte le operazioni di i/O asincrone nell'oggetto file.</span><span class="sxs-lookup"><span data-stu-id="09881-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="09881-142">Se si dichiara il puntatore alla struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) come variabile locale, non chiudere la funzione locale finché non sono state completate tutte le operazioni di i/O asincrone nell'oggetto file.</span><span class="sxs-lookup"><span data-stu-id="09881-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="09881-143">Se la funzione locale viene chiusa in modo anomalo, la struttura **sovrapposta** uscirà dall'ambito e non sarà accessibile a tutte le funzioni [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) o [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) rilevate al di fuori di tale funzione.</span><span class="sxs-lookup"><span data-stu-id="09881-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="09881-144">È anche possibile creare un evento e inserire l'handle nella struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ; le [funzioni Wait](/windows/desktop/Sync/wait-functions) possono quindi essere usate per attendere il completamento dell'operazione di i/O in attesa dell'handle dell'evento.</span><span class="sxs-lookup"><span data-stu-id="09881-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="09881-145">Come indicato in precedenza, quando si lavora con un handle asincrono, le applicazioni devono prestare attenzione quando si determinano quando liberare le risorse associate a un'operazione di I/O specificata su tale handle.</span><span class="sxs-lookup"><span data-stu-id="09881-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="09881-146">Se l'handle viene deallocato in modo anomalo, è possibile che [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) o [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) segnali erroneamente che l'operazione di i/O è stata completata.</span><span class="sxs-lookup"><span data-stu-id="09881-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="09881-147">Inoltre, la funzione **WriteFile** a volte restituisce **true** con un [**valore GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) con **\_ esito positivo errore**, anche se utilizza un handle asincrono (che può restituire anche **false** con **errore \_ io \_ in sospeso**).</span><span class="sxs-lookup"><span data-stu-id="09881-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="09881-148">I programmatori abituati alla progettazione di I/O sincrona in genere rilasceranno le risorse del buffer di dati in questo momento perché **true** e **Error \_ Success** indicano che l'operazione è stata completata.</span><span class="sxs-lookup"><span data-stu-id="09881-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="09881-149">Tuttavia, se si utilizzano le [porte di completamento i/o](i-o-completion-ports.md) con questo handle asincrono, verrà inviato anche un pacchetto di completamento anche se l'operazione di i/o è stata completata immediatamente.</span><span class="sxs-lookup"><span data-stu-id="09881-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="09881-150">In altre parole, se l'applicazione libera risorse dopo che **WriteFile** restituisce **true** con **l' \_ esito positivo dell'errore** , oltre che nella routine della porta di completamento i/O, avrà una condizione di errore double-free.</span><span class="sxs-lookup"><span data-stu-id="09881-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="09881-151">In questo esempio, si consiglia di consentire alla routine della porta di completamento di essere interamente responsabile di tutte le operazioni di liberazione per tali risorse.</span><span class="sxs-lookup"><span data-stu-id="09881-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="09881-152">Il sistema non mantiene il puntatore del file sugli handle asincroni per i file e i dispositivi che supportano i puntatori a file (ovvero la ricerca di dispositivi), pertanto la posizione del file deve essere passata alle funzioni di lettura e scrittura nei membri dati offset correlati della struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="09881-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="09881-153">Per ulteriori informazioni, vedere [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) e [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span><span class="sxs-lookup"><span data-stu-id="09881-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="09881-154">La posizione del puntatore del file per un handle sincrono viene gestita dal sistema quando i dati vengono letti o scritti e possono essere aggiornati anche tramite la funzione [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) o [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) .</span><span class="sxs-lookup"><span data-stu-id="09881-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="09881-155">Un'applicazione può inoltre attendere l'handle di file per sincronizzare il completamento di un'operazione di I/O, ma è necessario prestare estrema cautela.</span><span class="sxs-lookup"><span data-stu-id="09881-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="09881-156">Ogni volta che viene avviata un'operazione di I/O, il sistema operativo imposta l'handle di file sullo stato non segnalato.</span><span class="sxs-lookup"><span data-stu-id="09881-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="09881-157">Ogni volta che viene completata un'operazione di I/O, il sistema operativo imposta l'handle di file sullo stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="09881-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="09881-158">Pertanto, se un'applicazione avvia due operazioni di I/O e attende l'handle di file, non è possibile determinare quale operazione è terminata quando l'handle è impostato sullo stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="09881-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="09881-159">Se un'applicazione deve eseguire più operazioni di I/O asincrone su un singolo file, deve attendere l'handle di evento nella struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) specifica per ogni operazione di i/o, anziché nell'handle di file comune.</span><span class="sxs-lookup"><span data-stu-id="09881-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="09881-160">Per annullare tutte le operazioni di I/O asincrone in sospeso, usare:</span><span class="sxs-lookup"><span data-stu-id="09881-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="09881-161">[**CancelIo**](cancelio.md): questa funzione Annulla solo le operazioni rilasciate dal thread chiamante per l'handle di file specificato.</span><span class="sxs-lookup"><span data-stu-id="09881-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="09881-162">[**CancelIoEx**](cancelioex-func.md): questa funzione Annulla tutte le operazioni rilasciate dai thread per l'handle di file specificato.</span><span class="sxs-lookup"><span data-stu-id="09881-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="09881-163">Usare [**CancelSynchronousIo**](cancelsynchronousio-func.md) per annullare le operazioni di I/O sincrone in sospeso.</span><span class="sxs-lookup"><span data-stu-id="09881-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="09881-164">Le funzioni [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) e [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) consentono a un'applicazione di specificare una routine da eseguire (vedere [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) quando viene completata la richiesta di i/O asincrona.</span><span class="sxs-lookup"><span data-stu-id="09881-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
