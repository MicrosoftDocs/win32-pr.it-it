---
description: Vengono descritte le considerazioni per il controllo dell'applicazione del buffering dei file, noto anche come input/output (I/O) file non memorizzato nel buffer.
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Buffer dei file
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "104233518"
---
# <a name="file-buffering"></a><span data-ttu-id="cc343-103">Buffer dei file</span><span class="sxs-lookup"><span data-stu-id="cc343-103">File Buffering</span></span>

<span data-ttu-id="cc343-104">In questo argomento vengono illustrate le varie considerazioni per il controllo delle applicazioni del buffering dei file, noto anche come input/output (I/O) file non memorizzato nel buffer.</span><span class="sxs-lookup"><span data-stu-id="cc343-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="cc343-105">Il buffering dei file viene in genere gestito dal sistema dietro le quinte e viene considerato parte della [memorizzazione nella cache del file](file-caching.md) nel sistema operativo Windows, se non diversamente specificato.</span><span class="sxs-lookup"><span data-stu-id="cc343-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="cc343-106">Sebbene i termini *caching* e *buffering* vengano talvolta utilizzati in modo intercambiabile, in questo argomento viene utilizzato il termine *buffering* specifico nel contesto di spiegazione della modalità di interazione con i dati che non vengono memorizzati nella cache (memorizzati nel buffer) dal sistema, in modo da evitare il controllo diretto delle applicazioni in modalità utente.</span><span class="sxs-lookup"><span data-stu-id="cc343-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="cc343-107">Quando si apre o si crea un file con la funzione [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) , non è possibile specificare il flag del **\_ \_ \_ buffer** per disabilitare la memorizzazione nella cache del sistema dei dati letti o scritti nel file.</span><span class="sxs-lookup"><span data-stu-id="cc343-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="cc343-108">Sebbene ciò consenta il controllo completo e diretto del buffer di I/O dei dati, nel caso di file e dispositivi simili sono previsti requisiti di allineamento dei dati che devono essere presi in considerazione.</span><span class="sxs-lookup"><span data-stu-id="cc343-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="cc343-109">Queste informazioni di allineamento sono valide per I/O nei dispositivi, ad esempio i file che supportano la ricerca e il concetto di puntatori alla posizione dei file (o *offset*).</span><span class="sxs-lookup"><span data-stu-id="cc343-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="cc343-110">Per i dispositivi che non cercano, ad esempio le named pipe o i dispositivi di comunicazione, la disattivazione del buffer potrebbe non richiedere alcun allineamento particolare.</span><span class="sxs-lookup"><span data-stu-id="cc343-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="cc343-111">Eventuali limitazioni o efficienze che possono essere ottenute tramite l'allineamento in questo caso dipendono dalla tecnologia sottostante.</span><span class="sxs-lookup"><span data-stu-id="cc343-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="cc343-112">In un semplice esempio, l'applicazione apre un file per l'accesso in scrittura con **il \_ flag file senza flag di \_ \_ buffering** e quindi esegue una chiamata alla funzione [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) usando un buffer di dati definito nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="cc343-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="cc343-113">In queste circostanze, questo buffer locale è effettivamente l'unico buffer di file esistente per questa operazione.</span><span class="sxs-lookup"><span data-stu-id="cc343-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="cc343-114">A causa del layout del disco fisico, del layout di archiviazione file system e del rilevamento della posizione del puntatore del file a livello di sistema, questa operazione di scrittura avrà esito negativo a meno che i buffer dei dati definiti localmente soddisfino determinati criteri di allineamento, descritti nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="cc343-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="cc343-115">La discussione sulla memorizzazione nella cache non prende in considerazione la memorizzazione nell'hardware del disco fisico, che non è necessariamente all'interno del controllo diretto del sistema in ogni caso.</span><span class="sxs-lookup"><span data-stu-id="cc343-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="cc343-116">Questa operazione non ha alcun effetto sui requisiti specificati in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="cc343-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="cc343-117">Per ulteriori informazioni su come **flag di file \_ \_ nessun \_ buffer** interagisce con altri flag correlati alla cache, vedere [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span><span class="sxs-lookup"><span data-stu-id="cc343-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="cc343-118">Requisiti di allineamento e accesso ai file</span><span class="sxs-lookup"><span data-stu-id="cc343-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="cc343-119">Come descritto in precedenza, un'applicazione deve soddisfare determinati requisiti quando si lavora con i file aperti con il **flag di file \_ \_ senza \_ buffering**.</span><span class="sxs-lookup"><span data-stu-id="cc343-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="cc343-120">Si applicano le seguenti specifiche:</span><span class="sxs-lookup"><span data-stu-id="cc343-120">The following specifics apply:</span></span>

-   <span data-ttu-id="cc343-121">Le dimensioni di accesso ai file, incluso l'offset del file facoltativo nella struttura [**sovrapposta**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , se specificato, devono essere per un numero di byte che è un multiplo intero della dimensione del settore del volume.</span><span class="sxs-lookup"><span data-stu-id="cc343-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="cc343-122">Se, ad esempio, le dimensioni del settore sono pari a 512 byte, un'applicazione può richiedere letture e scritture di 512, 1.024, 1.536 o 2.048 byte, ma non di 335, 981 o 7.171 byte.</span><span class="sxs-lookup"><span data-stu-id="cc343-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="cc343-123">Gli indirizzi del buffer di accesso ai file per le operazioni di lettura e scrittura devono essere allineati al settore fisico, ovvero allineati sugli indirizzi in memoria che sono multipli integer delle dimensioni del settore fisico del volume.</span><span class="sxs-lookup"><span data-stu-id="cc343-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="cc343-124">A seconda del disco, questo requisito potrebbe non essere applicato.</span><span class="sxs-lookup"><span data-stu-id="cc343-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="cc343-125">Gli sviluppatori di applicazioni devono prendere nota dei nuovi tipi di dispositivi di archiviazione introdotti sul mercato con una dimensione di settore multimediale fisica di 4.096 byte.</span><span class="sxs-lookup"><span data-stu-id="cc343-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="cc343-126">Il nome del settore per questi dispositivi è "formato avanzato".</span><span class="sxs-lookup"><span data-stu-id="cc343-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="cc343-127">Poiché è possibile che si verifichino problemi di compatibilità con l'introduzione diretta di 4.096 byte come unità di indirizzamento per i supporti, una soluzione di compatibilità temporanea prevede l'introduzione di dispositivi che emulano un normale dispositivo di archiviazione settore a 512 byte, ma che rendono disponibili informazioni sulle reali dimensioni del settore tramite comandi ATA e SCSI standard.</span><span class="sxs-lookup"><span data-stu-id="cc343-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="cc343-128">In seguito a questa emulazione, esistono essenzialmente due dimensioni di settore che gli sviluppatori dovranno comprendere:</span><span class="sxs-lookup"><span data-stu-id="cc343-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="cc343-129">Settore logico: unità utilizzata per l'indirizzamento dei blocchi logici per il supporto.</span><span class="sxs-lookup"><span data-stu-id="cc343-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="cc343-130">Possiamo anche considerarlo come la più piccola unità di scrittura che la risorsa di archiviazione può accettare.</span><span class="sxs-lookup"><span data-stu-id="cc343-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="cc343-131">Si tratta dell'emulazione.</span><span class="sxs-lookup"><span data-stu-id="cc343-131">This is the "emulation".</span></span>
-   <span data-ttu-id="cc343-132">Settore fisico: unità per cui vengono completate le operazioni di lettura e scrittura nel dispositivo in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="cc343-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="cc343-133">Si tratta dell'unità di scrittura atomica e di quali elementi I/O non memorizzati nel buffer dovranno essere allineati per avere caratteristiche ottimali di prestazioni e affidabilità.</span><span class="sxs-lookup"><span data-stu-id="cc343-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="cc343-134">La maggior parte delle API Windows correnti, ad esempio [**IOCTL \_ disk \_ get \_ drive \_ Geometry**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) e [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), restituirà le dimensioni del settore logico, ma le dimensioni del settore fisico possono essere recuperate tramite il codice di controllo della [**\_ proprietà della query di archiviazione \_ \_ IOCTL**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) , con le informazioni rilevanti contenute nel membro **BytesPerPhysicalSector** nella struttura del [**\_ \_ \_ descrittore di allineamento dell'accesso di archiviazione**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) .</span><span class="sxs-lookup"><span data-stu-id="cc343-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="cc343-135">Per un esempio, vedere il codice di esempio [**al \_ \_ \_ descrittore di allineamento dell'accesso di archiviazione**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span><span class="sxs-lookup"><span data-stu-id="cc343-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="cc343-136">Microsoft consiglia agli sviluppatori di allineare i/O senza buffer alle dimensioni del settore fisico come riportato dal codice di controllo **delle \_ \_ \_ proprietà di query di archiviazione IOCTL** per garantire la preparazione delle applicazioni per la transizione delle dimensioni del settore.</span><span class="sxs-lookup"><span data-stu-id="cc343-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="cc343-137">**Windows Server 2003 e Windows XP:** La struttura del [**\_ \_ \_ descrittore di allineamento dell'accesso di archiviazione**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="cc343-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="cc343-138">È stata introdotta con Windows Vista e Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="cc343-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="cc343-139">Poiché gli indirizzi del buffer per le operazioni di lettura e scrittura devono essere allineati al settore, l'applicazione deve avere il controllo diretto del modo in cui vengono allocati i buffer.</span><span class="sxs-lookup"><span data-stu-id="cc343-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="cc343-140">Un modo per allineare i buffer al settore consiste nell'utilizzare la funzione [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) per allocare i buffer.</span><span class="sxs-lookup"><span data-stu-id="cc343-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="cc343-141">Considerare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="cc343-141">Consider the following:</span></span>

-   <span data-ttu-id="cc343-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) alloca memoria allineata agli indirizzi che sono multipli integer delle dimensioni di pagina del sistema.</span><span class="sxs-lookup"><span data-stu-id="cc343-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="cc343-143">Le dimensioni della pagina sono di 4.096 byte in x64 e x86 o 8.192 byte per sistemi basati su Itanium.</span><span class="sxs-lookup"><span data-stu-id="cc343-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="cc343-144">Per ulteriori informazioni, vedere la funzione [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) .</span><span class="sxs-lookup"><span data-stu-id="cc343-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="cc343-145">Le dimensioni del settore sono in genere da 512 a 4.096 byte per i dispositivi di archiviazione con accesso diretto (unità disco rigido) e 2.048 byte per CD-ROM.</span><span class="sxs-lookup"><span data-stu-id="cc343-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="cc343-146">Le dimensioni della pagina e del settore sono le potenze di 2.</span><span class="sxs-lookup"><span data-stu-id="cc343-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="cc343-147">Pertanto, nella maggior parte dei casi, la memoria allineata alla pagina sarà anche allineata a livello di settore, perché il caso in cui le dimensioni del settore sono maggiori delle dimensioni della pagina sono rare.</span><span class="sxs-lookup"><span data-stu-id="cc343-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="cc343-148">Un altro modo per ottenere buffer di memoria allineati manualmente consiste nell'usare la funzione di [ \_ \_ malloc allineata](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) dalla libreria Run-Time C.</span><span class="sxs-lookup"><span data-stu-id="cc343-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="cc343-149">Per un esempio di come controllare manualmente l'allineamento del buffer, vedere l'esempio di codice del linguaggio C++ nella sezione di codice di esempio di [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="cc343-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
