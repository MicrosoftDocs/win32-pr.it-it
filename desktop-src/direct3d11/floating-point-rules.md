---
title: Regole a virgola mobile (Direct3D 11)
description: Direct3D 11 supporta diverse rappresentazioni a virgola mobile. Tutti i calcoli a virgola mobile operano in un subset definito delle regole a virgola mobile a precisione singola IEEE 754 32 bit.
ms.assetid: 33F21BD0-FDF8-4D35-95C0-0A3920814CB6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d83c87db0daa69c0393d0399ece5bdb6cf01d519
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104399138"
---
# <a name="floating-point-rules-direct3d-11"></a><span data-ttu-id="a7a7b-104">Regole a virgola mobile (Direct3D 11)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-104">Floating-point rules (Direct3D 11)</span></span>

<span data-ttu-id="a7a7b-105">Direct3D 11 supporta diverse rappresentazioni a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-105">Direct3D 11 supports several floating-point representations.</span></span> <span data-ttu-id="a7a7b-106">Tutti i calcoli a virgola mobile operano in un subset definito delle regole a virgola mobile a precisione singola IEEE 754 32 bit.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-106">All floating-point computations operate under a defined subset of the IEEE 754 32-bit single precision floating-point rules.</span></span>

-   [<span data-ttu-id="a7a7b-107">regole a virgola mobile a 32 bit</span><span class="sxs-lookup"><span data-stu-id="a7a7b-107">32-bit floating-point rules</span></span>](#32-bit-floating-point-rules)
    -   [<span data-ttu-id="a7a7b-108">Regole IEEE-754 rispettate</span><span class="sxs-lookup"><span data-stu-id="a7a7b-108">Honored IEEE-754 rules</span></span>](#honored-ieee-754-rules)
    -   [<span data-ttu-id="a7a7b-109">Deviazioni o requisiti aggiuntivi da regole IEEE-754</span><span class="sxs-lookup"><span data-stu-id="a7a7b-109">Deviations or additional requirements from IEEE-754 rules</span></span>](#deviations-or-additional-requirements-from-ieee-754-rules)
-   [<span data-ttu-id="a7a7b-110">regole a virgola mobile a 64 bit (precisione doppia)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-110">64-bit (double precision) floating point rules</span></span>](#64-bit-double-precision-floating-point-rules)
-   [<span data-ttu-id="a7a7b-111">regole a virgola mobile a 16 bit</span><span class="sxs-lookup"><span data-stu-id="a7a7b-111">16-bit floating-point rules</span></span>](#16-bit-floating-point-rules)
-   [<span data-ttu-id="a7a7b-112">regole a virgola mobile a 11 e 10 bit</span><span class="sxs-lookup"><span data-stu-id="a7a7b-112">11-bit and 10-bit floating-point rules</span></span>](#11-bit-and-10-bit-floating-point-rules)
-   [<span data-ttu-id="a7a7b-113">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="a7a7b-113">Related topics</span></span>](#related-topics)

## <a name="32-bit-floating-point-rules"></a><span data-ttu-id="a7a7b-114">regole a virgola mobile a 32 bit</span><span class="sxs-lookup"><span data-stu-id="a7a7b-114">32-bit floating-point rules</span></span>

<span data-ttu-id="a7a7b-115">Sono disponibili due set di regole: quelle conformi a IEEE-754 e quelle che si scostano dallo standard.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-115">There are two sets of rules: those that conform to IEEE-754, and those that deviate from the standard.</span></span>

### <a name="honored-ieee-754-rules"></a><span data-ttu-id="a7a7b-116">Regole IEEE-754 rispettate</span><span class="sxs-lookup"><span data-stu-id="a7a7b-116">Honored IEEE-754 rules</span></span>

<span data-ttu-id="a7a7b-117">Alcune di queste regole sono una singola opzione in cui IEEE-754 offre opzioni.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-117">Some of these rules are a single option where IEEE-754 offers choices.</span></span>

-   <span data-ttu-id="a7a7b-118">Divide per 0 produce +/-INF, eccetto 0/0, che restituisce NaN.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-118">Divide by 0 produces +/- INF, except 0/0 which results in NaN.</span></span>
-   <span data-ttu-id="a7a7b-119">log di (+/-) 0 produce-INF.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-119">log of (+/-) 0 produces -INF.</span></span> <span data-ttu-id="a7a7b-120">il log di un valore negativo (diverso da-0) produce NaN.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-120">log of a negative value (other than -0) produces NaN.</span></span>
-   <span data-ttu-id="a7a7b-121">La radice quadrata reciproca (RSQ) o radice quadrata (sqrt) di un numero negativo produce NaN.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-121">Reciprocal square root (rsq) or square root (sqrt) of a negative number produces NaN.</span></span> <span data-ttu-id="a7a7b-122">L'eccezione è-0; sqrt (-0) produce-0 e RSQ (-0) produce-INF.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-122">The exception is -0; sqrt(-0) produces -0, and rsq(-0) produces -INF.</span></span>
-   <span data-ttu-id="a7a7b-123">INF-INF = NaN</span><span class="sxs-lookup"><span data-stu-id="a7a7b-123">INF - INF = NaN</span></span>
-   <span data-ttu-id="a7a7b-124">(+/-) INF/(+/-) INF = NaN</span><span class="sxs-lookup"><span data-stu-id="a7a7b-124">(+/-)INF / (+/-)INF = NaN</span></span>
-   <span data-ttu-id="a7a7b-125">(+/-) INF \* 0 = Nan</span><span class="sxs-lookup"><span data-stu-id="a7a7b-125">(+/-)INF \* 0 = NaN</span></span>
-   <span data-ttu-id="a7a7b-126">NaN (any OP) any-value = NaN</span><span class="sxs-lookup"><span data-stu-id="a7a7b-126">NaN (any OP) any-value = NaN</span></span>
-   <span data-ttu-id="a7a7b-127">I confronti EQ, GT, GE, LT e LE, quando uno o entrambi gli operandi è NaN restituisce **false**.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-127">The comparisons EQ, GT, GE, LT, and LE, when either or both operands is NaN returns **FALSE**.</span></span>
-   <span data-ttu-id="a7a7b-128">I confronti ignorano il segno di 0 (quindi + 0 è uguale a-0).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-128">Comparisons ignore the sign of 0 (so +0 equals -0).</span></span>
-   <span data-ttu-id="a7a7b-129">Il confronto NE, quando uno o entrambi gli operandi è NaN restituisce **true**.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-129">The comparison NE, when either or both operands is NaN returns **TRUE**.</span></span>
-   <span data-ttu-id="a7a7b-130">I confronti di qualsiasi valore non NaN rispetto a +/-INF restituiscono il risultato corretto.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-130">Comparisons of any non-NaN value against +/- INF return the correct result.</span></span>

### <a name="deviations-or-additional-requirements-from-ieee-754-rules"></a><span data-ttu-id="a7a7b-131">Deviazioni o requisiti aggiuntivi da regole IEEE-754</span><span class="sxs-lookup"><span data-stu-id="a7a7b-131">Deviations or additional requirements from IEEE-754 rules</span></span>

-   <span data-ttu-id="a7a7b-132">IEEE-754 richiede che le operazioni a virgola mobile producano un risultato che rappresenta il valore rappresentabile più vicino a un risultato preciso all'infinito, noto come arrotondato al più vicino.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-132">IEEE-754 requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result, known as round-to-nearest-even.</span></span> <span data-ttu-id="a7a7b-133">Direct3D 11 definisce lo stesso requisito: le operazioni a virgola mobile a 32 bit producono un risultato compreso tra 0,5 unit-Last-Place (ULP rispetto) del risultato di precisione infinita.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-133">Direct3D 11 defines the same requirement: 32-bit floating-point operations produce a result that is within 0.5 unit-last-place (ULP) of the infinitely-precise result.</span></span> <span data-ttu-id="a7a7b-134">Ciò significa che, ad esempio, l'hardware può troncare i risultati a 32 bit, anziché eseguire l'operazione più vicina, perché questo genera un errore di al massimo 0,5 ULP rispetto. Questa regola si applica solo a addizioni, sottrazioni e moltiplicazioni.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-134">This means that, for example, hardware is allowed to truncate results to 32-bit rather than perform round-to-nearest-even, as that would result in error of at most 0.5 ULP.This rule applies only to addition, subtraction, and multiplication.</span></span>
-   <span data-ttu-id="a7a7b-135">Non è previsto alcun supporto per eccezioni a virgola mobile, bit di stato o trap.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-135">There is no support for floating-point exceptions, status bits or traps.</span></span>
-   <span data-ttu-id="a7a7b-136">Le denormazioni vengono scaricate allo zero senza segno per l'input e l'output di qualsiasi operazione matematica a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-136">Denorms are flushed to sign-preserved zero on input and output of any floating-point mathematical operation.</span></span> <span data-ttu-id="a7a7b-137">Vengono eseguite eccezioni per qualsiasi operazione di I/O o spostamento dei dati che non modifica i dati.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-137">Exceptions are made for any I/O or data movement operation that doesn't manipulate the data.</span></span>
-   <span data-ttu-id="a7a7b-138">Gli Stati che contengono valori a virgola mobile, ad esempio viewport MinDepth/MaxDepth, i valori BorderColor, possono essere forniti come valori di deregolazione e possono o meno essere scaricati prima che l'hardware li usi.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-138">States that contain floating-point values, such as Viewport MinDepth/MaxDepth, BorderColor values, may be provided as denorm values and may or may not be flushed before the hardware uses them.</span></span>
-   <span data-ttu-id="a7a7b-139">Le operazioni minime o massime scaricano le denormazioni per il confronto, ma il risultato può essere scaricato o meno.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-139">Min or max operations flush denorms for comparison, but the result may or may not be denorm flushed.</span></span>
-   <span data-ttu-id="a7a7b-140">L'input NaN in un'operazione produce sempre NaN nell'output.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-140">NaN input to an operation always produces NaN on output.</span></span> <span data-ttu-id="a7a7b-141">Tuttavia, non è necessario che lo schema di bit esatto di NaN sia uguale, a meno che l'operazione non sia un'istruzione di spostamento non elaborata, che non modifica i dati.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-141">But the exact bit pattern of the NaN is not required to stay the same (unless the operation is a raw move instruction - which doesn't alter data.)</span></span>
-   <span data-ttu-id="a7a7b-142">Le operazioni min o Max per le quali un solo operando è NaN restituiscono l'altro operando come risultato (contrariamente alle regole di confronto esaminate in precedenza).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-142">Min or max operations for which only one operand is NaN return the other operand as the result (contrary to comparison rules we looked at earlier).</span></span> <span data-ttu-id="a7a7b-143">Si tratta di una regola IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-143">This is a IEEE 754R rule.</span></span>

    <span data-ttu-id="a7a7b-144">La specifica IEEE-754R per le operazioni min e Max a virgola mobile indica che se uno degli input a min o Max è un valore di QNaN non interattiva, il risultato dell'operazione è l'altro parametro.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-144">The IEEE-754R specification for floating point min and max operations states that if one of the inputs to min or max is a quiet QNaN value, the result of the operation is the other parameter.</span></span> <span data-ttu-id="a7a7b-145">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-145">For example:</span></span>

    ```C++
    min(x,QNaN) == min(QNaN,x) == x (same for max)
    ```

    

    <span data-ttu-id="a7a7b-146">Una revisione della specifica IEEE-754R ha adottato un comportamento diverso per min e Max quando un input è un valore SNaN di "segnalazione" rispetto a un valore di QNaN:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-146">A revision of the IEEE-754R specification adopted a different behavior for min and max when one input is a "signaling" SNaN value versus a QNaN value:</span></span>

    ```C++
    min(x,SNaN) == min(SNaN,x) == QNaN (same for max)
     
    ```

    

    <span data-ttu-id="a7a7b-147">In genere, Direct3D segue gli standard per aritmetici: IEEE-754 e IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-147">Generally, Direct3D follows the standards for arithmetic: IEEE-754 and IEEE-754R.</span></span> <span data-ttu-id="a7a7b-148">Ma in questo caso, abbiamo una deviazione.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-148">But in this case, we have a deviation.</span></span>

    <span data-ttu-id="a7a7b-149">Le regole aritmetiche in Direct3D 10 e versioni successive non fanno alcuna distinzione tra i valori NaN quiet e Signaling (QNaN e SNaN).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-149">The arithmetic rules in Direct3D 10 and later don't make any distinctions between quiet and signaling NaN values (QNaN versus SNaN).</span></span> <span data-ttu-id="a7a7b-150">Tutti i valori NaN vengono gestiti allo stesso modo.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-150">All NaN values are handled the same way.</span></span> <span data-ttu-id="a7a7b-151">Nel caso di min e Max, il comportamento di Direct3D per qualsiasi valore NaN è simile al modo in cui QNaN viene gestito nella definizione IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-151">In the case of min and max, the Direct3D behavior for any NaN value is like how QNaN is handled in the IEEE-754R definition.</span></span> <span data-ttu-id="a7a7b-152">(Per completezza-se entrambi gli input sono NaN, viene restituito qualsiasi valore NaN).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-152">(For completeness - if both inputs are NaN, any NaN value is returned.)</span></span>

-   <span data-ttu-id="a7a7b-153">Un'altra regola IEEE 754R è che min (-0, + 0) = = min (+ 0,-0) = =-0 e Max (-0, + 0) = = Max (+ 0,-0) = = + 0, che rispetta il segno, a differenza delle regole di confronto per zero con segno (come illustrato in precedenza).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-153">Another IEEE 754R rule is that min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, which honors the sign, in contrast to the comparison rules for signed zero (as we saw earlier).</span></span> <span data-ttu-id="a7a7b-154">Direct3D consiglia il comportamento IEEE 754R qui, ma non lo impone. è possibile che il risultato del confronto degli zeri sia dipendente dall'ordine dei parametri, usando un confronto che ignora i segni.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-154">Direct3D recommends the IEEE 754R behavior here, but doesn't enforce it; it is permissible for the result of comparing zeros to be dependent on the order of parameters, using a comparison that ignores the signs.</span></span>
-   <span data-ttu-id="a7a7b-155">x \* 1.0 f restituisce sempre x (eccetto la denormazione scaricata).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-155">x\*1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="a7a7b-156">x/1.0 f restituisce sempre x (eccetto la denormazione scaricata).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-156">x/1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="a7a7b-157">x +/-0,0 f restituisce sempre x (eccetto la denormazione scaricata).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-157">x +/- 0.0f always results in x (except denorm flushed).</span></span> <span data-ttu-id="a7a7b-158">Ma-0 + 0 = + 0.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-158">But -0 + 0 = +0.</span></span>
-   <span data-ttu-id="a7a7b-159">Le operazioni fuse, ad esempio Mad, DP3, producono risultati che non sono meno accurati rispetto al peggiore ordine seriale possibile di valutazione dell'espansione non fusa dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-159">Fused operations (such as mad, dp3) produce results that are no less accurate than the worst possible serial ordering of evaluation of the unfused expansion of the operation.</span></span> <span data-ttu-id="a7a7b-160">La definizione del peggiore ordinamento possibile, allo scopo di tollerare, non è una definizione fissa per un'operazione di cui è stata eseguita la fusione. dipende dai valori specifici degli input.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-160">The definition of the worst possible ordering, for the purpose of tolerance, is not a fixed definition for a given fused operation; it depends on the particular values of the inputs.</span></span> <span data-ttu-id="a7a7b-161">I singoli passaggi nell'espansione non fusa sono consentiti per ciascuna tolleranza ULP rispetto (o per tutte le istruzioni che Direct3D chiama con una tolleranza di lassismo maggiore di 1 ULP rispetto, maggiore è la tolleranza di lassismo).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-161">The individual steps in the unfused expansion are each allowed 1 ULP tolerance (or for any instructions Direct3D calls out with a more lax tolerance than 1 ULP, the more lax tolerance is allowed).</span></span>
-   <span data-ttu-id="a7a7b-162">Le operazioni fuse rispettano le stesse regole NaN delle operazioni non fuse.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-162">Fused operations adhere to the same NaN rules as non-fused operations.</span></span>
-   <span data-ttu-id="a7a7b-163">sqrt e RCP hanno una tolleranza ULP rispetto.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-163">sqrt and rcp have 1 ULP tolerance.</span></span> <span data-ttu-id="a7a7b-164">Le istruzioni per la radice quadrata reciproca e reciproca dello shader, [**RCP**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) e [**RSQ**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), hanno un requisito di precisione separata distinto.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-164">The shader reciprocal and reciprocal square-root instructions, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) and [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), have their own separate relaxed precision requirement.</span></span>
-   <span data-ttu-id="a7a7b-165">Multiply e divide each operano a livello di precisione a virgola mobile a 32 bit (accuratezza a 0,5 ULP rispetto per Multiply, 1,0 ULP rispetto per reciproca).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-165">Multiply and divide each operate at the 32-bit floating-point precision level (accuracy to 0.5 ULP for multiply, 1.0 ULP for reciprocal).</span></span> <span data-ttu-id="a7a7b-166">Se x/y viene implementato direttamente, i risultati devono essere di precisione maggiore o uguale a quello di un metodo in due passaggi.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-166">If x/y is implemented directly, results must be of greater or equal accuracy than a two-step method.</span></span>

## <a name="64-bit-double-precision-floating-point-rules"></a><span data-ttu-id="a7a7b-167">regole a virgola mobile a 64 bit (precisione doppia)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-167">64-bit (double precision) floating point rules</span></span>

<span data-ttu-id="a7a7b-168">I driver hardware e display supportano facoltativamente la virgola mobile a precisione doppia.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-168">Hardware and display drivers optionally support double-precision floating-point.</span></span> <span data-ttu-id="a7a7b-169">Per indicare il supporto, quando si chiama [**ID3D11Device:: CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) con la [**\_ funzionalità d3d11 \_ Doubles**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), il driver imposta **DoublePrecisionFloatShaderOps** dei dati della [**funzionalità di d3d11 \_ \_ \_ Double**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) su true.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-169">To indicate support, when you call [**ID3D11Device::CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) with [**D3D11\_FEATURE\_DOUBLES**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), the driver sets **DoublePrecisionFloatShaderOps** of [**D3D11\_FEATURE\_DATA\_DOUBLES**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) to TRUE.</span></span> <span data-ttu-id="a7a7b-170">Il driver e l'hardware devono supportare tutte le istruzioni a virgola mobile a precisione doppia.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-170">The driver and hardware must then support all double-precision floating-point instructions.</span></span>

<span data-ttu-id="a7a7b-171">Le istruzioni a precisione doppia seguono i requisiti del comportamento IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-171">Double-precision instructions follow IEEE 754R behavior requirements.</span></span>

<span data-ttu-id="a7a7b-172">Il supporto per la generazione di valori denormalizzati è necessario per i dati a precisione doppia (nessun comportamento di scaricamento zero).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-172">Support for generation of denormalized values is required for double-precision data (no flush-to-zero behavior).</span></span> <span data-ttu-id="a7a7b-173">Analogamente, le istruzioni non leggono i dati denormalizzati come zero con segno, rispettano il valore della denorma.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-173">Likewise, instructions don't read denormalized data as a signed zero, they honor the denorm value.</span></span>

## <a name="16-bit-floating-point-rules"></a><span data-ttu-id="a7a7b-174">regole a virgola mobile a 16 bit</span><span class="sxs-lookup"><span data-stu-id="a7a7b-174">16-bit floating-point rules</span></span>

<span data-ttu-id="a7a7b-175">Direct3D 11 supporta inoltre le rappresentazioni a 16 bit dei numeri a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-175">Direct3D 11 also supports 16-bit representations of floating-point numbers.</span></span>

<span data-ttu-id="a7a7b-176">Formato:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-176">Format:</span></span>

-   <span data-ttu-id="a7a7b-177">1 bit/i di segno nella posizione del bit MSB</span><span class="sxs-lookup"><span data-stu-id="a7a7b-177">1 sign bit (s)in the MSB bit position</span></span>
-   <span data-ttu-id="a7a7b-178">5 bit di esponente polarizzato (e)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-178">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="a7a7b-179">10 bit di frazione (f), con un bit nascosto aggiuntivo</span><span class="sxs-lookup"><span data-stu-id="a7a7b-179">10 bits of fraction (f), with an additional hidden bit</span></span>

<span data-ttu-id="a7a7b-180">Un valore float16 (v) segue le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-180">A float16 value (v) follows these rules:</span></span>

-   <span data-ttu-id="a7a7b-181">Se e = = 31 e f! = 0, v è NaN indipendentemente da s</span><span class="sxs-lookup"><span data-stu-id="a7a7b-181">if e == 31 and f != 0, then v is NaN regardless of s</span></span>
-   <span data-ttu-id="a7a7b-182">Se e = = 31 e f = = 0, v = (-1) s \* Infinity (Signed Infinity)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-182">if e == 31 and f == 0, then v = (-1)s\*infinity (signed infinity)</span></span>
-   <span data-ttu-id="a7a7b-183">Se e è compreso tra 0 e 31, v = (-1) s \* 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-183">if e is between 0 and 31, then v = (-1)s\*2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="a7a7b-184">Se e = = 0 e f! = 0, v = (-1) s \* 2 (e-14) \* (0. f) (numeri denormalizzati)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-184">if e == 0 and f != 0, then v = (-1)s\*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="a7a7b-185">Se e = = 0 e f = = 0, v = (-1) s \* 0 (con segno zero)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-185">if e == 0 and f == 0, then v = (-1)s\*0 (signed zero)</span></span>

<span data-ttu-id="a7a7b-186">le regole a virgola mobile a 32 bit sono disponibili anche per i numeri a virgola mobile a 16 bit, adattati per il layout di bit descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-186">32-bit floating-point rules also hold for 16-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="a7a7b-187">Alcune eccezioni:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-187">Exceptions to this include:</span></span>

-   <span data-ttu-id="a7a7b-188">Precisione: le operazioni non fuse sui numeri a virgola mobile a 16 bit producono un risultato che rappresenta il valore rappresentabile più vicino a un risultato preciso all'infinito (arrotondato al più vicino anche per IEEE-754, applicato ai valori a 16 bit).</span><span class="sxs-lookup"><span data-stu-id="a7a7b-188">Precision: Unfused operations on 16-bit floating-point numbers produce a result that is the nearest representable value to an infinitely-precise result (round to nearest even, per IEEE-754, applied to 16-bit values).</span></span> <span data-ttu-id="a7a7b-189">le regole a virgola mobile a 32 bit rispettano una tolleranza ULP rispetto, le regole a virgola mobile a 16 bit sono conformi a 0,5 ULP rispetto per le operazioni non fuse e 0,6 ULP rispetto per le operazioni fuse.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-189">32-bit floating-point rules adhere to 1 ULP tolerance, 16-bit floating-point rules adhere to 0.5 ULP for unfused operations, and 0.6 ULP for fused operations.</span></span>
-   <span data-ttu-id="a7a7b-190">i numeri a virgola mobile a 16 bit conservano le norme.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-190">16-bit floating-point numbers preserve denorms.</span></span>

## <a name="11-bit-and-10-bit-floating-point-rules"></a><span data-ttu-id="a7a7b-191">regole a virgola mobile a 11 e 10 bit</span><span class="sxs-lookup"><span data-stu-id="a7a7b-191">11-bit and 10-bit floating-point rules</span></span>

<span data-ttu-id="a7a7b-192">Direct3D 11 supporta inoltre formati a virgola mobile a 11 e 10 bit.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-192">Direct3D 11 also supports 11-bit and 10-bit floating-point formats.</span></span>

<span data-ttu-id="a7a7b-193">Formato:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-193">Format:</span></span>

-   <span data-ttu-id="a7a7b-194">Nessun bit di segno</span><span class="sxs-lookup"><span data-stu-id="a7a7b-194">No sign bit</span></span>
-   <span data-ttu-id="a7a7b-195">5 bit di esponente polarizzato (e)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-195">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="a7a7b-196">6 bit della frazione (f) per un formato a 11 bit, a 5 bit di frazione (f) per un formato a 10 bit, con un bit nascosto aggiuntivo in entrambi i casi.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-196">6 bits of fraction (f) for an 11-bit format, 5 bits of fraction (f) for a 10-bit format, with an additional hidden bit in either case.</span></span>

<span data-ttu-id="a7a7b-197">Un valore float11/float10 (v) segue le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-197">A float11/float10 value (v) follows the following rules:</span></span>

-   <span data-ttu-id="a7a7b-198">Se e = = 31 e f! = 0, v è NaN</span><span class="sxs-lookup"><span data-stu-id="a7a7b-198">if e == 31 and f != 0, then v is NaN</span></span>
-   <span data-ttu-id="a7a7b-199">Se e = = 31 e f = = 0, v = + Infinity</span><span class="sxs-lookup"><span data-stu-id="a7a7b-199">if e == 31 and f == 0, then v = +infinity</span></span>
-   <span data-ttu-id="a7a7b-200">Se e è compreso tra 0 e 31, v = 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-200">if e is between 0 and 31, then v = 2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="a7a7b-201">Se e = = 0 e f! = 0, v = \* 2 (e-14) \* (0. f) (numeri denormalizzati)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-201">if e == 0 and f != 0, then v = \*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="a7a7b-202">Se e = = 0 e f = = 0, v = 0 (zero)</span><span class="sxs-lookup"><span data-stu-id="a7a7b-202">if e == 0 and f == 0, then v = 0 (zero)</span></span>

<span data-ttu-id="a7a7b-203">le regole a virgola mobile a 32 bit sono disponibili anche per i numeri a virgola mobile a 11 bit e a 10 bit, adattati per il layout di bit descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-203">32-bit floating-point rules also hold for 11-bit and 10-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="a7a7b-204">Le eccezioni sono le seguenti:</span><span class="sxs-lookup"><span data-stu-id="a7a7b-204">Exceptions include:</span></span>

-   <span data-ttu-id="a7a7b-205">Precisione: le regole a virgola mobile a 32 bit aderiscono a 0,5 ULP rispetto.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-205">Precision: 32-bit floating-point rules adhere to 0.5 ULP.</span></span>
-   <span data-ttu-id="a7a7b-206">i numeri a virgola mobile 10/11 bit conservano le norme.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-206">10/11-bit floating-point numbers preserve denorms.</span></span>
-   <span data-ttu-id="a7a7b-207">Qualsiasi operazione che comporterebbe un numero minore di zero viene fissata a zero.</span><span class="sxs-lookup"><span data-stu-id="a7a7b-207">Any operation that would result in a number less than zero is clamped to zero.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a7a7b-208">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="a7a7b-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a7a7b-209">Risorse</span><span class="sxs-lookup"><span data-stu-id="a7a7b-209">Resources</span></span>](overviews-direct3d-11-resources.md)
</dt> <dt>

[<span data-ttu-id="a7a7b-210">Trame</span><span class="sxs-lookup"><span data-stu-id="a7a7b-210">Textures</span></span>](overviews-direct3d-11-resources-textures.md)
</dt> </dl>

 

 