---
title: Perché le risorse affiancate sono necessarie
description: Le risorse affiancate sono necessarie, in modo che la memoria dell'unità di elaborazione grafica (GPU) venga sprecata per l'archiviazione di aree di superfici che l'applicazione sa non sarà accessibile e l'hardware possa comprendere come filtrare tra i riquadri adiacenti.
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104976655"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="8dc1c-103">Perché sono necessarie risorse affiancate?</span><span class="sxs-lookup"><span data-stu-id="8dc1c-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="8dc1c-104">Le risorse affiancate sono necessarie, in modo che la memoria dell'unità di elaborazione grafica (GPU) venga sprecata per l'archiviazione di aree di superfici che l'applicazione sa non sarà accessibile e l'hardware possa comprendere come filtrare tra i riquadri adiacenti.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="8dc1c-105">In un sistema grafico (ovvero il sistema operativo, il driver di visualizzazione e l'hardware grafico) senza supporto delle risorse affiancate, il sistema grafico gestisce tutte le allocazioni di memoria Direct3D a livello di granularità delle risorse.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="8dc1c-106">Per un [buffer](overviews-direct3d-11-resources-buffers.md), l'intero buffer è la sottorisorsa.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="8dc1c-107">Per una [trama](overviews-direct3d-11-resources-textures.md) , ad esempio [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d), ogni livello MIP è una sottorisorsa; per una matrice di trame (ad esempio, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), ogni livello MIP in una determinata sezione della matrice è una sottorisorsa.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="8dc1c-108">Il sistema grafico espone solo la possibilità di gestire il mapping delle allocazioni in questa granularità delle sottorisorse.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="8dc1c-109">Nel contesto delle risorse affiancate, "mapping" si riferisce al fatto che i dati siano visibili alla GPU.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="8dc1c-110">Si supponga che un'applicazione sappia che un'operazione di rendering specifica deve solo accedere a una piccola parte di una catena di mipmap di immagini (probabilmente non anche all'area completa di un determinato mipmap).</span><span class="sxs-lookup"><span data-stu-id="8dc1c-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="8dc1c-111">Idealmente, l'app potrebbe informare il sistema grafico in merito a questa esigenza.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="8dc1c-112">Il sistema grafico dovrebbe quindi solo assicurarsi che la memoria necessaria sia mappata sulla GPU senza eseguire il paging in troppa memoria.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="8dc1c-113">In realtà, senza il supporto delle risorse affiancate, il sistema grafico può essere informato solo sulla memoria di cui è necessario eseguire il mapping sulla GPU a livello di granularità delle risorse (ad esempio, un intervallo di livelli di mipmap completi a cui è possibile accedere).</span><span class="sxs-lookup"><span data-stu-id="8dc1c-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="8dc1c-114">Non vi è alcuna richiesta di errori nel sistema grafico, quindi è necessario usare potenzialmente una quantità eccessiva di memoria GPU per eseguire il mapping delle sottorisorse complete prima che venga eseguito un comando di rendering che fa riferimento a una parte della memoria.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="8dc1c-115">Questo è solo un problema che rende difficile l'uso di allocazioni di memoria di grandi dimensioni in Direct3D senza supporto delle risorse affiancate.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="8dc1c-116">Direct3D 11 supporta le superfici [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) con un massimo di 16384 pixel su un lato specifico.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="8dc1c-117">Un'immagine di 16384 in larghezza per 16384 di altezza e 4 byte per pixel utilizzerebbe 1 GB di memoria video (e l'aggiunta di mipmap sarebbe raddoppiata).</span><span class="sxs-lookup"><span data-stu-id="8dc1c-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="8dc1c-118">In pratica, è necessario fare riferimento a tutti i GB in un'unica operazione di rendering.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="8dc1c-119">Alcuni sviluppatori di giochi modellano le superfici del terreno fino a 128 KB per 128 KB.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="8dc1c-120">Il modo in cui si ottiene questo lavoro sulle GPU esistenti è suddividere l'area in riquadri sufficientemente piccoli da poter gestire l'hardware.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="8dc1c-121">L'applicazione deve determinare quali riquadri potrebbero essere necessari e caricarli in una cache di trame nel sistema di paging GPU, un software.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="8dc1c-122">Uno svantaggio significativo di questo approccio deriva dall'hardware che non è in grado di conoscere il paging che sta succedendo: quando una parte di un'immagine deve essere mostrata sullo schermo che occupa i riquadri, l'hardware non è in grado di eseguire il filtraggio di una funzione fissa (ovvero efficiente) tra i riquadri.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="8dc1c-123">Ciò significa che l'applicazione che gestisce il proprio affiancamento software deve ricorrere al filtro di trama manuale nel codice dello shader (che diventa molto costosa se si desidera un filtro anisotropico di qualità elevata) e/o sprecare le grondature di creazione della memoria intorno ai riquadri contenenti dati provenienti da riquadri adiacenti, in modo che i filtri hardware per funzioni fisse possano continuare a fornire assistenza</span><span class="sxs-lookup"><span data-stu-id="8dc1c-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="8dc1c-124">Se una rappresentazione affiancata delle allocazioni di superficie può essere una funzionalità di prima classe nel sistema grafico, l'applicazione potrebbe indicare all'hardware quali riquadri rendere disponibili.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="8dc1c-125">In questo modo, una minore quantità di memoria GPU viene sprecata per archiviare le aree di superficie che l'applicazione sa non sarà accessibile e l'hardware è in grado di comprendere come filtrare tra i riquadri adiacenti, attenuando alcune delle problematiche riscontrate dagli sviluppatori che eseguono autonomamente l'affiancamento software.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="8dc1c-126">Tuttavia, per fornire una soluzione completa, è necessario eseguire un'operazione per gestire il fatto che, indipendentemente dal fatto che l'affiancamento all'interno di una superficie sia supportata, la dimensione massima della superficie è attualmente 16384-Nowhere vicino al 128 KB + che le applicazioni desiderano già.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="8dc1c-127">È sufficiente che l'hardware per supportare dimensioni di trama più grandi sia un approccio, tuttavia ci sono costi e/o compromessi significativi per l'itinerario.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="8dc1c-128">Il percorso del filtro di trama e il percorso di rendering di Direct3D 11 sono già saturi in termini di precisione nel supporto delle trame 16K con gli altri requisiti, ad esempio il supporto degli extent del viewport che non rientrano nell'area durante il rendering o il wrapping del bordo della superficie durante il filtro.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="8dc1c-129">Una possibilità consiste nel definire un compromesso in modo tale che, quando le dimensioni della trama aumentano oltre 16K, le funzionalità e la precisione vengono fornite in qualche modo.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="8dc1c-130">Anche con questa concessione, tuttavia, potrebbero essere necessari costi hardware aggiuntivi in termini di funzionalità di indirizzamento nel sistema hardware per passare a dimensioni di trama maggiori.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="8dc1c-131">Un problema che si verifica come una trama è molto grande è che le coordinate di trama a virgola mobile e precisione singola (e gli interpolatori associati per supportare la rasterizzazione) hanno esaurito la precisione per specificare accuratamente i percorsi sulla superficie.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="8dc1c-132">Si verificherà un filtro di trama di Jittery.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="8dc1c-133">Una delle opzioni più dispendiose è la necessità di supportare l'interpolazione a precisione doppia, sebbene questo possa essere eccessivo in base a una ragionevole alternativa.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="8dc1c-134">Un nome alternativo per le risorse affiancate è "trama sparse".</span><span class="sxs-lookup"><span data-stu-id="8dc1c-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="8dc1c-135">"Sparse" fornisce sia la natura affiancata delle risorse sia il motivo principale per affiancarli, che non tutti devono essere mappati in una sola volta.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="8dc1c-136">In realtà, un'applicazione potrebbe in teoria creare una risorsa affiancata in cui nessun dato venga creato per tutte le aree + MIPS della risorsa, intenzionalmente.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="8dc1c-137">Il contenuto stesso potrebbe pertanto essere di tipo sparse e il mapping del contenuto nella memoria GPU in un determinato momento sarà un subset di tale contenuto (anche più sparse).</span><span class="sxs-lookup"><span data-stu-id="8dc1c-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="8dc1c-138">Un altro scenario che può essere servito dalle risorse affiancate consiste nell'abilitare più risorse di dimensioni/formati diversi per la condivisione della stessa memoria.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="8dc1c-139">A volte le applicazioni hanno set esclusivi di risorse che non devono essere usate contemporaneamente o risorse create solo per un breve utilizzo e quindi distrutte, seguite dalla creazione di altre risorse.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="8dc1c-140">Una forma di generalizzazione che può rientrare nelle "risorse affiancate" è che è possibile consentire all'utente di puntare più risorse diverse alla stessa memoria (sovrapposta).</span><span class="sxs-lookup"><span data-stu-id="8dc1c-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="8dc1c-141">In altre parole, la creazione e l'eliminazione di "risorse", che definiscono una dimensione/un formato e così via, possono essere separate dalla gestione della memoria sottostante le risorse dal punto di vista dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="8dc1c-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8dc1c-142">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="8dc1c-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8dc1c-143">Risorse affiancate</span><span class="sxs-lookup"><span data-stu-id="8dc1c-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 