---
title: Fase pixel shader
description: La fase pixel shader (PS) consente tecniche di ombreggiatura avanzate, ad esempio l'illuminazione per pixel e la post-elaborazione.
ms.assetid: 09831B10-4FD1-41E7-8D81-5AA63DC90020
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 57142e9c32919a6959a7fac14bf544cca1dacd79
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104118194"
---
# <a name="pixel-shader-stage"></a><span data-ttu-id="f3b13-103">Fase pixel shader</span><span class="sxs-lookup"><span data-stu-id="f3b13-103">Pixel Shader Stage</span></span>

<span data-ttu-id="f3b13-104">La fase pixel shader (PS) consente tecniche di ombreggiatura avanzate, ad esempio l'illuminazione per pixel e la post-elaborazione.</span><span class="sxs-lookup"><span data-stu-id="f3b13-104">The pixel-shader stage (PS) enables rich shading techniques such as per-pixel lighting and post-processing.</span></span> <span data-ttu-id="f3b13-105">Un pixel shader è un programma che combina variabili costanti, dati di trama, valori interpolati per vertice e altri dati per produrre output per pixel.</span><span class="sxs-lookup"><span data-stu-id="f3b13-105">A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</span></span> <span data-ttu-id="f3b13-106">La fase di rasterizzazione richiama una pixel shader una volta per ogni pixel coperto da una primitiva, ma è possibile specificare uno shader **null** per evitare l'esecuzione di uno shader.</span><span class="sxs-lookup"><span data-stu-id="f3b13-106">The rasterizer stage invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a **NULL** shader to avoid running a shader.</span></span>

## <a name="the-pixel-shader"></a><span data-ttu-id="f3b13-107">Pixel shader</span><span class="sxs-lookup"><span data-stu-id="f3b13-107">The Pixel Shader</span></span>

<span data-ttu-id="f3b13-108">Quando si esegue il multicampionamento di una trama, viene richiamata una pixel shader una volta per ogni pixel, mentre si verifica un test di profondità/stencil per ogni multisample coperto.</span><span class="sxs-lookup"><span data-stu-id="f3b13-108">When multisampling a texture, a pixel shader is invoked once per-covered pixel while a depth/stencil test occurs for each covered multisample.</span></span> <span data-ttu-id="f3b13-109">Gli esempi che superano il test di profondità/stencil vengono aggiornati con il colore di output del pixel shader.</span><span class="sxs-lookup"><span data-stu-id="f3b13-109">Samples that pass the depth/stencil test are updated with the pixel shader output color.</span></span>

<span data-ttu-id="f3b13-110">Le funzioni intrinseche pixel shader producono o usano derivati di quantità rispetto allo spazio dello schermo x e y.</span><span class="sxs-lookup"><span data-stu-id="f3b13-110">The pixel shader intrinsic functions produce or use derivatives of quantities with respect to screen space x and y.</span></span> <span data-ttu-id="f3b13-111">L'uso più comune per i derivati consiste nel calcolare i calcoli del livello di dettaglio per il campionamento della trama e, nel caso del filtro anisotropico, selezionando esempi lungo l'asse di anisotropia.</span><span class="sxs-lookup"><span data-stu-id="f3b13-111">The most common use for derivatives is to compute level-of-detail calculations for texture sampling and in the case of anisotropic filtering, selecting samples along the axis of anisotropy.</span></span> <span data-ttu-id="f3b13-112">In genere, un'implementazione hardware esegue contemporaneamente un pixel shader su più pixel (ad esempio una griglia 2x2), in modo che i derivati delle quantità calcolate nel pixel shader possano essere ragionevolmente approssimati come Delta dei valori nello stesso punto di esecuzione in pixel adiacenti.</span><span class="sxs-lookup"><span data-stu-id="f3b13-112">Typically, a hardware implementation runs a pixel shader on multiple pixels (for example a 2x2 grid) simultaneously, so that derivatives of quantities computed in the pixel shader can be reasonably approximated as deltas of the values at the same point of execution in adjacent pixels.</span></span>

### <a name="inputs"></a><span data-ttu-id="f3b13-113">Input</span><span class="sxs-lookup"><span data-stu-id="f3b13-113">Inputs</span></span>

<span data-ttu-id="f3b13-114">Quando la pipeline viene configurata senza un geometry shader, un pixel shader è limitato a 16 input a 32 bit e a 4 componenti.</span><span class="sxs-lookup"><span data-stu-id="f3b13-114">When the pipeline is configured without a geometry shader, a pixel shader is limited to 16, 32-bit, 4-component inputs.</span></span> <span data-ttu-id="f3b13-115">In caso contrario, un pixel shader può richiedere fino a 32 input a 32 bit e a 4 componenti.</span><span class="sxs-lookup"><span data-stu-id="f3b13-115">Otherwise, a pixel shader can take up to 32, 32-bit, 4-component inputs.</span></span>

<span data-ttu-id="f3b13-116">I dati di input del pixel shader includono attributi di vertice (che possono essere interpolati con o senza correzione della prospettiva) oppure possono essere considerati come costanti per primitive.</span><span class="sxs-lookup"><span data-stu-id="f3b13-116">Pixel shader input data includes vertex attributes (that can be interpolated with or without perspective correction) or can be treated as per-primitive constants.</span></span> <span data-ttu-id="f3b13-117">Gli input del pixel shader vengono interpolati dagli attributi dei vertici della primitiva in fase di rasterizzazione, in base alla modalità di interpolazione dichiarata.</span><span class="sxs-lookup"><span data-stu-id="f3b13-117">Pixel shader inputs are interpolated from the vertex attributes of the primitive being rasterized, based on the interpolation mode declared.</span></span> <span data-ttu-id="f3b13-118">Se una primitiva viene ritagliata prima della rasterizzazione, la modalità di interpolazione viene rispettata anche durante il processo di ritaglio.</span><span class="sxs-lookup"><span data-stu-id="f3b13-118">If a primitive gets clipped before rasterization, the interpolation mode is honored during the clipping process as well.</span></span>

<span data-ttu-id="f3b13-119">Gli attributi vertici vengono interpolati (o valutati) in pixel shader Center Locations.</span><span class="sxs-lookup"><span data-stu-id="f3b13-119">Vertex attributes are interpolated (or evaluated) at pixel shader center locations.</span></span> <span data-ttu-id="f3b13-120">Le modalità di interpolazione degli attributi pixel shader sono dichiarate in una dichiarazione di registro di input, in base a ogni elemento in un [argomento](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) o una [struttura di input](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span><span class="sxs-lookup"><span data-stu-id="f3b13-120">Pixel shader attribute interpolation modes are declared in an input register declaration, on a per-element basis in either an [argument](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) or an [input structure](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span></span> <span data-ttu-id="f3b13-121">Gli attributi possono essere interpolati in modo lineare o con [campionamento](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx)del centro.</span><span class="sxs-lookup"><span data-stu-id="f3b13-121">Attributes can be interpolated linearly, or with [centroid sampling](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span></span> <span data-ttu-id="f3b13-122">La valutazione del centro è pertinente solo durante il campionamento multiplo per coprire i casi in cui un pixel è coperto da una primitiva, ma un pixel Center potrebbe non essere; la valutazione del baricentro si verifica il più vicino possibile al centro pixel (non coperto).</span><span class="sxs-lookup"><span data-stu-id="f3b13-122">Centroid evaluation is relevant only during multisampling to cover cases where a pixel is covered by a primitive but a pixel center may not be; centroid evaluation occurs as close as possible to the (non-covered) pixel center.</span></span>

<span data-ttu-id="f3b13-123">Gli input possono anche essere dichiarati con una [semantica del valore di sistema](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), che contrassegna un parametro utilizzato da altre fasi della pipeline.</span><span class="sxs-lookup"><span data-stu-id="f3b13-123">Inputs may also be declared with a [system-value semantic](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), which marks a parameter that is consumed by other pipeline stages.</span></span> <span data-ttu-id="f3b13-124">Ad esempio, la posizione di un pixel deve essere contrassegnata con la \_ semantica di posizione SV.</span><span class="sxs-lookup"><span data-stu-id="f3b13-124">For instance, a pixel position should be marked with the SV\_Position semantic.</span></span> <span data-ttu-id="f3b13-125">La fase IA può produrre un valore scalare per un pixel shader (usando SV \_ PrimitiveID); la fase di rasterizzazione può anche generare un valore scalare per una pixel shader (usando SV \_ IsFrontFace).</span><span class="sxs-lookup"><span data-stu-id="f3b13-125">The IA stage can produce one scalar for a pixel shader (using SV\_PrimitiveID); the rasterizer stage can also generate one scalar for a pixel shader (using SV\_IsFrontFace).</span></span>

### <a name="outputs"></a><span data-ttu-id="f3b13-126">Output</span><span class="sxs-lookup"><span data-stu-id="f3b13-126">Outputs</span></span>

<span data-ttu-id="f3b13-127">Un pixel shader può restituire colori fino a 8, a 32 bit, a 4 componenti o nessun colore se il pixel viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="f3b13-127">A pixel shader can output up to 8, 32-bit, 4-component colors, or no color if the pixel is discarded.</span></span> <span data-ttu-id="f3b13-128">I componenti del registro di output di pixel shader devono essere dichiarati prima di poter essere usati. a ogni registro è consentita una maschera di scrittura output distinta.</span><span class="sxs-lookup"><span data-stu-id="f3b13-128">Pixel shader output register components must be declared before they can be used; each register is allowed a distinct output-write mask.</span></span>

<span data-ttu-id="f3b13-129">Utilizzare lo stato Depth-Write-Enable (nella fase merge output) per controllare se i dati di profondità vengono scritti in un buffer di profondità (oppure utilizzare l'istruzione di eliminazione per eliminare i dati per tale pixel).</span><span class="sxs-lookup"><span data-stu-id="f3b13-129">Use the depth-write-enable state (in the output-merger stage) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel).</span></span> <span data-ttu-id="f3b13-130">Un pixel shader può anche restituire un valore facoltativo a virgola mobile a 32 bit, a 1 componente, a virgola mobile e di profondità per i test di profondità (usando la \_ semantica di profondità SV).</span><span class="sxs-lookup"><span data-stu-id="f3b13-130">A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV\_Depth semantic).</span></span> <span data-ttu-id="f3b13-131">Il valore depth viene restituito nel registro oDepth e sostituisce il valore di profondità interpolato per il test di profondità (presupponendo che i test di profondità siano abilitati).</span><span class="sxs-lookup"><span data-stu-id="f3b13-131">The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled).</span></span> <span data-ttu-id="f3b13-132">Non esiste alcun modo per cambiare dinamicamente tra l'uso della profondità della funzione fissa o dello shader oDepth.</span><span class="sxs-lookup"><span data-stu-id="f3b13-132">There is no way to dynamically change between using fixed-function depth or shader oDepth.</span></span>

<span data-ttu-id="f3b13-133">Un pixel shader non può restituire un valore di stencil.</span><span class="sxs-lookup"><span data-stu-id="f3b13-133">A pixel shader cannot output a stencil value.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f3b13-134">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="f3b13-134">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f3b13-135">Pipeline grafica</span><span class="sxs-lookup"><span data-stu-id="f3b13-135">Graphics Pipeline</span></span>](overviews-direct3d-11-graphics-pipeline.md)
</dt> <dt>

[<span data-ttu-id="f3b13-136">Fasi della pipeline (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="f3b13-136">Pipeline Stages (Direct3D 10)</span></span>](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

 