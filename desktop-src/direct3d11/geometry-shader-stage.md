---
title: Fase geometry shader
description: La fase geometry-shader (GS) esegue il codice shader specificato dall'applicazione con vertici come input e la possibilità di generare vertici nell'output.
ms.assetid: F3208862-980E-403F-9154-13B34A882787
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3099ed5ede8dd89dc607ed838ff6e3fabfb16a69
ms.sourcegitcommit: ca37395fd832e798375e81142b97cffcffabf184
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/24/2021
ms.locfileid: "110335365"
---
# <a name="geometry-shader-stage"></a><span data-ttu-id="998df-103">Fase geometry shader</span><span class="sxs-lookup"><span data-stu-id="998df-103">Geometry Shader Stage</span></span>

<span data-ttu-id="998df-104">La fase geometry-shader (GS) esegue il codice shader specificato dall'applicazione con vertici come input e la possibilità di generare vertici nell'output.</span><span class="sxs-lookup"><span data-stu-id="998df-104">The geometry-shader (GS) stage runs application-specified shader code with vertices as input and the ability to generate vertices on output.</span></span>

## <a name="the-geometry-shader"></a><span data-ttu-id="998df-105">The Geometry Shader</span><span class="sxs-lookup"><span data-stu-id="998df-105">The Geometry Shader</span></span>

<span data-ttu-id="998df-106">A differenza dei vertex shader, che operano su un singolo vertice, gli input del geometry shader sono i vertici per una primitiva completa (due vertici per le linee, tre vertici per i triangoli o un vertice singolo per il punto).</span><span class="sxs-lookup"><span data-stu-id="998df-106">Unlike vertex shaders, which operate on a single vertex, the geometry shader's inputs are the vertices for a full primitive (two vertices for lines, three vertices for triangles, or single vertex for point).</span></span> <span data-ttu-id="998df-107">Gli shader geometry possono anche inserire i dati dei vertici per le primitive adiacenti ai bordi come input (altri due vertici per una linea, altri tre per un triangolo).</span><span class="sxs-lookup"><span data-stu-id="998df-107">Geometry shaders can also bring in the vertex data for the edge-adjacent primitives as input (an additional two vertices for a line, an additional three for a triangle).</span></span> <span data-ttu-id="998df-108">La figura seguente mostra un triangolo e una linea con vertici adiacenti.</span><span class="sxs-lookup"><span data-stu-id="998df-108">The following illustration shows a triangle and a line with adjacent vertices.</span></span>

![illustrazione di un triangolo e di una linea con vertici adiacenti](images/d3d10-gs.png)

|     | <span data-ttu-id="998df-110">Tipo</span><span class="sxs-lookup"><span data-stu-id="998df-110">Type</span></span>                |
|-----|-----------------|
| <span data-ttu-id="998df-111">**TV**</span><span class="sxs-lookup"><span data-stu-id="998df-111">**TV**</span></span>  | <span data-ttu-id="998df-112">Vertice triangolare</span><span class="sxs-lookup"><span data-stu-id="998df-112">Triangle vertex</span></span> |
| <span data-ttu-id="998df-113">**Av**</span><span class="sxs-lookup"><span data-stu-id="998df-113">**AV**</span></span>  | <span data-ttu-id="998df-114">Vertice adiacente</span><span class="sxs-lookup"><span data-stu-id="998df-114">Adjacent vertex</span></span> |
| <span data-ttu-id="998df-115">**Lv**</span><span class="sxs-lookup"><span data-stu-id="998df-115">**LV**</span></span>  | <span data-ttu-id="998df-116">Vertice linea</span><span class="sxs-lookup"><span data-stu-id="998df-116">Line vertex</span></span>     |



 

<span data-ttu-id="998df-117">La fase geometry-shader può utilizzare il valore generato dal sistema SV \_ PrimitiveID generato automaticamente dall'IA. [](d3d10-graphics-programming-guide-input-assembler-stage-using.md)</span><span class="sxs-lookup"><span data-stu-id="998df-117">The geometry-shader stage can consume the SV\_PrimitiveID [system-generated value](d3d10-graphics-programming-guide-input-assembler-stage-using.md) that is auto-generated by the IA.</span></span> <span data-ttu-id="998df-118">Ciò consente di recuperare o calcolare i dati per primitivi, se lo si desidera.</span><span class="sxs-lookup"><span data-stu-id="998df-118">This allows per-primitive data to be fetched or computed if desired.</span></span>

<span data-ttu-id="998df-119">La fase geometry-shader è in grado di eseguire l'output di più vertici che formano una singola topologia selezionata (le topologie di output della fase GS disponibili sono: tristrip, linestrip e pointlist).</span><span class="sxs-lookup"><span data-stu-id="998df-119">The geometry-shader stage is capable of outputting multiple vertices forming a single selected topology (GS stage output topologies available are: tristrip, linestrip, and pointlist).</span></span> <span data-ttu-id="998df-120">Il numero di primitive emesse può variare liberamente all'interno di qualsiasi chiamata del geometry shader, anche se il numero massimo di vertici che possono essere generati deve essere dichiarato in modo statico.</span><span class="sxs-lookup"><span data-stu-id="998df-120">The number of primitives emitted can vary freely within any invocation of the geometry shader, though the maximum number of vertices that could be emitted must be declared statically.</span></span> <span data-ttu-id="998df-121">Le lunghezze di strip emesse da una chiamata geometry shader possono essere arbitrarie e le nuove strisce possono essere create tramite la funzione [RestartStrip](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-so-restartstrip) HLSL.</span><span class="sxs-lookup"><span data-stu-id="998df-121">Strip lengths emitted from a geometry shader invocation can be arbitrary, and new strips can be created via the [RestartStrip](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-so-restartstrip) HLSL function.</span></span>

<span data-ttu-id="998df-122">L'output dello shader geometry può essere alimentato alla fase del rasterizzatore e/o a un vertex buffer in memoria tramite la fase di output del flusso.</span><span class="sxs-lookup"><span data-stu-id="998df-122">Geometry shader output may be fed to the rasterizer stage and/or to a vertex buffer in memory via the stream output stage.</span></span> <span data-ttu-id="998df-123">L'output immesso in memoria viene espanso in singoli elenchi di punti/linee/triangoli (esattamente come verrebbero passati al rasterizzatore).</span><span class="sxs-lookup"><span data-stu-id="998df-123">Output fed to memory is expanded to individual point/line/triangle lists (exactly as they would be passed to the rasterizer).</span></span>

<span data-ttu-id="998df-124">Quando uno shader geometry è attivo, viene richiamato una volta per ogni primitiva passata o generata in precedenza nella pipeline.</span><span class="sxs-lookup"><span data-stu-id="998df-124">When a geometry shader is active, it is invoked once for every primitive passed down or generated earlier in the pipeline.</span></span> <span data-ttu-id="998df-125">Ogni chiamata dello shader geometry vede come input i dati per la primitiva di richiamo, sia che si tratta di un singolo punto, di una singola riga o di un singolo triangolo.</span><span class="sxs-lookup"><span data-stu-id="998df-125">Each invocation of the geometry shader sees as input the data for the invoking primitive, whether that is a single point, a single line, or a single triangle.</span></span> <span data-ttu-id="998df-126">Una striscia di triangoli precedente nella pipeline comporta una chiamata dello shader geometrico per ogni singolo triangolo nella striscia (come se la striscia fosse espansa in un elenco di triangoli).</span><span class="sxs-lookup"><span data-stu-id="998df-126">A triangle strip from earlier in the pipeline would result in an invocation of the geometry shader for each individual triangle in the strip (as if the strip were expanded out into a triangle list).</span></span> <span data-ttu-id="998df-127">Sono disponibili tutti i dati di input per ogni vertice nella singola primitiva (ad esempio 3 vertici per il triangolo), più i dati dei vertici adiacenti, se applicabile/disponibili.</span><span class="sxs-lookup"><span data-stu-id="998df-127">All the input data for each vertex in the individual primitive is available (i.e. 3 vertices for triangle), plus adjacent vertex data if applicable/available.</span></span>

<span data-ttu-id="998df-128">Un geometry shader restituisce i dati un vertice alla volta aggiungendo i vertici a un oggetto flusso di output.</span><span class="sxs-lookup"><span data-stu-id="998df-128">A geometry shader outputs data one vertex at a time by appending vertices to an output stream object.</span></span> <span data-ttu-id="998df-129">La topologia dei flussi è determinata da una dichiarazione fissa, scegliendo una delle seguenti: PointStream, LineStream o TriangleStream come output per la fase GS.</span><span class="sxs-lookup"><span data-stu-id="998df-129">The topology of the streams is determined by a fixed declaration, choosing one of: PointStream, LineStream, or TriangleStream as the output for the GS stage.</span></span> <span data-ttu-id="998df-130">Sono disponibili tre tipi di oggetti flusso, PointStream, LineStream e TriangleStream, che sono tutti oggetti modello.</span><span class="sxs-lookup"><span data-stu-id="998df-130">There are three types of stream objects available, PointStream, LineStream and TriangleStream which are all templated objects.</span></span> <span data-ttu-id="998df-131">La topologia dell'output è determinata dal rispettivo tipo di oggetto, mentre il formato dei vertici aggiunti al flusso è determinato dal tipo di modello.</span><span class="sxs-lookup"><span data-stu-id="998df-131">The topology of the output is determined by their respective object type, while the format of the vertices appended to the stream is determined by the template type.</span></span> <span data-ttu-id="998df-132">L'esecuzione di un'istanza geometry shader è atomica da altre chiamate, ad eccezione del fatto che i dati aggiunti ai flussi sono seriali.</span><span class="sxs-lookup"><span data-stu-id="998df-132">Execution of a geometry shader instance is atomic from other invocations, except that data added to the streams is serial.</span></span> <span data-ttu-id="998df-133">Gli output di una determinata chiamata di un geometry shader sono indipendenti dalle altre chiamate (anche se l'ordinamento viene rispettato).</span><span class="sxs-lookup"><span data-stu-id="998df-133">The outputs of a given invocation of a geometry shader are independent of other invocations (though ordering is respected).</span></span> <span data-ttu-id="998df-134">Un geometry shader che genera strisce di triangoli inizierà una nuova striscia a ogni chiamata.</span><span class="sxs-lookup"><span data-stu-id="998df-134">A geometry shader generating triangle strips will start a new strip on every invocation.</span></span>

<span data-ttu-id="998df-135">Quando un output di geometry shader viene identificato come valore interpretato dal sistema (ad esempio, SV RenderTargetArrayIndex o SV Position), l'hardware esamina questi dati ed esegue un comportamento dipendente dal valore, oltre a poter passare i dati stessi alla fase successiva dello shader per \_ \_ l'input.</span><span class="sxs-lookup"><span data-stu-id="998df-135">When a geometry shader output is identified as a System Interpreted Value (e.g. SV\_RenderTargetArrayIndex or SV\_Position), hardware looks at this data and performs some behavior dependent on the value, in addition to being able to pass the data itself to the next shader stage for input.</span></span> <span data-ttu-id="998df-136">Quando l'output di questi dati dal geometry shader ha significato per l'hardware in base alla primitiva (ad esempio SV RenderTargetArrayIndex o SV ViewportArrayIndex), anziché per ogni vertice (ad esempio \_ \_ SV \_ ClipDistance n o SV Position), i dati per primitiva vengono presi dal vertice iniziale emesso per la \[ \] \_ primitiva.</span><span class="sxs-lookup"><span data-stu-id="998df-136">When such data output from the geometry shader has meaning to the hardware on a per-primitive basis (such as SV\_RenderTargetArrayIndex or SV\_ViewportArrayIndex), rather than on a per-vertex basis (such as SV\_ClipDistance\[n\] or SV\_Position), the per-primitive data is taken from the leading vertex emitted for the primitive.</span></span>

<span data-ttu-id="998df-137">Le primitive parzialmente completate potrebbero essere generate dallo shader geometry se il geometry shader termina e la primitiva è incompleta.</span><span class="sxs-lookup"><span data-stu-id="998df-137">Partially completed primitives could be generated by the geometry shader if the geometry shader ends and the primitive is incomplete.</span></span> <span data-ttu-id="998df-138">Le primitive incomplete vengono ignorate automaticamente.</span><span class="sxs-lookup"><span data-stu-id="998df-138">Incomplete primitives are silently discarded.</span></span> <span data-ttu-id="998df-139">Questo è simile al modo in cui l'IA tratta le primitive parzialmente completate.</span><span class="sxs-lookup"><span data-stu-id="998df-139">This is similar to the way the IA treats partially completed primitives.</span></span>

<span data-ttu-id="998df-140">Lo shader geometry può eseguire operazioni di campionamento del carico e della trama in cui non sono necessari derivati dello spazio dello schermo (samplelevel, samplecmplevelzero, samplegrad).</span><span class="sxs-lookup"><span data-stu-id="998df-140">The geometry shader can perform load and texture sampling operations where screen-space derivatives are not required (samplelevel, samplecmplevelzero, samplegrad).</span></span>

<span data-ttu-id="998df-141">Gli algoritmi che possono essere implementati nello shader geometry includono:</span><span class="sxs-lookup"><span data-stu-id="998df-141">Algorithms that can be implemented in the geometry shader include:</span></span>

-   <span data-ttu-id="998df-142">Espansione point Sprite</span><span class="sxs-lookup"><span data-stu-id="998df-142">Point Sprite Expansion</span></span>
-   <span data-ttu-id="998df-143">Sistemi di particelle dinamiche</span><span class="sxs-lookup"><span data-stu-id="998df-143">Dynamic Particle Systems</span></span>
-   <span data-ttu-id="998df-144">Generazione di fur/fin</span><span class="sxs-lookup"><span data-stu-id="998df-144">Fur/Fin Generation</span></span>
-   <span data-ttu-id="998df-145">Generazione di volumi shadow</span><span class="sxs-lookup"><span data-stu-id="998df-145">Shadow Volume Generation</span></span>
-   <span data-ttu-id="998df-146">Single Pass Render-to-Cubemap</span><span class="sxs-lookup"><span data-stu-id="998df-146">Single Pass Render-to-Cubemap</span></span>
-   <span data-ttu-id="998df-147">Per-Primitive scambio di materiali</span><span class="sxs-lookup"><span data-stu-id="998df-147">Per-Primitive Material Swapping</span></span>
-   <span data-ttu-id="998df-148">Per-Primitive material setup : inclusa la generazione di coordinate barycentriche come dati primitivi in modo che un pixel shader possa eseguire l'interpolazione di attributi personalizzati (per un esempio di interpolazione normale di ordine superiore, vedere [CubeMapGS Sample](https://msdn.microsoft.com/library/Ee416398(v=VS.85).aspx)).</span><span class="sxs-lookup"><span data-stu-id="998df-148">Per-Primitive Material Setup - Including generation of barycentric coordinates as primitive data so that a pixel shader can perform custom attribute interpolation (for an example of higher-order normal interpolation, see [CubeMapGS Sample](https://msdn.microsoft.com/library/Ee416398(v=VS.85).aspx)).</span></span>

## <a name="related-topics"></a><span data-ttu-id="998df-149">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="998df-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="998df-150">Pipeline grafica</span><span class="sxs-lookup"><span data-stu-id="998df-150">Graphics Pipeline</span></span>](overviews-direct3d-11-graphics-pipeline.md)
</dt> <dt>

[<span data-ttu-id="998df-151">Fasi della pipeline (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="998df-151">Pipeline Stages (Direct3D 10)</span></span>](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

 