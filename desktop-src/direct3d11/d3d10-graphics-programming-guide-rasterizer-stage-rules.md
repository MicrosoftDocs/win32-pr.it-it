---
title: Regole di rasterizzazione
description: Le regole di rasterizzazione definiscono la modalità di mapping dei dati vettoriali nei dati raster.
ms.assetid: 2b3894eb-dff3-401f-8b14-4af98db86e39
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e256c6fc171c1cce9b63b79fac6a480e507a306e
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/20/2020
ms.locfileid: "104399060"
---
# <a name="rasterization-rules"></a><span data-ttu-id="e8d4b-103">Regole di rasterizzazione</span><span class="sxs-lookup"><span data-stu-id="e8d4b-103">Rasterization Rules</span></span>

<span data-ttu-id="e8d4b-104">Le regole di rasterizzazione definiscono la modalità di mapping dei dati vettoriali nei dati raster.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-104">Rasterization rules define how vector data is mapped into raster data.</span></span> <span data-ttu-id="e8d4b-105">I dati raster vengono bloccati in posizioni intere che vengono quindi rimosse e ritagliate (per tracciare il numero minimo di pixel) e gli attributi per pixel vengono interpolati (dagli attributi per vertice) prima di essere passati a una pixel shader.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-105">The raster data is snapped to integer locations that are then culled and clipped (to draw the minimum number of pixels), and per-pixel attributes are interpolated (from per-vertex attributes) before being passed to a pixel shader.</span></span>

<span data-ttu-id="e8d4b-106">Esistono diversi tipi di regole, che dipendono dal tipo di primitivo di cui è in corso il mapping, nonché dal fatto che i dati utilizzino il campionamento multiplo per ridurre l'aliasing.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-106">There are several types of rules, which depend on the type of primitive that is being mapped, as well as whether or not the data uses multisampling to reduce aliasing.</span></span> <span data-ttu-id="e8d4b-107">Nelle illustrazioni seguenti viene illustrato come vengono gestiti i casi d'angolo.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-107">The following illustrations demonstrate how the corner cases are handled.</span></span>

-   [<span data-ttu-id="e8d4b-108">Regole di rasterizzazione triangolari (senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-108">Triangle Rasterization Rules (Without Multisampling)</span></span>](#triangle-rasterization-rules-without-multisampling)
-   [<span data-ttu-id="e8d4b-109">Regole di rasterizzazione delle righe (con alias, senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-109">Line Rasterization Rules (Aliased, Without Multisampling)</span></span>](#line-rasterization-rules-aliased-without-multisampling)
-   [<span data-ttu-id="e8d4b-110">Regole di rasterizzazione delle righe (antialiasing, senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-110">Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>](#line-rasterization-rules-antialiased-without-multisampling)
-   [<span data-ttu-id="e8d4b-111">Regole di rasterizzazione punti (senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-111">Point Rasterization Rules (Without Multisampling)</span></span>](#point-rasterization-rules-without-multisampling)
-   [<span data-ttu-id="e8d4b-112">Regole di rasterizzazione di anti-aliasing multicampionamento</span><span class="sxs-lookup"><span data-stu-id="e8d4b-112">Multisample Anti-Aliasing Rasterization Rules</span></span>](#multisample-anti-aliasing-rasterization-rules)
    -   [<span data-ttu-id="e8d4b-113">Supporto hardware</span><span class="sxs-lookup"><span data-stu-id="e8d4b-113">Hardware Support</span></span>](#hardware-support)
    -   [<span data-ttu-id="e8d4b-114">Campionamento centrale degli attributi durante l'anti-aliasing di multicampionamento</span><span class="sxs-lookup"><span data-stu-id="e8d4b-114">Centroid Sampling of Attributes when Multisample Antialiasing</span></span>](#centroid-sampling-of-attributes-when-multisample-antialiasing)
    -   [<span data-ttu-id="e8d4b-115">Calcoli derivati durante il campionamento multiplo</span><span class="sxs-lookup"><span data-stu-id="e8d4b-115">Derivative Calculations When Multisampling</span></span>](#derivative-calculations-when-multisampling)
-   [<span data-ttu-id="e8d4b-116">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="e8d4b-116">Related topics</span></span>](#related-topics)

## <a name="triangle-rasterization-rules-without-multisampling"></a><span data-ttu-id="e8d4b-117">Regole di rasterizzazione triangolari (senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-117">Triangle Rasterization Rules (Without Multisampling)</span></span>

<span data-ttu-id="e8d4b-118">Ogni pixel Center che si trova all'interno di un triangolo viene disegnato; si presuppone che un pixel si trovi all'interno di se passa la regola in alto a sinistra.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-118">Any pixel center which falls inside a triangle is drawn; a pixel is assumed to be inside if it passes the top-left rule.</span></span> <span data-ttu-id="e8d4b-119">La regola in alto a sinistra è la definizione di un pixel Center che si trova all'interno di un triangolo se si trova sul bordo superiore o sul bordo sinistro di un triangolo.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-119">The top-left rule is that a pixel center is defined to lie inside of a triangle if it lies on the top edge or the left edge of a triangle.</span></span>

<span data-ttu-id="e8d4b-120">Dove:</span><span class="sxs-lookup"><span data-stu-id="e8d4b-120">Where:</span></span>

-   <span data-ttu-id="e8d4b-121">Un bordo superiore è un bordo esattamente orizzontale ed è sopra gli altri bordi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-121">A top edge, is an edge that is exactly horizontal and is above the other edges.</span></span>
-   <span data-ttu-id="e8d4b-122">Un bordo sinistro è un bordo che non è esattamente orizzontale e si trova sul lato sinistro del triangolo.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-122">A left edge, is an edge that is not exactly horizontal and is on the left side of the triangle.</span></span> <span data-ttu-id="e8d4b-123">Un triangolo può avere uno o due bordi A sinistra.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-123">A triangle can have one or two left edges.</span></span>

<span data-ttu-id="e8d4b-124">La regola in alto a sinistra garantisce che i triangoli adiacenti vengano disegnati una sola volta.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-124">The top-left rule ensures that adjacent triangles are drawn once.</span></span>

<span data-ttu-id="e8d4b-125">Questa illustrazione mostra esempi di pixel che vengono disegnati perché si trovano all'interno di un triangolo o seguono la regola in alto a sinistra.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-125">This illustration shows examples of pixels that are drawn because they either lie inside a triangle or follow the top-left rule.</span></span>

![illustrazione degli esempi di rasterizzazione del triangolo superiore sinistro](images/d3d10-rasterrulestriangle.png)

<span data-ttu-id="e8d4b-127">Il rivestimento grigio chiaro e scuro dei pixel li Mostra come gruppi di pixel per indicare il triangolo in cui si trovano.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-127">The light and dark gray covering of the pixels show them as groups of the pixels to indicate which triangle they are inside.</span></span>

## <a name="line-rasterization-rules-aliased-without-multisampling"></a><span data-ttu-id="e8d4b-128">Regole di rasterizzazione delle righe (con alias, senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-128">Line Rasterization Rules (Aliased, Without Multisampling)</span></span>

<span data-ttu-id="e8d4b-129">Le regole di rasterizzazione delle righe utilizzano un'area di test di diamanti per determinare se una linea copre un pixel.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-129">Line rasterization rules use a diamond test area to determine if a line covers a pixel.</span></span> <span data-ttu-id="e8d4b-130">Per le righe x-Major (righe con-1 <= Slope <= + 1), l'area di test Diamond include (mostrata Solid) il bordo inferiore sinistro, il bordo inferiore destro e l'angolo inferiore; il rombo esclude (visualizzato punteggiato) il bordo superiore sinistro, il bordo superiore destro, il cordoncino superiore, l'angolo sinistro e l'angolo destro.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-130">For x-major lines (lines with -1 <= slope <= +1), the diamond test area includes (shown solid) the lower-left edge, lower-right edge, and bottom corner; the diamond excludes (shown dotted) the upper-left edge, upper-right edge, the top corder, the left corner, and the right corner.</span></span> <span data-ttu-id="e8d4b-131">Una riga y-Major è una riga che non è una linea x-Major; l'area dei diamanti del test è uguale a quella descritta per la riga x-Major, a eccezione dell'angolo destro.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-131">A y-major line is any line that is not an x-major line; the test diamond area is the same as described for the x-major line except the right corner is also included.</span></span>

<span data-ttu-id="e8d4b-132">Data l'area Diamond, una linea copre un pixel se la riga esce dall'area di test del rombo del pixel quando si viaggia lungo la linea dall'inizio verso la fine.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-132">Given the diamond area, a line covers a pixel if the line exits the pixel's diamond test area when traveling along the line from the start towards the end.</span></span> <span data-ttu-id="e8d4b-133">Una striscia di linea si comporta allo stesso modo, poiché viene disegnata come una sequenza di righe.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-133">A line strip behaves the same, as it is drawn as a sequence of lines.</span></span>

<span data-ttu-id="e8d4b-134">Nella figura seguente vengono illustrati alcuni esempi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-134">The following illustration shows some examples.</span></span>

![illustrazione degli esempi di rasterizzazione di righe con alias](images/d3d10-rasterrulesline.png)

## <a name="line-rasterization-rules-antialiased-without-multisampling"></a><span data-ttu-id="e8d4b-136">Regole di rasterizzazione delle righe (antialiasing, senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-136">Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>

<span data-ttu-id="e8d4b-137">Una linea con antialias viene rasterizzata come se fosse un rettangolo (con larghezza = 1).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-137">An antialiased line is rasterized as if it were a rectangle (with width = 1).</span></span> <span data-ttu-id="e8d4b-138">Il rettangolo si interseca con una destinazione di rendering che produce valori di code coverage per pixel, moltiplicati in pixel shader componenti alfa di output.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-138">The rectangle intersects with a render target producing per-pixel coverage values, which are multiplied into pixel shader output alpha components.</span></span> <span data-ttu-id="e8d4b-139">Quando si disegnano linee in una destinazione di rendering multicampionata, non è presente alcun anti-aliasing.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-139">There is no antialiasing preformed when drawing lines on a multisampled render target.</span></span>

<span data-ttu-id="e8d4b-140">Si ritiene che non esista un unico modo "migliore" per eseguire il rendering di linee con anti-aliasing.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-140">It is deemed that there is no single "best" way to perform antialiased line rendering.</span></span> <span data-ttu-id="e8d4b-141">Direct3D 10 adotta come linea guida il metodo illustrato nella figura seguente.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-141">Direct3D 10 adopts as a guideline the method shown in the following illustration.</span></span> <span data-ttu-id="e8d4b-142">Questo metodo è stato derivato empiricamente, mostrando un certo numero di proprietà visive ritenute desiderabili.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-142">This method was derived empirically, exhibiting a number of visual properties deemed desirable.</span></span> <span data-ttu-id="e8d4b-143">L'hardware non deve corrispondere esattamente a questo algoritmo; i test rispetto a questo riferimento avranno tolleranze "ragionevoli", seguiti da alcuni dei principi elencati più avanti, permettendo diverse implementazioni hardware e filtrare le dimensioni del kernel.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-143">Hardware need not exactly match this algorithm; tests against this reference shall have "reasonable" tolerances, guided by some of the principles listed further below, permitting various hardware implementations and filter kernel sizes.</span></span> <span data-ttu-id="e8d4b-144">Nessuna di questa flessibilità consentita nell'implementazione dell'hardware, tuttavia, può essere comunicata attraverso Direct3D 10 alle applicazioni, oltre a disegnare semplicemente linee e osservare/misurare il modo in cui appaiono.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-144">None of this flexibility permitted in hardware implementation, however, can be communicated up through Direct3D 10 to applications, beyond simply drawing lines and observing/measuring how they look.</span></span>

![illustrazione degli esempi di rasterizzazione di linee con anti-aliasing](images/d3d10-rasterruleslineaa.png)

<span data-ttu-id="e8d4b-146">Questo algoritmo genera linee relativamente smussate, con intensità uniforme, con bordi o trecce minime.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-146">This algorithm generates relatively smooth lines, with uniform intensity, with minimal jagged edges or braiding.</span></span> <span data-ttu-id="e8d4b-147">La modellazione dell'effetto moiré per le linee di chiusura è ridotta a icona.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-147">Moire patterning for close lines is minimized.</span></span> <span data-ttu-id="e8d4b-148">Esiste una corretta copertura per le giunzioni tra segmenti di linea posizionati end-to-end.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-148">There is good coverage for junctions between line segments placed end-to-end.</span></span> <span data-ttu-id="e8d4b-149">Il kernel di filtro è un ragionevole compromesso tra la quantità di sfocatura perimetrale e le modifiche di intensità causata da correzioni gamma.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-149">The filter kernel is a reasonable tradeoff between the amount of edge blurring and the changes in intensity caused by gamma corrections.</span></span> <span data-ttu-id="e8d4b-150">Il valore di code coverage viene moltiplicato in pixel shader o0. a (srcAlpha) per la formula seguente dalla fase di Unione dell'output: srcColor \* srcAlpha + destColor \* (1-srcAlpha).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-150">The coverage value is multiplied into pixel shader o0.a (srcAlpha) per the following formula by the output-merger stage: srcColor \* srcAlpha + destColor \* (1-srcAlpha).</span></span>

## <a name="point-rasterization-rules-without-multisampling"></a><span data-ttu-id="e8d4b-151">Regole di rasterizzazione punti (senza campionamento multiplo)</span><span class="sxs-lookup"><span data-stu-id="e8d4b-151">Point Rasterization Rules (Without Multisampling)</span></span>

<span data-ttu-id="e8d4b-152">Un punto viene interpretato come se fosse costituito da due triangoli in un modello Z, che usano le regole di rasterizzazione dei triangoli.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-152">A point is interpreted as though it were composed of two triangles in a Z pattern, which use triangle rasterization rules.</span></span> <span data-ttu-id="e8d4b-153">La coordinata identifica il centro di un quadrato in larghezza di un pixel.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-153">The coordinate identifies the center of a one pixel wide square.</span></span> <span data-ttu-id="e8d4b-154">Non esiste alcun abbattimento per i punti.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-154">There is no culling for points.</span></span>

<span data-ttu-id="e8d4b-155">Nella figura seguente vengono illustrati alcuni esempi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-155">The following illustration shows some examples.</span></span>

![illustrazione degli esempi di rasterizzazione dei punti](images/d3d10-rasterrulespoint.png)

## <a name="multisample-anti-aliasing-rasterization-rules"></a><span data-ttu-id="e8d4b-157">Regole di rasterizzazione di anti-aliasing multicampionamento</span><span class="sxs-lookup"><span data-stu-id="e8d4b-157">Multisample Anti-Aliasing Rasterization Rules</span></span>

<span data-ttu-id="e8d4b-158">L'anti-aliasing di multicampionamento consente di ridurre gli alias di geometria usando il code coverage dei pixel e i test di stencil depth in più percorsi di sottocampionamento.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-158">Multisample antialiasing (MSAA) reduces geometry aliasing using pixel coverage and depth-stencil tests at multiple sub-sample locations.</span></span> <span data-ttu-id="e8d4b-159">Per migliorare le prestazioni, i calcoli per pixel vengono eseguiti una volta per ogni pixel coperto, condividendo gli output dello shader tra i sub-pixel coperti.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-159">To improve performance, per-pixel calculations are performed once for each covered pixel, by sharing shader outputs across covered sub-pixels.</span></span> <span data-ttu-id="e8d4b-160">L'anti-aliasing multicampionamento non riduce l'aliasing della superficie.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-160">Multisample antialiasing does not reduce surface aliasing.</span></span> <span data-ttu-id="e8d4b-161">Le posizioni di esempio e le funzioni di ricostruzione dipendono dall'implementazione dell'hardware.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-161">Sample locations and reconstruction functions are dependent on the hardware implementation.</span></span>

<span data-ttu-id="e8d4b-162">Nella figura seguente vengono illustrati alcuni esempi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-162">The following illustration shows some examples.</span></span>

![illustrazione degli esempi di rasterizzazione antialias multicampionamento](images/d3d10-rasterrulesmsaa.png)

<span data-ttu-id="e8d4b-164">Il numero di percorsi di esempio dipende dalla modalità multicampionamento.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-164">The number of sample locations is dependent on the multisample mode.</span></span> <span data-ttu-id="e8d4b-165">Gli attributi dei vertici vengono interpolati in pixel Center, perché si tratta del punto in cui viene richiamata la pixel shader (questo diventa un'estrapolazione se il centro non viene analizzato).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-165">Vertex attributes are interpolated at pixel centers, since this is where the pixel shader is invoked (this becomes extrapolation if the center is not covered).</span></span> <span data-ttu-id="e8d4b-166">Gli attributi possono essere contrassegnati nel pixel shader come centro campionato, che fa sì che i pixel non coperti interpolano l'attributo all'intersezione dell'area del pixel e della primitiva.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-166">Attributes can be flagged in the pixel shader to be centroid sampled, which causes non-covered pixels to interpolate the attribute at intersection of the pixel's area and the primitive.</span></span> <span data-ttu-id="e8d4b-167">Viene eseguito un pixel shader per ogni area del pixel 2x2 per supportare calcoli derivati (che usano Delta x e y).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-167">A pixel shader runs for each 2x2 pixel area to support derivative calculations (which use x and y deltas).</span></span> <span data-ttu-id="e8d4b-168">Ciò significa che le chiamate dello shader si verificano più di quanto venga visualizzato per compilare il numero minimo di 2x2, che è indipendente dal campionamento multiplo.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-168">This means that shader invocations occur more than is shown to fill out the minimum 2x2 quanta (which is independent of multisampling).</span></span> <span data-ttu-id="e8d4b-169">Il risultato dello shader viene scritto per ogni esempio coperto che supera il test di stencil profondità per campione.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-169">The shader result is written out for each covered sample that passes the per-sample depth-stencil test.</span></span>

<span data-ttu-id="e8d4b-170">Le regole di rasterizzazione per le primitive sono, in generale, invariate dall'anti-aliasing multicampione, tranne:</span><span class="sxs-lookup"><span data-stu-id="e8d4b-170">Rasterization rules for primitives are, in general, unchanged by multisample antialiasing, except:</span></span>

-   <span data-ttu-id="e8d4b-171">Per un triangolo, viene eseguito un test di code coverage per ogni posizione di esempio (non per un pixel Center).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-171">For a triangle, a coverage test is performed for each sample location (not for a pixel center).</span></span> <span data-ttu-id="e8d4b-172">Se viene analizzato più di un percorso di esempio, un pixel shader viene eseguito una volta con gli attributi interpolati al centro pixel.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-172">If more than one sample location is covered, a pixel shader runs once with attributes interpolated at the pixel center.</span></span> <span data-ttu-id="e8d4b-173">Il risultato viene archiviato (replicato) per ogni percorso di esempio coperto nel pixel che supera il test di profondità/stencil.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-173">The result is stored (replicated) for each covered sample location in the pixel that passes the depth/stencil test.</span></span>

    <span data-ttu-id="e8d4b-174">Una linea viene considerata come un rettangolo costituito da due triangoli, con una lunghezza di riga di 1,4.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-174">A line is treated as a rectangle made up of two triangles, with a line width of 1.4.</span></span>

-   <span data-ttu-id="e8d4b-175">Per un punto, viene eseguito un test di code coverage per ogni percorso di esempio (non per un pixel Center).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-175">For a point, a coverage test is performed for each sample location (not for a pixel center).</span></span>

<span data-ttu-id="e8d4b-176">Molti formati supportano il campionamento multiplo (vedere [supporto hardware per i formati Direct3D 10](/previous-versions//cc627090(v=vs.85))). è possibile risolvere alcuni formati ([**ResolveSubresource**](/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource), che downsampling delle un formato multicampionato a una dimensione di esempio di 1).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-176">Many formats support multisampling (see [Hardware Support for Direct3D 10 Formats](/previous-versions//cc627090(v=vs.85))), some formats can be resolved ([**ResolveSubresource**](/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource); which downsamples a multisampled format to a sample size of 1).</span></span> <span data-ttu-id="e8d4b-177">I formati di campionamento multiplo possono essere usati nelle destinazioni di rendering che possono essere letti in shader usando [Load](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load), perché non è richiesta alcuna risoluzione per i singoli esempi a cui si accede dallo shader.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-177">Multisampling formats can be used in render targets which can be read back into shaders using [load](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load), since no resolve is required for individual samples accessed by the shader.</span></span> <span data-ttu-id="e8d4b-178">I formati di profondità non sono supportati per la risorsa multisample, quindi i formati di profondità sono limitati solo alle destinazioni di rendering.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-178">Depth formats are not supported for multisample resource, therefore, depth formats are restricted to render targets only.</span></span>

<span data-ttu-id="e8d4b-179">I formati con tipi (R8G8B8A8 \_ , ad esempio) supportano il campionamento multiplo per consentire a una visualizzazione risorse di interpretare i dati in modi diversi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-179">Typeless formats (R8G8B8A8\_TYPELESS for instance) support multisampling to allow a resource view to interpret data in different ways.</span></span> <span data-ttu-id="e8d4b-180">Ad esempio, è possibile creare una risorsa multisample usando il \_ tipo R8G8B8A8, eseguirne il rendering usando una risorsa render-target-View con un \_ formato R8G8B8A8 uint, quindi risolvere il contenuto in un'altra risorsa con un \_ formato dati R8G8B8A8 UNORM.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-180">For instance, you could create a multisample resource using R8G8B8A8\_TYPELESS, render to it using a render-target-view resource with a R8G8B8A8\_UINT format, then resolve the contents to another resource with a R8G8B8A8\_UNORM data format.</span></span>

### <a name="hardware-support"></a><span data-ttu-id="e8d4b-181">Supporto hardware</span><span class="sxs-lookup"><span data-stu-id="e8d4b-181">Hardware Support</span></span>

<span data-ttu-id="e8d4b-182">L'API segnala il supporto hardware per il campionamento multiplo attraverso il numero di livelli qualitativi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-182">The API reports hardware support for multisampling through the number of quality levels.</span></span> <span data-ttu-id="e8d4b-183">Ad esempio, un livello di qualità 0 indica che l'hardware non supporta il campionamento multiplo (con un formato e un livello di qualità particolari).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-183">For example, a 0 quality level means the hardware does not support multisampling (at a particular format and quality level).</span></span> <span data-ttu-id="e8d4b-184">3 per i livelli di qualità significa che l'hardware supporta tre diversi layout di esempio e/o Risolvi gli algoritmi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-184">A 3 for quality levels means that the hardware supports three different sample layouts and/or resolve algorithms.</span></span> <span data-ttu-id="e8d4b-185">È anche possibile presupporre quanto segue:</span><span class="sxs-lookup"><span data-stu-id="e8d4b-185">You can also assume the following:</span></span>

-   <span data-ttu-id="e8d4b-186">Qualsiasi formato che supporta il campionamento multiplo supporta lo stesso numero di livelli di qualità per ogni formato di tale famiglia.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-186">Any format that supports multisampling, supports the same number of quality levels for every format in that family.</span></span>
-   <span data-ttu-id="e8d4b-187">Ogni formato che supporta il campionamento multiplo e presenta i \_ formati UNORM, \_ sRGB, \_ russa o \_ float, supporta anche la risoluzione.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-187">Every format that supports multisampling, and has the \_UNORM, \_SRGB, \_SNORM or \_FLOAT formats, also supports resolving.</span></span>

### <a name="centroid-sampling-of-attributes-when-multisample-antialiasing"></a><span data-ttu-id="e8d4b-188">Campionamento centrale degli attributi durante l'anti-aliasing di multicampionamento</span><span class="sxs-lookup"><span data-stu-id="e8d4b-188">Centroid Sampling of Attributes when Multisample Antialiasing</span></span>

<span data-ttu-id="e8d4b-189">Per impostazione predefinita, gli attributi dei vertici vengono interpolati in un centro pixel durante l'anti-aliasing di multicampionamento. Se il pixel Center non viene analizzato, gli attributi vengono estrapolati in un centro pixel.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-189">By default, vertex attributes are interpolated to a pixel center during multisample antialiasing; if the pixel center is not covered, attributes are extrapolated to a pixel center.</span></span> <span data-ttu-id="e8d4b-190">Se un pixel shader input che contiene la semantica del centro (presupponendo che il pixel non è completamente coperto) verrà campionato in un punto all'interno dell'area coperta del pixel, possibilmente in una delle posizioni di esempio coperte.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-190">If a pixel shader input that contains the centroid semantic (assuming the pixel is not fully covered) will be sampled somewhere within the covered area of the pixel, possibly at one of the covered sample locations.</span></span> <span data-ttu-id="e8d4b-191">Una maschera di esempio (specificata dallo stato di rasterizzazione) viene applicata prima del calcolo del baricentro.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-191">A sample mask (specified by the rasterizer state) is applied prior to centroid computation.</span></span> <span data-ttu-id="e8d4b-192">Pertanto, un campione mascherato non verrà usato come posizione centrale.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-192">Therefore, a sample that is masked out will not be used as a centroid location.</span></span>

<span data-ttu-id="e8d4b-193">L'rasterizzatore di riferimento sceglie un percorso di esempio per il campionamento del baricentro simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="e8d4b-193">The reference rasterizer chooses a sample location for centroid sampling similar to this:</span></span>

-   <span data-ttu-id="e8d4b-194">La maschera di esempio consente tutti gli esempi.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-194">The sample mask allows all samples.</span></span> <span data-ttu-id="e8d4b-195">Usare un pixel Center se il pixel è coperto o se nessuno degli esempi è coperto.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-195">Use a pixel center if the pixel is covered or if none of the samples are covered.</span></span> <span data-ttu-id="e8d4b-196">In caso contrario, viene scelto il primo campione incluso, a partire dal centro pixel e spostandosi verso l'esterno.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-196">Otherwise, the first covered sample is chosen, starting from the pixel center and moving outward.</span></span>
-   <span data-ttu-id="e8d4b-197">La maschera di esempio disattiva tutti gli esempi, ma uno (uno scenario comune).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-197">The sample mask turns off all samples but one (a common scenario).</span></span> <span data-ttu-id="e8d4b-198">Un'applicazione può implementare il supercampionamento MultiPASS scorrendo i valori della maschera di esempio a singolo bit ed eseguendo nuovamente il rendering della scena per ogni esempio usando il campionamento del centro.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-198">An application can implement multipass supersampling by cycling through single-bit sample-mask values and re-rendering the scene for each sample using centroid sampling.</span></span> <span data-ttu-id="e8d4b-199">Per questa operazione è necessario che un'applicazione modifichi i derivati per selezionare la texture MIPS più dettagliata in modo appropriato per una maggiore densità di campionamento della trama.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-199">This would require that an application adjust derivatives to select appropriately more detailed texture mips for the higher texture sampling density.</span></span>

### <a name="derivative-calculations-when-multisampling"></a><span data-ttu-id="e8d4b-200">Calcoli derivati durante il campionamento multiplo</span><span class="sxs-lookup"><span data-stu-id="e8d4b-200">Derivative Calculations When Multisampling</span></span>

<span data-ttu-id="e8d4b-201">I pixel shader vengono sempre eseguiti usando un'area minima di 2x2 pixel per supportare calcoli derivati, che vengono calcolati mediante l'acquisizione di Delta tra dati provenienti da pixel adiacenti (presupponendo che i dati in ogni pixel siano stati campionati con spaziatura tra unità orizzontalmente o verticalmente).</span><span class="sxs-lookup"><span data-stu-id="e8d4b-201">Pixel shaders always run using a minimum 2x2 pixel area to support derivative calculations, which are calculated by taking deltas between data from adjacent pixels (making the assumption that the data in each pixel has been sampled with unit spacing horizontally or vertically).</span></span> <span data-ttu-id="e8d4b-202">Questo non è influenzato dal campionamento multiplo.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-202">This is unaffected by multisampling.</span></span>

<span data-ttu-id="e8d4b-203">Se vengono richiesti derivati su un attributo che è stato utilizzato per il baricentro, il calcolo hardware non viene regolato, che può causare derivati non accurati.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-203">If derivatives are requested on an attribute that has been centroid sampled, the hardware calculation is not adjusted, which can cause inaccurate derivatives.</span></span> <span data-ttu-id="e8d4b-204">Uno shader prevede un vettore di unità nello spazio di destinazione di rendering, ma può ottenere un vettore non di unità in relazione a un altro spazio vettoriale.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-204">A shader will expect a unit vector in render-target space but may get a non-unit vector with respect to some other vector space.</span></span> <span data-ttu-id="e8d4b-205">Pertanto, è responsabilità dell'applicazione prestare attenzione quando si richiedono derivati dagli attributi campionati.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-205">Therefore, it is an application's responsibility to exhibit caution when requesting derivatives from attributes that are centroid sampled.</span></span> <span data-ttu-id="e8d4b-206">Infatti, è consigliabile non combinare i derivati e il campionamento del centro.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-206">In fact, it is recommended that you do not combine derivatives and centroid sampling.</span></span> <span data-ttu-id="e8d4b-207">Il campionamento centrale può essere utile per situazioni in cui è fondamentale che gli attributi interpolati di una primitiva non vengano estrapolati, ma questo avviene con compromessi come gli attributi che sembrano saltare dove un bordo primitivo interseca un pixel, anziché modificare continuamente, o derivati che non possono essere usati da operazioni di campionamento di trama che derivano da LOD.</span><span class="sxs-lookup"><span data-stu-id="e8d4b-207">Centroid sampling can be useful for situations where it is critical that a primitive's interpolated attributes are not extrapolated, but this comes with tradeoffs such as attributes that appear to jump where a primitive edge crosses a pixel (rather than change continuously) or derivatives that cannot be used by texture sampling operations that derive LOD.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e8d4b-208">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="e8d4b-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e8d4b-209">Fase Rasterizzazione</span><span class="sxs-lookup"><span data-stu-id="e8d4b-209">Rasterizer Stage</span></span>](d3d10-graphics-programming-guide-rasterizer-stage.md)
</dt> </dl>

 

 