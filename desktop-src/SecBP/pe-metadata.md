---
description: Questo articolo fornisce dettagli aggiuntivi per i metadati di Guard flusso di controllo nelle immagini PE.
title: Metadati PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106319388"
---
# <a name="pe-metadata"></a>Metadati PE

Questo articolo fornisce dettagli aggiuntivi per i metadati di Guard flusso di controllo (CFG) nelle immagini PE. Si presuppone una certa familiarità con la struttura per i metadati CFG nelle immagini PE. Vedere l'argomento [formato PE](../debug/pe-format.md) per la documentazione di alto livello per i metadati cfg nelle immagini PE.

- Le funzioni che sono destinazioni di chiamata indiretta valide sono elencate nella **GuardCFFunctionTable** collegata alla directory di configurazione del carico, a volte definita la tabella **GFIDS** per brevità. Si tratta di un elenco ordinato di indirizzi RVA (relative Virtual Address) che contengono informazioni sulle destinazioni di chiamata CFG valide. Si tratta, in generale, dei simboli di funzione presi in parola. Un'immagine che prevede l'imposizione di CFG deve enumerare tutti i simboli di funzione accettati nella tabella **GFIDS** . L'elenco RVA nella tabella **GFIDS** deve essere ordinato correttamente oppure l'immagine non verrà caricata. La tabella **GFIDS** è una matrice di 4 + *n* byte, dove *n* viene fornito da ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). "GuardFlags" è il campo GuardFlags della directory di configurazione load. In questo modo è possibile associare metadati aggiuntivi a destinazioni di chiamata CFG in futuro. Gli unici metadati attualmente definiti sono un campo facoltativo di flag aggiuntivi a 1 byte ("flag GFIDS") collegato a ogni voce **GFIDS** se le destinazioni di chiamata hanno metadati. Sono definiti due flag **GFIDS** :
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | La destinazione della chiamata viene eliminata in modo esplicito (non considerarla valida per scopi di CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2 | La destinazione della chiamata viene esportata. Per altri dettagli, vedere [eliminazione dell'esportazione](#export-suppression) |
  
  Per la compatibilità con le versioni successive, gli strumenti non devono impostare flag **GFIDS** che non sono stati ancora definiti e non devono includere altri byte di metadati aggiuntivi di **GFIDS** oltre a un byte attualmente definito poiché i significati per altri flag o metadati aggiuntivi non sono ancora stati assegnati. È possibile trovare esempi di immagini che includono byte di metadati aggiuntivi eseguendo il dump della tabella **GFIDS** di file binari, ad esempio Ntdll.dll in una versione moderna del sistema operativo Windows 10.

  Gli strumenti devono dichiarare solo i simboli di funzione come destinazioni di chiamata valide che possono meritare considerazioni aggiuntive per il codice dell'assembler in cui è possibile indirizzare le etichette. Per motivi cronologici, il codice assembler può basarsi su etichette di codice diverse da PROC o. altentry come non essere convertite in destinazioni di chiamata CFG dal linker.

  Inoltre, per motivi cronologici, il codice può dichiarare intenzionalmente il codice come dati per evitare l'inclusione nella tabella **GFIDS** . Ad esempio, un file oggetto può implementare un simbolo come codice, mentre un altro può dichiararlo come dati per prendere l'indirizzo del simbolo senza generare un record di destinazione CFG valido. Per compatibilità, è consigliabile che i set di strumenti supportino questa procedura.

- Le immagini che supportano CFG e che desiderano o eseguono controlli CFG devono impostare il IMAGE_GUARD_CF_INSTRUMENTED e IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT bit GuardFlags e impostare il IMAGE_DLLCHARACTERISTICS_GUARD_CF bit DllCharacteristics nelle intestazioni di immagine.

- La directory di configurazione del caricamento annuncia due puntatori a funzione: GuardCFCheckFunctionPointer e GuardCFDispatchFunctionPointer (quest'ultimo è supportato solo per alcune architetture, ad esempio AMD64). Questi puntatori a funzione devono puntare alla memoria di sola lettura per l'efficacia della sicurezza di CFG; il caricatore DLL del sistema operativo riproteggerà la memoria in modo temporaneo durante il caricamento dell'immagine per archiviare i puntatori a funzione. L'utilizzo tipico potrebbe consistere nell'unire questi nella stessa sezione che contiene la tabella di indirizzi di importazione (IAT). GuardCFCheckFunctionPointer fornisce l'indirizzo di un simbolo del caricatore del sistema operativo che può essere chiamato con un puntatore a funzione nel primo registro di argomenti Integer (ECX su x86) che restituirà in caso di esito positivo o interromperà il processo se la destinazione della chiamata non è una destinazione CFG valida. GuardCFDispatchFunctionPointer fornisce l'indirizzo di un simbolo del caricatore del sistema operativo che accetta una destinazione di chiamata in Register RAX ed esegue una chiamata combinata di controllo CFG e della coda del ramo della coda alla destinazione della chiamata (i registri R10/R11 sono riservati per l'uso da parte di GuardCFDispatchFunctionPointer e i registri di argomenti Integer sono riservati per l'uso da parte della destinazione di chiamata finale). L'indirizzo predefinito dei simboli CFG in un'immagine deve puntare a una funzione che restituisce solo (GuardCFCheckFunctionPointer) o che restituisce un simbolo di Guard-eliminato (oppure è preferibilmente completamente omesso dal simbolo della tabella **GFIDS** ) che esegue un'istruzione "JMP Rax". Per AMD64 GuardCFDispatchFunctionPointer, quando un'immagine viene caricata in un sistema operativo compatibile con CFG ed è abilitata la funzionalità CFG, il caricatore della DLL del sistema operativo installerà i puntatori a funzione appropriati, che consente la compatibilità con le versioni precedenti. Un'immagine può fornire 0 per GuardCFDispatchFunctionPointer nella configurazione di caricamento se non prevede l'uso della funzionalità di invio tramite CFG. Questa operazione dovrebbe essere eseguita per le architetture non AMD64 per la compatibilità futura, nel caso in cui queste architetture supportino il meccanismo di invio di CFG in qualche forma. Si noti che Windows 8.1 AMD64 non supporta la distribuzione di CFG e lascia il puntatore a funzione predefinito per GuardCFDispatchFunctionPointer. Il servizio di invio CFG è supportato solo nei sistemi operativi Windows 10 e versioni successive.

- È possibile applicare la CFG in modalità utente solo per le immagini contrassegnate come compatibili con ASLR (Address Space Layout randomation), specificato dall'opzione/DYNAMICBASE con Microsoft linker. Questo è dovuto al modo in cui il sistema operativo gestisce internamente la CFG dove è essenzialmente collegata all'infrastruttura di ASLR. In generale, gli utenti di CFG devono abilitare ASLR per le proprie immagini come primo passaggio. Gli strumenti non devono presupporre che il sistema operativo ignori sempre la configurazione CFG senza ASLR, ma in genere deve impostare entrambe contemporaneamente.

## <a name="compiler-directives"></a>Direttive del compilatore

- Le destinazioni di chiamata possono essere contrassegnate come eliminati in modo esplicito con il modificatore __declspec (Guard (evita)) o con la direttiva del linker/guardsym: SymName, S (per il codice ASM, ad esempio). In questo modo la destinazione della chiamata viene inclusa nella tabella **GFIDS** , ma contrassegnata in modo tale che il sistema operativo considererà la destinazione della chiamata come non valida. Alcuni scenari non di produzione, ad esempio con determinate strumentazione di Application Verifier abilitati in alcuni sistemi operativi meno recenti, possono consentire la gestione delle destinazioni di chiamata non valide, ma in generale questi scenari non sono previsti scenari di produzione. Questa direttiva è utile per l'annotazione di funzioni "pericolose" che non devono essere considerate come destinazioni di chiamata valide, anche se le normali regole CFG le includono.

- Il codice può indicare che i controlli CFG non sono desiderati con il modificatore __declspec (Guard (nocf)). Ciò indica al compilatore di non inserire controlli CFG per l'intera funzione. Il compilatore deve eseguire la propagazione di questa direttiva a qualsiasi codice fornito da una funzione inline contrassegnata come se non si desiderassero controlli CFG. Questo approccio viene in genere usato solo sporadicamente in situazioni specifiche in cui il programmatore ha inserito manualmente la protezione "CFG-equivalente". Il programmatore sa che sta chiamando tramite una tabella di funzioni di sola lettura il cui indirizzo viene ottenuto tramite riferimenti di memoria di sola lettura e per il quale l'indice viene mascherato al limite della tabella di funzioni. Questo approccio può essere applicato anche a piccole funzioni wrapper che non sono inline e che non eseguono alcuna operazione oltre a effettuare una chiamata tramite un puntatore a funzione. Poiché l'utilizzo errato di questa direttiva può compromettere la sicurezza di CFG, il programmatore deve prestare molta attenzione all'utilizzo della direttiva. In genere, questo utilizzo è limitato alle funzioni molto piccole che chiamano una sola funzione.

## <a name="import-handling"></a>Gestione importazione

- Le chiamate tramite la tabella IAT non devono utilizzare la protezione CFG. La tabella IAT è di sola lettura nelle immagini moderne (presupponendo che la tabella IAT sia dichiarata nelle intestazioni PE, nel qual caso deve trovarsi nelle proprie pagine). La tabella IAT può essere usata per raggiungere le funzioni che vengono evitate, pertanto si tratta di un requisito di correttezza. La protezione della memoria di sola lettura tramite la tabella IAT sostituisce quella di CFG, poiché l'associazione di destinazione della chiamata non è modificabile dopo la risoluzione degli snap di importazione dell'immagine e la risoluzione dell'associazione è con granularità fine.

- Caricamento ritardato protetto: le chiamate tramite la tabella IAT con carico ritardato non devono utilizzare la protezione CFG, per gli stessi motivi della IAT standard. La tabella IAT per il caricamento ritardato deve trovarsi nella relativa sezione e l'immagine deve impostare l'IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT bit GuardFlags. Ciò indica che il caricatore DLL del sistema operativo deve modificare le protezioni per la IAT con caricamento ritardato durante la risoluzione dell'esportazione se si utilizza il supporto del caricamento ritardato del sistema operativo nativo per Windows 8 e sistemi operativi successivi. La sincronizzazione di questo passaggio viene gestita dal caricatore della DLL del sistema operativo se è in uso il supporto del caricamento ritardato del sistema operativo nativo (ad esempio ResolveDelayLoadedAPI), pertanto nessun altro componente deve riproteggere le pagine che si estendono sulla IAT di caricamento ritardato dichiarato. Per la compatibilità con le versioni precedenti dei sistemi operativi precedenti a CFG, gli strumenti possono abilitare l'opzione per spostare la tabella IAT di caricamento ritardato nella relativa sezione (in modo canonico ". didat"), protetta come lettura/scrittura nelle intestazioni dell'immagine e impostare anche il flag di IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Questa impostazione provocherà il caricamento della DLL del sistema operativo compatibile con CFG per riproteggere l'intera sezione contenente la tabella IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT per leggere solo la memoria durante il caricamento dell'immagine. Se non si è interessati a eseguire un'immagine nei sistemi operativi del supporto per la versione di data e ora, è possibile che l'opzione per collocare la tabella IAT di caricamento ritardato nella relativa sezione non sia necessaria se non si è interessati al supporto del sistema operativo minimo necessario per un'immagine.

  Se un'immagine non usa il supporto per il caricamento ritardato nativo del sistema operativo, può comunque impostare i bit di GuardFlags relativi al caricamento ritardato protetto. In questa configurazione, il caricatore del sistema operativo fornirà solo il supporto per proteggere la tabella IAT di caricamento ritardato come di sola lettura in fase di esecuzione, se supportata dalla piattaforma, e diventerà la responsabilità degli stub interni della risoluzione del carico ritardato dell'immagine per sincronizzare e gestire la protezione della IAT di caricamento ritardato. A condizione che la tabella di configurazione del carico sia archiviata nella memoria di sola lettura (scelta consigliata), la presenza o l'assenza del bit protetto di caricamento ritardato nel campo GuardFlags dell'immagine può essere utile come hint interno per gli stub di risoluzione del caricamento ritardato interno dell'immagine, in modo da indicare se è necessario proteggere la IAT di caricamento ritardato.

  Se è abilitata la funzionalità CFG, è consigliabile abilitare il caricamento dei ritardi protetti per impostazione predefinita. Le immagini che vengono eseguite in versioni precedenti del sistema operativo e che utilizzano il supporto per il caricamento ritardato nativo del sistema operativo, come indicato, possono utilizzare la tabella IAT per il caricamento ritardato nella propria sezione supporto per la compatibilità con le versioni precedenti. Ciò si oppone a contrassegnare il ritardo di caricamento IAT come di sola lettura e a unirlo a un'altra sezione, che si interrompe in caso di sistemi operativi precedenti che non comprendono i carichi di ritardo protetti e che forniscono supporto nativo per la risoluzione del carico ritardato. Tutte le versioni di Windows 10 e le prime Windows 8.1/Windows Server 2012 R2 compilazioni supportate da CFG, ovvero l'aggiornamento del 2014 novembre, introducono il supporto per il caricamento ritardato protetto nel sistema operativo.

## <a name="function-alignment"></a>Allineamento funzioni

- Le funzioni che sono indirizzate e pertanto incluse nella tabella **GFIDS** devono essere allineate a 16 byte, se possibile. Questa operazione potrebbe non essere sempre possibile. Per le funzioni non COMDAT, ad esempio, che fanno parte di file oggetto assemblati insieme come un'unica unità da strumenti non compatibili con i CFG, che alcuni assemblatori possono produrre, l'utente dello strumento che ha prodotto i file deve impostare correttamente l'allineamento. Gli strumenti possono decidere di emettere un avviso di diagnostica in questa situazione, in modo che l'utente possa adottare un'azione correttiva appropriata. Il motivo è che i contrassegni CFG chiamano le destinazioni come valide o non sono validi per i limiti di 16 byte per l'efficienza dei controlli CFG veloci. Se una funzione non è allineata a 16 byte, l'intero slot a 16 byte deve essere contrassegnato come valido, che non è sicuro perché è possibile chiamare non allineato a un codice che non si trova all'inizio di una funzione. Questo scenario è supportato per semplificare l'interoperabilità quando si crea prima una CFG per un progetto. Le immagini non compatibili con CFG sono contrassegnate in modo analogo come valide per qualsiasi allineamento della destinazione della chiamata per la compatibilità. Come in precedenza, la presenza di destinazioni di chiamata non allineate riduce i vantaggi di sicurezza di CFG, quindi gli strumenti devono essere allineati automaticamente a un limite di 16 byte per qualsiasi elemento nella tabella **GFIDS** quando si desidera una cfg per un'immagine. I simboli che non sono presenti nella tabella **GFIDS** non devono avere particolari allineamenti per la cfg.

## <a name="export-suppression"></a>Eliminazione esportazione

- L'eliminazione dell'esportazione (CFG ES) di CFG è una modalità facoltativa che consente a un processo di indicare che le destinazioni di chiamata che erano valide solo perché sono i simboli dllexport e che non sono stati ancora risolti in modo dinamico da GetProcAddress, verranno considerate non valide a scopo di CFG. In questo modo si riduce la superficie di attacco di CFG dalle esportazioni DLL di sistema. L'eliminazione dell'esportazione implica la comunicazione tra le destinazioni di chiamata dllexport "esportazione eliminata" e contrassegnate con i flag di IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** . I simboli dllexport e il punto di ingresso dell'immagine PE devono essere considerati in modo implicito con gli strumenti necessari per la generazione della tabella **GFIDS** .  Se un simbolo di esportazione è allineato a 16 byte e l'indirizzo viene eseguito per nessun altro motivo rispetto a dllexport, può essere contrassegnato con il flag Export **GFIDS** eliminato nella tabella function. Le destinazioni di chiamata che non sono allineate a 16 byte **non devono** essere contrassegnate con il IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED flag **GFIDS** e non possono essere limitate a essere abilitate solo in modo dinamico come destinazioni di chiamata valide in fase di GetProcAddress.

  Un'immagine che supporta le CFG ES include un GuardAddressTakenIatEntryTable il cui conteggio viene fornito da GuardAddressTakenIatEntryCount come parte della directory di configurazione di caricamento. Questa tabella è formattata in modo strutturale come la tabella **GFIDS** . USA lo stesso meccanismo di IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags per codificare byte di metadati facoltativi aggiuntivi nella tabella IAT Address taken, anche se tutti i byte dei metadati devono essere pari a zero per la tabella IAT Address taken e sono riservati. La tabella IAT Address taken indica una matrice ordinata di RVA di thunk di importazione, che hanno l'oggetto importato come indirizzo del simbolo assunto come destinazione della chiamata. Questo costrutto supporta i simboli di indirizzi usati presenti in un modulo remoto e che sono dllexports, con CFG ES in uso. Un esempio di un costrutto di codice di questo tipo è:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  È necessario enumerare tutti questi thunk di importazione, in modo che il caricatore del sistema operativo possa trovarli e rendere valide le destinazioni di chiamata appropriate durante il caricamento di un'immagine e l'allineamento delle relative importazioni. La tabella e il conteggio possono essere 0 se non sono presenti thunk di importazione da considerare.

  Un modulo imposta il bit IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags per indicare che sono stati enumerati tutti i thunk degli indirizzi effettuati nella tabella IAT e che tutte le esportazioni che sono idonee per le esportazioni sono contrassegnate con il flag di IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** . Si noti che potrebbero essere presenti zero thunk di questo tipo e che potrebbero essere presenti anche zero simboli dllexport. La mancata manutenzione della tabella IAT degli indirizzi ottenuti può essere un problema di correttezza, perché alcune destinazioni di chiamata potrebbero non essere rese valide quando devono trovarsi in fase di caricamento della DLL.

  Un modulo imposta il bit di IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags per indicare che vuole abilitare l'ES CFG per il processo. In pratica, questo è significativo solo per i exe. Un processo di abilitazione di CFG ES non deve caricare le dll non compilate con CFG ES o gli errori di runtime possono verificarsi a causa di simboli IAT considerati come indirizzi non designati. Il supporto per l'abilitazione di CFG ES dovrebbe essere un'opzione di consenso esplicito diversa dall'abilitazione di CFG. Fornire i metadati di CFG ES è sicuro e consigliato per impostazione predefinita con CFG, sebbene i set di strumenti debbano assicurarsi di produrre metadati corretti. In caso contrario, le immagini generate potrebbero non essere eseguite correttamente in un processo CFG ES. Questo tipo di supporto deve essere testato accuratamente in un processo di test che impone l'utilizzo di CFG ES. Le DLL di sistema del sistema operativo supportano i metadati di CFG ES per le versioni moderne del sistema operativo Windows 10 che comprendono la funzionalità CFG ES. Le versioni del sistema operativo precedenti a questo supporto non comprendono alcuna CFG ES e ignoreranno eventuali direttive correlate a CFG ES nell'immagine. Queste immagini sono ancora compatibili con le versioni precedenti del sistema operativo.

  Il supporto di CFG ES è facoltativo dal punto di vista del set di strumenti, ma è consigliabile che i set di strumenti includano almeno il supporto per enumerare informazioni sufficienti per l'esecuzione di immagini in un processo che desideri CFG ES. Come indicato, è fondamentale che il supporto del set di strumenti venga testato accuratamente per assicurarsi che sia compatibile con CFG ES, perché la maggior parte dei processi non Abilita ancora la CFG ES.

## <a name="exception-handling-and-unwinding"></a>Gestione delle eccezioni e rimozione

- I gestori specifici del linguaggio come __C_specific_handler, come indicato dalle informazioni del gestore di eccezioni in una registrazione pData, non devono essere contrassegnati come destinazioni di chiamata valide nella tabella **GFIDS** . Vengono invece ricercati attraversando la memoria di sola lettura. Analogamente, il gestore specifico del linguaggio C Microsoft usa le ricerche di memoria di sola lettura per individuare funclets per i gestori di eccezioni e pertanto non dichiara il funclets come destinazioni di chiamata valide nella tabella **GFIDS** .

- Gestione del salto lungo (per destinazioni non x86 come AMD64): i set di strumenti che compilano con CFG e supportano setjmp ()/longjmp () devono implementare il salto lungo come "salto lungo sicuro" che interagisce con la gestione delle eccezioni strutturata (SEH). Ciò significa che Long Jump viene implementato come una chiamata a RtlUnwindEx con STATUS_LONGJUMP come codice di stato nel record di eccezione fornito e un _JUMP_BUFFER standard a cui punta ExceptionInformation [0]. La destinazione di rimozione del salto dovrebbe essere il TargetIp della rimozione. Il buffer di salto rappresenta il contesto di registro ripristinato dal sistema operativo dopo il completamento del salto lungo. RtlUnwind (ad esempio) quando viene chiamato con STATUS_LONGJUMP ha un significato speciale univoco per CFG. Destinazione di salto lungo (_JUMP_BUFFER. RIP o _JUMP_BUFFER. LR in ARM64) viene cercato nell'elenco dei moduli caricati gestito dal sistema operativo nella memoria di sola lettura. Se il modulo contenitore per la destinazione di salto (il "modulo di destinazione") ha il flag di IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT impostato nel campo GuardFlags, la directory di configurazione del carico ha un GuardLongJumpTargetTable con un numero di elementi specificato dal campo Load Configuration GuardLongJumpTargetCount. Questa tabella è formattata in modo strutturale come la tabella **GFIDS** e usa lo stesso meccanismo di IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags per codificare i byte di metadati aggiuntivi facoltativi nella tabella di salto lungo. Tutti i byte dei metadati devono essere pari a zero per la tabella di salto lungo e sono riservati.

  La tabella di salto lungo rappresenta una matrice ordinata di RVA che sono destinazioni di salto lungo valide. Se un modulo di destinazione con salto lungo imposta IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT nel campo GuardFlags, tutte le destinazioni di salto lungo devono essere enumerate in LongJumpTargetTable. Anche se un modulo ha destinazioni di salto a lungo zero, deve comunque impostare il flag di IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT se il set di strumenti supporta la protezione avanzata a lungo termine per la CFG. Questo significa in modo esplicito che l'immagine non ha destinazioni di salto lungo e non è un'immagine precedente che il sistema operativo deve presupporre potrebbe avere destinazioni di salto lungo valide in posizioni non contrassegnate per le quali non è possibile eseguire il controllo della destinazione di salto lungo.

  Per impostazione predefinita, è consigliabile abilitare la funzionalità di protezione avanzata con salto a lungo se è supportata la funzionalità CFG. Questa è la disposizione dei compilatori Microsoft. I sistemi operativi che non sono in grado di eseguire la protezione avanzata da più tempo (versioni precedenti a Windows 10 o versioni precedenti di Windows 10) non eseguono controlli di protezione avanzata a lungo termine e ignorano i metadati a lungo termine, quindi la protezione avanzata è compatibile con le versioni precedenti del sistema operativo.

  Per le immagini in modalità kernel, la tabella di destinazione per il salto lungo della protezione non deve essere inclusa in una sezione non riutilizzabile. La tabella di destinazione per il salto lungo di Guard deve essere sempre archiviata nella memoria di sola lettura per garantire l'efficacia delle proprietà di sicurezza.

## <a name="coff-information"></a>Informazioni COFF

- Sono presenti contrassegni di file oggetto per dichiarare se un file oggetto è conforme a CFG o meno. Un file oggetto che è conforme a CFG elenca le destinazioni di chiamata valide che produce, in modo esplicito, nonché qualsiasi indirizzo utilizzato per i metadati IAT. Un file oggetto che non è conforme a CFG deve avere destinazioni di chiamata dedotto esaminando le rilocazioni COFF del file obj per trovare le rilocazioni che puntano all'inizio di un simbolo di funzione. Questo può comportare la presenza di destinazioni di chiamata CFG valide, pertanto è opportuno che gli strumenti contrassegnino i file obj che sono compatibili con CFG e includano i metadati del file obj CFG se vengono compilati con CFG.

- Sono presenti contrassegni di file oggetto per dichiarare destinazioni di salto lungo per il salto lungo con protezione avanzata CFG da popolare per la modalità di compilazione CFG.
