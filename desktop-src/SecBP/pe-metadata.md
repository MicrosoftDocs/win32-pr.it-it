---
description: Questo articolo fornisce dettagli aggiuntivi per i metadati di Control Flow Guard nelle immagini PE.
title: Metadati PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c2bce23a94629900f8610cf3cbc1e2ba0db1c4e6a079bd5f610be230df24ec6e
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/11/2021
ms.locfileid: "119994490"
---
# <a name="pe-metadata"></a>Metadati PE

Questo articolo fornisce dettagli aggiuntivi per i metadati di Control Flow Guard (CFG) nelle immagini PE. Si presuppone una familiarità con la struttura per i metadati CFG nelle immagini PE. Vedere [l'argomento Formato PE](../debug/pe-format.md) per la documentazione di alto livello per i metadati CFG nelle immagini PE.

- Le funzioni che sono destinazioni di chiamata indirette valide sono elencate nella **tabella GuardCFFunctionTable** collegata alla directory di configurazione del carico, talvolta chiamata **tabella GFIDS** per brevità. Si tratta di un elenco ordinato di indirizzi virtuali relativi che contengono informazioni sulle destinazioni di chiamata CFG valide. Si tratta, in generale, di simboli di funzione address taken. Un'immagine che vuole l'imposizione CFG deve enumerare tutti i simboli di funzione address taken nella tabella **GFIDS.** L'elenco RVA nella **tabella GFIDS** deve essere ordinato correttamente o l'immagine non verrà caricata. La **tabella GFIDS** è una matrice di 4 + *n* byte, in cui *n* viene specificato da ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). "GuardFlags" è il campo GuardFlags della directory di configurazione del caricamento. Ciò consente di associare metadati aggiuntivi alle destinazioni di chiamata CFG in futuro. Gli unici metadati attualmente definiti sono un campo flag aggiuntivo di 1 byte facoltativo ("flag GFIDS") associato a ogni voce **GFIDS** se le destinazioni di chiamata hanno metadati. Sono definiti **due flag GFIDS:**
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | La destinazione della chiamata viene eliminata in modo esplicito (non considerarla valida ai fini di CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2 | L'esportazione della destinazione della chiamata è stata eliminata. Per [altri dettagli, vedere](#export-suppression) Eliminazione dell'esportazione |
  
  Per la compatibilità futura, gli strumenti non devono impostare flag **GFIDS** che non sono ancora stati definiti e non devono includere byte di metadati **aggiuntivi GFIDS** aggiuntivi oltre i byte di 1 byte attualmente definiti perché i significati per altri flag o metadati aggiuntivi non sono ancora assegnati. È possibile trovare esempi di immagini che includono byte di metadati aggiuntivi effettuando il dump della tabella **GFIDS** di file binari, ad esempio Ntdll.dll in una versione moderna Windows 10 del sistema operativo.

  Gli strumenti devono dichiarare solo i simboli di funzione come destinazioni di chiamata valide, che possono richiedere una considerazione aggiuntiva per il codice dell'assembler in cui le etichette potrebbero essere prese come indirizzi. Per motivi cronologici, il codice dell'assembler può basarsi su etichette di codice diverse da PROC o altentry come non convertite in destinazioni di chiamata CFG dal linker.

  Anche per motivi cronologici, il codice può dichiarare intenzionalmente il codice come dati per evitare l'inclusione nella **tabella GFIDS.** Ad esempio, un file oggetto può implementare un simbolo come codice, mentre un altro può dichiararlo come dati per prendere l'indirizzo del simbolo senza generare un record di destinazione CFG valido. Per motivi di compatibilità, è consigliabile che i set di strumenti supportino questa procedura.

- Le immagini che supportano CFG e che vogliono o eseguono controlli CFG devono impostare i bit IMAGE_GUARD_CF_INSTRUMENTED e IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags e impostare il bit IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics nelle intestazioni dell'immagine.

- La directory di configurazione del caricamento annuncia due puntatori a funzione: GuardCFCheckFunctionPointer e GuardCFDispatchFunctionPointer (quest'ultimo è supportato solo per determinate architetture, ad esempio AMD64). Questi puntatori a funzione devono puntare alla memoria di sola lettura perché la sicurezza CFG sia efficace. Il caricatore DLL del sistema operativo riproteggere la memoria in modo temporaneo durante il caricamento dell'immagine per archiviare i puntatori a funzione. L'uso tipico potrebbe essere quello di unire questi elementi nella stessa sezione che contiene la tabella di indirizzi di importazione (IAT). GuardCFCheckFunctionPointer fornisce l'indirizzo di un simbolo fornito dal caricatore del sistema operativo che può essere chiamato con un puntatore a funzione nel primo registro di argomenti integer (ECX in x86) che restituirà l'esito positivo o interromperà il processo se la destinazione della chiamata non è una destinazione CFG valida. GuardCFDispatchFunctionPointer fornisce l'indirizzo di un simbolo fornito dal caricatore del sistema operativo che accetta una destinazione di chiamata nel registro RAX ed esegue un controllo CFG combinato e una chiamata ottimizzata per il ramo tail alla destinazione di chiamata (i registri R10/R11 sono riservati per l'uso da parte di GuardCFDispatchFunctionPointer e i registri di argomenti integer sono riservati per l'uso da parte della destinazione di chiamata finale). L'indirizzo predefinito dei simboli CFG in un'immagine deve puntare a una funzione che restituisce solo (GuardCFCheckFunctionPointer) o che restituisce un simbolo eliminato dalla protezione (o preferibilmente interamente omesso dal simbolo di tabella **GFIDS)** che esegue un'istruzione "jmp rax". Per AMD64 GuardCFDispatchFunctionPointer, quando un'immagine viene caricata in un sistema operativo compatibile con CFG e CFG è abilitato, il caricatore DLL del sistema operativo installerà puntatori a funzione appropriati, che agevola la compatibilità con le versioni precedenti. Un'immagine può fornire 0 per GuardCFDispatchFunctionPointer nella configurazione di caricamento se non intende usare la funzionalità di distribuzione CFG. Questa operazione deve essere eseguita per le architetture non AMD64 per la compatibilità futura, nel caso in cui queste architetture supportino infine il meccanismo di invio CFG in qualche modo. Si noti Windows 8.1 AMD64 non supporta l'invio CFG e lascia il puntatore a funzione predefinito in posizione per GuardCFDispatchFunctionPointer. L'invio CFG è supportato solo nei Windows 10 e versioni successive.

- L'impostazione CFG in modalità utente può essere applicata solo per le immagini contrassegnate come compatibili con aslr (Address Space Layout Randomization) (aslr), specificate dall'opzione /DYNAMICBASE con il linker Microsoft. Ciò è dovuto al modo in cui il sistema operativo gestisce internamente CFG in cui è essenzialmente collegato all'infrastruttura ASLR. In generale, gli utenti di CFG devono abilitare ASLR per le immagini come primo passaggio. Gli strumenti non devono presupporre che il sistema operativo ignorerà sempre CFG senza ASLR impostato, ma deve in genere impostare entrambi contemporaneamente.

## <a name="compiler-directives"></a>Direttive del compilatore

- Le destinazioni di chiamata possono essere contrassegnate come esplicitamente soppresse con il modificatore __declspec(guard(suppress)) o con la direttiva /guardsym:symname,S linker (ad esempio, per il codice asm). In questo modo la destinazione della chiamata viene inclusa nella tabella **GFIDS,** ma contrassegnata in modo tale che il sistema operativo tratterà la destinazione della chiamata come non valida. Alcuni scenari non di produzione, ad esempio con determinati strumenti di verifica delle applicazioni abilitati in alcuni sistemi operativi meno recenti, possono consentire di trattare come valide le destinazioni di chiamata soppresse, ma in generale questi scenari non sono previsti scenari di produzione. Questa direttiva è utile per annotare funzioni "pericolose" che non devono essere considerate come destinazioni di chiamata valide, anche se la normale regola CFG le include.

- Il codice può indicare che i controlli CFG non sono ricercati con il modificatore __declspec(guard(nocf)). In questo modo il compilatore non inserisce alcun controllo CFG per l'intera funzione. Il compilatore deve fare attenzione a propagare questa direttiva a qualsiasi codice contribuito da una funzione inline contrassegnata come che non vuole controlli CFG. Questo approccio viene in genere usato solo in situazioni specifiche in cui il programmatore ha inserito manualmente la protezione equivalente a CFG. Il programmatore sa di chiamare tramite una tabella di funzioni di sola lettura il cui indirizzo viene ottenuto tramite riferimenti di memoria di sola lettura e per il quale l'indice viene mascherato al limite della tabella della funzione. Questo approccio può essere applicato anche a funzioni wrapper di piccole dimensioni che non sono inline e che non fanno altro che effettuare una chiamata tramite un puntatore a funzione. Poiché l'uso non corretto di questa direttiva può compromettere la sicurezza di CFG, il programmatore deve prestare particolare attenzione usando la direttiva . In genere, questo utilizzo è limitato a funzioni molto piccole che chiamano una sola funzione.

## <a name="import-handling"></a>Gestione delle importazioni

- Le chiamate tramite IAT non devono usare la protezione CFG. L'IAT è di sola lettura nelle immagini moderne (presupponendo che l'IAT sia dichiarato nelle intestazioni PE, nel qual caso deve essere presente nelle proprie pagine). L'IAT può essere usato per raggiungere le funzioni che sono sorvegliate soppresse, quindi si tratta di un requisito di correttezza. La protezione della memoria di sola lettura tramite IAT sostituisce quella di CFG poiché l'associazione di destinazione della chiamata non è modificabile dopo la risoluzione degli snap di importazione dell'immagine e la risoluzione dell'associazione è granulare.

- Caricamento ritardato protetto: le chiamate tramite il caricamento ritardato IAT non devono usare la protezione CFG, per gli stessi motivi dell'IAT standard. L'IAT di caricamento ritardato deve essere nella propria sezione e l'immagine deve impostare il bit IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags. Ciò indica che il caricatore DLL del sistema operativo deve modificare le protezioni per il caricamento ritardato IAT durante la risoluzione dell'esportazione se si usa il supporto del caricamento ritardato del sistema operativo nativo per Windows 8 e sistemi operativi successivi. La sincronizzazione di questo passaggio viene gestita dal caricatore DLL del sistema operativo se è in uso il supporto del caricamento ritardato del sistema operativo nativo ,ad esempio ResolveDelayLoadedAPI, quindi nessun altro componente deve riprotezione delle pagine che si estendono sull'IAT di caricamento ritardato dichiarato. Per garantire la compatibilità con le versioni precedenti dei sistemi operativi pre-CFG, gli strumenti possono abilitare l'opzione per spostare l'IAT di caricamento ritardato nella propria sezione (canonicamente ".didat"), protetta come lettura/scrittura nelle intestazioni dell'immagine e impostare anche il flag IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Questa impostazione fa in modo che i caricatori DLL del sistema operativo in grado di riconoscere CFG riproteggono l'intera sezione contenente la tabella IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT per la memoria di sola lettura durante il caricamento dell'immagine. L'opzione per inserire l'IAT di caricamento ritardato nella propria sezione potrebbe non essere necessaria se non si è interessati all'esecuzione di un'immagine nei sistemi operativi che precedono il supporto CFG, ma gli strumenti devono prendere questa decisione in base al supporto minimo del sistema operativo necessario per un'immagine.

  Se un'immagine non usa il supporto del caricamento ritardato nativo del sistema operativo, può comunque impostare i bit GuardFlags correlati al caricamento ritardato protetto. In questa configurazione, il caricatore del sistema operativo fornirà solo il supporto per proteggere l'IAT di caricamento ritardato come di sola lettura in fase di esecuzione se supportato dalla piattaforma e diventa responsabilità degli stub di risoluzione del carico ritardato interno dell'immagine per sincronizzare e gestire la protezione dell'IAT di caricamento ritardato. A condizione che la tabella di configurazione del carico sia archiviata nella memoria di sola lettura (scelta consigliata), la presenza o l'assenza del bit IAT di caricamento ritardato protetto nel campo GuardFlags dell'immagine potrebbe essere utile come suggerimento interno agli stub di risoluzione del carico ritardato interno dell'immagine per indicare se deve proteggere o meno l'IAT di caricamento ritardato.

  È consigliabile che il caricamento ritardato protetto sia abilitato per impostazione predefinita se CFG è abilitato. Le immagini che vengono eseguite in versioni precedenti del sistema operativo e che usano il supporto del caricamento ritardato nativo del sistema operativo, come si è detto, possono usare l'IAT di caricamento ritardato nella propria sezione di supporto per la compatibilità con le versioni precedenti. A differenza di contrassegnare l'IAT di caricamento ritardato come di sola lettura e unirlo a un'altra sezione, che interromperebbe i carichi di ritardo protetti del sistema operativo meno recenti e che forniscono supporto nativo per la risoluzione del carico ritardato. Tutte Windows 10 e le prime build Windows 8.1/Windows Server 2012 R2 che supportano CFG (ovvero l'aggiornamento di novembre 2014) introducono il supporto per il caricamento ritardato protetto nel sistema operativo.

## <a name="function-alignment"></a>Allineamento delle funzioni

- Le funzioni che vengono prese e sono quindi incluse nella **tabella GFIDS** devono essere allineate a 16 byte, se possibile. Questo potrebbe non essere sempre possibile. Ad esempio, per le funzioni non COMDAT che fanno parte di file oggetto assemblati insieme come un'unità da strumenti non in grado di riconoscere CFG, che alcuni assembler possono produrre, l'utente dello strumento che ha prodotto i file deve impostare in modo appropriato l'allineamento. Gli strumenti possono scegliere di emettere un avviso di diagnostica in questa situazione in modo che l'utente possa intraprendere un'azione correttiva appropriata. Il motivo è che CFG contrassegna le destinazioni di chiamata come valide o non valide nei limiti a 16 byte per migliorare l'efficienza dei controlli CFG veloci. Se una funzione non è allineata a 16 byte, l'intero slot a 16 byte deve essere contrassegnato come valido, che non è così sicuro perché è possibile chiamare disallineato nel codice che non si trova all'inizio di una funzione. Questo scenario è supportato per semplificare l'interoperabilità quando si alza per la prima volta CFG per un progetto. Le immagini non compatibili con CFG sono contrassegnate in modo analogo come valide per qualsiasi allineamento della destinazione di chiamata per motivi di compatibilità. Come in precedenza, la presenza di destinazioni di chiamata disallineate riduce i vantaggi per la sicurezza di CFG, quindi gli strumenti devono allinearsi automaticamente a un limite di 16 byte per qualsiasi elemento nella tabella **GFIDS** quando si desidera utilizzare CFG per un'immagine. I simboli non presenti nella **tabella GFIDS** non devono avere allineamenti specifici per CFG.

## <a name="export-suppression"></a>Eliminazione dell'esportazione

- L'eliminazione dell'esportazione CFG (CFG ES) è una modalità facoltativa che consente a un processo di indicare che le destinazioni di chiamata valide solo perché erano simboli dllexport e che non sono ancora state risolte dinamicamente da GetProcAddress, verranno considerate non valide ai fini di CFG. In questo modo si riduce la superficie di attacco di CFG dalle esportazioni di DLL di sistema. L'eliminazione dell'esportazione comporta la comunicazione delle destinazioni di chiamata dllexport "export suppressed" idonee contrassegnandole con IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **flag GFIDS.** I simboli dllexport e il punto di ingresso dell'immagine PE devono essere considerati in modo implicito come indirizzo assunto dagli strumenti ai fini della generazione della **tabella GFIDS.**  Se un simbolo di esportazione è allineato a 16 byte e l'indirizzo è preso per nessun altro motivo se non come dllexport, può essere contrassegnato con il flag **GFIDS** eliminato dall'esportazione nella tabella delle funzioni. Le destinazioni di chiamata che non  sono allineate a 16 byte non devono essere contrassegnate con il flag **GFIDS** IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED e non possono essere abilitate solo dinamicamente come destinazioni di chiamata valide in fase di GetProcAddress.

  Un'immagine che supporta CFG ES include un oggetto GuardAddressTakenIatEntryTable il cui conteggio viene fornito da GuardAddressTakenIatEntryCount come parte della directory di configurazione del caricamento. Questa tabella è strutturalmente formattata come la **tabella GFIDS.** Usa lo stesso meccanismo guardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK per codificare byte di metadati facoltativi aggiuntivi nella tabella IAT dell'indirizzo, anche se tutti i byte di metadati devono essere pari a zero per la tabella IAT dell'indirizzo preso e sono riservati. La tabella IAT dell'indirizzo utilizzato indica una matrice ordinata di RVA di thunk di importazione con l'oggetto importato come destinazione di chiamata dell'indirizzo del simbolo. Questo costrutto supporta i simboli address taken presenti in un modulo remoto e che sono dllexport, con CFG ES in uso. Un esempio di tale costrutto di codice è il seguente:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Tutti i thunk di importazione di questo tipo devono essere enumerati in modo che il caricatore del sistema operativo possa trovarli e rendere valide le destinazioni di chiamata appropriate quando si carica un'immagine e si bloccano le relative importazioni. La tabella e il conteggio possono essere 0 se non sono presenti thunk di importazione che sono stati presi come indirizzo.

  Un modulo imposta il bit IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags per indicare che ha enumerato tutti gli indirizzi presi thunk nella relativa tabella IAT address taken e che tutte le esportazioni idonee per CFG ES sono contrassegnate con il flag **GFIDS** IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED. Si noti che potrebbero essere presenti zero thunk di questo tipo e che potrebbero non essere presenti simboli dllexport di questo tipo. La mancata gestione della tabella IAT dell'indirizzo può essere un problema di correttezza perché alcune destinazioni di chiamata potrebbero non essere rese valide quando devono essere in fase di caricamento della DLL.

  Un modulo imposta il IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION bit GuardFlags per indicare che vuole abilitare CFG ES per il processo. In pratica, questo è significativo solo per le esere attuali. Un processo che abilita CFG ES non deve caricare DLL non compilate con CFG ES o potrebbero verificarsi errori di runtime a causa di indirizzi non designati eseguiti con simboli IAT. Il supporto per l'abilitazione di CFG ES deve essere un'opzione di consenso esplicito separata dall'abilitazione di CFG. La creazione di metadati CFG ES è sicura e consigliata per impostazione predefinita con CFG, anche se i set di strumenti devono assicurarsi che produca metadati corretti. In caso contrario, le immagini generate potrebbero non essere eseguite correttamente in un processo CFG ES. Tale supporto deve essere testato accuratamente in un processo di test che applica CFG ES. Le DLL di sistema incorporate del sistema operativo supportano i metadati CFG ES per le versioni Windows 10 dei sistemi operativi moderni che comprendono CFG ES. Le versioni del sistema operativo precedenti a questo supporto non comprendono affatto CFG ES e ignoreranno tutte le direttive correlate AFG ES nell'immagine. Tali immagini sono ancora compatibili con le versioni precedenti del sistema operativo.

  Il supporto di CFG ES è facoltativo dal punto di vista del set di strumenti, ma è consigliabile che i set di strumenti includano almeno il supporto per enumerare informazioni sufficienti per l'esecuzione delle immagini in un processo che desideri CFG ES. Come accennato, è fondamentale testare accuratamente il supporto del set di strumenti per assicurarsi che sia compatibile con CFG ES, perché la maggior parte dei processi non abilita ancora CFG ES.

## <a name="exception-handling-and-unwinding"></a>Gestione e rimozione delle eccezioni

- I gestori specifici del linguaggio come __C_specific_handler, designati dalle informazioni sul gestore di eccezioni in una registrazione con estensione pdata, non devono essere contrassegnati come destinazioni di chiamata valide nella **tabella GFIDS.** Vengono invece cercati attraversando la memoria di sola lettura. Analogamente, il gestore specifico del linguaggio Microsoft C usa ricerche di memoria di sola lettura per individuare i funclet per i gestori di eccezioni e pertanto non dichiara i relativi funclet come destinazioni di chiamata valide nella tabella **GFIDS.**

- Gestione dei salti lunghi (per destinazioni non x86 come AMD64): i set di strumenti compilati con CFG e che supportano setjmp()/longjmp() devono implementare il salto lungo come "salto lungo sicuro" che interagisce con la gestione strutturata delle eccezioni (SEH). Ciò significa che il passaggio lungo viene implementato come chiamata a RtlUnwindEx con STATUS_LONGJUMP come codice di stato nel record di eccezione fornito e un _JUMP_BUFFER standard a cui punta ExceptionInformation[0]. La destinazione di rimozione del salto deve essere targetIp della rimozione. Il jump buffer rappresenta il contesto del registro ripristinato dal sistema operativo dopo il completamento del passaggio lungo. RtlUnwind(Ex) quando viene chiamato con STATUS_LONGJUMP ha un significato speciale univoco per CFG. Destinazione di salto lungo (_JUMP_BUFFER. Rip o _JUMP_BUFFER. Lr in ARM64) viene cercato nell'elenco dei moduli caricati gestito dal sistema operativo in memoria di sola lettura. Se per il modulo contenitore per la destinazione di salto (il "modulo di destinazione") è impostato il flag IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT nel campo GuardFlags, la directory di configurazione del caricamento ha un elemento GuardLongJumpTargetTable che indica un numero di elementi specificato dal campo GuardLongJumpTargetCount della configurazione di caricamento. Questa tabella è strutturalmente formattata come la tabella **GFIDS** e usa lo stesso meccanismo guardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK per codificare i byte di metadati aggiuntivi facoltativi nella tabella di salto lungo. Tutti i byte dei metadati devono essere pari a zero per la tabella di salto lungo e sono riservati.

  La tabella dei salti lunghi rappresenta una matrice ordinata di oggetti RVA che sono destinazioni di salto lungo valide. Se un modulo di destinazione a salto lungo IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT nel relativo campo GuardFlags, tutte le destinazioni di salto lungo devono essere enumerate in LongJumpTargetTable. Anche se un modulo non ha obiettivi di salto lunghi, deve comunque impostare il flag IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT se il set di strumenti supporta la protezione avanzata a salto lungo per CFG. Ciò significa in modo esplicito che l'immagine non ha destinazioni di salto lungo e non è un'immagine precedente che il sistema operativo deve presupporre possa avere destinazioni di salto lungo valide in posizioni non contrassegnate per le quali non può eseguire il controllo della destinazione di salto lungo.

  È consigliabile che la protezione avanzata a salto lungo sia abilitata per impostazione predefinita se la protezione avanzata è supportata. Questa è la disposizione dei compilatori Microsoft. I sistemi operativi che non comprendono la protezione avanzata per i salti lunghi (pre-Windows 10 o versioni precedenti di Windows 10) non eseguiranno controlli di protezione avanzata a salto lungo e ignoreranno i metadati di protezione avanzata per i salti lunghi, quindi la protezione avanzata dei salti a lungo è compatibile con le versioni precedenti del sistema operativo.

  Per le immagini in modalità kernel, la tabella di destinazione guard long jump non deve essere inclusa in una sezione eliminabile. Per essere efficace, la tabella di destinazione guard long jump deve essere sempre archiviata nella memoria di sola lettura.

## <a name="coff-information"></a>Informazioni COFF

- Esistono contrassegni di file oggetto per dichiarare se un file oggetto è conforme o meno a CFG. In un file oggetto conforme a CFG verranno elencate le destinazioni di chiamata valide che produce, in modo esplicito, nonché qualsiasi indirizzo di metadati IAT. Un file oggetto non conforme a CFG deve avere destinazioni di chiamata dedosse esaminando le rilocazioni COFF del file obj per trovare le rilocazioni che puntano all'inizio di un simbolo di funzione. Ciò può causare un'overapproximate destinazioni di chiamata CFG valide, pertanto è consigliabile che gli strumenti contrassegnino i file obj che sono in grado di riconoscere CFG e includono i metadati del file obj CFG se si esegue la compilazione con CFG.

- Esistono contrassegni di file oggetto per dichiarare le destinazioni di salto lungo per il passaggio lungo con protezione avanzata CFG che devono essere popolati per la modalità di compilazione CFG.
