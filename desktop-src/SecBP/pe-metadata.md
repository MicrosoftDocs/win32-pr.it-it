---
description: Questo articolo fornisce dettagli aggiuntivi per i metadati di Guard flusso di controllo nelle immagini PE.
title: Metadati PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106319388"
---
# <a name="pe-metadata"></a><span data-ttu-id="697e0-103">Metadati PE</span><span class="sxs-lookup"><span data-stu-id="697e0-103">PE metadata</span></span>

<span data-ttu-id="697e0-104">Questo articolo fornisce dettagli aggiuntivi per i metadati di Guard flusso di controllo (CFG) nelle immagini PE.</span><span class="sxs-lookup"><span data-stu-id="697e0-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="697e0-105">Si presuppone una certa familiarità con la struttura per i metadati CFG nelle immagini PE.</span><span class="sxs-lookup"><span data-stu-id="697e0-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="697e0-106">Vedere l'argomento [formato PE](../debug/pe-format.md) per la documentazione di alto livello per i metadati cfg nelle immagini PE.</span><span class="sxs-lookup"><span data-stu-id="697e0-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="697e0-107">Le funzioni che sono destinazioni di chiamata indiretta valide sono elencate nella **GuardCFFunctionTable** collegata alla directory di configurazione del carico, a volte definita la tabella **GFIDS** per brevità.</span><span class="sxs-lookup"><span data-stu-id="697e0-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="697e0-108">Si tratta di un elenco ordinato di indirizzi RVA (relative Virtual Address) che contengono informazioni sulle destinazioni di chiamata CFG valide.</span><span class="sxs-lookup"><span data-stu-id="697e0-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="697e0-109">Si tratta, in generale, dei simboli di funzione presi in parola.</span><span class="sxs-lookup"><span data-stu-id="697e0-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="697e0-110">Un'immagine che prevede l'imposizione di CFG deve enumerare tutti i simboli di funzione accettati nella tabella **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="697e0-111">L'elenco RVA nella tabella **GFIDS** deve essere ordinato correttamente oppure l'immagine non verrà caricata.</span><span class="sxs-lookup"><span data-stu-id="697e0-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="697e0-112">La tabella **GFIDS** è una matrice di 4 + *n* byte, dove *n* viene fornito da ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span><span class="sxs-lookup"><span data-stu-id="697e0-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="697e0-113">"GuardFlags" è il campo GuardFlags della directory di configurazione load.</span><span class="sxs-lookup"><span data-stu-id="697e0-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="697e0-114">In questo modo è possibile associare metadati aggiuntivi a destinazioni di chiamata CFG in futuro.</span><span class="sxs-lookup"><span data-stu-id="697e0-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="697e0-115">Gli unici metadati attualmente definiti sono un campo facoltativo di flag aggiuntivi a 1 byte ("flag GFIDS") collegato a ogni voce **GFIDS** se le destinazioni di chiamata hanno metadati.</span><span class="sxs-lookup"><span data-stu-id="697e0-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="697e0-116">Sono definiti due flag **GFIDS** :</span><span class="sxs-lookup"><span data-stu-id="697e0-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="697e0-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="697e0-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="697e0-118">La destinazione della chiamata viene eliminata in modo esplicito (non considerarla valida per scopi di CFG)</span><span class="sxs-lookup"><span data-stu-id="697e0-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="697e0-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span><span class="sxs-lookup"><span data-stu-id="697e0-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="697e0-120">La destinazione della chiamata viene esportata.</span><span class="sxs-lookup"><span data-stu-id="697e0-120">Call target is export suppressed.</span></span> <span data-ttu-id="697e0-121">Per altri dettagli, vedere [eliminazione dell'esportazione](#export-suppression)</span><span class="sxs-lookup"><span data-stu-id="697e0-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="697e0-122">Per la compatibilità con le versioni successive, gli strumenti non devono impostare flag **GFIDS** che non sono stati ancora definiti e non devono includere altri byte di metadati aggiuntivi di **GFIDS** oltre a un byte attualmente definito poiché i significati per altri flag o metadati aggiuntivi non sono ancora stati assegnati.</span><span class="sxs-lookup"><span data-stu-id="697e0-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="697e0-123">È possibile trovare esempi di immagini che includono byte di metadati aggiuntivi eseguendo il dump della tabella **GFIDS** di file binari, ad esempio Ntdll.dll in una versione moderna del sistema operativo Windows 10.</span><span class="sxs-lookup"><span data-stu-id="697e0-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="697e0-124">Gli strumenti devono dichiarare solo i simboli di funzione come destinazioni di chiamata valide che possono meritare considerazioni aggiuntive per il codice dell'assembler in cui è possibile indirizzare le etichette.</span><span class="sxs-lookup"><span data-stu-id="697e0-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="697e0-125">Per motivi cronologici, il codice assembler può basarsi su etichette di codice diverse da PROC o. altentry come non essere convertite in destinazioni di chiamata CFG dal linker.</span><span class="sxs-lookup"><span data-stu-id="697e0-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="697e0-126">Inoltre, per motivi cronologici, il codice può dichiarare intenzionalmente il codice come dati per evitare l'inclusione nella tabella **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="697e0-127">Ad esempio, un file oggetto può implementare un simbolo come codice, mentre un altro può dichiararlo come dati per prendere l'indirizzo del simbolo senza generare un record di destinazione CFG valido.</span><span class="sxs-lookup"><span data-stu-id="697e0-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="697e0-128">Per compatibilità, è consigliabile che i set di strumenti supportino questa procedura.</span><span class="sxs-lookup"><span data-stu-id="697e0-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="697e0-129">Le immagini che supportano CFG e che desiderano o eseguono controlli CFG devono impostare il IMAGE_GUARD_CF_INSTRUMENTED e IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT bit GuardFlags e impostare il IMAGE_DLLCHARACTERISTICS_GUARD_CF bit DllCharacteristics nelle intestazioni di immagine.</span><span class="sxs-lookup"><span data-stu-id="697e0-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="697e0-130">La directory di configurazione del caricamento annuncia due puntatori a funzione: GuardCFCheckFunctionPointer e GuardCFDispatchFunctionPointer (quest'ultimo è supportato solo per alcune architetture, ad esempio AMD64).</span><span class="sxs-lookup"><span data-stu-id="697e0-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="697e0-131">Questi puntatori a funzione devono puntare alla memoria di sola lettura per l'efficacia della sicurezza di CFG; il caricatore DLL del sistema operativo riproteggerà la memoria in modo temporaneo durante il caricamento dell'immagine per archiviare i puntatori a funzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="697e0-132">L'utilizzo tipico potrebbe consistere nell'unire questi nella stessa sezione che contiene la tabella di indirizzi di importazione (IAT).</span><span class="sxs-lookup"><span data-stu-id="697e0-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="697e0-133">GuardCFCheckFunctionPointer fornisce l'indirizzo di un simbolo del caricatore del sistema operativo che può essere chiamato con un puntatore a funzione nel primo registro di argomenti Integer (ECX su x86) che restituirà in caso di esito positivo o interromperà il processo se la destinazione della chiamata non è una destinazione CFG valida.</span><span class="sxs-lookup"><span data-stu-id="697e0-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="697e0-134">GuardCFDispatchFunctionPointer fornisce l'indirizzo di un simbolo del caricatore del sistema operativo che accetta una destinazione di chiamata in Register RAX ed esegue una chiamata combinata di controllo CFG e della coda del ramo della coda alla destinazione della chiamata (i registri R10/R11 sono riservati per l'uso da parte di GuardCFDispatchFunctionPointer e i registri di argomenti Integer sono riservati per l'uso da parte della destinazione di chiamata finale).</span><span class="sxs-lookup"><span data-stu-id="697e0-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="697e0-135">L'indirizzo predefinito dei simboli CFG in un'immagine deve puntare a una funzione che restituisce solo (GuardCFCheckFunctionPointer) o che restituisce un simbolo di Guard-eliminato (oppure è preferibilmente completamente omesso dal simbolo della tabella **GFIDS** ) che esegue un'istruzione "JMP Rax".</span><span class="sxs-lookup"><span data-stu-id="697e0-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="697e0-136">Per AMD64 GuardCFDispatchFunctionPointer, quando un'immagine viene caricata in un sistema operativo compatibile con CFG ed è abilitata la funzionalità CFG, il caricatore della DLL del sistema operativo installerà i puntatori a funzione appropriati, che consente la compatibilità con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="697e0-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="697e0-137">Un'immagine può fornire 0 per GuardCFDispatchFunctionPointer nella configurazione di caricamento se non prevede l'uso della funzionalità di invio tramite CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="697e0-138">Questa operazione dovrebbe essere eseguita per le architetture non AMD64 per la compatibilità futura, nel caso in cui queste architetture supportino il meccanismo di invio di CFG in qualche forma.</span><span class="sxs-lookup"><span data-stu-id="697e0-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="697e0-139">Si noti che Windows 8.1 AMD64 non supporta la distribuzione di CFG e lascia il puntatore a funzione predefinito per GuardCFDispatchFunctionPointer.</span><span class="sxs-lookup"><span data-stu-id="697e0-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="697e0-140">Il servizio di invio CFG è supportato solo nei sistemi operativi Windows 10 e versioni successive.</span><span class="sxs-lookup"><span data-stu-id="697e0-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="697e0-141">È possibile applicare la CFG in modalità utente solo per le immagini contrassegnate come compatibili con ASLR (Address Space Layout randomation), specificato dall'opzione/DYNAMICBASE con Microsoft linker.</span><span class="sxs-lookup"><span data-stu-id="697e0-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="697e0-142">Questo è dovuto al modo in cui il sistema operativo gestisce internamente la CFG dove è essenzialmente collegata all'infrastruttura di ASLR.</span><span class="sxs-lookup"><span data-stu-id="697e0-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="697e0-143">In generale, gli utenti di CFG devono abilitare ASLR per le proprie immagini come primo passaggio.</span><span class="sxs-lookup"><span data-stu-id="697e0-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="697e0-144">Gli strumenti non devono presupporre che il sistema operativo ignori sempre la configurazione CFG senza ASLR, ma in genere deve impostare entrambe contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="697e0-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="697e0-145">Direttive del compilatore</span><span class="sxs-lookup"><span data-stu-id="697e0-145">Compiler directives</span></span>

- <span data-ttu-id="697e0-146">Le destinazioni di chiamata possono essere contrassegnate come eliminati in modo esplicito con il modificatore __declspec (Guard (evita)) o con la direttiva del linker/guardsym: SymName, S (per il codice ASM, ad esempio).</span><span class="sxs-lookup"><span data-stu-id="697e0-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="697e0-147">In questo modo la destinazione della chiamata viene inclusa nella tabella **GFIDS** , ma contrassegnata in modo tale che il sistema operativo considererà la destinazione della chiamata come non valida.</span><span class="sxs-lookup"><span data-stu-id="697e0-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="697e0-148">Alcuni scenari non di produzione, ad esempio con determinate strumentazione di Application Verifier abilitati in alcuni sistemi operativi meno recenti, possono consentire la gestione delle destinazioni di chiamata non valide, ma in generale questi scenari non sono previsti scenari di produzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="697e0-149">Questa direttiva è utile per l'annotazione di funzioni "pericolose" che non devono essere considerate come destinazioni di chiamata valide, anche se le normali regole CFG le includono.</span><span class="sxs-lookup"><span data-stu-id="697e0-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="697e0-150">Il codice può indicare che i controlli CFG non sono desiderati con il modificatore __declspec (Guard (nocf)).</span><span class="sxs-lookup"><span data-stu-id="697e0-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="697e0-151">Ciò indica al compilatore di non inserire controlli CFG per l'intera funzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="697e0-152">Il compilatore deve eseguire la propagazione di questa direttiva a qualsiasi codice fornito da una funzione inline contrassegnata come se non si desiderassero controlli CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="697e0-153">Questo approccio viene in genere usato solo sporadicamente in situazioni specifiche in cui il programmatore ha inserito manualmente la protezione "CFG-equivalente".</span><span class="sxs-lookup"><span data-stu-id="697e0-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="697e0-154">Il programmatore sa che sta chiamando tramite una tabella di funzioni di sola lettura il cui indirizzo viene ottenuto tramite riferimenti di memoria di sola lettura e per il quale l'indice viene mascherato al limite della tabella di funzioni.</span><span class="sxs-lookup"><span data-stu-id="697e0-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="697e0-155">Questo approccio può essere applicato anche a piccole funzioni wrapper che non sono inline e che non eseguono alcuna operazione oltre a effettuare una chiamata tramite un puntatore a funzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="697e0-156">Poiché l'utilizzo errato di questa direttiva può compromettere la sicurezza di CFG, il programmatore deve prestare molta attenzione all'utilizzo della direttiva.</span><span class="sxs-lookup"><span data-stu-id="697e0-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="697e0-157">In genere, questo utilizzo è limitato alle funzioni molto piccole che chiamano una sola funzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="697e0-158">Gestione importazione</span><span class="sxs-lookup"><span data-stu-id="697e0-158">Import handling</span></span>

- <span data-ttu-id="697e0-159">Le chiamate tramite la tabella IAT non devono utilizzare la protezione CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="697e0-160">La tabella IAT è di sola lettura nelle immagini moderne (presupponendo che la tabella IAT sia dichiarata nelle intestazioni PE, nel qual caso deve trovarsi nelle proprie pagine).</span><span class="sxs-lookup"><span data-stu-id="697e0-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="697e0-161">La tabella IAT può essere usata per raggiungere le funzioni che vengono evitate, pertanto si tratta di un requisito di correttezza.</span><span class="sxs-lookup"><span data-stu-id="697e0-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="697e0-162">La protezione della memoria di sola lettura tramite la tabella IAT sostituisce quella di CFG, poiché l'associazione di destinazione della chiamata non è modificabile dopo la risoluzione degli snap di importazione dell'immagine e la risoluzione dell'associazione è con granularità fine.</span><span class="sxs-lookup"><span data-stu-id="697e0-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="697e0-163">Caricamento ritardato protetto: le chiamate tramite la tabella IAT con carico ritardato non devono utilizzare la protezione CFG, per gli stessi motivi della IAT standard.</span><span class="sxs-lookup"><span data-stu-id="697e0-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="697e0-164">La tabella IAT per il caricamento ritardato deve trovarsi nella relativa sezione e l'immagine deve impostare l'IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT bit GuardFlags.</span><span class="sxs-lookup"><span data-stu-id="697e0-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="697e0-165">Ciò indica che il caricatore DLL del sistema operativo deve modificare le protezioni per la IAT con caricamento ritardato durante la risoluzione dell'esportazione se si utilizza il supporto del caricamento ritardato del sistema operativo nativo per Windows 8 e sistemi operativi successivi.</span><span class="sxs-lookup"><span data-stu-id="697e0-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="697e0-166">La sincronizzazione di questo passaggio viene gestita dal caricatore della DLL del sistema operativo se è in uso il supporto del caricamento ritardato del sistema operativo nativo (ad esempio ResolveDelayLoadedAPI), pertanto nessun altro componente deve riproteggere le pagine che si estendono sulla IAT di caricamento ritardato dichiarato.</span><span class="sxs-lookup"><span data-stu-id="697e0-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="697e0-167">Per la compatibilità con le versioni precedenti dei sistemi operativi precedenti a CFG, gli strumenti possono abilitare l'opzione per spostare la tabella IAT di caricamento ritardato nella relativa sezione (in modo canonico ". didat"), protetta come lettura/scrittura nelle intestazioni dell'immagine e impostare anche il flag di IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION.</span><span class="sxs-lookup"><span data-stu-id="697e0-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="697e0-168">Questa impostazione provocherà il caricamento della DLL del sistema operativo compatibile con CFG per riproteggere l'intera sezione contenente la tabella IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT per leggere solo la memoria durante il caricamento dell'immagine.</span><span class="sxs-lookup"><span data-stu-id="697e0-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="697e0-169">Se non si è interessati a eseguire un'immagine nei sistemi operativi del supporto per la versione di data e ora, è possibile che l'opzione per collocare la tabella IAT di caricamento ritardato nella relativa sezione non sia necessaria se non si è interessati al supporto del sistema operativo minimo necessario per un'immagine.</span><span class="sxs-lookup"><span data-stu-id="697e0-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="697e0-170">Se un'immagine non usa il supporto per il caricamento ritardato nativo del sistema operativo, può comunque impostare i bit di GuardFlags relativi al caricamento ritardato protetto.</span><span class="sxs-lookup"><span data-stu-id="697e0-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="697e0-171">In questa configurazione, il caricatore del sistema operativo fornirà solo il supporto per proteggere la tabella IAT di caricamento ritardato come di sola lettura in fase di esecuzione, se supportata dalla piattaforma, e diventerà la responsabilità degli stub interni della risoluzione del carico ritardato dell'immagine per sincronizzare e gestire la protezione della IAT di caricamento ritardato.</span><span class="sxs-lookup"><span data-stu-id="697e0-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="697e0-172">A condizione che la tabella di configurazione del carico sia archiviata nella memoria di sola lettura (scelta consigliata), la presenza o l'assenza del bit protetto di caricamento ritardato nel campo GuardFlags dell'immagine può essere utile come hint interno per gli stub di risoluzione del caricamento ritardato interno dell'immagine, in modo da indicare se è necessario proteggere la IAT di caricamento ritardato.</span><span class="sxs-lookup"><span data-stu-id="697e0-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="697e0-173">Se è abilitata la funzionalità CFG, è consigliabile abilitare il caricamento dei ritardi protetti per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="697e0-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="697e0-174">Le immagini che vengono eseguite in versioni precedenti del sistema operativo e che utilizzano il supporto per il caricamento ritardato nativo del sistema operativo, come indicato, possono utilizzare la tabella IAT per il caricamento ritardato nella propria sezione supporto per la compatibilità con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="697e0-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="697e0-175">Ciò si oppone a contrassegnare il ritardo di caricamento IAT come di sola lettura e a unirlo a un'altra sezione, che si interrompe in caso di sistemi operativi precedenti che non comprendono i carichi di ritardo protetti e che forniscono supporto nativo per la risoluzione del carico ritardato.</span><span class="sxs-lookup"><span data-stu-id="697e0-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="697e0-176">Tutte le versioni di Windows 10 e le prime Windows 8.1/Windows Server 2012 R2 compilazioni supportate da CFG, ovvero l'aggiornamento del 2014 novembre, introducono il supporto per il caricamento ritardato protetto nel sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="697e0-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="697e0-177">Allineamento funzioni</span><span class="sxs-lookup"><span data-stu-id="697e0-177">Function alignment</span></span>

- <span data-ttu-id="697e0-178">Le funzioni che sono indirizzate e pertanto incluse nella tabella **GFIDS** devono essere allineate a 16 byte, se possibile.</span><span class="sxs-lookup"><span data-stu-id="697e0-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="697e0-179">Questa operazione potrebbe non essere sempre possibile.</span><span class="sxs-lookup"><span data-stu-id="697e0-179">This may not always be possible.</span></span> <span data-ttu-id="697e0-180">Per le funzioni non COMDAT, ad esempio, che fanno parte di file oggetto assemblati insieme come un'unica unità da strumenti non compatibili con i CFG, che alcuni assemblatori possono produrre, l'utente dello strumento che ha prodotto i file deve impostare correttamente l'allineamento.</span><span class="sxs-lookup"><span data-stu-id="697e0-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="697e0-181">Gli strumenti possono decidere di emettere un avviso di diagnostica in questa situazione, in modo che l'utente possa adottare un'azione correttiva appropriata.</span><span class="sxs-lookup"><span data-stu-id="697e0-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="697e0-182">Il motivo è che i contrassegni CFG chiamano le destinazioni come valide o non sono validi per i limiti di 16 byte per l'efficienza dei controlli CFG veloci.</span><span class="sxs-lookup"><span data-stu-id="697e0-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="697e0-183">Se una funzione non è allineata a 16 byte, l'intero slot a 16 byte deve essere contrassegnato come valido, che non è sicuro perché è possibile chiamare non allineato a un codice che non si trova all'inizio di una funzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="697e0-184">Questo scenario è supportato per semplificare l'interoperabilità quando si crea prima una CFG per un progetto.</span><span class="sxs-lookup"><span data-stu-id="697e0-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="697e0-185">Le immagini non compatibili con CFG sono contrassegnate in modo analogo come valide per qualsiasi allineamento della destinazione della chiamata per la compatibilità.</span><span class="sxs-lookup"><span data-stu-id="697e0-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="697e0-186">Come in precedenza, la presenza di destinazioni di chiamata non allineate riduce i vantaggi di sicurezza di CFG, quindi gli strumenti devono essere allineati automaticamente a un limite di 16 byte per qualsiasi elemento nella tabella **GFIDS** quando si desidera una cfg per un'immagine.</span><span class="sxs-lookup"><span data-stu-id="697e0-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="697e0-187">I simboli che non sono presenti nella tabella **GFIDS** non devono avere particolari allineamenti per la cfg.</span><span class="sxs-lookup"><span data-stu-id="697e0-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="697e0-188">Eliminazione esportazione</span><span class="sxs-lookup"><span data-stu-id="697e0-188">Export suppression</span></span>

- <span data-ttu-id="697e0-189">L'eliminazione dell'esportazione (CFG ES) di CFG è una modalità facoltativa che consente a un processo di indicare che le destinazioni di chiamata che erano valide solo perché sono i simboli dllexport e che non sono stati ancora risolti in modo dinamico da GetProcAddress, verranno considerate non valide a scopo di CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="697e0-190">In questo modo si riduce la superficie di attacco di CFG dalle esportazioni DLL di sistema.</span><span class="sxs-lookup"><span data-stu-id="697e0-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="697e0-191">L'eliminazione dell'esportazione implica la comunicazione tra le destinazioni di chiamata dllexport "esportazione eliminata" e contrassegnate con i flag di IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="697e0-192">I simboli dllexport e il punto di ingresso dell'immagine PE devono essere considerati in modo implicito con gli strumenti necessari per la generazione della tabella **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="697e0-193">Se un simbolo di esportazione è allineato a 16 byte e l'indirizzo viene eseguito per nessun altro motivo rispetto a dllexport, può essere contrassegnato con il flag Export **GFIDS** eliminato nella tabella function.</span><span class="sxs-lookup"><span data-stu-id="697e0-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="697e0-194">Le destinazioni di chiamata che non sono allineate a 16 byte **non devono** essere contrassegnate con il IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED flag **GFIDS** e non possono essere limitate a essere abilitate solo in modo dinamico come destinazioni di chiamata valide in fase di GetProcAddress.</span><span class="sxs-lookup"><span data-stu-id="697e0-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="697e0-195">Un'immagine che supporta le CFG ES include un GuardAddressTakenIatEntryTable il cui conteggio viene fornito da GuardAddressTakenIatEntryCount come parte della directory di configurazione di caricamento.</span><span class="sxs-lookup"><span data-stu-id="697e0-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="697e0-196">Questa tabella è formattata in modo strutturale come la tabella **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="697e0-197">USA lo stesso meccanismo di IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags per codificare byte di metadati facoltativi aggiuntivi nella tabella IAT Address taken, anche se tutti i byte dei metadati devono essere pari a zero per la tabella IAT Address taken e sono riservati.</span><span class="sxs-lookup"><span data-stu-id="697e0-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="697e0-198">La tabella IAT Address taken indica una matrice ordinata di RVA di thunk di importazione, che hanno l'oggetto importato come indirizzo del simbolo assunto come destinazione della chiamata.</span><span class="sxs-lookup"><span data-stu-id="697e0-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="697e0-199">Questo costrutto supporta i simboli di indirizzi usati presenti in un modulo remoto e che sono dllexports, con CFG ES in uso.</span><span class="sxs-lookup"><span data-stu-id="697e0-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="697e0-200">Un esempio di un costrutto di codice di questo tipo è:</span><span class="sxs-lookup"><span data-stu-id="697e0-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="697e0-201">È necessario enumerare tutti questi thunk di importazione, in modo che il caricatore del sistema operativo possa trovarli e rendere valide le destinazioni di chiamata appropriate durante il caricamento di un'immagine e l'allineamento delle relative importazioni.</span><span class="sxs-lookup"><span data-stu-id="697e0-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="697e0-202">La tabella e il conteggio possono essere 0 se non sono presenti thunk di importazione da considerare.</span><span class="sxs-lookup"><span data-stu-id="697e0-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="697e0-203">Un modulo imposta il bit IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags per indicare che sono stati enumerati tutti i thunk degli indirizzi effettuati nella tabella IAT e che tutte le esportazioni che sono idonee per le esportazioni sono contrassegnate con il flag di IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="697e0-204">Si noti che potrebbero essere presenti zero thunk di questo tipo e che potrebbero essere presenti anche zero simboli dllexport.</span><span class="sxs-lookup"><span data-stu-id="697e0-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="697e0-205">La mancata manutenzione della tabella IAT degli indirizzi ottenuti può essere un problema di correttezza, perché alcune destinazioni di chiamata potrebbero non essere rese valide quando devono trovarsi in fase di caricamento della DLL.</span><span class="sxs-lookup"><span data-stu-id="697e0-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="697e0-206">Un modulo imposta il bit di IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags per indicare che vuole abilitare l'ES CFG per il processo.</span><span class="sxs-lookup"><span data-stu-id="697e0-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="697e0-207">In pratica, questo è significativo solo per i exe.</span><span class="sxs-lookup"><span data-stu-id="697e0-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="697e0-208">Un processo di abilitazione di CFG ES non deve caricare le dll non compilate con CFG ES o gli errori di runtime possono verificarsi a causa di simboli IAT considerati come indirizzi non designati.</span><span class="sxs-lookup"><span data-stu-id="697e0-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="697e0-209">Il supporto per l'abilitazione di CFG ES dovrebbe essere un'opzione di consenso esplicito diversa dall'abilitazione di CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="697e0-210">Fornire i metadati di CFG ES è sicuro e consigliato per impostazione predefinita con CFG, sebbene i set di strumenti debbano assicurarsi di produrre metadati corretti.</span><span class="sxs-lookup"><span data-stu-id="697e0-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="697e0-211">In caso contrario, le immagini generate potrebbero non essere eseguite correttamente in un processo CFG ES.</span><span class="sxs-lookup"><span data-stu-id="697e0-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="697e0-212">Questo tipo di supporto deve essere testato accuratamente in un processo di test che impone l'utilizzo di CFG ES.</span><span class="sxs-lookup"><span data-stu-id="697e0-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="697e0-213">Le DLL di sistema del sistema operativo supportano i metadati di CFG ES per le versioni moderne del sistema operativo Windows 10 che comprendono la funzionalità CFG ES.</span><span class="sxs-lookup"><span data-stu-id="697e0-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="697e0-214">Le versioni del sistema operativo precedenti a questo supporto non comprendono alcuna CFG ES e ignoreranno eventuali direttive correlate a CFG ES nell'immagine.</span><span class="sxs-lookup"><span data-stu-id="697e0-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="697e0-215">Queste immagini sono ancora compatibili con le versioni precedenti del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="697e0-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="697e0-216">Il supporto di CFG ES è facoltativo dal punto di vista del set di strumenti, ma è consigliabile che i set di strumenti includano almeno il supporto per enumerare informazioni sufficienti per l'esecuzione di immagini in un processo che desideri CFG ES.</span><span class="sxs-lookup"><span data-stu-id="697e0-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="697e0-217">Come indicato, è fondamentale che il supporto del set di strumenti venga testato accuratamente per assicurarsi che sia compatibile con CFG ES, perché la maggior parte dei processi non Abilita ancora la CFG ES.</span><span class="sxs-lookup"><span data-stu-id="697e0-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="697e0-218">Gestione delle eccezioni e rimozione</span><span class="sxs-lookup"><span data-stu-id="697e0-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="697e0-219">I gestori specifici del linguaggio come __C_specific_handler, come indicato dalle informazioni del gestore di eccezioni in una registrazione pData, non devono essere contrassegnati come destinazioni di chiamata valide nella tabella **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="697e0-220">Vengono invece ricercati attraversando la memoria di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="697e0-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="697e0-221">Analogamente, il gestore specifico del linguaggio C Microsoft usa le ricerche di memoria di sola lettura per individuare funclets per i gestori di eccezioni e pertanto non dichiara il funclets come destinazioni di chiamata valide nella tabella **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="697e0-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="697e0-222">Gestione del salto lungo (per destinazioni non x86 come AMD64): i set di strumenti che compilano con CFG e supportano setjmp ()/longjmp () devono implementare il salto lungo come "salto lungo sicuro" che interagisce con la gestione delle eccezioni strutturata (SEH).</span><span class="sxs-lookup"><span data-stu-id="697e0-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="697e0-223">Ciò significa che Long Jump viene implementato come una chiamata a RtlUnwindEx con STATUS_LONGJUMP come codice di stato nel record di eccezione fornito e un _JUMP_BUFFER standard a cui punta ExceptionInformation [0].</span><span class="sxs-lookup"><span data-stu-id="697e0-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="697e0-224">La destinazione di rimozione del salto dovrebbe essere il TargetIp della rimozione.</span><span class="sxs-lookup"><span data-stu-id="697e0-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="697e0-225">Il buffer di salto rappresenta il contesto di registro ripristinato dal sistema operativo dopo il completamento del salto lungo.</span><span class="sxs-lookup"><span data-stu-id="697e0-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="697e0-226">RtlUnwind (ad esempio) quando viene chiamato con STATUS_LONGJUMP ha un significato speciale univoco per CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="697e0-227">Destinazione di salto lungo (_JUMP_BUFFER. RIP o _JUMP_BUFFER. LR in ARM64) viene cercato nell'elenco dei moduli caricati gestito dal sistema operativo nella memoria di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="697e0-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="697e0-228">Se il modulo contenitore per la destinazione di salto (il "modulo di destinazione") ha il flag di IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT impostato nel campo GuardFlags, la directory di configurazione del carico ha un GuardLongJumpTargetTable con un numero di elementi specificato dal campo Load Configuration GuardLongJumpTargetCount.</span><span class="sxs-lookup"><span data-stu-id="697e0-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="697e0-229">Questa tabella è formattata in modo strutturale come la tabella **GFIDS** e usa lo stesso meccanismo di IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags per codificare i byte di metadati aggiuntivi facoltativi nella tabella di salto lungo.</span><span class="sxs-lookup"><span data-stu-id="697e0-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="697e0-230">Tutti i byte dei metadati devono essere pari a zero per la tabella di salto lungo e sono riservati.</span><span class="sxs-lookup"><span data-stu-id="697e0-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="697e0-231">La tabella di salto lungo rappresenta una matrice ordinata di RVA che sono destinazioni di salto lungo valide.</span><span class="sxs-lookup"><span data-stu-id="697e0-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="697e0-232">Se un modulo di destinazione con salto lungo imposta IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT nel campo GuardFlags, tutte le destinazioni di salto lungo devono essere enumerate in LongJumpTargetTable.</span><span class="sxs-lookup"><span data-stu-id="697e0-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="697e0-233">Anche se un modulo ha destinazioni di salto a lungo zero, deve comunque impostare il flag di IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT se il set di strumenti supporta la protezione avanzata a lungo termine per la CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="697e0-234">Questo significa in modo esplicito che l'immagine non ha destinazioni di salto lungo e non è un'immagine precedente che il sistema operativo deve presupporre potrebbe avere destinazioni di salto lungo valide in posizioni non contrassegnate per le quali non è possibile eseguire il controllo della destinazione di salto lungo.</span><span class="sxs-lookup"><span data-stu-id="697e0-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="697e0-235">Per impostazione predefinita, è consigliabile abilitare la funzionalità di protezione avanzata con salto a lungo se è supportata la funzionalità CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="697e0-236">Questa è la disposizione dei compilatori Microsoft.</span><span class="sxs-lookup"><span data-stu-id="697e0-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="697e0-237">I sistemi operativi che non sono in grado di eseguire la protezione avanzata da più tempo (versioni precedenti a Windows 10 o versioni precedenti di Windows 10) non eseguono controlli di protezione avanzata a lungo termine e ignorano i metadati a lungo termine, quindi la protezione avanzata è compatibile con le versioni precedenti del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="697e0-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="697e0-238">Per le immagini in modalità kernel, la tabella di destinazione per il salto lungo della protezione non deve essere inclusa in una sezione non riutilizzabile.</span><span class="sxs-lookup"><span data-stu-id="697e0-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="697e0-239">La tabella di destinazione per il salto lungo di Guard deve essere sempre archiviata nella memoria di sola lettura per garantire l'efficacia delle proprietà di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="697e0-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="697e0-240">Informazioni COFF</span><span class="sxs-lookup"><span data-stu-id="697e0-240">COFF information</span></span>

- <span data-ttu-id="697e0-241">Sono presenti contrassegni di file oggetto per dichiarare se un file oggetto è conforme a CFG o meno.</span><span class="sxs-lookup"><span data-stu-id="697e0-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="697e0-242">Un file oggetto che è conforme a CFG elenca le destinazioni di chiamata valide che produce, in modo esplicito, nonché qualsiasi indirizzo utilizzato per i metadati IAT.</span><span class="sxs-lookup"><span data-stu-id="697e0-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="697e0-243">Un file oggetto che non è conforme a CFG deve avere destinazioni di chiamata dedotto esaminando le rilocazioni COFF del file obj per trovare le rilocazioni che puntano all'inizio di un simbolo di funzione.</span><span class="sxs-lookup"><span data-stu-id="697e0-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="697e0-244">Questo può comportare la presenza di destinazioni di chiamata CFG valide, pertanto è opportuno che gli strumenti contrassegnino i file obj che sono compatibili con CFG e includano i metadati del file obj CFG se vengono compilati con CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="697e0-245">Sono presenti contrassegni di file oggetto per dichiarare destinazioni di salto lungo per il salto lungo con protezione avanzata CFG da popolare per la modalità di compilazione CFG.</span><span class="sxs-lookup"><span data-stu-id="697e0-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
