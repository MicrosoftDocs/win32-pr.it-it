---
description: Il controllo del flusso di controllo (CFG) è una funzionalità di sicurezza della piattaforma altamente ottimizzata che è stata creata per combattere le vulnerabilità di danneggiamento della memoria.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Protezione del flusso di controllo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "104132023"
---
# <a name="control-flow-guard"></a><span data-ttu-id="8b166-103">Protezione del flusso di controllo</span><span class="sxs-lookup"><span data-stu-id="8b166-103">Control Flow Guard</span></span>

## <a name="what-is-control-flow-guard"></a><span data-ttu-id="8b166-104">Che cos'è la protezione del flusso di controllo?</span><span class="sxs-lookup"><span data-stu-id="8b166-104">What is Control Flow Guard?</span></span>

<span data-ttu-id="8b166-105">Il controllo del flusso di controllo (CFG) è una funzionalità di sicurezza della piattaforma altamente ottimizzata che è stata creata per combattere le vulnerabilità di danneggiamento della memoria.</span><span class="sxs-lookup"><span data-stu-id="8b166-105">Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.</span></span> <span data-ttu-id="8b166-106">Ponendo restrizioni restrittive su dove un'applicazione può eseguire il codice, rende molto più difficile per gli exploit eseguire codice arbitrario attraverso vulnerabilità come gli overflow del buffer.</span><span class="sxs-lookup"><span data-stu-id="8b166-106">By placing tight restrictions on where an application can execute code from, it makes it much harder for exploits to execute arbitrary code through vulnerabilities such as buffer overflows.</span></span> <span data-ttu-id="8b166-107">CFG estende le tecnologie di mitigazione degli exploit precedenti, ad esempio [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)e [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span><span class="sxs-lookup"><span data-stu-id="8b166-107">CFG extends previous exploit mitigation technologies such as [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md), and [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span></span>

<span data-ttu-id="8b166-108">Questa funzionalità è disponibile in Microsoft Visual Studio 2015 e viene eseguita su versioni di Windows compatibili con CFG, ovvero le versioni x86 e x64 per desktop e server di Windows 10 e Windows 8.1 Update (KB3000850).</span><span class="sxs-lookup"><span data-stu-id="8b166-108">This feature is available in Microsoft Visual Studio 2015, and runs on "CFG-Aware" versions of Windows—the x86 and x64 releases for Desktop and Server of Windows 10 and Windows 8.1 Update (KB3000850).</span></span>

<span data-ttu-id="8b166-109">Si consiglia agli sviluppatori di abilitare la CFG per le proprie applicazioni.</span><span class="sxs-lookup"><span data-stu-id="8b166-109">We strongly encourage developers to enable CFG for their applications.</span></span> <span data-ttu-id="8b166-110">Non è necessario abilitare la funzionalità CFG per ogni parte del codice, perché una combinazione di CFG abilitata e il codice non abilitato per la CFG verrà eseguita correttamente.</span><span class="sxs-lookup"><span data-stu-id="8b166-110">You don't have to enable CFG for every part of your code, as a mixture of CFG enabled and non-CFG enabled code will execute fine.</span></span> <span data-ttu-id="8b166-111">Tuttavia, la mancata abilitazione di CFG per tutto il codice può aprire gap nella protezione.</span><span class="sxs-lookup"><span data-stu-id="8b166-111">But failing to enable CFG for all code can open gaps in the protection.</span></span> <span data-ttu-id="8b166-112">Inoltre, il codice abilitato per la funzionalità CFG funziona correttamente nelle versioni di Windows "non compatibili con CFG" ed è quindi completamente compatibile con loro.</span><span class="sxs-lookup"><span data-stu-id="8b166-112">Furthermore, CFG enabled code works fine on "CFG-Unaware" versions of Windows and is therefore fully compatible with them.</span></span>

## <a name="how-can-i-enable-cfg"></a><span data-ttu-id="8b166-113">Come è possibile abilitare la CFG?</span><span class="sxs-lookup"><span data-stu-id="8b166-113">How Can I Enable CFG?</span></span>

<span data-ttu-id="8b166-114">Nella maggior parte dei casi, non è necessario modificare il codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="8b166-114">In most cases, there is no need to change source code.</span></span> <span data-ttu-id="8b166-115">È sufficiente aggiungere un'opzione al progetto di Visual Studio 2015 e il compilatore e il linker abilitano la funzione CFG.</span><span class="sxs-lookup"><span data-stu-id="8b166-115">All you have to do is add an option to your Visual Studio 2015 project, and the compiler and linker will enable CFG.</span></span>

<span data-ttu-id="8b166-116">Il metodo più semplice consiste nel passare alle proprietà di configurazione delle proprietà di **\| \| configurazione \| C/C++ \| generazione del codice** e scegliere **Sì (/Guard: CF)** per la protezione del flusso di controllo.</span><span class="sxs-lookup"><span data-stu-id="8b166-116">The simplest method is to navigate to **Project \| Properties \| Configuration Properties \| C/C++ \| Code Generation** and choose **Yes (/guard:cf)** for Control Flow Guard.</span></span>

![Proprietà cfg in Visual Studio](images/cfg-vs.png)

<span data-ttu-id="8b166-118">In alternativa, aggiungere **/Guard: CF** alle proprietà di progetto proprietà di **\| \| configurazione \| \| \| Opzioni aggiuntive della riga di comando di C/C++** (per il compilatore) e **/Guard: CF** to **Project Properties proprietà di \| \| configurazione \| \| \| Opzioni aggiuntive della riga di comando** (per il linker).</span><span class="sxs-lookup"><span data-stu-id="8b166-118">Alternatively, add **/guard:cf** to **Project \| Properties \| Configuration Properties \| C/C++ \| Command Line \| Additional Options** (for the compiler) and **/guard:cf** to **Project \| Properties \| Configuration Properties \| Linker \| Command Line \| Additional Options** (for the linker).</span></span>

![Proprietà cfg per il compilatore](images/cfg-compiler.png)![Proprietà cfg per linker](images/cfg-linker.png)

<span data-ttu-id="8b166-121">Per ulteriori informazioni, vedere [/Guard (Abilita Guard flusso di controllo)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) .</span><span class="sxs-lookup"><span data-stu-id="8b166-121">See [/guard (Enable Control Flow Guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) for additional info.</span></span>

<span data-ttu-id="8b166-122">Se si compila il progetto dalla riga di comando, è possibile aggiungere le stesse opzioni.</span><span class="sxs-lookup"><span data-stu-id="8b166-122">If you are building your project from the command line, you can add the same options.</span></span> <span data-ttu-id="8b166-123">Se ad esempio si compila un progetto denominato test. cpp, usare **CL/Guard: CF test. cpp/link/Guard: CF**.</span><span class="sxs-lookup"><span data-stu-id="8b166-123">For example, if you are compiling a project called test.cpp, use **cl /guard:cf test.cpp /link /guard:cf**.</span></span>

<span data-ttu-id="8b166-124">È anche possibile controllare dinamicamente il set di indirizzi di destinazione iCal che sono considerati validi da CFG usando [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) dall'API di gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="8b166-124">You also have the option of dynamically controlling the set of icall target addresses that are considered valid by CFG using the [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) from the Memory Management API.</span></span> <span data-ttu-id="8b166-125">La stessa API può essere usata per specificare se le pagine sono destinazioni non valide o valide per la CFG.</span><span class="sxs-lookup"><span data-stu-id="8b166-125">The same API can be used to specify whether pages are invalid or valid targets for CFG.</span></span> <span data-ttu-id="8b166-126">Per impostazione predefinita, le funzioni [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) e [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) gestiscono un'area specificata di pagine eseguibili e di cui viene eseguito il commit come destinazioni di chiamata indirette valide.</span><span class="sxs-lookup"><span data-stu-id="8b166-126">The [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) and [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) functions will by default treat a specified region of executable and committed pages as valid indirect call targets.</span></span> <span data-ttu-id="8b166-127">È possibile eseguire l'override di questo comportamento, ad esempio quando si implementa un compilatore just-in-time, specificando **destinazioni della pagina \_ \_ non valide** quando si chiama **VirtualAlloc** o non viene eseguito **\_ \_ alcun \_ aggiornamento** quando si chiama **VirtualProtect** come descritto in [**costanti di protezione della memoria**](/windows/desktop/Memory/memory-protection-constants).</span><span class="sxs-lookup"><span data-stu-id="8b166-127">It is possible to override this behavior, such as when implementing a Just-in-Time compiler, by specifying **PAGE\_TARGETS\_INVALID** when calling **VirtualAlloc** or **PAGE\_TARGETS\_NO\_UPDATE** when calling **VirtualProtect** as detailed under [**Memory Protection Constants**](/windows/desktop/Memory/memory-protection-constants).</span></span>

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a><span data-ttu-id="8b166-128">Come è possibile stabilire se un file binario è sotto la protezione del flusso di controllo?</span><span class="sxs-lookup"><span data-stu-id="8b166-128">How Do I Tell That a Binary is under Control Flow Guard?</span></span>

<span data-ttu-id="8b166-129">Eseguire lo [strumento DUMPBIN](/cpp/build/reference/dumpbin-reference) (incluso nell'installazione di visual studio 2015) dal prompt dei comandi di Visual Studio con le opzioni */headers* e */loadconfig* : **dumpbin/headers/loadConfig test.exe**.</span><span class="sxs-lookup"><span data-stu-id="8b166-129">Run the [dumpbin tool](/cpp/build/reference/dumpbin-reference) (included in the Visual Studio 2015 installation) from the Visual Studio command prompt with the */headers* and */loadconfig* options: **dumpbin /headers /loadconfig test.exe**.</span></span> <span data-ttu-id="8b166-130">L'output di un file binario in CFG dovrebbe indicare che i valori dell'intestazione includono "Guard" e che i valori di configurazione di caricamento includono "CF instrumentato" e "FID Table present".</span><span class="sxs-lookup"><span data-stu-id="8b166-130">The output for a binary under CFG should show that the header values include "Guard", and that the load config values include "CF Instrumented" and "FID table present".</span></span>

![output di dumpbin/headers](images/cfg-dumpbin-headers.png)

![output di DUMPBIN/loadConfig](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a><span data-ttu-id="8b166-133">Come funziona la funzione CFG?</span><span class="sxs-lookup"><span data-stu-id="8b166-133">How Does CFG Really Work?</span></span>

<span data-ttu-id="8b166-134">Le vulnerabilità software vengono spesso sfruttate fornendo dati improbabili, insoliti o estremi a un programma in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="8b166-134">Software vulnerabilities are often exploited by providing unlikely, unusual, or extreme data to a running program.</span></span> <span data-ttu-id="8b166-135">Un utente malintenzionato può, ad esempio, sfruttare una vulnerabilità di overflow del buffer fornendo un maggior numero di input a un programma, quindi sovrascrivendo l'area riservata dal programma per mantenere una risposta.</span><span class="sxs-lookup"><span data-stu-id="8b166-135">For example, an attacker can exploit a buffer overflow vulnerability by providing more input to a program than expected, thereby over-running the area reserved by the program to hold a response.</span></span> <span data-ttu-id="8b166-136">Questo potrebbe danneggiare la memoria adiacente che può avere un puntatore a funzione.</span><span class="sxs-lookup"><span data-stu-id="8b166-136">This could corrupt adjacent memory that may hold a function pointer.</span></span> <span data-ttu-id="8b166-137">Quando il programma chiama tramite questa funzione, può passare a una posizione non desiderata specificata dall'autore dell'attacco.</span><span class="sxs-lookup"><span data-stu-id="8b166-137">When the program calls through this function it may then jump to an unintended location specified by the attacker.</span></span>

<span data-ttu-id="8b166-138">Tuttavia, una potente combinazione di supporto di compilazione e Runtime da CFG implementa l'integrità del flusso di controllo che limita strettamente la posizione in cui possono essere eseguite le istruzioni per le chiamate indirette.</span><span class="sxs-lookup"><span data-stu-id="8b166-138">However, a potent combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.</span></span>

<span data-ttu-id="8b166-139">Il compilatore esegue le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="8b166-139">The compiler does the following:</span></span>

1.  <span data-ttu-id="8b166-140">Aggiunge controlli di sicurezza leggeri al codice compilato.</span><span class="sxs-lookup"><span data-stu-id="8b166-140">Adds lightweight security checks to the compiled code.</span></span>
2.  <span data-ttu-id="8b166-141">Identifica il set di funzioni nell'applicazione che sono destinazioni valide per le chiamate indirette.</span><span class="sxs-lookup"><span data-stu-id="8b166-141">Identifies the set of functions in the application that are valid targets for indirect calls.</span></span>

<span data-ttu-id="8b166-142">Supporto del runtime, fornito dal kernel di Windows:</span><span class="sxs-lookup"><span data-stu-id="8b166-142">The runtime support, provided by the Windows kernel:</span></span>

1.  <span data-ttu-id="8b166-143">Mantiene in modo efficiente lo stato che identifica destinazioni di chiamata indirette valide.</span><span class="sxs-lookup"><span data-stu-id="8b166-143">Efficiently maintains state that identifies valid indirect call targets.</span></span>
2.  <span data-ttu-id="8b166-144">Implementa la logica che verifica che una destinazione di chiamata indiretta sia valida.</span><span class="sxs-lookup"><span data-stu-id="8b166-144">Implements the logic that verifies that an indirect call target is valid.</span></span>

<span data-ttu-id="8b166-145">Per illustrare:</span><span class="sxs-lookup"><span data-stu-id="8b166-145">To illustrate:</span></span>

![pseudocodice cfg](images/cfg-pseudocode.jpg)

<span data-ttu-id="8b166-147">Quando un controllo CFG ha esito negativo in fase di esecuzione, Windows termina immediatamente il programma, in modo da interrompere eventuali exploit che tentano di chiamare indirettamente un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="8b166-147">When a CFG check fails at runtime, Windows immediately terminates the program, thus breaking any exploit that attempts to indirectly call an invalid address.</span></span>

 

 
