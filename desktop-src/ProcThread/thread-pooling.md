---
description: Sono disponibili molte applicazioni che creano thread che impiegano molto tempo nello stato di sospensione in attesa del verificarsi di un evento.
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: Pooling dei thread
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/07/2021
ms.locfileid: "103881693"
---
# <a name="thread-pooling"></a><span data-ttu-id="ba4f0-103">Pooling dei thread</span><span class="sxs-lookup"><span data-stu-id="ba4f0-103">Thread Pooling</span></span>

<span data-ttu-id="ba4f0-104">Sono disponibili molte applicazioni che creano thread che impiegano molto tempo nello stato di sospensione in attesa del verificarsi di un evento.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="ba4f0-105">Gli altri thread possono entrare in uno stato di sospensione solo per essere riattivati periodicamente per eseguire il polling di una modifica o aggiornare le informazioni sullo stato.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="ba4f0-106">Il *pool di thread* consente di usare i thread in modo più efficiente fornendo all'applicazione un pool di thread di lavoro gestiti dal sistema.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="ba4f0-107">Almeno un thread monitora lo stato di tutte le operazioni di attesa accodate al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="ba4f0-108">Al termine di un'operazione di attesa, un thread di lavoro del pool di thread esegue la funzione di callback corrispondente.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="ba4f0-109">Questo argomento descrive l'API del pool di thread originale.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="ba4f0-110">L'API del pool di thread introdotta in Windows Vista è più semplice, più affidabile, offre prestazioni migliori e offre maggiore flessibilità per gli sviluppatori.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="ba4f0-111">Per informazioni sull'API del pool di thread corrente, vedere [pool di thread](thread-pools.md).</span><span class="sxs-lookup"><span data-stu-id="ba4f0-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="ba4f0-112">È anche possibile accodare gli elementi di lavoro che non sono correlati a un'operazione di attesa al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="ba4f0-113">Per richiedere che un elemento di lavoro venga gestito da un thread nel pool di thread, chiamare la funzione [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) .</span><span class="sxs-lookup"><span data-stu-id="ba4f0-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="ba4f0-114">Questa funzione accetta un parametro per la funzione che verrà chiamata dal thread selezionato dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="ba4f0-115">Non è possibile annullare un elemento di lavoro dopo che è stato accodato.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="ba4f0-116">[Timer:](../sync/timer-queues.md) i timer della coda e [le operazioni di attesa registrate](../sync/wait-functions.md) utilizzano anche il pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="ba4f0-117">Le funzioni di callback vengono accodate al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="ba4f0-118">È anche possibile usare la funzione [**BindIoCompletionCallback ha provocato**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) per inviare operazioni di I/O asincrone.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="ba4f0-119">Al completamento dell'i/O, il callback viene eseguito da un thread del pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="ba4f0-120">Il pool di thread viene creato la prima volta che si chiama [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) o [**BindIoCompletionCallback ha provocato**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback)o quando un timer-coda timer o un'operazione di attesa registrata Accoda una funzione di callback.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="ba4f0-121">Per impostazione predefinita, il numero di thread che è possibile creare nel pool di thread è pari a circa 500.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="ba4f0-122">Ogni thread usa le dimensioni predefinite dello stack e viene eseguito con la priorità predefinita.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="ba4f0-123">Esistono due tipi di thread di lavoro nel pool di thread: I/O e non-I/O.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="ba4f0-124">Un *thread di lavoro di I/O* è un thread che attende uno stato di attesa di avviso.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="ba4f0-125">Gli elementi di lavoro vengono accodati ai thread di lavoro di I/O come chiamate di procedure asincrone (APC).</span><span class="sxs-lookup"><span data-stu-id="ba4f0-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="ba4f0-126">È necessario accodare un elemento di lavoro a un thread di lavoro di I/O se deve essere eseguito in un thread che attende in uno stato di avviso.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="ba4f0-127">Un *thread di lavoro non di i/o* è in attesa sulle porte di completamento i/o.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="ba4f0-128">L'utilizzo di thread di lavoro non di I/O è più efficiente rispetto all'utilizzo di thread di lavoro di I/O.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="ba4f0-129">Pertanto, quando possibile, è consigliabile utilizzare thread di lavoro non di I/O.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="ba4f0-130">I thread di lavoro di I/O e non di I/O non terminano se sono presenti richieste di I/O asincrone in sospeso.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="ba4f0-131">Entrambi i tipi di thread possono essere utilizzati da elementi di lavoro che avviano richieste di completamento I/O asincrone.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="ba4f0-132">Evitare tuttavia di inviare richieste di completamento I/O asincrone nei thread di lavoro non di I/O se il completamento potrebbe richiedere molto tempo.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="ba4f0-133">Per usare il pool di thread, gli elementi di lavoro e tutte le funzioni che chiamano devono essere sicuri del pool di thread.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="ba4f0-134">Una funzione Safe non presuppone che il thread che lo esegue sia un thread dedicato o persistente.</span><span class="sxs-lookup"><span data-stu-id="ba4f0-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="ba4f0-135">In generale, è consigliabile evitare di usare l' [archiviazione locale di thread](thread-local-storage.md) o effettuare una chiamata asincrona che richiede un thread persistente, ad esempio la funzione [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) .</span><span class="sxs-lookup"><span data-stu-id="ba4f0-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="ba4f0-136">Tuttavia, tali funzioni possono essere chiamate su un thread dedicato (creato dall'applicazione) o accodate a un thread di lavoro permanente (usando [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) con l' \_ opzione WT EXECUTEINPERSISTENTTHREAD).</span><span class="sxs-lookup"><span data-stu-id="ba4f0-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="ba4f0-137">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="ba4f0-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ba4f0-138">I/O Alertable</span><span class="sxs-lookup"><span data-stu-id="ba4f0-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="ba4f0-139">Chiamate di procedure asincrone</span><span class="sxs-lookup"><span data-stu-id="ba4f0-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="ba4f0-140">Porte di completamento I/O</span><span class="sxs-lookup"><span data-stu-id="ba4f0-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="ba4f0-141">Pool di thread</span><span class="sxs-lookup"><span data-stu-id="ba4f0-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
