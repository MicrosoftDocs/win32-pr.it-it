---
description: Informazioni su come evitare blocchi nelle applicazioni Windows per le piattaforme Windows 7 e Windows Server 2008 R2.
ms.assetid: 698a046b-1934-49cd-a717-d61e7e1ec534
title: Prevenzione di blocchi nelle applicazioni Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35a2d8fac95039f20c8c684c50138933c54750c3
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/06/2021
ms.locfileid: "104058408"
---
# <a name="preventing-hangs-in-windows-applications"></a><span data-ttu-id="1e2f3-103">Prevenzione di blocchi nelle applicazioni Windows</span><span class="sxs-lookup"><span data-stu-id="1e2f3-103">Preventing Hangs in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="1e2f3-104">Piattaforme interessate</span><span class="sxs-lookup"><span data-stu-id="1e2f3-104">Affected Platforms</span></span>

<span data-ttu-id="1e2f3-105">**Client** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="1e2f3-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="1e2f3-106">**Server** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="1e2f3-106">**Servers** - Windows Server 2008 R2</span></span>  









## <a name="description"></a><span data-ttu-id="1e2f3-107">Descrizione</span><span class="sxs-lookup"><span data-stu-id="1e2f3-107">Description</span></span>

<span data-ttu-id="1e2f3-108">**Blocchi-prospettiva utente**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-108">**Hangs - User Perspective**</span></span>

<span data-ttu-id="1e2f3-109">Utenti come le applicazioni reattive.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-109">Users like responsive applications.</span></span> <span data-ttu-id="1e2f3-110">Quando si fa clic su un menu, si desidera che l'applicazione reagisca immediatamente, anche se attualmente sta stampando il lavoro.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-110">When they click a menu, they want the application to react instantly, even if it is currently printing their work.</span></span> <span data-ttu-id="1e2f3-111">Quando si salva un documento lungo nel proprio elaboratore di testo preferito, è necessario continuare a digitare mentre il disco è ancora in fase di rotazione.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-111">When they save a lengthy document in their favorite word processor, they want to continue typing while the disk is still spinning.</span></span> <span data-ttu-id="1e2f3-112">Gli utenti si impazienteno piuttosto rapidamente quando l'applicazione non reagirà tempestivamente all'input.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-112">Users get impatient rather quickly when the application does not react in a timely fashion to their input.</span></span>

<span data-ttu-id="1e2f3-113">Un programmatore potrebbe riconoscere molti motivi legittimi per cui un'applicazione non risponde immediatamente all'input dell'utente.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-113">A programmer might recognize many legitimate reasons for an application not to instantly respond to user input.</span></span> <span data-ttu-id="1e2f3-114">È possibile che l'applicazione sia occupata per il ricalcolo di alcuni dati o semplicemente in attesa del completamento dell'I/O del disco.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-114">The application might be busy recalculating some data, or simply waiting for its disk I/O to complete.</span></span> <span data-ttu-id="1e2f3-115">Tuttavia, dalla ricerca degli utenti, sappiamo che gli utenti si annoiano e sono frustrati dopo un paio di secondi di inattività.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-115">However, from user research, we know that users get annoyed and frustrated after just a couple of seconds of unresponsiveness.</span></span> <span data-ttu-id="1e2f3-116">Dopo 5 secondi tenterà di terminare un'applicazione bloccata.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-116">After 5 seconds, they will try to terminate a hung application.</span></span> <span data-ttu-id="1e2f3-117">Accanto a arresti anomali, i blocchi dell'applicazione sono l'origine più comune di interruzioni dell'utente quando si lavora con le applicazioni Win32.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-117">Next to crashes, application hangs are the most common source of user disruption when working with Win32 applications.</span></span>

<span data-ttu-id="1e2f3-118">Ci sono molte cause principali diverse per i blocchi dell'applicazione e non tutti si manifestano in un'interfaccia utente che non risponde.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-118">There are many different root causes for application hangs, and not all of them manifest themselves in an unresponsive UI.</span></span> <span data-ttu-id="1e2f3-119">Tuttavia, un'interfaccia utente che non risponde è una delle più comuni esperienze di blocco e questo scenario attualmente riceve la maggior parte del supporto del sistema operativo sia per il rilevamento che per il ripristino.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-119">However, an unresponsive UI is one of the most common hang experiences, and this scenario currently receives the most operating system support for both detection as well as recovery.</span></span> <span data-ttu-id="1e2f3-120">Windows rileva automaticamente, raccoglie le informazioni di debug e, facoltativamente, termina o riavvia le applicazioni appese.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-120">Windows automatically detects, collects debug information, and optionally terminates or restarts hung applications.</span></span> <span data-ttu-id="1e2f3-121">In caso contrario, l'utente potrebbe dover riavviare il computer per ripristinare un'applicazione bloccata.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-121">Otherwise, the user might have to restart the machine in order to recover a hung application.</span></span>

<span data-ttu-id="1e2f3-122">**Blocchi-prospettiva del sistema operativo**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-122">**Hangs - Operating System Perspective**</span></span>

<span data-ttu-id="1e2f3-123">Quando un'applicazione (o più accuratamente, un thread) crea una finestra sul desktop, entra in un contratto implicito con il Gestione finestre desktop (DWM) per elaborare i messaggi della finestra in modo tempestivo.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-123">When an application (or more accurately, a thread) creates a window on the desktop, it enters into an implicit contract with the Desktop Window Manager (DWM) to process window messages in a timely fashion.</span></span> <span data-ttu-id="1e2f3-124">DWM inserisce i messaggi (input da tastiera/mouse e messaggi da altre finestre, così come se stessi) nella coda di messaggi specifica del thread.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-124">The DWM posts messages (keyboard/mouse input and messages from other windows, as well as itself) into the thread-specific message queue.</span></span> <span data-ttu-id="1e2f3-125">Il thread recupera e invia tali messaggi tramite la relativa coda di messaggi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-125">The thread retrieves and dispatches those messages via its message queue.</span></span> <span data-ttu-id="1e2f3-126">Se il thread non esegue la manutenzione della coda chiamando GetMessage (), i messaggi non vengono elaborati e la finestra si blocca: non può né ridisegnato né può accettare l'input dell'utente.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-126">If the thread does not service the queue by calling GetMessage(), messages are not processed, and the window hangs: it can neither redraw nor can it accept input from the user.</span></span> <span data-ttu-id="1e2f3-127">Il sistema operativo rileva questo stato connettendo un timer ai messaggi in sospeso nella coda di messaggi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-127">The operating system detects this state by attaching a timer to pending messages in the message queue.</span></span> <span data-ttu-id="1e2f3-128">Se un messaggio non è stato recuperato entro 5 secondi, DWM dichiara che la finestra deve essere bloccata.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-128">If a message has not been retrieved within 5 seconds, the DWM declares the window to be hung.</span></span> <span data-ttu-id="1e2f3-129">È possibile eseguire query su questo particolare stato della finestra tramite l'API IsHungAppWindow ().</span><span class="sxs-lookup"><span data-stu-id="1e2f3-129">You can query this particular window state via the IsHungAppWindow() API.</span></span>

<span data-ttu-id="1e2f3-130">Il rilevamento è solo il primo passaggio.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-130">Detection is only the first step.</span></span> <span data-ttu-id="1e2f3-131">A questo punto, l'utente non può ancora terminare l'applicazione. Se si fa clic sul pulsante X (Chiudi), \_ verrà visualizzato un messaggio di chiusura WM, che verrebbe bloccato nella coda dei messaggi esattamente come per qualsiasi altro messaggio.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-131">At this point, the user still cannot even terminate the application - clicking the X (Close) button would result in a WM\_CLOSE message, which would be stuck in the message queue just like any other message.</span></span> <span data-ttu-id="1e2f3-132">Il Gestione finestre desktop facilita la semplice occultamento e la sostituzione della finestra bloccata con una copia ' fantasma ' che visualizza una bitmap dell'area client precedente della finestra originale (e l'aggiunta di "non risponde" alla barra del titolo).</span><span class="sxs-lookup"><span data-stu-id="1e2f3-132">The Desktop Window Manager assists by seamlessly hiding and then replacing the hung window with a 'ghost' copy displaying a bitmap of the original window's previous client area (and adding "Not Responding" to the title bar).</span></span> <span data-ttu-id="1e2f3-133">Finché il thread della finestra originale non recupera i messaggi, DWM gestisce entrambe le finestre simultaneamente, ma consente all'utente di interagire solo con la copia fantasma.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-133">As long as the original window's thread does not retrieve messages, the DWM manages both windows simultaneously, but allows the user to interact only with the ghost copy.</span></span> <span data-ttu-id="1e2f3-134">Utilizzando questa finestra fantasma, l'utente può solo spostare, ridurre a icona e, più importante, chiudere l'applicazione che non risponde, ma non modificarne lo stato interno.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-134">Using this ghost window, the user can only move, minimize, and - most importantly - close the unresponsive application, but not change its internal state.</span></span>

<span data-ttu-id="1e2f3-135">L'intera esperienza fantasma ha un aspetto simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="1e2f3-135">The whole ghost experience looks like this:</span></span>

![Screenshot che mostra la finestra di dialogo "blocco note non risponde".](images/preventinghangs-ghostwindow.gif)

<span data-ttu-id="1e2f3-137">Il Gestione finestre desktop esegue un'ultima operazione; si integra con Segnalazione errori Windows, consentendo all'utente non solo di chiudere e, facoltativamente, di riavviare l'applicazione, ma anche di inviare dati di debug importanti a Microsoft.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-137">The Desktop Window Manager does one last thing; it integrates with Windows Error Reporting, allowing the user to not only close and optionally restart the application, but also send valuable debugging data back to Microsoft.</span></span> <span data-ttu-id="1e2f3-138">Puoi ottenere questi dati di blocco per le tue applicazioni iscrivendoti al sito Web winqual.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-138">You can get this hang data for your own applications by signing up at the Winqual website.</span></span>

<span data-ttu-id="1e2f3-139">Windows 7 ha aggiunto una nuova funzionalità a questa esperienza.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-139">Windows 7 added one new feature to this experience.</span></span> <span data-ttu-id="1e2f3-140">Il sistema operativo analizza l'applicazione bloccata e, in determinate circostanze, offre all'utente la possibilità di annullare un'operazione di blocco e di riattivare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-140">The operating system analyzes the hung application and, under certain circumstances, gives the user the option to cancel a blocking operation and make the application responsive again.</span></span> <span data-ttu-id="1e2f3-141">L'implementazione corrente supporta l'annullamento delle chiamate al socket di blocco; altre operazioni saranno annullabili dall'utente nelle versioni future.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-141">The current implementation supports cancellation of blocking Socket calls; more operations will be user-cancelable in future releases.</span></span>

<span data-ttu-id="1e2f3-142">Per integrare l'applicazione con l'esperienza di ripristino del blocco e per sfruttare al meglio i dati disponibili, attenersi alla procedura seguente:</span><span class="sxs-lookup"><span data-stu-id="1e2f3-142">To integrate your application with the hang recovery experience and to make the most out of the available data, follow these steps:</span></span>

-   <span data-ttu-id="1e2f3-143">Assicurarsi che l'applicazione venga registrata per il riavvio e il ripristino, facendo in modo che un blocco sia più libero possibile per l'utente.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-143">Ensure that your application registers for restart and recovery, making a hang as pain-free as possible to the user.</span></span> <span data-ttu-id="1e2f3-144">Un'applicazione registrata correttamente può essere riavviata automaticamente con la maggior parte dei dati non salvati intatti.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-144">A properly registered application can automatically restart with most of its unsaved data intact.</span></span> <span data-ttu-id="1e2f3-145">Questa operazione può essere eseguita per blocchi e arresti anomali dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-145">This works for both application hangs and crashes.</span></span>
-   <span data-ttu-id="1e2f3-146">Ottenere informazioni sulla frequenza, nonché i dati di debug per le applicazioni bloccate e bloccate dal sito Web winqual.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-146">Get frequency information as well as debugging data for your hung and crashed applications from the Winqual website.</span></span> <span data-ttu-id="1e2f3-147">È possibile usare queste informazioni anche durante la beta per migliorare il codice.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-147">You can use this information even during your Beta to improve your code.</span></span> <span data-ttu-id="1e2f3-148">Per una breve panoramica, vedere "Introduzione a Segnalazione errori Windows".</span><span class="sxs-lookup"><span data-stu-id="1e2f3-148">See "Introducing Windows Error Reporting" for a brief overview.</span></span>
-   <span data-ttu-id="1e2f3-149">È possibile disabilitare la funzionalità ghosting nell'applicazione tramite una chiamata a DisableProcessWindowsGhosting ().</span><span class="sxs-lookup"><span data-stu-id="1e2f3-149">You can disable the ghosting feature in your application via a call to DisableProcessWindowsGhosting ().</span></span> <span data-ttu-id="1e2f3-150">Tuttavia, in questo modo si impedisce all'utente medio di chiudere e riavviare un'applicazione bloccata e spesso termina con un riavvio.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-150">However, this prevents the average user from closing and restarting a hung application and often ends in a reboot.</span></span>

<span data-ttu-id="1e2f3-151">**Blocchi-prospettiva per sviluppatori**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-151">**Hangs - Developer Perspective**</span></span>

<span data-ttu-id="1e2f3-152">Il sistema operativo definisce un'applicazione bloccata come un thread dell'interfaccia utente che non ha elaborato i messaggi per almeno 5 secondi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-152">The operating system defines an application hang as a UI thread that has not processed messages for at least 5 seconds.</span></span> <span data-ttu-id="1e2f3-153">I bug evidenti provocano alcuni blocchi, ad esempio un thread in attesa di un evento che non viene mai segnalato e due thread che bloccano e tentano di acquisire gli altri.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-153">Obvious bugs cause some hangs, for example, a thread waiting for an event that is never signaled, and two threads each holding a lock and trying to acquire the others.</span></span> <span data-ttu-id="1e2f3-154">È possibile correggere i bug senza troppi sforzi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-154">You can fix those bugs without too much effort.</span></span> <span data-ttu-id="1e2f3-155">Tuttavia, molti blocchi non sono così chiari.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-155">However, many hangs are not so clear.</span></span> <span data-ttu-id="1e2f3-156">Sì, il thread dell'interfaccia utente non recupera i messaggi, ma è ugualmente occupato a eseguire altre attività "importanti" e alla fine verrà restituito l'elaborazione dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-156">Yes, the UI thread is not retrieving messages - but it is equally busy doing other 'important' work and will eventually come back to processing messages.</span></span>

<span data-ttu-id="1e2f3-157">Tuttavia, l'utente lo percepisce come un bug.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-157">However, the user perceives this as a bug.</span></span> <span data-ttu-id="1e2f3-158">Il progetto deve corrispondere alle aspettative dell'utente.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-158">The design should match the user's expectations.</span></span> <span data-ttu-id="1e2f3-159">Se la progettazione dell'applicazione conduce a un'applicazione che non risponde, sarà necessario modificare la progettazione.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-159">If the application's design leads to an unresponsive application, the design will have to change.</span></span> <span data-ttu-id="1e2f3-160">Infine, e questo è importante, la mancata risposta non può essere fissata come un bug del codice; richiede un lavoro iniziale durante la fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-160">Finally, and this is important, unresponsiveness cannot be fixed like a code bug; it requires upfront work during the design phase.</span></span> <span data-ttu-id="1e2f3-161">Il tentativo di adattare la codebase esistente di un'applicazione per rendere l'interfaccia utente più reattiva è spesso troppo costosa.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-161">Trying to retrofit an application's existing code base to make the UI more responsive is often too expensive.</span></span> <span data-ttu-id="1e2f3-162">Le linee guida di progettazione seguenti potrebbero essere utili.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-162">The following design guidelines might help.</span></span>

-   <span data-ttu-id="1e2f3-163">Rendere la velocità di risposta dell'interfaccia utente un requisito di livello superiore; l'utente deve sempre tenere sotto controllo l'applicazione</span><span class="sxs-lookup"><span data-stu-id="1e2f3-163">Make UI responsiveness a top-level requirement; the user should always feel in control of your application</span></span>
-   <span data-ttu-id="1e2f3-164">Assicurarsi che gli utenti possano annullare le operazioni che importano più di un secondo per il completamento e/o che le operazioni possano essere completate in background; fornire l'interfaccia utente di avanzamento appropriata, se necessario</span><span class="sxs-lookup"><span data-stu-id="1e2f3-164">Ensure that users can cancel operations that take longer than one second to complete and/or that operations can complete in the background; provide appropriate progress UI if necessary</span></span>

![Screenshot che mostra la finestra di dialogo "copia di elementi".](images/preventinghangs-progressbar.gif)

-   <span data-ttu-id="1e2f3-166">Accodare operazioni a esecuzione prolungata o bloccate come attività in background (questo richiede un meccanismo di messaggistica ben concepito per informare il thread dell'interfaccia utente quando il lavoro è stato completato)</span><span class="sxs-lookup"><span data-stu-id="1e2f3-166">Queue long-running or blocking operations as background tasks (this requires a well-thought out messaging mechanism to inform the UI thread when work has been completed)</span></span>
-   <span data-ttu-id="1e2f3-167">Mantieni semplice il codice per i thread dell'interfaccia utente; rimuovere il maggior numero possibile di chiamate API di blocco</span><span class="sxs-lookup"><span data-stu-id="1e2f3-167">Keep the code for UI threads simple; remove as many blocking API calls as possible</span></span>
-   <span data-ttu-id="1e2f3-168">Mostra finestre e finestre di dialogo solo quando sono pronte e completamente operative.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-168">Show windows and dialogs only when they are ready and fully operational.</span></span> <span data-ttu-id="1e2f3-169">Se la finestra di dialogo deve visualizzare informazioni che richiedono un utilizzo eccessivo delle risorse per il calcolo, visualizzare prima alcune informazioni generiche e aggiornarle immediatamente quando diventano disponibili più dati.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-169">If the dialog needs to display information that is too resource-intensive to calculate, show some generic information first and update it on the fly when more data becomes available.</span></span> <span data-ttu-id="1e2f3-170">Un esempio valido è la finestra di dialogo Proprietà cartella da Esplora risorse.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-170">A good example is the folder properties dialog from Windows Explorer.</span></span> <span data-ttu-id="1e2f3-171">Deve visualizzare le dimensioni totali della cartella, le informazioni che non sono immediatamente disponibili dal file system.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-171">It needs to display the folder's total size, information that is not readily available from the file system.</span></span> <span data-ttu-id="1e2f3-172">La finestra di dialogo viene visualizzata immediatamente e il campo "size" viene aggiornato da un thread di lavoro:</span><span class="sxs-lookup"><span data-stu-id="1e2f3-172">The dialog shows up right away and the "size" field is updated from a worker thread:</span></span>

![Screenshot che mostra la pagina generale delle proprietà di Windows con il testo "size", "size on disk" e "Contains".](images/preventinghangs-updatingdialog.gif)

<span data-ttu-id="1e2f3-174">Sfortunatamente, non esiste un modo semplice per progettare e scrivere un'applicazione reattiva.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-174">Unfortunately, there is no simple way to design and write a responsive application.</span></span> <span data-ttu-id="1e2f3-175">Windows non fornisce un semplice Framework asincrono che consente una pianificazione semplice del blocco o di operazioni con esecuzione prolungata.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-175">Windows does not provide a simple asynchronous framework that would allow for easy scheduling of blocking or long-running operations.</span></span> <span data-ttu-id="1e2f3-176">Le sezioni seguenti introducono alcune delle procedure consigliate per prevenire i blocchi ed evidenziare alcuni problemi comuni.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-176">The following sections introduce some of the best practices in preventing hangs and highlight some of the common pitfalls.</span></span>

## <a name="best-practices"></a><span data-ttu-id="1e2f3-177">Procedure consigliate</span><span class="sxs-lookup"><span data-stu-id="1e2f3-177">Best Practices</span></span>

<span data-ttu-id="1e2f3-178">**Mantieni semplice il thread dell'interfaccia utente**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-178">**Keep the UI Thread Simple**</span></span>

<span data-ttu-id="1e2f3-179">La responsabilità principale del thread dell'interfaccia utente è recuperare e inviare messaggi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-179">The UI thread's primary responsibility is to retrieve and dispatch messages.</span></span> <span data-ttu-id="1e2f3-180">Qualsiasi altro tipo di lavoro introduce il rischio di appendere le finestre di proprietà del thread.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-180">Any other kind of work introduces the risk of hanging the windows owned by this thread.</span></span>

<span data-ttu-id="1e2f3-181">**Fare**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-181">**Do:**</span></span>

-   <span data-ttu-id="1e2f3-182">Spostare algoritmi a elevato utilizzo di risorse o non associati che comportano operazioni a esecuzione prolungata ai thread di lavoro</span><span class="sxs-lookup"><span data-stu-id="1e2f3-182">Move resource-intensive or unbounded algorithms that result in long-running operations to worker threads</span></span>
-   <span data-ttu-id="1e2f3-183">Identificare il numero di chiamate di funzione di blocco possibili e provare a spostarle nei thread di lavoro; qualsiasi funzione che chiama un'altra DLL dovrebbe essere sospetta</span><span class="sxs-lookup"><span data-stu-id="1e2f3-183">Identify as many blocking function calls as possible and try to move them to worker threads; any function calling into another DLL should be suspicious</span></span>
-   <span data-ttu-id="1e2f3-184">Eseguire un'operazione aggiuntiva per rimuovere tutte le chiamate API di I/O di file e di rete dal thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-184">Make an extra effort to remove all file I/O and networking API calls from your worker thread.</span></span> <span data-ttu-id="1e2f3-185">Queste funzioni possono bloccarsi per molti secondi se non sono minuti.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-185">These functions can block for many seconds if not minutes.</span></span> <span data-ttu-id="1e2f3-186">Se è necessario eseguire qualsiasi tipo di I/O nel thread UI, provare a usare l'I/O asincrono</span><span class="sxs-lookup"><span data-stu-id="1e2f3-186">If you need to do any kind of I/O in the UI thread, consider using asynchronous I/O</span></span>
-   <span data-ttu-id="1e2f3-187">Tenere presente che il thread dell'interfaccia utente è anche in grado di gestire tutti i server COM di Apartment a thread singolo (STA) ospitati dal processo. Se si effettua una chiamata di blocco, questi server COM non risponderanno fino a quando non si riservirà la coda dei messaggi</span><span class="sxs-lookup"><span data-stu-id="1e2f3-187">Be aware that your UI thread is also servicing all single-threaded apartment (STA) COM servers hosted by your process; if you make a blocking call, these COM servers will be unresponsive until you service the message queue again</span></span>

<span data-ttu-id="1e2f3-188">**Non:**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-188">**Do not:**</span></span>

-   <span data-ttu-id="1e2f3-189">Attendere qualsiasi oggetto kernel, ad esempio Event o mutex, per un periodo di tempo molto breve; Se è necessario attendere, provare a usare MsgWaitForMultipleObjects (), che si sblocca quando arriva un nuovo messaggio</span><span class="sxs-lookup"><span data-stu-id="1e2f3-189">Wait on any kernel object (like Event or Mutex) for more than a very short amount of time; if you have to wait at all, consider using MsgWaitForMultipleObjects(), which will unblock when a new message arrives</span></span>
-   <span data-ttu-id="1e2f3-190">Condividere la coda di messaggi della finestra di un thread con un altro thread utilizzando la funzione AttachThreadInput ().</span><span class="sxs-lookup"><span data-stu-id="1e2f3-190">Share a thread's window message queue with another thread by using the AttachThreadInput() function.</span></span> <span data-ttu-id="1e2f3-191">Non è solo estremamente difficile sincronizzare correttamente l'accesso alla coda, ma anche impedire al sistema operativo Windows di rilevare correttamente una finestra bloccata</span><span class="sxs-lookup"><span data-stu-id="1e2f3-191">It is not only extremely difficult to properly synchronize access to the queue, it also can prevent the Windows operating system from properly detecting a hung window</span></span>
-   <span data-ttu-id="1e2f3-192">Usare TerminateThread () in uno qualsiasi dei thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-192">Use TerminateThread() on any of your worker threads.</span></span> <span data-ttu-id="1e2f3-193">La chiusura di un thread in questo modo non consentirà di rilasciare i blocchi o gli eventi di segnale e può facilmente produrre oggetti di sincronizzazione orfani</span><span class="sxs-lookup"><span data-stu-id="1e2f3-193">Terminating a thread in this way will not allow it to release locks or signal events and can easily result in orphaned synchronization objects</span></span>
-   <span data-ttu-id="1e2f3-194">Chiama il codice ' Unknown ' dal thread dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-194">Call into any 'unknown' code from your UI thread.</span></span> <span data-ttu-id="1e2f3-195">Ciò è particolarmente vero se l'applicazione ha un modello di estendibilità. non vi è alcuna garanzia che il codice di terze parti segua le linee guida per la velocità di risposta</span><span class="sxs-lookup"><span data-stu-id="1e2f3-195">This is especially true if your application has an extensibility model; there is no guarantee that 3rd-party code follows your responsiveness guidelines</span></span>
-   <span data-ttu-id="1e2f3-196">Eseguire qualsiasi tipo di chiamata di trasmissione di blocco; SendMessage ( \_ trasmissione HWND) si pone alla mercé di ogni applicazione attualmente in esecuzione</span><span class="sxs-lookup"><span data-stu-id="1e2f3-196">Make any kind of blocking broadcast call; SendMessage(HWND\_BROADCAST) puts you at the mercy of every ill-written application currently running</span></span>

<span data-ttu-id="1e2f3-197">**Implementare i modelli asincroni**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-197">**Implement Asynchronous Patterns**</span></span>

<span data-ttu-id="1e2f3-198">La rimozione di operazioni a esecuzione prolungata o di blocco dal thread UI richiede l'implementazione di un Framework asincrono che consente di eseguire l'offload di tali operazioni ai thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-198">Removing long-running or blocking operations from the UI thread requires implementing an asynchronous framework that allows offloading those operations to worker threads.</span></span>

<span data-ttu-id="1e2f3-199">**Fare**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-199">**Do:**</span></span>

-   <span data-ttu-id="1e2f3-200">Usare le API dei messaggi di finestra asincrone nel thread dell'interfaccia utente, in particolare sostituendo SendMessage con uno dei relativi peer non bloccanti: PostMessage, SendNotifyMessage o SendMessageCallback</span><span class="sxs-lookup"><span data-stu-id="1e2f3-200">Use asynchronous window message APIs in your UI thread, especially by replacing SendMessage with one of its non-blocking peers: PostMessage, SendNotifyMessage, or SendMessageCallback</span></span>
-   <span data-ttu-id="1e2f3-201">Usare i thread in background per eseguire attività a esecuzione prolungata o di blocco.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-201">Use background threads to execute long-running or blocking tasks.</span></span> <span data-ttu-id="1e2f3-202">Usare la nuova API del pool di thread per implementare i thread di lavoro</span><span class="sxs-lookup"><span data-stu-id="1e2f3-202">Use the new thread pool API to implement your worker threads</span></span>
-   <span data-ttu-id="1e2f3-203">Fornire il supporto per l'annullamento per le attività in background con esecuzione prolungata.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-203">Provide cancellation support for long-running background tasks.</span></span> <span data-ttu-id="1e2f3-204">Per le operazioni di I/O di blocco, utilizzare l'annullamento I/O, ma solo come ultima risorsa. non è facile annullare l'operazione "Right"</span><span class="sxs-lookup"><span data-stu-id="1e2f3-204">For blocking I/O operations, use I/O cancellation, but only as a last resort; it's not easy to cancel the 'right' operation</span></span>
-   <span data-ttu-id="1e2f3-205">Implementare una progettazione asincrona per il codice gestito usando il modello IAsyncResult o gli eventi</span><span class="sxs-lookup"><span data-stu-id="1e2f3-205">Implement an asynchronous design for managed code by using the IAsyncResult pattern or by using Events</span></span>

<span data-ttu-id="1e2f3-206">**Usare i blocchi in modo oculato**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-206">**Use Locks Wisely**</span></span>

<span data-ttu-id="1e2f3-207">L'applicazione o la DLL necessita di blocchi per sincronizzare l'accesso alle strutture di dati interne.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-207">Your application or DLL needs locks to synchronize access to its internal data structures.</span></span> <span data-ttu-id="1e2f3-208">L'uso di più blocchi aumenta il parallelismo e rende l'applicazione più reattiva.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-208">Using multiple locks increases parallelism and makes your application more responsive.</span></span> <span data-ttu-id="1e2f3-209">Tuttavia, l'utilizzo di più blocchi aumenta anche la possibilità di acquisire tali blocchi in ordini diversi e causare il deadlock dei thread.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-209">However, using multiple locks also increases the chance of acquiring those locks in different orders and causing your threads to deadlock.</span></span> <span data-ttu-id="1e2f3-210">Se due thread contengono un blocco e tentano di acquisire il blocco del altro thread, le relative operazioni costituiranno un'attesa circolare che blocca lo stato di avanzamento di questi thread.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-210">If two threads each hold a lock and then try to acquire the other thread's lock, their operations will form a circular wait that blocks any forward progress for these threads.</span></span> <span data-ttu-id="1e2f3-211">È possibile evitare questo deadlock solo assicurandosi che tutti i thread dell'applicazione acquisiscano sempre tutti i blocchi nello stesso ordine.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-211">You can avoid this deadlock only by ensuring that all threads in the application always acquire all locks in the same order.</span></span> <span data-ttu-id="1e2f3-212">Tuttavia, non è sempre facile acquisire i blocchi nell'ordine "corretto".</span><span class="sxs-lookup"><span data-stu-id="1e2f3-212">However, it isn't always easy to acquire locks in the 'right' order.</span></span> <span data-ttu-id="1e2f3-213">È possibile comporre componenti software, ma le acquisizioni di blocchi non possono.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-213">Software components can be composed, but lock acquisitions cannot.</span></span> <span data-ttu-id="1e2f3-214">Se il codice chiama un altro componente, i blocchi di tale componente diventano ora parte dell'ordine di blocco implicito, anche se non si dispone di visibilità in tali blocchi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-214">If your code calls some other component, that component's locks now become part of your implicit lock order - even if you have no visibility into those locks.</span></span>

<span data-ttu-id="1e2f3-215">Ciò è ancora più difficile perché le operazioni di blocco includono molto più delle consuete funzioni per sezioni critiche, mutex e altri blocchi tradizionali.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-215">Things get even harder because locking operations include far more than the usual functions for Critical Sections, Mutexes, and other traditional locks.</span></span> <span data-ttu-id="1e2f3-216">Tutte le chiamate di blocco che attraversano i limiti dei thread hanno proprietà di sincronizzazione che possono causare un deadlock.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-216">Any blocking call that crosses thread boundaries has synchronization properties that can result in a deadlock.</span></span> <span data-ttu-id="1e2f3-217">Il thread chiamante esegue un'operazione con la semantica ' Acquisisci ' e non può essere sbloccato fino a quando il thread di destinazione ' rilascia ' che chiama.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-217">The calling thread performs an operation with 'acquire' semantics and cannot unblock until the target thread 'releases' that call.</span></span> <span data-ttu-id="1e2f3-218">Alcune funzioni User32 (ad esempio SendMessage), così come molte chiamate COM di blocco, rientrano in questa categoria.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-218">Quite a few User32 functions (for example SendMessage), as well as many blocking COM calls fall into this category.</span></span>

<span data-ttu-id="1e2f3-219">Peggio ancora, il sistema operativo ha un blocco interno specifico del processo che talvolta viene mantenuto durante l'esecuzione del codice.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-219">Worse yet, the operating system has its own internal process-specific lock that sometimes is held while your code executes.</span></span> <span data-ttu-id="1e2f3-220">Questo blocco viene acquisito quando le dll vengono caricate nel processo ed è quindi chiamato "blocco del caricatore".</span><span class="sxs-lookup"><span data-stu-id="1e2f3-220">This lock is acquired when DLLs are loaded into the process, and is therefore called the 'loader lock.'</span></span> <span data-ttu-id="1e2f3-221">La funzione DllMain viene sempre eseguita sotto il blocco del caricatore; Se si acquisiscono blocchi in DllMain (e non è consigliabile), è necessario fare in modo che il caricatore blocchi la parte dell'ordine di blocco.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-221">The DllMain function always executes under the loader lock; if you acquire any locks in DllMain (and you should not), you need to make the loader lock part of your lock order.</span></span> <span data-ttu-id="1e2f3-222">La chiamata di determinate API Win32 potrebbe inoltre acquisire il blocco del caricatore per conto dell'utente, ad esempio LoadLibraryEx, GetModuleHandle e in particolare CoCreateInstance.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-222">Calling certain Win32 APIs might also acquire the loader lock on your behalf - functions like LoadLibraryEx, GetModuleHandle, and especially CoCreateInstance.</span></span>

<span data-ttu-id="1e2f3-223">Per unire tutto questo insieme, esaminare il codice di esempio riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-223">To tie all of this together, look at the sample code below.</span></span> <span data-ttu-id="1e2f3-224">Questa funzione acquisisce più oggetti di sincronizzazione e definisce in modo implicito un ordine di blocco, un'operazione che non è necessariamente ovvia sull'ispezione del cursore.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-224">This function acquires multiple synchronization objects and implicitly defines a lock order, something that is not necessarily obvious on cursory inspection.</span></span> <span data-ttu-id="1e2f3-225">Sulla voce della funzione, il codice acquisisce una sezione critica e non la rilascia fino alla chiusura della funzione, rendendola quindi il nodo principale nella gerarchia dei blocchi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-225">On function entry, the code acquires a Critical Section and does not release it until function exit, thereby making it the top node in our lock hierarchy.</span></span> <span data-ttu-id="1e2f3-226">Il codice chiama quindi la funzione Win32 LoadIcon (), che dietro le quinte potrebbe chiamare il caricatore del sistema operativo per caricare il file binario.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-226">The code then calls the Win32 function LoadIcon(), which under the covers might call into the Operating System Loader to load this binary.</span></span> <span data-ttu-id="1e2f3-227">Questa operazione acquisisce il blocco del caricatore, che ora diventa anche parte di questa gerarchia di blocchi (assicurarsi che la funzione DllMain non acquisisca il \_ blocco g CS).</span><span class="sxs-lookup"><span data-stu-id="1e2f3-227">This operation would acquire the loader lock, which now also becomes part of this lock hierarchy (make sure the DllMain function does not acquire the g\_cs lock).</span></span> <span data-ttu-id="1e2f3-228">Successivamente, il codice chiama SendMessage (), un'operazione cross-thread di blocco, che non verrà restituita a meno che il thread dell'interfaccia utente non risponda.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-228">Next the code calls SendMessage(), a blocking cross-thread operation, which will not return unless the UI thread responds.</span></span> <span data-ttu-id="1e2f3-229">Anche in questo caso, assicurarsi che il thread dell'interfaccia utente non acquisisca mai g \_ cs.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-229">Again, make sure that the UI thread never acquires g\_cs.</span></span>

```
bool foo::bar (char* buffer)  
{  
      EnterCriticalSection(&g_cs);  
      // Get 'new data' icon  
      this.m_Icon = LoadIcon(hInst, MAKEINTRESOURCE(5));  
      // Let UI thread know to update icon SendMessage(hWnd,WM_COMMAND,IDM_ICON,NULL);  
      this.m_Params = GetParams(buffer);  
      LeaveCriticalSection(&g_cs);
      return true;  
}  
```

<span data-ttu-id="1e2f3-230">Esaminando questo codice è evidente che è stato creato in modo implicito g \_ cs come blocco di primo livello nella gerarchia dei blocchi, anche se si voleva solo sincronizzare l'accesso alle variabili membro della classe.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-230">Looking at this code it seems clear that we implicitly made g\_cs the top-level lock in our lock hierarchy, even if we only wanted to synchronize access to the class member variables.</span></span>

<span data-ttu-id="1e2f3-231">**Fare**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-231">**Do:**</span></span>

-   <span data-ttu-id="1e2f3-232">Progettare una gerarchia di blocchi e rispettarla.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-232">Design a lock hierarchy and obey it.</span></span> <span data-ttu-id="1e2f3-233">Aggiungere tutti i blocchi necessari.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-233">Add all the necessary locks.</span></span> <span data-ttu-id="1e2f3-234">Sono disponibili molte più primitive di sincronizzazione rispetto a mutex e CriticalSections; tutti devono essere inclusi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-234">There are many more synchronization primitives than just Mutex and CriticalSections; they all need to be included.</span></span> <span data-ttu-id="1e2f3-235">Includere il blocco del caricatore nella gerarchia se si accettano blocchi in DllMain ()</span><span class="sxs-lookup"><span data-stu-id="1e2f3-235">Include the loader lock in your hierarchy if you take any locks in DllMain()</span></span>
-   <span data-ttu-id="1e2f3-236">Accetta il protocollo di blocco con le dipendenze.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-236">Agree on locking protocol with your dependencies.</span></span> <span data-ttu-id="1e2f3-237">Qualsiasi codice chiamato dall'applicazione o che potrebbe chiamare l'applicazione deve condividere la stessa gerarchia di blocco</span><span class="sxs-lookup"><span data-stu-id="1e2f3-237">Any code your application calls or that might call your application needs to share the same lock hierarchy</span></span>
-   <span data-ttu-id="1e2f3-238">Bloccare le strutture dei dati non funzioni.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-238">Lock data structures not functions.</span></span> <span data-ttu-id="1e2f3-239">Spostare le acquisizioni dei blocchi dai punti di ingresso della funzione e sorvegliare solo l'accesso ai dati con blocchi.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-239">Move lock acquisitions away from function entry points and guard only data access with locks.</span></span> <span data-ttu-id="1e2f3-240">Se un minor numero di codice opera sotto un blocco, è possibile che si verifichino deadlock</span><span class="sxs-lookup"><span data-stu-id="1e2f3-240">If less code operates under a lock, there is less of a chance for deadlocks</span></span>
-   <span data-ttu-id="1e2f3-241">Analizzare le acquisizioni e i rilasci dei blocchi nel codice di gestione degli errori.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-241">Analyze lock acquisitions and releases in your error handling code.</span></span> <span data-ttu-id="1e2f3-242">Spesso la gerarchia di blocco viene dimenticata quando si tenta di eseguire il ripristino da una condizione di errore</span><span class="sxs-lookup"><span data-stu-id="1e2f3-242">Often the lock hierarchy if forgotten when trying to recover from an error condition</span></span>
-   <span data-ttu-id="1e2f3-243">Sostituire i blocchi annidati con i contatori di riferimento. Impossibile eseguire il deadlock.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-243">Replace nested locks with reference counters - they cannot deadlock.</span></span> <span data-ttu-id="1e2f3-244">Gli elementi bloccati singolarmente negli elenchi e nelle tabelle sono candidati validi</span><span class="sxs-lookup"><span data-stu-id="1e2f3-244">Individually locked elements in lists and tables are good candidates</span></span>
-   <span data-ttu-id="1e2f3-245">Prestare attenzione quando si è in attesa di un handle di thread da una DLL.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-245">Be careful when waiting on a thread handle from a DLL.</span></span> <span data-ttu-id="1e2f3-246">Si supponga sempre che il codice possa essere chiamato sotto il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-246">Always assume that your code could be called under the loader lock.</span></span> <span data-ttu-id="1e2f3-247">È preferibile fare riferimento al conteggio delle risorse e lasciare che il thread di lavoro esegua la pulizia (e quindi usare FreeLibraryAndExitThread per terminare in modo corretto)</span><span class="sxs-lookup"><span data-stu-id="1e2f3-247">It's better to reference-count your resources and let the worker thread do its own cleanup (and then use FreeLibraryAndExitThread to terminate cleanly)</span></span>
-   <span data-ttu-id="1e2f3-248">Usare l'API di attraversamento della catena di attesa se si vuole diagnosticare i deadlock</span><span class="sxs-lookup"><span data-stu-id="1e2f3-248">Use the Wait Chain Traversal API if you want to diagnose your own deadlocks</span></span>

<span data-ttu-id="1e2f3-249">**Non:**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-249">**Do not:**</span></span>

-   <span data-ttu-id="1e2f3-250">Eseguire operazioni diverse dall'inizializzazione molto semplice nella funzione DllMain ().</span><span class="sxs-lookup"><span data-stu-id="1e2f3-250">Do anything other than very simple initialization work in your DllMain() function.</span></span> <span data-ttu-id="1e2f3-251">Per ulteriori informazioni, vedere funzione di callback DllMain.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-251">See DllMain Callback Function for more details.</span></span> <span data-ttu-id="1e2f3-252">In particolare, non chiamare LoadLibraryEx o CoCreateInstance</span><span class="sxs-lookup"><span data-stu-id="1e2f3-252">Especially do not call LoadLibraryEx or CoCreateInstance</span></span>
-   <span data-ttu-id="1e2f3-253">Scrivere le primitive di blocco personalizzate.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-253">Write your own locking primitives.</span></span> <span data-ttu-id="1e2f3-254">Il codice di sincronizzazione personalizzato può introdurre con facilità bug sottili nella codebase.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-254">Custom synchronization code can easily introduce subtle bugs into your code base.</span></span> <span data-ttu-id="1e2f3-255">Usare invece la selezione avanzata degli oggetti di sincronizzazione del sistema operativo</span><span class="sxs-lookup"><span data-stu-id="1e2f3-255">Use the rich selection of operating system synchronization objects instead</span></span>
-   <span data-ttu-id="1e2f3-256">Eseguire qualsiasi operazione nei costruttori e nei distruttori per le variabili globali che vengono eseguite sotto il blocco del caricatore</span><span class="sxs-lookup"><span data-stu-id="1e2f3-256">Do any work in the constructors and destructors for global variables, they are executed under the loader lock</span></span>

<span data-ttu-id="1e2f3-257">**Prestare attenzione con le eccezioni**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-257">**Be Careful with Exceptions**</span></span>

<span data-ttu-id="1e2f3-258">Le eccezioni consentono la separazione del normale flusso di programma e della gestione degli errori.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-258">Exceptions allow the separation of normal program flow and error handling.</span></span> <span data-ttu-id="1e2f3-259">A causa di questa separazione, può essere difficile individuare lo stato preciso del programma prima dell'eccezione e il gestore di eccezioni potrebbe perdere i passaggi cruciali per il ripristino di uno stato valido.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-259">Because of this separation, it can be difficult to know the precise state of the program prior to the exception and the exception handler might miss crucial steps in restoring a valid state.</span></span> <span data-ttu-id="1e2f3-260">Ciò è particolarmente vero per le acquisizioni di blocchi che devono essere rilasciate nel gestore per evitare deadlock futuri.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-260">This is especially true for lock acquisitions that need to be released in the handler to prevent future deadlocks.</span></span>

<span data-ttu-id="1e2f3-261">Il codice di esempio seguente illustra questo problema.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-261">The sample code below illustrates this issue.</span></span> <span data-ttu-id="1e2f3-262">L'accesso non associato alla variabile "buffer" provocherà occasionalmente una violazione di accesso (AV).</span><span class="sxs-lookup"><span data-stu-id="1e2f3-262">The unbounded access to the "buffer" variable will occasionally result in an access violation (AV).</span></span> <span data-ttu-id="1e2f3-263">Questo AV viene rilevato dal gestore di eccezioni native, ma non ha un modo semplice per determinare se la sezione critica è già stata acquisita al momento dell'eccezione (l'AV potrebbe essere stato preso in un punto qualsiasi del codice EnterCriticalSection).</span><span class="sxs-lookup"><span data-stu-id="1e2f3-263">This AV is caught by the native exception handler, but it has no easy way of determining if the critical section was already acquired at the time of the exception (the AV could even have taken place somewhere in the EnterCriticalSection code).</span></span>

```
 BOOL bar (char* buffer)  
{  
   BOOL rc = FALSE;  
   __try {  
      EnterCriticalSection(&cs);  
      while (*buffer++ != '&') ;  
      rc = GetParams(buffer);  
      LeaveCriticalSection(&cs);  
   } __except (EXCEPTION_EXECUTE_HANDLER)  
   {  
      return FALSE;  
   } 
   return rc;  
}  
```

<span data-ttu-id="1e2f3-264">**Fare**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-264">**Do:**</span></span>

-   <span data-ttu-id="1e2f3-265">Rimuovere \_ \_ try/ \_ \_ except quando possibile; non usare SetUnhandledExceptionFilter</span><span class="sxs-lookup"><span data-stu-id="1e2f3-265">Remove \_\_try/\_\_except whenever possible; do not use SetUnhandledExceptionFilter</span></span>
-   <span data-ttu-id="1e2f3-266">Eseguire il wrapping dei blocchi in \_ modelli personalizzati di tipo PTR automatico se si usano le eccezioni C++.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-266">Wrap your locks in custom auto\_ptr-like templates if you use C++ exceptions.</span></span> <span data-ttu-id="1e2f3-267">Il blocco deve essere rilasciato nel distruttore.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-267">The lock should be released in the destructor.</span></span> <span data-ttu-id="1e2f3-268">Per le eccezioni native rilascia i blocchi nell' \_ \_ istruzione finally</span><span class="sxs-lookup"><span data-stu-id="1e2f3-268">For native exceptions release the locks in your \_\_finally statement</span></span>
-   <span data-ttu-id="1e2f3-269">Prestare attenzione al codice in esecuzione in un gestore di eccezioni native; è possibile che l'eccezione abbia perso molti blocchi, quindi il gestore non deve acquisire alcun</span><span class="sxs-lookup"><span data-stu-id="1e2f3-269">Be careful with the code executing in a native exception handler; the exception might have leaked many locks, so your handler should not acquire any</span></span>

<span data-ttu-id="1e2f3-270">**Non:**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-270">**Do not:**</span></span>

-   <span data-ttu-id="1e2f3-271">Gestire le eccezioni native se non sono necessarie o richieste dalle API Win32.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-271">Handle native exceptions if not necessary or required by the Win32 APIs.</span></span> <span data-ttu-id="1e2f3-272">Se si utilizzano gestori di eccezioni nativi per la creazione di report o il ripristino dei dati dopo errori irreversibili, provare a utilizzare il meccanismo del sistema operativo predefinito di Segnalazione errori Windows</span><span class="sxs-lookup"><span data-stu-id="1e2f3-272">If you use native exception handlers for reporting or data recovery after catastrophic failures, consider using the default operating system mechanism of Windows Error Reporting instead</span></span>
-   <span data-ttu-id="1e2f3-273">Usare le eccezioni C++ con qualsiasi tipo di codice dell'interfaccia utente (User32); un'eccezione generata in un callback verrà spostata attraverso i livelli del codice C forniti dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="1e2f3-273">Use C++ exceptions with any kind of UI (user32) code; an exception thrown in a callback will travel through layers of C code provided by the operating system.</span></span> <span data-ttu-id="1e2f3-274">Il codice non è a conoscenza della semantica di unroll di C++</span><span class="sxs-lookup"><span data-stu-id="1e2f3-274">That code does not know about C++ unroll semantics</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="1e2f3-275">Collegamenti alle risorse</span><span class="sxs-lookup"><span data-stu-id="1e2f3-275">Links to Resources</span></span>

-   [<span data-ttu-id="1e2f3-276">Segnalazione errori Windows</span><span class="sxs-lookup"><span data-stu-id="1e2f3-276">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   <span data-ttu-id="1e2f3-277">[Progettazione asincrona](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="1e2f3-277">[Asynchronous Design](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="1e2f3-278">I/O asincrono</span><span class="sxs-lookup"><span data-stu-id="1e2f3-278">Asynchronous I/O</span></span>](../fileio/synchronous-and-asynchronous-i-o.md)
-   [<span data-ttu-id="1e2f3-279">**AttachThreadInput (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-279">**AttachThreadInput Function**</span></span>](/windows/win32/api/winuser/nf-winuser-attachthreadinput)
-   <span data-ttu-id="1e2f3-280">[**\_classe PTR automatico**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="1e2f3-280">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="1e2f3-281">**DisableProcessWindowsGhosting (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-281">**DisableProcessWindowsGhosting Function**</span></span>](/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting)
-   [<span data-ttu-id="1e2f3-282">**Funzione di callback DllMain**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-282">**DllMain Callback Function**</span></span>](../dlls/dllmain.md)
-   <span data-ttu-id="1e2f3-283">[Eventi](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="1e2f3-283">[Events](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="1e2f3-284">**GetMessage (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-284">**GetMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-getmessage)
-   [<span data-ttu-id="1e2f3-285">Annullamento I/O</span><span class="sxs-lookup"><span data-stu-id="1e2f3-285">I/O cancellation</span></span>](../fileio/canceling-pending-i-o-operations.md)
-   [<span data-ttu-id="1e2f3-286">**IsHungAppWindow (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-286">**IsHungAppWindow Function**</span></span>](/windows/win32/api/winuser/nf-winuser-ishungappwindow)
-   [<span data-ttu-id="1e2f3-287">Coda messaggi</span><span class="sxs-lookup"><span data-stu-id="1e2f3-287">Message Queue</span></span>](../winmsg/using-messages-and-message-queues.md)
-   [<span data-ttu-id="1e2f3-288">**MsgWaitForMultipleObjects (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-288">**MsgWaitForMultipleObjects Function**</span></span>](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)
-   [<span data-ttu-id="1e2f3-289">Nuova API del pool di thread</span><span class="sxs-lookup"><span data-stu-id="1e2f3-289">New Thread Pool API</span></span>](../procthread/thread-pool-api.md)
-   [<span data-ttu-id="1e2f3-290">**Funzione PostMessage**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-290">**PostMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-postmessagea)
-   [<span data-ttu-id="1e2f3-291">Riavvio e ripristino</span><span class="sxs-lookup"><span data-stu-id="1e2f3-291">Restart and Recovery</span></span>](../recovery/registering-for-application-restart.md)
-   [<span data-ttu-id="1e2f3-292">**SendMessageCallback (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-292">**SendMessageCallback Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka)
-   [<span data-ttu-id="1e2f3-293">**SendNotifyMessage (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-293">**SendNotifyMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendnotifymessagea)
-   [<span data-ttu-id="1e2f3-294">Oggetti di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="1e2f3-294">Synchronization Objects</span></span>](../sync/about-synchronization.md)
-   [<span data-ttu-id="1e2f3-295">**TerminateThread (funzione)**</span><span class="sxs-lookup"><span data-stu-id="1e2f3-295">**TerminateThread Function**</span></span>](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread)
-   [<span data-ttu-id="1e2f3-296">Segnalazione errori Windows</span><span class="sxs-lookup"><span data-stu-id="1e2f3-296">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   [<span data-ttu-id="1e2f3-297">Winqual</span><span class="sxs-lookup"><span data-stu-id="1e2f3-297">Winqual</span></span>](/windows-hardware/drivers/dashboard/winqual-submission-tool--winqualexe-)

 

 
