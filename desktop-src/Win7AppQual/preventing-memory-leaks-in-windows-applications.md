---
description: Informazioni su come prevenire le perdite di memoria nelle applicazioni Windows per le piattaforme Windows 7 e Windows Server 2008 R2.
ms.assetid: c5dedcab-3e6f-433f-95de-d741321c683e
title: Prevenzione delle perdite di memoria nelle applicazioni Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e973da19d075ac94824df340d1741fd9cefb3486
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/06/2021
ms.locfileid: "104554618"
---
# <a name="preventing-memory-leaks-in-windows-applications"></a><span data-ttu-id="22cab-103">Prevenzione delle perdite di memoria nelle applicazioni Windows</span><span class="sxs-lookup"><span data-stu-id="22cab-103">Preventing Memory Leaks in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="22cab-104">Piattaforme interessate</span><span class="sxs-lookup"><span data-stu-id="22cab-104">Affected Platforms</span></span>

<span data-ttu-id="22cab-105">**Client** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="22cab-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="22cab-106">**Server** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="22cab-106">**Servers** - Windows Server 2008 R2</span></span>  

## <a name="description"></a><span data-ttu-id="22cab-107">Descrizione</span><span class="sxs-lookup"><span data-stu-id="22cab-107">Description</span></span>

<span data-ttu-id="22cab-108">Le perdite di memoria sono una classe di bug in cui l'applicazione non riesce a rilasciare la memoria quando non è più necessaria.</span><span class="sxs-lookup"><span data-stu-id="22cab-108">Memory leaks are a class of bugs where the application fails to release memory when no longer needed.</span></span> <span data-ttu-id="22cab-109">Nel tempo le perdite di memoria influiscono sulle prestazioni dell'applicazione specifica e del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="22cab-109">Over time, memory leaks affect the performance of both the particular application as well as the operating system.</span></span> <span data-ttu-id="22cab-110">Una perdita di grandi dimensioni può causare tempi di risposta inaccettabili a causa di un paging eccessivo.</span><span class="sxs-lookup"><span data-stu-id="22cab-110">A large leak might result in unacceptable response times due to excessive paging.</span></span> <span data-ttu-id="22cab-111">Infine, l'applicazione e altre parti del sistema operativo si verificheranno errori.</span><span class="sxs-lookup"><span data-stu-id="22cab-111">Eventually the application as well as other parts of the operating system will experience failures.</span></span>

<span data-ttu-id="22cab-112">Windows consente di liberare tutta la memoria allocata dall'applicazione alla chiusura del processo, quindi le applicazioni a esecuzione prolungata non influiscono significativamente sulle prestazioni complessive del sistema.</span><span class="sxs-lookup"><span data-stu-id="22cab-112">Windows will free all memory allocated by the application on process termination, so short-running applications will not affect overall system performance significantly.</span></span> <span data-ttu-id="22cab-113">Tuttavia, le perdite nei processi a esecuzione prolungata come i servizi o anche i plug-in di Esplora risorse possono avere un notevole effetto sull'affidabilità del sistema e possono forzare l'utente a riavviare Windows per riutilizzarlo di nuovo.</span><span class="sxs-lookup"><span data-stu-id="22cab-113">However, leaks in long-running processes like services or even Explorer plug-ins can greatly impact system reliability and might force the user to reboot Windows in order to make the system usable again.</span></span>

<span data-ttu-id="22cab-114">Le applicazioni possono allocare memoria per conto di più mezzi.</span><span class="sxs-lookup"><span data-stu-id="22cab-114">Applications can allocate memory on their behalf by multiple means.</span></span> <span data-ttu-id="22cab-115">Ogni tipo di allocazione può causare una perdita se non viene liberato dopo l'utilizzo.</span><span class="sxs-lookup"><span data-stu-id="22cab-115">Each type of allocation can result in a leak if not freed after use.</span></span> <span data-ttu-id="22cab-116">Di seguito sono riportati alcuni esempi di modelli di allocazione comuni:</span><span class="sxs-lookup"><span data-stu-id="22cab-116">Here are some examples of common allocation patterns:</span></span>

-   <span data-ttu-id="22cab-117">Memoria heap tramite la funzione [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) o i relativi equivalenti di runtime C/C++ **malloc** o **New**</span><span class="sxs-lookup"><span data-stu-id="22cab-117">Heap memory via the [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) function or its C/C++ runtime equivalents **malloc** or **new**</span></span>
-   <span data-ttu-id="22cab-118">Allocazioni dirette dal sistema operativo tramite la funzione [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) .</span><span class="sxs-lookup"><span data-stu-id="22cab-118">Direct allocations from the operating system via the [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function.</span></span>
-   <span data-ttu-id="22cab-119">Gli handle del kernel creati tramite le API Kernel32 come [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)o [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)contengono memoria kernel per conto dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="22cab-119">Kernel handles created via Kernel32 APIs such as [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa), or [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), hold kernel memory on behalf of the application</span></span>
-   <span data-ttu-id="22cab-120">GDI e handle utente creati tramite le API User32 e gdi32 (per impostazione predefinita, ogni processo ha una quota di 10.000 handle)</span><span class="sxs-lookup"><span data-stu-id="22cab-120">GDI and USER handles created via User32 and Gdi32 APIs (by default, each process has a quota of 10,000 handles)</span></span>

## <a name="best-practices"></a><span data-ttu-id="22cab-121">Procedure consigliate</span><span class="sxs-lookup"><span data-stu-id="22cab-121">Best Practices</span></span>

<span data-ttu-id="22cab-122">Il monitoraggio del consumo di risorse dell'applicazione nel corso del tempo è il primo passaggio per rilevare e diagnosticare le perdite di memoria.</span><span class="sxs-lookup"><span data-stu-id="22cab-122">Monitoring the resource consumption of your application over time is the first step in detecting and diagnosing memory leaks.</span></span> <span data-ttu-id="22cab-123">Utilizzare Gestione attività di Windows e aggiungere le colonne seguenti: "dimensioni commit", "handle", "oggetti utente" e "oggetti GDI".</span><span class="sxs-lookup"><span data-stu-id="22cab-123">Use Windows Task Manager and add the following columns: "Commit Size", "Handles", "User Objects", and "GDI Objects".</span></span> <span data-ttu-id="22cab-124">Ciò consentirà di stabilire una linea di base per l'applicazione e di monitorare l'utilizzo delle risorse nel tempo.</span><span class="sxs-lookup"><span data-stu-id="22cab-124">This will allow you to establish a baseline for your application and monitor resource usage over time.</span></span>

![Screenshot che mostra la pagina "processi" in Gestione attività di Windows.](images/preventingmemoryleaks-windowstaskmanager.gif)

<span data-ttu-id="22cab-126">Gli strumenti Microsoft seguenti forniscono informazioni più dettagliate e possono aiutare a rilevare e diagnosticare le perdite per i vari tipi di allocazione nell'applicazione:</span><span class="sxs-lookup"><span data-stu-id="22cab-126">The following Microsoft tools provide more-detailed information and can help to detect and diagnose leaks for the various allocation types in your application:</span></span>

-   <span data-ttu-id="22cab-127">Performance Monitor e Monitoraggio risorse fanno parte di Windows 7 e possono monitorare e tracciare l'utilizzo delle risorse nel tempo</span><span class="sxs-lookup"><span data-stu-id="22cab-127">Performance Monitor and Resource Monitor are part of Windows 7 and can monitor and graph resource use over time</span></span>
-   <span data-ttu-id="22cab-128">La versione più recente di Application Verifier è in grado di diagnosticare le perdite di heap in Windows 7</span><span class="sxs-lookup"><span data-stu-id="22cab-128">The latest version of Application Verifier can diagnose heap leaks on Windows 7</span></span>
-   <span data-ttu-id="22cab-129">UMDH, che fa parte degli strumenti di debug per Windows, analizza le allocazioni di memoria heap per un determinato processo e può aiutare a individuare le perdite e altri modelli di utilizzo insoliti</span><span class="sxs-lookup"><span data-stu-id="22cab-129">UMDH, which is part of the Debugging Tools for Windows, analyzes the heap memory allocations for a given process and can help find leaks and other unusual usage patterns</span></span>
-   <span data-ttu-id="22cab-130">Xperf è uno strumento di analisi delle prestazioni sofisticato con supporto per le tracce di allocazione heap</span><span class="sxs-lookup"><span data-stu-id="22cab-130">Xperf is a sophisticated performance analysis tool with support for heap allocation traces</span></span>
-   <span data-ttu-id="22cab-131">L'heap di debug CRT tiene traccia delle allocazioni di heap e consente di compilare le funzionalità di debug dell'heap</span><span class="sxs-lookup"><span data-stu-id="22cab-131">CRT Debug Heap tracks heap allocations and can help build your own heap debugging features</span></span>

<span data-ttu-id="22cab-132">Alcune procedure di codifica e progettazione possono limitare il numero di perdite nel codice.</span><span class="sxs-lookup"><span data-stu-id="22cab-132">Certain coding and design practices can limit the number of leaks in your code.</span></span>

-   <span data-ttu-id="22cab-133">Usare i puntatori intelligenti nel codice C++ per le allocazioni di heap e per le risorse Win32, ad esempio gli **handle** del kernel.</span><span class="sxs-lookup"><span data-stu-id="22cab-133">Use smart pointers in C++ code both for heap allocations as well as for Win32 resources like kernel **HANDLE** s.</span></span> <span data-ttu-id="22cab-134">La libreria standard C++ fornisce la **classe \_ ptr automatica** per le allocazioni di heap.</span><span class="sxs-lookup"><span data-stu-id="22cab-134">The C++ Standard library provides the **auto\_ptr** class for heap allocations.</span></span> <span data-ttu-id="22cab-135">Per altri tipi di allocazione sarà necessario scrivere classi personalizzate.</span><span class="sxs-lookup"><span data-stu-id="22cab-135">For other allocation types you will need to write your own classes.</span></span> <span data-ttu-id="22cab-136">La libreria ATL offre un set completo di classi per la gestione automatica delle risorse sia per gli oggetti heap che per gli handle del kernel</span><span class="sxs-lookup"><span data-stu-id="22cab-136">The ATL library provides a rich set of classes for automatic resource management for both heap objects and kernel handles</span></span>
-   <span data-ttu-id="22cab-137">Usare le funzionalità intrinseche del compilatore, come **\_ com \_ ptr \_ t** , per incapsulare i puntatori dell'interfaccia com in "puntatori intelligenti" e supportare il conteggio dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="22cab-137">Use compiler intrinsic features like **\_com\_ptr\_t** to encapsulate your COM interface pointers into "smart pointers" and assist with reference counting.</span></span> <span data-ttu-id="22cab-138">Esistono classi simili per altri tipi di dati COM: **\_ BSTR \_ t** e **\_ Variant \_ t**</span><span class="sxs-lookup"><span data-stu-id="22cab-138">There are similar classes for other COM data types: **\_bstr\_t** and **\_variant\_t**</span></span>
-   <span data-ttu-id="22cab-139">Monitorare l'utilizzo insolito della memoria per il codice .NET.</span><span class="sxs-lookup"><span data-stu-id="22cab-139">Monitor your .NET code unusual memory usage.</span></span> <span data-ttu-id="22cab-140">Il codice gestito non è immune alle perdite di memoria.</span><span class="sxs-lookup"><span data-stu-id="22cab-140">Managed code is not immune to memory leaks.</span></span> <span data-ttu-id="22cab-141">Vedere ["rilevamento delle perdite di managed memory"](/archive/blogs/ricom/) per informazioni su come trovare le perdite GC</span><span class="sxs-lookup"><span data-stu-id="22cab-141">See ["Tracking down managed memory leaks"](/archive/blogs/ricom/) on how to find GC leaks</span></span>
-   <span data-ttu-id="22cab-142">Tenere presente i modelli di perdita nel codice sul lato client Web.</span><span class="sxs-lookup"><span data-stu-id="22cab-142">Be aware of leak patterns in web client-side code.</span></span> <span data-ttu-id="22cab-143">I riferimenti circolari tra oggetti COM e motori di script come JScript possono causare perdite di grandi dimensioni nelle applicazioni Web.</span><span class="sxs-lookup"><span data-stu-id="22cab-143">Circular references between COM objects and scripting engines like JScript can cause large leaks in web applications.</span></span> <span data-ttu-id="22cab-144">["Comprensione e risoluzione dei modelli di perdita di Internet Explorer"](/previous-versions/ms976398(v=msdn.10)) contiene altre informazioni su questi tipi di perdite.</span><span class="sxs-lookup"><span data-stu-id="22cab-144">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10)) has more information on these kinds of leaks.</span></span> <span data-ttu-id="22cab-145">Per eseguire il debug di perdite di memoria nel codice, è possibile usare il rilevatore di perdite di memoria JavaScript.</span><span class="sxs-lookup"><span data-stu-id="22cab-145">You can use the JavaScript Memory Leak Detector to debug memory leaks in your code.</span></span> <span data-ttu-id="22cab-146">Sebbene Windows Internet Explorer 8, fornito con Windows 7, rilevi la maggior parte di questi problemi, i browser meno recenti sono ancora vulnerabili a questi bug</span><span class="sxs-lookup"><span data-stu-id="22cab-146">While Windows Internet Explorer 8, which is shipping with Windows 7, mitigates most of these issues, older browsers are still vulnerable to these bugs</span></span>
-   <span data-ttu-id="22cab-147">Evitare di usare più percorsi di uscita da una funzione.</span><span class="sxs-lookup"><span data-stu-id="22cab-147">Avoid using multiple exit paths from a function.</span></span> <span data-ttu-id="22cab-148">Le allocazioni assegnate a variabili nell'ambito della funzione devono essere liberate in un blocco particolare alla fine della funzione</span><span class="sxs-lookup"><span data-stu-id="22cab-148">Allocations assigned to variables at function scope should be freed in one particular block at the end of the function</span></span>
-   <span data-ttu-id="22cab-149">Non usare eccezioni nel codice senza liberare tutte le variabili locali nelle funzioni.</span><span class="sxs-lookup"><span data-stu-id="22cab-149">Do not use exceptions in your code without freeing all local variables in functions.</span></span> <span data-ttu-id="22cab-150">Se si utilizzano eccezioni native, liberare tutte le allocazioni all'interno del \_ \_ blocco finally.</span><span class="sxs-lookup"><span data-stu-id="22cab-150">If you use native exceptions, free all your allocations inside the \_\_finally block.</span></span> <span data-ttu-id="22cab-151">Se si usano le eccezioni C++, è necessario che tutte le allocazioni di heap e handle siano racchiuse nei puntatori intelligenti</span><span class="sxs-lookup"><span data-stu-id="22cab-151">If you use C++ exceptions, all your heap and handle allocations need to be wrapped in smart pointers</span></span>
-   <span data-ttu-id="22cab-152">Non rimuovere o reinizializzare un oggetto [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) senza chiamare la funzione [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)</span><span class="sxs-lookup"><span data-stu-id="22cab-152">Do not discard or reinitialize a [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) object without calling the [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) function</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="22cab-153">Collegamenti alle risorse</span><span class="sxs-lookup"><span data-stu-id="22cab-153">Links to Resources</span></span>

<span data-ttu-id="22cab-154">*Modelli di allocazione comuni:*</span><span class="sxs-lookup"><span data-stu-id="22cab-154">*Common Allocation Patterns:*</span></span>

-   [<span data-ttu-id="22cab-155">**Funzione di allocazione heap**</span><span class="sxs-lookup"><span data-stu-id="22cab-155">**Heap Allocation Function**</span></span>](/windows/win32/api/heapapi/nf-heapapi-heapalloc)
-   <span data-ttu-id="22cab-156">[**Funzione di allocazione della memoria**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-156">[**Memory Allocation Function**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="22cab-157">[**Operatore New (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-157">[**New Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="22cab-158">**Funzione di allocazione virtuale**</span><span class="sxs-lookup"><span data-stu-id="22cab-158">**Virtual Allocation Function**</span></span>](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
-   [<span data-ttu-id="22cab-159">Oggetti kernel</span><span class="sxs-lookup"><span data-stu-id="22cab-159">Kernel Objects</span></span>](../sysinfo/kernel-objects.md)
-   [<span data-ttu-id="22cab-160">Handle di oggetti GDI</span><span class="sxs-lookup"><span data-stu-id="22cab-160">GDI Object Handles</span></span>](../sysinfo/gdi-objects.md)
-   [<span data-ttu-id="22cab-161">Handle oggetto interfaccia utente</span><span class="sxs-lookup"><span data-stu-id="22cab-161">User Interface Object Handles</span></span>](../sysinfo/user-objects.md)

<span data-ttu-id="22cab-162">*Strumenti Microsoft:*</span><span class="sxs-lookup"><span data-stu-id="22cab-162">*Microsoft Tools:*</span></span>

-   [<span data-ttu-id="22cab-163">Application Verifier</span><span class="sxs-lookup"><span data-stu-id="22cab-163">Application Verifier</span></span>](application-verifier.md)
-   [<span data-ttu-id="22cab-164">Strumenti di debug per Windows</span><span class="sxs-lookup"><span data-stu-id="22cab-164">Debugging Tools for Windows</span></span>](/windows-hardware/drivers/debugger/)
-   [<span data-ttu-id="22cab-165">Heap dump in modalità utente</span><span class="sxs-lookup"><span data-stu-id="22cab-165">User-Mode Dump Heap</span></span>](/windows-hardware/drivers/debugger/umdh)
-   [<span data-ttu-id="22cab-166">Strumento di acquisizione, elaborazione e analisi delle tracce</span><span class="sxs-lookup"><span data-stu-id="22cab-166">Trace Capture, Processing, and Analysis Tool</span></span>](https://msdn.microsoft.com/performance/cc825801.aspx)
-   [<span data-ttu-id="22cab-167">Heap di debug CRT</span><span class="sxs-lookup"><span data-stu-id="22cab-167">CRT Debug Heap</span></span>](/visualstudio/debugger/crt-debug-heap-details?view=vs-2015)

<span data-ttu-id="22cab-168">*Collegamenti aggiuntivi:*</span><span class="sxs-lookup"><span data-stu-id="22cab-168">*Additional Links:*</span></span>

-   <span data-ttu-id="22cab-169">[**\_classe PTR automatico**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-169">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="22cab-170">[Classi di memoria Active Template Library (ATL)](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-170">[Active Template Library (ATL) Memory Classes](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="22cab-171">[**\_\_oggetto com PTR \_ t**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-171">[**\_com\_ptr\_t Object**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="22cab-172">[**\_\_classe BSTR t**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-172">[**\_bstr\_t Class**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="22cab-173">[**\_Classe della variante \_ YT**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-173">[**\_variant\_yt Class**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="22cab-174">"Rilevamento delle perdite di managed memory"</span><span class="sxs-lookup"><span data-stu-id="22cab-174">"Tracking down managed memory leaks"</span></span>](/archive/blogs/ricom/)
-   <span data-ttu-id="22cab-175">["Comprensione e risoluzione dei modelli di perdita di Internet Explorer"](/previous-versions/ms976398(v=msdn.10))</span><span class="sxs-lookup"><span data-stu-id="22cab-175">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10))</span></span>
-   [<span data-ttu-id="22cab-176">"Rilevatore di perdite di memoria JavaScript"</span><span class="sxs-lookup"><span data-stu-id="22cab-176">"JavaScript Memory Leak Detector"</span></span>](/archive/blogs/gpde/new-javascript-memory-leak-detector-from-our-team)
-   <span data-ttu-id="22cab-177">[Attenuazione della perdita di memoria circolare (nei browser):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="22cab-177">[Circular Memory Leak Mitigation (in browsers):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span></span>
-   <span data-ttu-id="22cab-178">[**Istruzione try-finally**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="22cab-178">[**try-finally statement**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="22cab-179">**Struttura PROPVARIANT**</span><span class="sxs-lookup"><span data-stu-id="22cab-179">**PROPVARIANT Structure**</span></span>](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)
-   [<span data-ttu-id="22cab-180">**PropVariantClear (funzione)**</span><span class="sxs-lookup"><span data-stu-id="22cab-180">**PropVariantClear Function**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)

 

 
