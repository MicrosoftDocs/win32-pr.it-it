---
description: La creazione di dll presenta una serie di problemi per gli sviluppatori.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Procedure consigliate per la libreria Dynamic-Link
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106317824"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="b2661-103">Procedure consigliate per la libreria Dynamic-Link</span><span class="sxs-lookup"><span data-stu-id="b2661-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="b2661-104">\* \* Aggiornato: \* \*</span><span class="sxs-lookup"><span data-stu-id="b2661-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="b2661-105">17 maggio 2006</span><span class="sxs-lookup"><span data-stu-id="b2661-105">May 17, 2006</span></span>

<span data-ttu-id="b2661-106">**API importanti**</span><span class="sxs-lookup"><span data-stu-id="b2661-106">**Important APIs**</span></span>

-   [<span data-ttu-id="b2661-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="b2661-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="b2661-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="b2661-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="b2661-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="b2661-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="b2661-110">La creazione di dll presenta una serie di problemi per gli sviluppatori.</span><span class="sxs-lookup"><span data-stu-id="b2661-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="b2661-111">Le dll non hanno il controllo delle versioni applicato dal sistema.</span><span class="sxs-lookup"><span data-stu-id="b2661-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="b2661-112">Quando in un sistema esistono più versioni di una DLL, la facilità di sovrascrittura associata alla mancanza di uno schema di controllo delle versioni crea conflitti tra le dipendenze e le API.</span><span class="sxs-lookup"><span data-stu-id="b2661-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="b2661-113">La complessità dell'ambiente di sviluppo, l'implementazione del caricatore e le dipendenze DLL hanno creato una fragilità in base all'ordine di caricamento e al comportamento dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2661-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="b2661-114">Infine, molte applicazioni si basano sulle dll e hanno set complessi di dipendenze che devono essere rispettate per il corretto funzionamento delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="b2661-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="b2661-115">In questo documento vengono fornite le linee guida per gli sviluppatori di DLL che consentono di creare DLL più solide, portatili ed estendibili.</span><span class="sxs-lookup"><span data-stu-id="b2661-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="b2661-116">Una sincronizzazione non corretta all'interno di [**DllMain**](dllmain.md) può causare il deadlock di un'applicazione o l'accesso a dati o codice in una dll non inizializzata.</span><span class="sxs-lookup"><span data-stu-id="b2661-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="b2661-117">La chiamata di determinate funzioni dall'interno di **DllMain** causa tali problemi.</span><span class="sxs-lookup"><span data-stu-id="b2661-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![cosa accade quando viene caricata una libreria](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="b2661-119">Procedure consigliate generali</span><span class="sxs-lookup"><span data-stu-id="b2661-119">General Best Practices</span></span>

<span data-ttu-id="b2661-120">Il metodo [**DllMain**](dllmain.md) viene chiamato mentre viene mantenuto il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="b2661-121">Pertanto, vengono imposte restrizioni significative sulle funzioni che possono essere chiamate in **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="b2661-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="b2661-122">Di conseguenza, **DllMain** è progettato per eseguire attività di inizializzazione minime, usando un piccolo subset dell'API Microsoft® Windows®.</span><span class="sxs-lookup"><span data-stu-id="b2661-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="b2661-123">Non è possibile chiamare alcuna funzione in **DllMain** che tenti direttamente o indirettamente di acquisire il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="b2661-124">In caso contrario, si introdurrà la possibilità che l'applicazione si blocchi o arresti anomali.</span><span class="sxs-lookup"><span data-stu-id="b2661-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="b2661-125">Un errore in un'implementazione di **DllMain** può compromettere l'intero processo e tutti i relativi thread.</span><span class="sxs-lookup"><span data-stu-id="b2661-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="b2661-126">Il valore [**DllMain**](dllmain.md) ideale è semplicemente uno stub vuoto.</span><span class="sxs-lookup"><span data-stu-id="b2661-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="b2661-127">Tuttavia, data la complessità di molte applicazioni, questa operazione è in genere troppo restrittiva.</span><span class="sxs-lookup"><span data-stu-id="b2661-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="b2661-128">Una buona regola empirica per **DllMain** è rimandare il maggior quantità possibile di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="b2661-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="b2661-129">L'inizializzazione differita aumenta l'affidabilità dell'applicazione perché questa inizializzazione non viene eseguita durante il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="b2661-130">Inoltre, l'inizializzazione differita consente di usare in modo sicuro gran parte dell'API Windows.</span><span class="sxs-lookup"><span data-stu-id="b2661-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="b2661-131">Non è possibile posticipare alcune attività di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="b2661-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="b2661-132">Una DLL che dipende da un file di configurazione, ad esempio, non può essere caricata se il file è in formato non valido o contiene un'operazione di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="b2661-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="b2661-133">Per questo tipo di inizializzazione, la DLL deve tentare l'azione e generare un errore rapidamente anziché sprecare risorse completando altre operazioni.</span><span class="sxs-lookup"><span data-stu-id="b2661-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="b2661-134">Non eseguire mai le seguenti attività dall'interno di [**DllMain**](dllmain.md):</span><span class="sxs-lookup"><span data-stu-id="b2661-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="b2661-135">Chiamare [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) o [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) , direttamente o indirettamente.</span><span class="sxs-lookup"><span data-stu-id="b2661-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="b2661-136">Questo può causare un deadlock o un arresto anomalo.</span><span class="sxs-lookup"><span data-stu-id="b2661-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="b2661-137">Chiamare [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)o [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) , direttamente o indirettamente.</span><span class="sxs-lookup"><span data-stu-id="b2661-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="b2661-138">Questo può causare un deadlock o un arresto anomalo.</span><span class="sxs-lookup"><span data-stu-id="b2661-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="b2661-139">Sincronizzare con altri thread.</span><span class="sxs-lookup"><span data-stu-id="b2661-139">Synchronize with other threads.</span></span> <span data-ttu-id="b2661-140">Questo può causare un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b2661-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="b2661-141">Acquisire un oggetto di sincronizzazione di proprietà del codice in attesa di acquisire il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="b2661-142">Questo può causare un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b2661-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="b2661-143">Inizializzare i thread COM usando [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="b2661-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="b2661-144">In determinate condizioni, questa funzione può chiamare [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span><span class="sxs-lookup"><span data-stu-id="b2661-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="b2661-145">Chiamare le funzioni del registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="b2661-145">Call the registry functions.</span></span> <span data-ttu-id="b2661-146">Queste funzioni vengono implementate in Advapi32.dll.</span><span class="sxs-lookup"><span data-stu-id="b2661-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="b2661-147">Se Advapi32.dll non viene inizializzato prima della DLL, la DLL può accedere alla memoria non inizializzata e causare l'arresto anomalo del processo.</span><span class="sxs-lookup"><span data-stu-id="b2661-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="b2661-148">Chiamare [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span><span class="sxs-lookup"><span data-stu-id="b2661-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="b2661-149">La creazione di un processo può caricare un'altra DLL.</span><span class="sxs-lookup"><span data-stu-id="b2661-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="b2661-150">Chiamare [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span><span class="sxs-lookup"><span data-stu-id="b2661-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="b2661-151">L'uscita da un thread durante la disconnessione della DLL può causare l'acquisizione del blocco del caricatore, causando un deadlock o un arresto anomalo.</span><span class="sxs-lookup"><span data-stu-id="b2661-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="b2661-152">Chiamare [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span><span class="sxs-lookup"><span data-stu-id="b2661-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="b2661-153">La creazione di un thread può funzionare se non si esegue la sincronizzazione con altri thread, ma è rischiosa.</span><span class="sxs-lookup"><span data-stu-id="b2661-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="b2661-154">Creare un named pipe o un altro oggetto denominato (solo Windows 2000).</span><span class="sxs-lookup"><span data-stu-id="b2661-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="b2661-155">In Windows 2000, gli oggetti denominati vengono forniti dalla DLL di Servizi terminal.</span><span class="sxs-lookup"><span data-stu-id="b2661-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="b2661-156">Se questa DLL non è inizializzata, le chiamate alla DLL possono causare l'arresto anomalo del processo.</span><span class="sxs-lookup"><span data-stu-id="b2661-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="b2661-157">Usare la funzione di gestione della memoria dalla Run-Time C dinamica (CRT).</span><span class="sxs-lookup"><span data-stu-id="b2661-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="b2661-158">Se la DLL CRT non è inizializzata, le chiamate a queste funzioni possono causare l'arresto anomalo del processo.</span><span class="sxs-lookup"><span data-stu-id="b2661-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="b2661-159">Chiamare le funzioni in User32.dll o Gdi32.dll.</span><span class="sxs-lookup"><span data-stu-id="b2661-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="b2661-160">Alcune funzioni caricano un'altra DLL, che potrebbe non essere inizializzata.</span><span class="sxs-lookup"><span data-stu-id="b2661-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="b2661-161">Usa codice gestito.</span><span class="sxs-lookup"><span data-stu-id="b2661-161">Use managed code.</span></span>

<span data-ttu-id="b2661-162">Le attività seguenti possono essere eseguite in modo sicuro all'interno di **DllMain**:</span><span class="sxs-lookup"><span data-stu-id="b2661-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="b2661-163">Inizializzare strutture di dati statiche e membri in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2661-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="b2661-164">Creare e inizializzare gli oggetti di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="b2661-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="b2661-165">Allocare memoria e inizializzare strutture di dati dinamiche (evitando le funzioni elencate in precedenza).</span><span class="sxs-lookup"><span data-stu-id="b2661-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="b2661-166">Configurare l'archiviazione locale di thread (TLS).</span><span class="sxs-lookup"><span data-stu-id="b2661-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="b2661-167">Aprire, leggere e scrivere nei file.</span><span class="sxs-lookup"><span data-stu-id="b2661-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="b2661-168">Chiamare le funzioni in Kernel32.dll (ad eccezione delle funzioni elencate in precedenza).</span><span class="sxs-lookup"><span data-stu-id="b2661-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="b2661-169">Impostare i puntatori globali su NULL, disattivando l'inizializzazione dei membri dinamici.</span><span class="sxs-lookup"><span data-stu-id="b2661-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="b2661-170">In Microsoft Windows Vista™ è possibile utilizzare le funzioni di inizializzazione monouso per garantire che un blocco di codice venga eseguito una sola volta in un ambiente a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="b2661-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="b2661-171">Deadlock causati dall'inversione dell'ordine di blocco</span><span class="sxs-lookup"><span data-stu-id="b2661-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="b2661-172">Quando si implementa codice che utilizza più oggetti di sincronizzazione, ad esempio blocchi, è fondamentale rispettare l'ordine di blocco.</span><span class="sxs-lookup"><span data-stu-id="b2661-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="b2661-173">Quando è necessario acquisire più di un blocco alla volta, è necessario definire una precedenza esplicita denominata gerarchia dei blocchi o ordine di blocco.</span><span class="sxs-lookup"><span data-stu-id="b2661-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="b2661-174">Se, ad esempio, il blocco A viene acquisito prima del blocco B in un punto qualsiasi del codice e il blocco B viene acquisito prima del blocco C in un altro punto del codice, l'ordine di blocco è A, B, C e questo ordine deve essere seguito in tutto il codice.</span><span class="sxs-lookup"><span data-stu-id="b2661-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="b2661-175">L'inversione dell'ordine di blocco si verifica quando l'ordine di blocco non viene seguito, ad esempio se viene acquisito il blocco B prima del blocco A. l'inversione dell'ordine di blocco può causare deadlock difficili da eseguire il debug.</span><span class="sxs-lookup"><span data-stu-id="b2661-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="b2661-176">Per evitare tali problemi, tutti i thread devono acquisire i blocchi nello stesso ordine.</span><span class="sxs-lookup"><span data-stu-id="b2661-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="b2661-177">È importante notare che il caricatore chiama [**DllMain**](dllmain.md) con il blocco del caricatore già acquisito, quindi il blocco del caricatore deve avere la precedenza più alta nella gerarchia di blocco.</span><span class="sxs-lookup"><span data-stu-id="b2661-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="b2661-178">Si noti inoltre che il codice deve solo acquisire i blocchi necessari per una corretta sincronizzazione. non è necessario acquisire ogni singolo blocco definito nella gerarchia.</span><span class="sxs-lookup"><span data-stu-id="b2661-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="b2661-179">Se, ad esempio, una sezione di codice richiede solo i blocchi A e C per la corretta sincronizzazione, il codice deve acquisire il blocco A prima di acquisire il blocco C; non è necessario che il codice acquisisca anche il blocco B. Il codice DLL non può inoltre acquisire in modo esplicito il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="b2661-180">Se il codice deve chiamare un'API, ad esempio [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) , che può acquisire indirettamente il blocco del caricatore e anche il codice deve acquisire un blocco privato, il codice deve chiamare **GetModuleFileName** prima di acquisire il blocco P, assicurando in tal modo che l'ordine di caricamento venga rispettato.</span><span class="sxs-lookup"><span data-stu-id="b2661-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="b2661-181">Nella figura 2 è riportato un esempio che illustra l'inversione dell'ordine di blocco.</span><span class="sxs-lookup"><span data-stu-id="b2661-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="b2661-182">Si consideri una DLL il cui thread principale contiene [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="b2661-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="b2661-183">Il caricatore della libreria acquisisce il blocco del caricatore e quindi chiama **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="b2661-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="b2661-184">Il thread principale crea gli oggetti di sincronizzazione A, B e G per serializzare l'accesso alle strutture di dati e quindi tenta di acquisire il blocco G. Un thread di lavoro che ha già acquisito il blocco G chiama una funzione, ad esempio GetModuleHandle, che tenta di acquisire il blocco del caricatore. Pertanto, il thread di lavoro è bloccato su L e il thread principale è bloccato su G, causando un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b2661-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![deadlock causato dall'inversione dell'ordine di blocco](images/fig2.png)

<span data-ttu-id="b2661-186">Per evitare deadlock causati da inversione dell'ordine di blocco, tutti i thread devono tentare di acquisire sempre gli oggetti di sincronizzazione nell'ordine di caricamento definito.</span><span class="sxs-lookup"><span data-stu-id="b2661-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="b2661-187">Procedure consigliate per la sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="b2661-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="b2661-188">Si consideri una DLL che crea thread di lavoro come parte dell'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="b2661-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="b2661-189">Quando si pulisce la DLL, è necessario eseguire la sincronizzazione con tutti i thread di lavoro per assicurarsi che le strutture di dati siano in uno stato coerente e quindi terminare i thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="b2661-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="b2661-190">Attualmente, non esiste un modo semplice per risolvere completamente il problema della sincronizzazione e dell'arresto delle dll in un ambiente a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="b2661-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="b2661-191">In questa sezione vengono descritte le procedure consigliate correnti per la sincronizzazione dei thread durante l'arresto della DLL.</span><span class="sxs-lookup"><span data-stu-id="b2661-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="b2661-192">Sincronizzazione thread in [**DllMain**](dllmain.md) durante l'uscita del processo</span><span class="sxs-lookup"><span data-stu-id="b2661-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="b2661-193">Quando [**DllMain**](dllmain.md) viene chiamato all'uscita del processo, tutti i thread del processo sono stati eliminati forzatamente ed è possibile che lo spazio degli indirizzi sia incoerente.</span><span class="sxs-lookup"><span data-stu-id="b2661-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="b2661-194">In questo caso la sincronizzazione non è obbligatoria.</span><span class="sxs-lookup"><span data-stu-id="b2661-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="b2661-195">In altre parole, il gestore di \_ scollegamento del processo dll ideale \_ è vuoto.</span><span class="sxs-lookup"><span data-stu-id="b2661-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="b2661-196">Windows Vista garantisce che le strutture di dati principali (variabili di ambiente, directory correnti, heap del processo e così via) siano in uno stato coerente.</span><span class="sxs-lookup"><span data-stu-id="b2661-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="b2661-197">Tuttavia, altre strutture di dati possono essere danneggiate, quindi la pulizia della memoria non è sicura.</span><span class="sxs-lookup"><span data-stu-id="b2661-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="b2661-198">Lo stato persistente che deve essere salvato deve essere scaricato nell'archivio permanente.</span><span class="sxs-lookup"><span data-stu-id="b2661-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="b2661-199">Sincronizzazione dei thread in **DllMain** per lo \_ scollegamento del thread dll durante lo \_ scaricamento della dll</span><span class="sxs-lookup"><span data-stu-id="b2661-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="b2661-200">Quando la DLL viene scaricata, lo spazio degli indirizzi non viene eliminato.</span><span class="sxs-lookup"><span data-stu-id="b2661-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="b2661-201">Pertanto, è previsto che la DLL esegua una chiusura normale.</span><span class="sxs-lookup"><span data-stu-id="b2661-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="b2661-202">Sono inclusi la sincronizzazione di thread, gli handle aperti, lo stato persistente e le risorse allocate.</span><span class="sxs-lookup"><span data-stu-id="b2661-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="b2661-203">La sincronizzazione del thread è complessa perché l'attesa di chiusura di thread in [**DllMain**](dllmain.md) può causare un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b2661-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="b2661-204">Ad esempio, la DLL A include il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="b2661-205">Segnala al thread T di uscire e attende la chiusura del thread.</span><span class="sxs-lookup"><span data-stu-id="b2661-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="b2661-206">Il thread T viene chiuso e il caricatore tenta di acquisire il blocco del caricatore per effettuare una chiamata a **DllMain** della dll a con la \_ disconnessione del thread dll \_ .</span><span class="sxs-lookup"><span data-stu-id="b2661-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="b2661-207">Causando un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b2661-207">This causes a deadlock.</span></span> <span data-ttu-id="b2661-208">Per ridurre al minimo il rischio di un deadlock:</span><span class="sxs-lookup"><span data-stu-id="b2661-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="b2661-209">La DLL a ottiene un \_ \_ messaggio di scollegamento del thread dll nella relativa [**DllMain**](dllmain.md) e imposta un evento per il thread T, segnalando l'uscita.</span><span class="sxs-lookup"><span data-stu-id="b2661-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="b2661-210">Il thread T termina l'attività corrente, porta se stesso a uno stato coerente, segnala la DLL A e attende infinitamente.</span><span class="sxs-lookup"><span data-stu-id="b2661-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="b2661-211">Si noti che le routine di controllo della coerenza devono rispettare le stesse restrizioni di [**DllMain**](dllmain.md) per evitare il deadlock.</span><span class="sxs-lookup"><span data-stu-id="b2661-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="b2661-212">La DLL A termina T, sapendo che è in uno stato coerente.</span><span class="sxs-lookup"><span data-stu-id="b2661-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="b2661-213">Se una DLL viene scaricata dopo la creazione di tutti i relativi thread, ma prima dell'avvio dell'esecuzione, i thread potrebbero arrestarsi in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="b2661-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="b2661-214">Se la DLL ha creato thread nella relativa **DllMain** come parte dell'inizializzazione, è possibile che l'inizializzazione di alcuni thread non sia terminata e che il \_ \_ messaggio di connessione del thread dll sia ancora in attesa di essere recapitato alla dll.</span><span class="sxs-lookup"><span data-stu-id="b2661-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="b2661-215">In questa situazione, se la DLL viene scaricata, inizierà a terminare i thread.</span><span class="sxs-lookup"><span data-stu-id="b2661-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="b2661-216">Tuttavia, alcuni thread possono essere bloccati dietro il blocco del caricatore.</span><span class="sxs-lookup"><span data-stu-id="b2661-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="b2661-217">I \_ \_ messaggi di associazione dei thread dll vengono elaborati dopo che è stato annullato il mapping della dll, causando un arresto anomalo del processo.</span><span class="sxs-lookup"><span data-stu-id="b2661-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="b2661-218">Consigli</span><span class="sxs-lookup"><span data-stu-id="b2661-218">Recommendations</span></span>

<span data-ttu-id="b2661-219">Di seguito sono riportate le linee guida consigliate:</span><span class="sxs-lookup"><span data-stu-id="b2661-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="b2661-220">Utilizzare Application Verifier per intercettare gli errori più comuni in [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="b2661-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="b2661-221">Se si usa un blocco privato all'interno di [**DllMain**](dllmain.md), definire una gerarchia di blocco e usarla in modo coerente.</span><span class="sxs-lookup"><span data-stu-id="b2661-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="b2661-222">Il blocco del caricatore deve trovarsi nella parte inferiore della gerarchia.</span><span class="sxs-lookup"><span data-stu-id="b2661-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="b2661-223">Verificare che nessuna chiamata dipenda da un'altra DLL che potrebbe non essere ancora stata completamente caricata.</span><span class="sxs-lookup"><span data-stu-id="b2661-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="b2661-224">Eseguire inizializzazioni semplici in modo statico in fase di compilazione, anziché in [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="b2661-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="b2661-225">Rinviare tutte le chiamate in [**DllMain**](dllmain.md) che possono attendere più tardi.</span><span class="sxs-lookup"><span data-stu-id="b2661-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="b2661-226">Rinvia le attività di inizializzazione che possono attendere più tardi.</span><span class="sxs-lookup"><span data-stu-id="b2661-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="b2661-227">Alcune condizioni di errore devono essere rilevate in anticipo in modo che l'applicazione possa gestire correttamente gli errori.</span><span class="sxs-lookup"><span data-stu-id="b2661-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="b2661-228">Tuttavia, esistono compromessi tra questo rilevamento iniziale e la perdita di affidabilità che può derivare da essa.</span><span class="sxs-lookup"><span data-stu-id="b2661-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="b2661-229">Il rinvio dell'inizializzazione è spesso migliore.</span><span class="sxs-lookup"><span data-stu-id="b2661-229">Deferring initialization is often best.</span></span>

 

 
