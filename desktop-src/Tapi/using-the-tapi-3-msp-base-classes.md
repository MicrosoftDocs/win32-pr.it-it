---
description: Nella procedura seguente viene descritto come implementare un MSP utilizzando ATL versione 2,1 o ATL versione 3,0 e le classi base MSP.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Uso delle classi base MSP di TAPI 3
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: eb8ad4fd160cf0fc4c7dd682a44f3a4ff0bcec25
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/08/2021
ms.locfileid: "106318601"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Uso delle classi base MSP di TAPI 3

Nella procedura seguente viene descritto come implementare un MSP utilizzando ATL versione 2,1 o ATL versione 3,0 e le classi base MSP. Per ulteriori informazioni e per un elenco di librerie e intestazioni, vedere [classi di base msp di TAPI 3](tapi-3-msp-base-classes.md). Il contenuto contenuto in questo argomento presuppone che lo sviluppatore abbia una conoscenza approfondita di ATL e COM e abbia esperienza nell'implementazione di DLL COM con ATL.

**Per implementare e MSP utilizzando ATL 2,1 o ATL 3,0**

1.  Creare un file IDL per l'MSP. Questo file definisce un CLSID per l'MSP. Dichiarare l'MSP "CoClass" come implementazione dell'interfaccia [**ITMSPAddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) e dichiarare questa interfaccia come interfaccia predefinita nell'oggetto classe. Per la definizione di **ITMSPAddress**, importare il file "msp. idl". Includere la "coclasse" MSP in una libreria dei tipi per il MSP. Se il MSP supporta le interfacce private (personalizzate), definirle qui e includerle nella libreria dei tipi. L'esempio di codice seguente è un file IDL come descritto in precedenza, senza interfacce personalizzate.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Modificare il TSP per annunciare il CLSID del MSP quando Tapi3.dll richiesto. Verificare che (1) il TSP possa negoziare TAPI \_ VERSION3 \_ 0 o versione successiva nella funzione TSPI [**TSPI \_ lineNegotiateTSPIVersion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion), (2) la struttura del TSP [**LINEDEVCAPS**](/windows/win32/api/tapi/ns-tapi-linedevcaps) ha il \_ flag msp LINEDEVCAPFLAGS impostato nel membro **DWDEVCAPFLAGS** e (3) il TSP restituisce il CLSID msp nella funzione TSPI TSPI [**\_ lineMSPIdentify**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify). Deve corrispondere al CLSID specificato nel file IDL. ad esempio, la seconda riga "UUID" nel file IDL di esempio nel passaggio precedente.
3.  Compilare l'applicazione di esempio MSPBase, che si trova nella piattaforma Software Development Kit (SDK), per creare la libreria MSPBaseSample. lib.
4.  Collegare la DLL MSP con la libreria MSPBaseSample. lib.
5.  Includere Mspbase. h dalle definizioni delle classi base di SDK per MSP.
6.  Implementare le esportazioni di DLL (ad esempio, DllMain). Microsoft Visual C++ li genererà automaticamente. In DllMain, nella DLL \_ processo di \_ collegamento e \_ \_ scollegamento processo dll, utilizzare rispettivamente le macro **MSPLOGREGISTER** e **MSPLOGDEREGISTER** per abilitare le funzionalità di registrazione per la dll. Specificare il nome della DLL nella chiamata **MSPLOGDEREGISTER** .
7.  Utilizzare la macro LOG, definita in Msplog. h, per restituire i messaggi di traccia nello stesso modo delle classi di base. Definire il simbolo del preprocessore MSPLOG per includere la registrazione nella DLL; lasciarlo indefinito per compilare una DLL che non dispone di registrazione.
8.  Derivare una classe da CMSPAddress che implementi gli indirizzi per l'MSP. Dichiarare una mappa di oggetti ATL globale che indica ad ATL di creare un'istanza della classe Address quando viene richiesto di creare una **cocreazione** sul CLSID specificato nel file IDL. Inoltre, derivare la classe Address dal modello ATL **CComCoClass** e includere una dichiarazione Declare \_ Registry \_ RESOURCEID nella classe Address. Costruire uno script di risorsa e un file di intestazione corrispondenti, come per qualsiasi altra DLL COM ATL.
9.  Implementare le sostituzioni CMSPAddress necessarie per la classe Address. Per [**MSPAddressAddRef**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) e [**MSPAddressRelease**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease), chiamare i modelli di funzione helper forniti. Per [**GetCallMediaTypes**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes), è sufficiente restituire una bitmap **DWORD** con tutti i ORed TAPIMEDIAMODEs supportati da msp. Per [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) e [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall), restituire e \_ NOTIMPL e compilare e collegare il msp a questo punto. A questo punto, verificare che sia possibile registrare e creare un'istanza dell'MSP dalle applicazioni TAPI 3, ma non creare correttamente le chiamate.
10. Derivare una classe da CMSPCallMultiGraph per implementare gli oggetti chiamata MSP. È possibile che si desideri derivare da [**CMSPCallBase**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) anziché da [**CMSPCallMultiGraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) se il modello Filter-Graph-per-Stream non soddisfa i requisiti. in questo modo si aumenta la complessità dell'attività (al momento della stesura di questo articolo, tutti MSPs derivano gli oggetti Call direttamente da **CMSPCallMultiGraph**). Nell'oggetto Address implementare [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) e [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) per creare e arrestare il tipo specifico di oggetto call usando i modelli di funzione helper forniti. Nell'oggetto chiamata eseguire l'override di [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) per restituire E \_ NOTIMPL. Eseguire l'override di [**MSPCallAddRef**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) e [**MSPCallRelease**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) in modo identico ai metodi Address corrispondenti. Anche in questo caso, dovrebbe essere possibile compilare e collegare il proprio MSP; a questo punto dovrebbe essere in grado di creare e arrestare le chiamate, ma le chiamate non eseguiranno alcuna trasmissione utile.
11. Derivare una classe da CMSPStream per implementare gli oggetti flusso MSP. Nell'oggetto chiamata implementare [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) per creare e inizializzare l'oggetto flusso, in genere chiamando il **CreateInstance** ATL seguito da ATL **\_ InternalQueryInterface** per [**ITStream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) seguito dalla chiamata a **init** nell'oggetto flusso. Per supportare un numero fisso di flussi (questo è comune per MSPs che non supportano la modifica delle configurazioni di flusso da parte di altri endpoint nella chiamata), eseguire l'override di **init**, [**CreateStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)e [**RemoveStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) nell'oggetto chiamata. (Call **init** crea tutti i flussi inizialmente e **CreateStream** e **RemoveStream** restituiscono i codici di errore TAPI appropriati per impedire che l'applicazione crei o rimuovono i flussi). In caso contrario, eseguire l'override del metodo **init** della chiamata per creare una configurazione iniziale predefinita dei flussi usando i tipi di supporto richiesti per la chiamata. Quando si creano oggetti flusso predefiniti nel metodo **init** della chiamata, usare il metodo helper [**InternalCreateStream**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream) .
12. Implementare l'oggetto flusso. L'unico override obbligatorio è il metodo [**get \_ Name**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) , che restituisce semplicemente un nome descrittivo per il flusso. Inoltre, sarà necessario eseguire l'override di diversi altri metodi. Esattamente i metodi di cui eseguire l'override dipendono dall'implementazione e quando si decide di eseguire le varie attività necessarie per la costruzione e la decostruzione del grafico di filtro. Queste attività includono la creazione dei filtri di "trasporto" appropriati, i codec e così via e l'inserimento e la rimozione dei grafici dei filtri nei momenti appropriati. Sarà anche necessario usare l'interfaccia [**ITTerminalControl**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) sugli oggetti terminal per connettere i terminali selezionati ai flussi. Potrebbe essere necessario eseguire l'override di [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) sull'oggetto Stream per limitare le configurazioni del terminale che i flussi accetteranno. la limitazione di ogni flusso a un singolo terminale semplificherà in particolare la costruzione dei grafici di filtro, ma sacrifica le funzionalità dell'applicazione, ad esempio l'anteprima video. A seconda dell'implementazione, si inseriranno la costruzione del grafo, la decostruzione e il codice di connessione terminal nei metodi [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown), [**SELECTTERMINAL**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) oppure nei metodi personalizzati basati sulla comunicazione del TSP privato. Tenere presente che un flusso senza terminali selezionati deve tenere traccia dello stato del grafico desiderato; una chiamata **StartStream** seguita da una chiamata **SelectTerminal** su un flusso di questo tipo deve generare un flusso di dati. Eseguire l'override della maggior parte di questi metodi per assicurarsi che la costruzione, la decostruzione, la connessione e la disconnessione corrette avvengano in ogni caso a seconda dello stato del flusso.
13. Implementare la comunicazione del TSP. Eseguire l'override di [**CMSPAddress:: ReceiveTSPAddressData**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) e/o [**CMSPCallBase:: ReceiveTSPCallData**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata)e/o chiamando [**postEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) nell'oggetto Address oppure [**HandleStreamEvent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) nell'oggetto chiamata (dagli oggetti chiamata o flusso).
14. Usare postEvent nell'oggetto Address o HandleStreamEvent nell'oggetto chiamata (dagli oggetti chiamata o flusso) per inviare chiamate a eventi multimediali all'applicazione tramite Tapi3.dll. Questa operazione viene eseguita in genere nell'oggetto flusso, nei metodi sottoposti a override, inclusi i metodi [**ProcessGraphEvent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , a seconda della modalità di implementazione dei flussi.
15. Implementare le interfacce private o i sottoflussi desiderati sugli oggetti esistenti (indirizzo, chiamata e flusso). In genere non è presente alcun valore. Tenere presente che quando si implementano le interfacce private, specificare il LIBID della libreria dei tipi dal file IDL. Ovvero, i programmatori di applicazioni devono utilizzare la libreria dei tipi MSP quando si utilizzano le interfacce personalizzate. Le interfacce MSP standard, implementate nelle classi di base MSP, usano la Tapi3.dll LIBID e sono pertanto accessibili a tutte le applicazioni TAPI 3.
16. Se si implementano oggetti terminali statici o dinamici specifici di MSP o sostituzioni per i terminali statici predefiniti (non tipici), è possibile utilizzare le classi base del terminale fornite. Sarà necessario eseguire l'override di diversi metodi sull'oggetto Address per fornire metodi alternativi o aggiuntivi per la creazione di oggetti terminal.
17. Implementare l'interfaccia IObjectSafety sugli oggetti Address, Call, Stream e terminal. Per usare il [Mapper di invio](dispatch-mapper.md) per eseguire query per le interfacce sugli oggetti msp, contrassegnare gli oggetti come sicuri per gli script in tali interfacce. A tale scopo, implementare l'interfaccia **IObjectSafety** sull'oggetto. La derivazione da **CMSPObjectSafetyImpl** (una classe helper fornita in Msputils. h) e l'aggiunta di **IOBJECTSAFETY** alla mappa COM ATL della classe renderà gli \_ oggetti sicuri per gli script in tutte le interfacce che espongono. Tenere presente che l'utilizzo del mapper di invio sugli oggetti MSP potrebbe essere implicito. L'indirizzo MSP e la chiamata MSP sono aggregati in base all'indirizzo TAPI e agli oggetti chiamata TAPI. Se il mapper di dispatch viene usato per gli oggetti TAPI per eseguire una query per le interfacce esposte dagli oggetti MSP aggregati, verrà eseguita una query sugli oggetti MSP aggregati per garantire la sicurezza delle interfacce richieste.

 

 
