---
description: La procedura seguente descrive come implementare un msp usando ATL versione 2.1 o ATL versione 3.0 e le classi di base MSP.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Uso delle classi di base TAPI 3 MSP
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6131d44b6746075c43fc61c9d35decbe0564773db4746bba6d72b0da4697cabd
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/11/2021
ms.locfileid: "119139714"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Uso delle classi di base TAPI 3 MSP

La procedura seguente descrive come implementare un msp usando ATL versione 2.1 o ATL versione 3.0 e le classi di base MSP. Per altre informazioni e un elenco di librerie e intestazioni, vedere Classi di [base TAPI 3 MSP.](tapi-3-msp-base-classes.md) Il contenuto contenuto in questo argomento presuppone che lo sviluppatore abbia una conoscenza pratica di ATL e COM e abbia esperienza nell'implementazione di DLL COM tramite ATL.

**Per implementare e MSP usando ATL 2.1 o ATL 3.0**

1.  Creare un file IDL per il msp. Questo file definisce un CLSID per il msp. Dichiarare la "coclasse" MSP come implementazione [**dell'interfaccia ITMSPAddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) e dichiarare questa interfaccia come interfaccia predefinita nell'oggetto classe. Per la definizione di **ITMSPAddress**, importare il file "msp.idl". Includere la "coclasse" MSP in una libreria dei tipi per msp. Se il msp supporta interfacce private (personalizzate), definirle qui e includerle nella libreria dei tipi. L'esempio di codice seguente è un file IDL come descritto in precedenza, senza interfacce personalizzate.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Modificare il provider di servizi di configurazione per annunciare il CLSID del provider di servizi Tapi3.dll richiederlo. Assicurarsi che (1) il TSP possa negoziare TAPI VERSION3 0 o versione successiva nella riga TSPI della funzione \_ \_ [**\_ TSPINegotiateTSPIVersion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion), (2) la struttura [**LINEDEVCAPS**](/windows/win32/api/tapi/ns-tapi-linedevcaps) TSP abbia il flag LINEDEVCAPFLAGS MSP impostato nel membro \_ **dwDevCapFlags** e (3) il TSP restituisca il CLSID MSP nella riga TSPI della funzione [**\_ TSPIMSPIdentify**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify). Deve essere lo stesso CLSID specificato nel file IDL. ad esempio la seconda riga "uuid" nel file IDL di esempio nel passaggio precedente.
3.  Compilare l'applicazione di esempio MSPBase, disponibile in Platform Software Development Kit (SDK), per creare la libreria MSPBaseSample.lib.
4.  Collegare la DLL MSP alla libreria MSPBaseSample.lib.
5.  Includere Mspbase.h dall'SDK per le definizioni della classe di base MSP.
6.  Implementare le esportazioni dll (ad esempio, DllMain). Microsoft Visual C++ genererà automaticamente questi elementi. In DllMain, rispettivamente in DLL PROCESS ATTACH e DLL PROCESS DETACH, usare le \_ \_ macro \_ \_ **MSPLOGREGISTER** e **MSPLOGDEREGISTER** per abilitare le funzionalità di registrazione per la DLL. Specificare il nome della DLL nella **chiamata MSPLOGDEREGISTER.**
7.  Usare la macro LOG, definita in Msplog.h, per l'output dei messaggi di traccia nello stesso modo delle classi di base. Definire il simbolo del preprocessore MSPLOG per includere la registrazione nella DLL. lasciare indefinito per compilare una DLL che non dispone della registrazione.
8.  Derivare una classe da CMSPAddress che implementa gli indirizzi per msp. Dichiarare una mappa di oggetti ATL globale che indica ad ATL di creare un'istanza della classe di indirizzi quando viene richiesto di creare un elemento **CoCreate** in base al CLSID specificato nel file IDL. Derivare anche la classe di indirizzi dal modello **ATL CComCoClass** e includere una dichiarazione DECLARE \_ REGISTRY \_ RESOURCEID nella classe di indirizzi. Costruire uno script di risorsa e un file di intestazione corrispondenti, come per qualsiasi altra DLL COM ATL.
9.  Implementare gli override CMSPAddress necessari per la classe di indirizzi. Per [**MSPAddressAddRef**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) e [**MSPAddressRelease,**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease)chiamare i modelli di funzione helper forniti. Per [**GetCallMediaTypes,**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes)è sufficiente restituire una bitmap **DWORD** con tutti i TAPIMEDIAMODEs supportati da MSP insieme. Per [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) e [**ShutdownMSPCall,**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall)restituire E \_ NOTIMPL e compilare e collegare il msp a questo punto. A questo punto, verificare che sia possibile registrare e creare un'istanza del msp dalle applicazioni TAPI 3, ma non creare correttamente le chiamate.
10. Derivare una classe da CMSPCallMultiGraph per implementare gli oggetti chiamata MSP. È possibile derivare da [**CMSPCallBase**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) invece di [**CMSPCallMultiGraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) se il modello filter-graph-per-stream non è adatto alle proprie esigenze. In questo modo si aumenta la complessità dell'attività (al completamento di questa scrittura, tutti i provider di servizi gestiti derivano gli oggetti chiamata **direttamente da CMSPCallMultiGraph).** Nell'oggetto indirizzo implementare [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) e [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) per creare e arrestare il tipo specifico di oggetto chiamata usando i modelli di funzione helper forniti. Nell'oggetto di chiamata eseguire l'override [**di CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) per restituire E \_ NOTIMPL. Eseguire [**l'override di MSPCallAddRef**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) [**e MSPCallRelease**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) in modo identico ai metodi di indirizzo corrispondenti. Anche in questo caso, dovrebbe essere possibile compilare e collegare il msp; Dovrebbe ora essere in grado di creare e arrestare le chiamate, ma le chiamate non eseranno alcun flusso utile.
11. Derivare una classe da CMSPStream per implementare gli oggetti flusso MSP. Nell'oggetto di chiamata implementare [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) per creare e inizializzare l'oggetto flusso( in genere chiamando **l'elemento CreateInstance** ATL seguito da ATL **\_ InternalQueryInterface** per [**ITStream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) seguito dalla chiamata **a Init** sull'oggetto flusso). Per supportare un numero fisso di flussi (questo comportamento è comune per i msp che non supportano la modifica delle configurazioni di flusso da parte di altri endpoint nella chiamata), eseguire l'override di **Init**, [**CreateStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)e [**RemoveStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) sull'oggetto chiamata. La chiamata **Init** crea inizialmente tutti i flussi e **CreateStream** e **RemoveStream** restituiscono i codici di errore TAPI appropriati per impedire all'applicazione di creare o rimuovere flussi. In caso contrario, eseguire l'override del metodo **Init** della chiamata per creare alcune configurazioni predefinite iniziali dei flussi usando i tipi di supporti richiesti per la chiamata. Quando si creano oggetti flusso predefiniti nel metodo **Init della** chiamata, usare il metodo helper [**InternalCreateStream.**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream)
12. Implementare l'oggetto flusso. L'unico override obbligatorio è [**il metodo get \_ Name,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) che restituisce semplicemente un nome descrittivo per il flusso. Sarà anche necessario eseguire l'override di diversi altri metodi. I metodi di cui eseguire l'override dipendono dall'implementazione e quando si decide di eseguire le varie attività necessarie per costruire e decostruire il grafico dei filtri. Queste attività includono la creazione dei filtri di "trasporto", i codec e così via appropriati, l'inserimento e la rimozione dei filtri dai grafici dei filtri nei momenti appropriati. Sarà anche necessario usare [**l'interfaccia ITTerminalControl**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) sugli oggetti terminale per connettere i terminali selezionati ai flussi. È possibile eseguire l'override di [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) nell'oggetto flusso per limitare le configurazioni terminali che i flussi accetteranno. la limitazione di ogni flusso a un singolo terminale semplificherà in particolare la costruzione dei grafici dei filtri, ma inasorrà le funzionalità dell'applicazione, ad esempio l'anteprima video. A seconda dell'implementazione, la costruzione del grafo, la decostruzione e il codice di connessione terminale verranno posizionati nei metodi [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)e [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) oppure nei propri metodi basati sulla comunicazione TSP privata. Tenere presente che un flusso senza terminali selezionati deve tenere traccia dello stato desiderato del grafico. Una **chiamata StartStream** seguita da una **chiamata SelectTerminal** su tale flusso deve comportare un flusso di dati. Eseguire l'override della maggior parte di questi metodi per assicurarsi che la costruzione, la decostruzione, la connessione e la disconnessione corrette avvengano in ogni caso a seconda dello stato del flusso.
13. Implementare la comunicazione TSP. Eseguire l'override di [**CMSPAddress::ReceiveTSPAddressData**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) e/o [**CMSPCallBase::ReceiveTSPCallData**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata)e/o chiamando [**PostEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) sull'oggetto indirizzo o [**HandleStreamEvent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) sull'oggetto chiamata (dagli oggetti di chiamata o di flusso).
14. Usare PostEvent nell'oggetto indirizzo o HandleStreamEvent nell'oggetto chiamata (da oggetti chiamata o flusso) per inviare eventi multimediali di chiamata all'applicazione tramite Tapi3.dll. In genere si esegue questa operazione nell'oggetto flusso, nei metodi sottoposti a override, tra cui i metodi [**ProcessGraphEvent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)e [**UnselectTerminal,**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) a seconda della modalità di implementazione dei flussi.
15. Implementare le interfacce private o i flussi secondari desiderati sugli oggetti esistenti (indirizzo, chiamata e flusso). In genere non ne sono presenti. Tenere presente che quando si implementano le interfacce private, specificare il LIBID della libreria dei tipi dal file IDL. Ciò significa che i programmatori di applicazioni devono usare la libreria dei tipi MSP quando usano le interfacce personalizzate. Le interfacce MSP standard, implementate nelle classi di base MSP, usano Tapi3.dll LIBID e sono pertanto accessibili a tutte le applicazioni TAPI 3.
16. Se si implementano oggetti terminali statici o dinamici specifici di MSP o sostituzioni per i terminali statici predefiniti (non tipici), è possibile usare le classi di base del terminale fornite. Sarà necessario eseguire l'override di vari metodi nell'oggetto indirizzo per fornire metodi alternativi o aggiuntivi per la creazione di oggetti terminale.
17. Implementare l'interfaccia IObjectSafety sugli oggetti Address, Call, Stream e Terminal. Per usare [Dispatch Mapper per](dispatch-mapper.md) eseguire query per le interfacce sugli oggetti MSP, contrassegnare gli oggetti come sicuri per lo scripting su queste interfacce. A tale scopo, implementare **l'interfaccia IObjectSafety** nell'oggetto. La derivazione da **CMSPObjectSafetyImpl** (una classe helper fornita in Msputils.h) e l'aggiunta di **IObjectSafety** alla mappa COM ATL della classe renderanno gli oggetti sicuri per lo scripting in tutte le interfacce esporle. \_ Tenere presente che l'uso di Dispatch Mapper su oggetti MSP può essere implicito. L'indirizzo MSP e la chiamata MSP vengono aggregati in base agli oggetti Indirizzo TAPI e Chiamata TAPI. Se Dispatch Mapper viene usato sugli oggetti TAPI per eseguire una query per le interfacce esposte dagli oggetti MSP aggregati, verrà eseguita una query sugli oggetti MSP aggregati per garantire la sicurezza delle interfacce richieste.

 

 
