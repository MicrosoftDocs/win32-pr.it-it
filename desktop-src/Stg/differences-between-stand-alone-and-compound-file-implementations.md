---
title: Differenze tra le implementazioni di file autonomi e composti
description: L'implementazione autonoma delle interfacce del set di proprietà e dell'implementazione del file composto differisce in qualche modo.
ms.assetid: 650d4759-a58a-47a4-922d-5757e356cf56
keywords:
- IPropertyStorage Strctd STG, implementazioni
- IPropertyStorage Strctd STG, implementazioni, differenze
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 988f8a9cfdaca0a131bedf98cd8ff10ae8b89525
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/16/2019
ms.locfileid: "103855946"
---
# <a name="differences-between-stand-alone-and-compound-file-implementations"></a><span data-ttu-id="5ab7d-105">Differenze tra le implementazioni di file autonomi e composti</span><span class="sxs-lookup"><span data-stu-id="5ab7d-105">Differences between Stand-alone and Compound File Implementations</span></span>

<span data-ttu-id="5ab7d-106">L'implementazione autonoma delle interfacce del set di proprietà e dell'implementazione del file composto differisce in qualche modo.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-106">The stand-alone implementation of the property set interfaces and the compound file implementation differ in some ways.</span></span> <span data-ttu-id="5ab7d-107">Nell'implementazione del file composto di flusso, archiviazione, archiviazione dei set di proprietà e oggetti di archiviazione delle proprietà, le varie interfacce coordinano tra loro perché condividono un'implementazione comune.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-107">In the compound-file implementation of stream, storage, property set storage, and property storage objects, the various interfaces coordinate with each another because they share a common implementation.</span></span> <span data-ttu-id="5ab7d-108">Nell'implementazione autonoma, le implementazioni dell'interfaccia sono distinte.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-108">In the stand-alone implementation, the interface implementations are distinct.</span></span>

<span data-ttu-id="5ab7d-109">Di conseguenza, l'implementazione del file composto gestisce i problemi di concorrenza e sincronizza l'oggetto set di proprietà con l'oggetto di archiviazione o flusso.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-109">As a result, the compound-file implementation handles concurrency issues and synchronizes the property set object with the storage or stream object.</span></span> <span data-ttu-id="5ab7d-110">Con l'implementazione autonoma, il client è responsabile della gestione dei problemi di concorrenza e di sincronizzazione tra l'oggetto di archiviazione o flusso e il set di proprietà.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-110">With the stand-alone implementation, the client is responsible for handling concurrency and synchronization issues between the storage or stream object and the property set.</span></span> <span data-ttu-id="5ab7d-111">Un client può soddisfare questi requisiti seguendo due semplici regole.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-111">A client can meet these requirements by following two simple rules.</span></span> <span data-ttu-id="5ab7d-112">Prima di tutto, non modificare mai un set di proprietà usando le interfacce di flusso o di archiviazione mentre un oggetto di archiviazione delle proprietà è aperto.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-112">First, never manipulate a property set using its stream or storage interfaces while a property storage object is open on it.</span></span> <span data-ttu-id="5ab7d-113">In secondo luogo, chiamare sempre **commit** su un oggetto di archiviazione della proprietà prima di chiamare **CopyTo**, **MoveElementTo** o **commit** su un oggetto di archiviazione predecessore.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-113">Second, always call **Commit** on a property storage object before calling **CopyTo**, **MoveElementTo**, or **Commit** on an ancestor storage object.</span></span> <span data-ttu-id="5ab7d-114">In particolare, per i seguenti elementi è richiesta l'attenzione del client:</span><span class="sxs-lookup"><span data-stu-id="5ab7d-114">Specifically, the following items require client attention:</span></span>

-   <span data-ttu-id="5ab7d-115">Nell'implementazione del file composto, un singolo meccanismo fornisce la protezione della concorrenza per l'oggetto di archiviazione e i relativi oggetti del set di proprietà associati.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-115">In the compound-file implementation, a single mechanism provides concurrency protection for the storage object and its associated property set objects.</span></span> <span data-ttu-id="5ab7d-116">Tuttavia, nell'implementazione autonoma, l'implementazione dell'oggetto di archiviazione è separata dall'implementazione del set di proprietà e ognuno fornisce i propri meccanismi di concorrenza.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-116">However, in the stand-alone implementation, the storage object implementation is separate from the property set implementation and each provides its own concurrency mechanisms.</span></span> <span data-ttu-id="5ab7d-117">Nell'implementazione autonoma, quindi, il client è responsabile della gestione della protezione della concorrenza tra le due implementazioni tramite un meccanismo di esclusione reciproca.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-117">Thus, in the stand-alone implementation, the client is responsible for maintaining concurrency protection between the two implementations through a mechanism of mutual exclusion.</span></span>
-   <span data-ttu-id="5ab7d-118">Nell'implementazione del file composto le modifiche apportate ai set di proprietà vengono memorizzate nel buffer in una cache di set di proprietà.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-118">In the compound file implementation, changes to property sets are buffered in a property-set cache.</span></span> <span data-ttu-id="5ab7d-119">Quindi, quando il metodo [**IStorage:: commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) viene chiamato sull'oggetto di archiviazione, l'implementazione dei file composti Scarica automaticamente le modifiche del set di proprietà dal buffer del set di proprietà prima del commit dell'oggetto di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-119">Then, when the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method is called on the storage object, the compound files implementation automatically flushes the property-set changes from the property-set buffer before the storage object is committed.</span></span> <span data-ttu-id="5ab7d-120">Pertanto, le modifiche apportate al set di proprietà vengono rese visibili come parte della transazione di cui viene eseguito il commit.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-120">Thus, the property-set changes are made visible as part of the transaction being committed.</span></span>

    <span data-ttu-id="5ab7d-121">Nell'implementazione autonoma, il client deve svuotare in modo esplicito il buffer del set di proprietà chiamando [**IPropertyStorage:: commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) prima di chiamare il metodo [**IStorage:: commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) sull'archiviazione.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-121">In the stand-alone implementation, the client must explicitly flush the property-set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method on the storage.</span></span> <span data-ttu-id="5ab7d-122">In alternativa, il client può utilizzare il nuovo \_ valore non memorizzato nel buffer di PROPSETFLAG nell'implementazione autonoma per scrivere direttamente nel set di proprietà anziché memorizzare nella cache le modifiche apportate al buffer interno del set di proprietà.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-122">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value in the stand-alone implementation to write directly to the property set instead of caching changes to the property set's internal buffer.</span></span> <span data-ttu-id="5ab7d-123">Se \_ viene usato PROPSETFLAG non memorizzato nel buffer, le responsabilità del client vengono soddisfatte automaticamente.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-123">If PROPSETFLAG\_UNBUFFERED is used, the client's responsibilities are automatically met.</span></span> <span data-ttu-id="5ab7d-124">L'implementazione del file composto non supporta il valore non memorizzato nel BUFFER di PROPSETFLAG \_ .</span><span class="sxs-lookup"><span data-stu-id="5ab7d-124">The compound file implementation does not support the PROPSETFLAG\_UNBUFFERED value.</span></span> <span data-ttu-id="5ab7d-125">Per altre informazioni, vedere [**costanti PROPSETFLAG**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="5ab7d-125">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

-   <span data-ttu-id="5ab7d-126">Come con le archiviazioni transazionali, l'implementazione del file composto aggiorna il set di proprietà scaricando il buffer interno prima di eseguire una chiamata a [**IStorage:: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) o [**IStorage:: MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="5ab7d-126">As with transacted storages, the compound file implementation updates the property set by flushing its internal buffer before executing a call to [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="5ab7d-127">Pertanto, le modifiche apportate al set di proprietà vengono riflesse nell'elemento di archiviazione copiato o spostato.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-127">Thus, changes to the property set are reflected in the copied or moved storage element.</span></span>

    <span data-ttu-id="5ab7d-128">Nell'implementazione autonoma, il client deve svuotare in modo esplicito il buffer del set di proprietà chiamando [**IPropertyStorage:: commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) prima di chiamare [**IStorage:: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) o [**IStorage:: MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="5ab7d-128">In the stand-alone implementation, the client must explicitly flush the property set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="5ab7d-129">In alternativa, il client può utilizzare il nuovo \_ valore non memorizzato nel buffer di PROPSETFLAG per scrivere direttamente nel set di proprietà anziché memorizzare nella cache le modifiche apportate al buffer del set di proprietà.</span><span class="sxs-lookup"><span data-stu-id="5ab7d-129">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value to write directly to the property set instead of caching changes to the property set buffer.</span></span> <span data-ttu-id="5ab7d-130">Per altre informazioni, vedere [**costanti PROPSETFLAG**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="5ab7d-130">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

 

 




