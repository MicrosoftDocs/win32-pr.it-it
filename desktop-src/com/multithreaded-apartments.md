---
title: Apartment con multithreading
description: Apartment con multithreading
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2020
ms.locfileid: "106300547"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="b6ec1-103">Apartment con multithreading</span><span class="sxs-lookup"><span data-stu-id="b6ec1-103">Multithreaded Apartments</span></span>

<span data-ttu-id="b6ec1-104">In un modello di Apartment a thread multipli tutti i thread del processo che sono stati inizializzati come a thread libero si trovano in un unico Apartment.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="b6ec1-105">Non è pertanto necessario effettuare il marshalling tra thread.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="b6ec1-106">I thread non devono recuperare e inviare messaggi perché COM non usa i messaggi di finestra in questo modello.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="b6ec1-107">Le chiamate a metodi di oggetti nell'Apartment con multithreading possono essere eseguite in qualsiasi thread dell'Apartment.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="b6ec1-108">Nessuna serializzazione delle chiamate; molte chiamate possono verificarsi contemporaneamente allo stesso metodo o allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="b6ec1-109">Gli oggetti creati nell'Apartment a thread multipli devono essere in grado di gestire le chiamate sui rispettivi metodi da altri thread in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="b6ec1-110">Poiché le chiamate agli oggetti non vengono serializzate in alcun modo, la concorrenza di oggetti multithreading offre le prestazioni più elevate e sfrutta al meglio l'hardware del multiprocessore per la chiamata cross-thread, tra processi e tra computer.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="b6ec1-111">Ciò significa, tuttavia, che il codice per gli oggetti deve fornire la sincronizzazione nelle implementazioni dell'interfaccia, in genere tramite l'uso di primitive di sincronizzazione, ad esempio oggetti evento, sezioni critiche, mutex o semafori, descritti più avanti in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="b6ec1-112">Inoltre, poiché l'oggetto non controlla la durata dei thread che vi accedono, non è possibile archiviare lo stato specifico del thread nell'oggetto (nell'archiviazione locale del thread).</span><span class="sxs-lookup"><span data-stu-id="b6ec1-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="b6ec1-113">Di seguito sono riportate alcune considerazioni importanti relative alla sincronizzazione per gli Apartment a thread multipli:</span><span class="sxs-lookup"><span data-stu-id="b6ec1-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="b6ec1-114">COM fornisce la sincronizzazione delle chiamate solo per gli Apartment a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="b6ec1-115">Gli Apartment con multithreading non ricevono chiamate durante l'esecuzione di chiamate (sullo stesso thread).</span><span class="sxs-lookup"><span data-stu-id="b6ec1-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="b6ec1-116">Gli apartment multithreading non possono eseguire chiamate sincronizzate in input.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="b6ec1-117">Le chiamate asincrone vengono convertite in chiamate sincrone in Apartment con multithreading.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="b6ec1-118">Il filtro messaggi non viene chiamato per alcun thread in un Apartment a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="b6ec1-119">Per inizializzare un thread come a thread libero, chiamare [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specificando CoInit \_ multithreading.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="b6ec1-120">Per informazioni sul threading del server in-process, vedere [problemi di threading del server in-process](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="b6ec1-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="b6ec1-121">Più client possono chiamare contemporaneamente, da thread diversi, un oggetto che supporta il threading libero.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="b6ec1-122">Nei server out-of-process a thread libero, COM, tramite il sottosistema RPC, crea un pool di thread nel processo server e una chiamata client (o più chiamate client) può essere recapitata da uno qualsiasi di questi thread in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="b6ec1-123">Un server out-of-process deve implementare anche la sincronizzazione nell'class factory.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="b6ec1-124">Gli oggetti in-process a thread libero possono ricevere chiamate dirette da più thread del client.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="b6ec1-125">Il client può eseguire operazioni COM in più thread.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="b6ec1-126">Tutti i thread appartengono allo stesso Apartment a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="b6ec1-127">I puntatori di interfaccia vengono passati direttamente dal thread al thread all'interno di un Apartment a thread multipli, quindi non viene eseguito il marshalling dei puntatori di interfaccia tra i thread.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="b6ec1-128">I filtri messaggi (implementazioni di [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) non vengono usati negli Apartment a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="b6ec1-129">Il thread client verrà sospeso quando effettuerà una chiamata COM a oggetti out-of-Apartment e riprenderà quando la chiamata restituirà.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="b6ec1-130">Le chiamate tra i processi sono ancora gestite da RPC.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="b6ec1-131">I thread inizializzati con il modello a thread libero devono implementare la propria sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="b6ec1-132">Come indicato in precedenza in questa sezione, Windows Abilita questa implementazione tramite le primitive di sincronizzazione seguenti:</span><span class="sxs-lookup"><span data-stu-id="b6ec1-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="b6ec1-133">Gli oggetti evento consentono di segnalare uno o più thread in cui si è verificato un evento.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="b6ec1-134">Qualsiasi thread all'interno di un processo può creare un oggetto evento.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="b6ec1-135">Un handle per l'evento viene restituito dalla funzione di creazione degli eventi, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span><span class="sxs-lookup"><span data-stu-id="b6ec1-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="b6ec1-136">Una volta creato un oggetto evento, i thread con un handle per l'oggetto possono attenderlo prima di continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="b6ec1-137">Le sezioni critiche vengono utilizzate per una sezione di codice che richiede l'accesso esclusivo a un set di dati condivisi prima che sia possibile eseguirlo e che venga utilizzato solo dai thread all'interno di un singolo processo.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="b6ec1-138">Una sezione critica è come un tornello attraverso il quale può trascorrere un solo thread alla volta, funzionando come segue:</span><span class="sxs-lookup"><span data-stu-id="b6ec1-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="b6ec1-139">Per assicurarsi che non più di un thread alla volta acceda ai dati condivisi, il thread primario di un processo alloca una struttura di \_ dati della sezione critica globale e inizializza i relativi membri.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="b6ec1-140">Un thread che entra in una sezione critica chiama la funzione [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) e modifica i membri della struttura di dati.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="b6ec1-141">Un thread che tenta di immettere una sezione critica chiama [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) che verifica se la \_ struttura dei dati della sezione critica è stata modificata.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="b6ec1-142">In tal caso, un altro thread si trova attualmente nella sezione critica e il thread successivo viene messo in stato di sospensione.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="b6ec1-143">Un thread che lascia una sezione critica chiama [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), che reimposta la struttura dei dati.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="b6ec1-144">Quando un thread lascia una sezione critica, il sistema riattiva uno dei thread in sospensione, che quindi immette la sezione critica.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="b6ec1-145">Mutex esegue la stessa funzione di una sezione critica, ad eccezione del fatto che il mutex è accessibile ai thread in esecuzione in processi diversi.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="b6ec1-146">Il proprietario di un oggetto mutex è simile a una discussione.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="b6ec1-147">Un processo crea un oggetto mutex chiamando la funzione [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) , che restituisce un handle.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="b6ec1-148">Il primo thread che richiede un oggetto Mutex ne ottiene la proprietà.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="b6ec1-149">Quando il thread è terminato con il mutex, la proprietà passa ad altri thread in base a una prima esecuzione, prima che venga servita.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="b6ec1-150">I semafori vengono usati per mantenere un conteggio dei riferimenti in alcune risorse disponibili.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="b6ec1-151">Un thread crea un semaforo per una risorsa chiamando la funzione [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) e passando un puntatore alla risorsa, un numero di risorse iniziale e il numero massimo di risorse.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="b6ec1-152">Questa funzione restituisce un handle.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-152">This function returns a handle.</span></span> <span data-ttu-id="b6ec1-153">Un thread che richiede una risorsa passa l'handle del semaforo in una chiamata alla funzione [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="b6ec1-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="b6ec1-154">L'oggetto semaforo esegue il polling della risorsa per stabilire se è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="b6ec1-155">In tal caso, il semaforo decrementa il conteggio delle risorse e riattiva il thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="b6ec1-156">Se il conteggio è pari a zero, il thread rimane in attesa fino a quando un altro thread non rilascia una risorsa, causando l'incremento del numero a uno del semaforo.</span><span class="sxs-lookup"><span data-stu-id="b6ec1-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b6ec1-157">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="b6ec1-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b6ec1-158">Accesso alle interfacce tra gli Apartment</span><span class="sxs-lookup"><span data-stu-id="b6ec1-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="b6ec1-159">Scelta del modello di threading</span><span class="sxs-lookup"><span data-stu-id="b6ec1-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="b6ec1-160">Problemi di threading del server in-process</span><span class="sxs-lookup"><span data-stu-id="b6ec1-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="b6ec1-161">Processi, thread e Apartment</span><span class="sxs-lookup"><span data-stu-id="b6ec1-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="b6ec1-162">Comunicazione a thread singolo e multithreading</span><span class="sxs-lookup"><span data-stu-id="b6ec1-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="b6ec1-163">Apartment a thread singolo</span><span class="sxs-lookup"><span data-stu-id="b6ec1-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 