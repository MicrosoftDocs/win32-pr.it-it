---
title: Regole per la gestione dei conteggi dei riferimenti
description: L'utilizzo di un conteggio dei riferimenti per gestire la durata di un oggetto consente a più client di ottenere e rilasciare l'accesso a un singolo oggetto senza dover coordinarsi tra loro per gestire la durata dell'oggetto.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2020
ms.locfileid: "104399754"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="c78d1-103">Regole per la gestione dei conteggi dei riferimenti</span><span class="sxs-lookup"><span data-stu-id="c78d1-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="c78d1-104">L'utilizzo di un conteggio dei riferimenti per gestire la durata di un oggetto consente a più client di ottenere e rilasciare l'accesso a un singolo oggetto senza dover coordinarsi tra loro per gestire la durata dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="c78d1-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="c78d1-105">Finché l'oggetto client è conforme a determinate regole d'uso, l'oggetto, in effetti, fornisce tale gestione.</span><span class="sxs-lookup"><span data-stu-id="c78d1-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="c78d1-106">Queste regole specificano come gestire i riferimenti tra oggetti.</span><span class="sxs-lookup"><span data-stu-id="c78d1-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="c78d1-107">(COM non specifica implementazioni interne di oggetti, anche se queste regole rappresentano un punto di partenza ragionevole per un criterio all'interno di un oggetto).</span><span class="sxs-lookup"><span data-stu-id="c78d1-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="c78d1-108">Concettualmente, i puntatori all'interfaccia possono essere considerati come risiedono all'interno di variabili puntatore che includono tutto lo stato di calcolo interno che contiene un puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="c78d1-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="c78d1-109">Sono incluse le variabili in posizioni di memoria, i registri interni del processore e le variabili generate dal programmatore e generate dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="c78d1-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="c78d1-110">L'assegnazione o l'inizializzazione di una variabile puntatore implica la creazione di una nuova copia di un puntatore già esistente.</span><span class="sxs-lookup"><span data-stu-id="c78d1-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="c78d1-111">Dove era presente una copia del puntatore in una variabile (il valore usato nell'assegnazione/inizializzazione), ora sono due.</span><span class="sxs-lookup"><span data-stu-id="c78d1-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="c78d1-112">Un'assegnazione a una variabile puntatore Elimina la copia del puntatore attualmente nella variabile, così come la distruzione della variabile stessa.</span><span class="sxs-lookup"><span data-stu-id="c78d1-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="c78d1-113">Ovvero, l'ambito in cui viene trovata la variabile, ad esempio il stack frame, viene eliminato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="c78d1-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="c78d1-114">Dal punto di vista del client COM, il conteggio dei riferimenti viene sempre eseguito per ogni interfaccia.</span><span class="sxs-lookup"><span data-stu-id="c78d1-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="c78d1-115">I client non devono mai presupporre che un oggetto usi lo stesso contatore per tutte le interfacce.</span><span class="sxs-lookup"><span data-stu-id="c78d1-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="c78d1-116">Il caso predefinito è che [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) deve essere chiamato per ogni nuova copia di un puntatore a interfaccia e la [**versione**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) deve essere chiamata per ogni eliminazione di un puntatore a interfaccia, tranne nel caso in cui le regole seguenti consentano altrimenti:</span><span class="sxs-lookup"><span data-stu-id="c78d1-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="c78d1-117">**Parametri in uscita per le funzioni.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="c78d1-118">Il chiamante deve chiamare [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) sul parametro perché verrà rilasciato (con una chiamata a [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) nel codice di implementazione quando il valore out viene archiviato al suo interno.</span><span class="sxs-lookup"><span data-stu-id="c78d1-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="c78d1-119">**Recupero di una variabile globale.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-119">**Fetching a global variable.**</span></span> <span data-ttu-id="c78d1-120">Quando si crea una copia locale di un puntatore a interfaccia da una copia esistente del puntatore in una variabile globale, è necessario chiamare [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) sulla copia locale perché un'altra funzione potrebbe eliminare la copia nella variabile globale mentre la copia locale è ancora valida.</span><span class="sxs-lookup"><span data-stu-id="c78d1-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="c78d1-121">**I nuovi puntatori sintetizzano una "aria sottile".**</span><span class="sxs-lookup"><span data-stu-id="c78d1-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="c78d1-122">Una funzione che sintetizza un puntatore di interfaccia usando una conoscenza interna speciale anziché ottenerla da un'altra origine deve chiamare [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) inizialmente sul puntatore appena sintetizzato.</span><span class="sxs-lookup"><span data-stu-id="c78d1-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="c78d1-123">Esempi importanti di tali routine includono routine di creazione di istanze, implementazioni di [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))e così via.</span><span class="sxs-lookup"><span data-stu-id="c78d1-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="c78d1-124">**Recupero di una copia di un puntatore archiviato internamente.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="c78d1-125">Quando una funzione recupera una copia di un puntatore archiviato internamente dall'oggetto chiamato, il codice dell'oggetto deve chiamare [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) sul puntatore prima che la funzione restituisca.</span><span class="sxs-lookup"><span data-stu-id="c78d1-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="c78d1-126">Una volta recuperato il puntatore, l'oggetto di origine non è in grado di determinare il modo in cui la sua durata è correlata a quella della copia interna del puntatore.</span><span class="sxs-lookup"><span data-stu-id="c78d1-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="c78d1-127">Per le uniche eccezioni al caso predefinito è necessario che il codice di gestione conosca le relazioni delle durate di due o più copie di un puntatore alla stessa interfaccia di un oggetto e assicuri semplicemente che l'oggetto non venga eliminato definitivamente consentendo al conteggio dei riferimenti di andare a zero.</span><span class="sxs-lookup"><span data-stu-id="c78d1-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="c78d1-128">Esistono in genere due casi, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="c78d1-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="c78d1-129">Quando una copia di un puntatore esiste già e un secondo viene creato successivamente e viene eliminato definitivamente mentre la prima copia esiste ancora, le chiamate a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)per la seconda copia possono essere omesse.</span><span class="sxs-lookup"><span data-stu-id="c78d1-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="c78d1-130">Quando una copia di un puntatore esiste e viene creato un secondo e il primo viene eliminato definitivamente prima del secondo, le chiamate a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)per la seconda copia e al [**rilascio**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) per la prima copia possono essere omesse.</span><span class="sxs-lookup"><span data-stu-id="c78d1-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="c78d1-131">Di seguito sono riportati alcuni esempi specifici di queste situazioni, le prime due sono particolarmente comuni:</span><span class="sxs-lookup"><span data-stu-id="c78d1-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="c78d1-132">**In parametri per le funzioni.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-132">**In parameters to functions.**</span></span> <span data-ttu-id="c78d1-133">Il ciclo di vita della copia di un puntatore a interfaccia passato come parametro a una funzione è annidato in quello del puntatore utilizzato per inizializzare il valore, pertanto non è necessario un conteggio dei riferimenti separato sul parametro.</span><span class="sxs-lookup"><span data-stu-id="c78d1-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="c78d1-134">**Parametri out da funzioni, inclusi i valori restituiti.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="c78d1-135">Per impostare il parametro out, è necessario che la funzione disponga di una copia stabile del puntatore a interfaccia.</span><span class="sxs-lookup"><span data-stu-id="c78d1-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="c78d1-136">Al ritorno, il chiamante è responsabile del rilascio del puntatore.</span><span class="sxs-lookup"><span data-stu-id="c78d1-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="c78d1-137">Il parametro out non necessita pertanto di un conteggio dei riferimenti separato.</span><span class="sxs-lookup"><span data-stu-id="c78d1-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="c78d1-138">**Variabili locali.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-138">**Local variables.**</span></span> <span data-ttu-id="c78d1-139">Un'implementazione del metodo ha il controllo delle durate di ogni variabile del puntatore allocata nel stack frame e può usarla per determinare come omettere le coppie di versioni [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)ridondanti / [](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) .</span><span class="sxs-lookup"><span data-stu-id="c78d1-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="c78d1-140">**Puntatori.**</span><span class="sxs-lookup"><span data-stu-id="c78d1-140">**Backpointers.**</span></span> <span data-ttu-id="c78d1-141">Alcune strutture di dati contengono due oggetti, ognuno con un puntatore all'altro.</span><span class="sxs-lookup"><span data-stu-id="c78d1-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="c78d1-142">Se la durata del primo oggetto è nota per contenere la durata del secondo, non è necessario disporre di un conteggio dei riferimenti sul puntatore del secondo oggetto al primo oggetto.</span><span class="sxs-lookup"><span data-stu-id="c78d1-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="c78d1-143">Spesso, evitando questo ciclo è importante mantenere il comportamento di deallocazione appropriato.</span><span class="sxs-lookup"><span data-stu-id="c78d1-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="c78d1-144">Tuttavia, i puntatori non conteggiati devono essere usati con estrema cautela perché la parte del sistema operativo che gestisce l'elaborazione remota non è in grado di conoscere questa relazione.</span><span class="sxs-lookup"><span data-stu-id="c78d1-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="c78d1-145">Pertanto, in quasi tutti i casi, la soluzione preferita è rappresentata dal fatto che il backpointer Visualizza un secondo oggetto "Friend" del primo puntatore (evitando così la circolare).</span><span class="sxs-lookup"><span data-stu-id="c78d1-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="c78d1-146">L'architettura degli oggetti collegabili di COM, ad esempio, usa questo approccio.</span><span class="sxs-lookup"><span data-stu-id="c78d1-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="c78d1-147">Quando si implementano o si usano oggetti con conteggio dei riferimenti, può essere utile applicare *conteggi dei riferimenti artificiali*, che garantiscono la stabilità degli oggetti durante l'elaborazione di una funzione.</span><span class="sxs-lookup"><span data-stu-id="c78d1-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="c78d1-148">Quando si implementa un metodo di un'interfaccia, è possibile chiamare le funzioni che hanno la possibilità di decrementare il conteggio dei riferimenti a un oggetto, causando una versione prematura dell'oggetto e l'errore dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="c78d1-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="c78d1-149">Un modo efficace per evitare questo problema consiste nell'inserire una chiamata a [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) all'inizio dell'implementazione del metodo e associarla a una chiamata a [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) immediatamente prima della restituzione del metodo.</span><span class="sxs-lookup"><span data-stu-id="c78d1-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="c78d1-150">In alcune situazioni, i valori restituiti di [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) possono risultare instabili e non devono essere basati su di essi. devono essere utilizzati solo a scopo di debug o di diagnostica.</span><span class="sxs-lookup"><span data-stu-id="c78d1-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="c78d1-151">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="c78d1-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="c78d1-152">Gestione della durata degli oggetti tramite il conteggio dei riferimenti</span><span class="sxs-lookup"><span data-stu-id="c78d1-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 