---
title: Comunicazione Inter-Object
description: COM è progettato per consentire ai client di comunicare in modo trasparente con gli oggetti, indipendentemente dalla posizione in cui tali oggetti vengono eseguiti nello stesso processo, nello stesso computer o in un computer diverso.
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9356ba2bcb9dd3a6a56ac16c354f3abcb752d717
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2020
ms.locfileid: "104118495"
---
# <a name="inter-object-communication"></a><span data-ttu-id="4fce7-103">Comunicazione Inter-Object</span><span class="sxs-lookup"><span data-stu-id="4fce7-103">Inter-Object Communication</span></span>

<span data-ttu-id="4fce7-104">COM è progettato per consentire ai client di comunicare in modo trasparente con gli oggetti, indipendentemente dalla posizione in cui si trovano gli oggetti runningÂ nello stesso processo, nello stesso computer o in un computer diverso.</span><span class="sxs-lookup"><span data-stu-id="4fce7-104">COM is designed to allow clients to communicate transparently with objects, regardless of where those objects are runningâ€”in the same process, on the same computer, or on a different computer.</span></span> <span data-ttu-id="4fce7-105">In questo modo viene fornito un unico modello di programmazione per tutti i tipi di oggetti e per i client oggetto e i server oggetti.</span><span class="sxs-lookup"><span data-stu-id="4fce7-105">This provides a single programming model for all types of objects, and for both object clients and object servers.</span></span>

<span data-ttu-id="4fce7-106">Dal punto di vista di un client, è possibile accedere a tutti gli oggetti tramite puntatori di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4fce7-106">From a client's point of view, all objects are accessed through interface pointers.</span></span> <span data-ttu-id="4fce7-107">Un puntatore deve essere in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-107">A pointer must be in-process.</span></span> <span data-ttu-id="4fce7-108">In realtà, qualsiasi chiamata a una funzione di interfaccia raggiunge sempre parte del codice in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-108">In fact, any call to an interface function always reaches some piece of in-process code first.</span></span> <span data-ttu-id="4fce7-109">Se l'oggetto è in-process, la chiamata lo raggiunge direttamente, senza il codice dell'infrastruttura di sistema corrispondente.</span><span class="sxs-lookup"><span data-stu-id="4fce7-109">If the object is in-process, the call reaches it directly, with no intervening system-infrastructure code.</span></span> <span data-ttu-id="4fce7-110">Se l'oggetto è out-of-process, la chiamata raggiunge prima di tutto un oggetto "proxy" fornito da COM o dall'oggetto (se l'implementatore vuole).</span><span class="sxs-lookup"><span data-stu-id="4fce7-110">If the object is out-of-process, the call first reaches what is called a "proxy" object provided either by COM or by the object (if the implementor wishes).</span></span> <span data-ttu-id="4fce7-111">I pacchetti proxy chiamano parametri (inclusi tutti i puntatori di interfaccia) e generano la chiamata di procedura remota appropriata (o un altro meccanismo di comunicazione nel caso di proxy generati personalizzati) per l'altro processo o per l'altro computer in cui si trova l'implementazione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="4fce7-111">The proxy packages call parameters (including any interface pointers) and generate the appropriate remote procedure call (or other communication mechanism in the case of custom generated proxies) to the other process or the other computer where the object implementation is located.</span></span> <span data-ttu-id="4fce7-112">Questo processo di creazione di pacchetti di puntatori per la trasmissione tra i limiti del processo viene chiamato *marshalling*.</span><span class="sxs-lookup"><span data-stu-id="4fce7-112">This process of packaging pointers for transmission across process boundaries is called *marshaling*.</span></span>

<span data-ttu-id="4fce7-113">Dal punto di vista di un server, tutte le chiamate alle funzioni di interfaccia di un oggetto vengono eseguite tramite un puntatore a tale interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4fce7-113">From a server's point of view, all calls to an object's interface functions are made through a pointer to that interface.</span></span> <span data-ttu-id="4fce7-114">Anche in questo caso, un puntatore ha un contesto solo in un singolo processo e il chiamante deve essere sempre parte del codice in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-114">Again, a pointer has context only in a single process, and the caller must always be some piece of in-process code.</span></span> <span data-ttu-id="4fce7-115">Se l'oggetto è in-process, il chiamante è il client stesso.</span><span class="sxs-lookup"><span data-stu-id="4fce7-115">If the object is in-process, the caller is the client itself.</span></span> <span data-ttu-id="4fce7-116">In caso contrario, il chiamante è un oggetto "Stub" fornito da COM o dall'oggetto stesso.</span><span class="sxs-lookup"><span data-stu-id="4fce7-116">Otherwise, the caller is a "stub" object provided either by COM or by the object itself.</span></span> <span data-ttu-id="4fce7-117">Lo stub riceve la chiamata di procedura remota (o un altro meccanismo di comunicazione nel caso di proxy generati personalizzati) dal "proxy" nel processo client, effettua il marshalling dei parametri e chiama l'interfaccia appropriata nell'oggetto server.</span><span class="sxs-lookup"><span data-stu-id="4fce7-117">The stub receives the remote procedure call (or other communication mechanism in the case of custom generated proxies) from the "proxy" in the client process, unmarshals the parameters, and calls the appropriate interface on the server object.</span></span> <span data-ttu-id="4fce7-118">Dal punto di vista dei client e dei server, comunicano sempre direttamente con un altro codice in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-118">From the points of view of both clients and servers, they always communicate directly with some other in-process code.</span></span>

<span data-ttu-id="4fce7-119">COM fornisce un'implementazione del marshalling, definita *marshalling standard*.</span><span class="sxs-lookup"><span data-stu-id="4fce7-119">COM provides an implementation of marshaling, referred to as *standard marshaling*.</span></span> <span data-ttu-id="4fce7-120">Questa implementazione funziona molto bene per la maggior parte degli oggetti e riduce notevolmente i requisiti di programmazione, rendendo effettivamente trasparente il processo di marshalling.</span><span class="sxs-lookup"><span data-stu-id="4fce7-120">This implementation works very well for most objects and greatly reduces programming requirements, making the marshaling process effectively transparent.</span></span>

<span data-ttu-id="4fce7-121">La netta separazione dell'interfaccia dall'implementazione della trasparenza del processo COM può, tuttavia, arrivare in alcune situazioni.</span><span class="sxs-lookup"><span data-stu-id="4fce7-121">The clear separation of interface from implementation of COM's process transparency can, however, get in the way in some situations.</span></span> <span data-ttu-id="4fce7-122">La progettazione di un'interfaccia incentrata sulla propria funzione dal punto di vista del client può a volte causare decisioni di progettazione in conflitto con un'implementazione efficiente di tale interfaccia in una rete.</span><span class="sxs-lookup"><span data-stu-id="4fce7-122">The design of an interface that focuses on its function from the client's point of view can sometimes lead to design decisions that conflict with efficient implementation of that interface across a network.</span></span> <span data-ttu-id="4fce7-123">In casi come questo, ciò che è necessario non è la trasparenza dei processi puri, ma la trasparenza dei processi, a meno che non sia necessario preoccuparsi ".</span><span class="sxs-lookup"><span data-stu-id="4fce7-123">In cases like this, what is needed is not pure process transparency but "process transparency, unless you need to care."</span></span> <span data-ttu-id="4fce7-124">COM offre questa funzionalità consentendo a un implementatore di oggetti di supportare il *marshalling personalizzato* (chiamato anche marshalling [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) ).</span><span class="sxs-lookup"><span data-stu-id="4fce7-124">COM provides this capability by allowing an object implementor to support *custom marshaling* (also called [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) marshaling).</span></span> <span data-ttu-id="4fce7-125">Il marshalling standard è in realtà un'istanza del marshalling personalizzato; si tratta dell'implementazione predefinita utilizzata quando un oggetto non richiede il marshalling personalizzato.</span><span class="sxs-lookup"><span data-stu-id="4fce7-125">Standard marshaling is, in fact, an instance of custom marshaling; it is the default implementation used when an object does not require custom marshaling.</span></span>

<span data-ttu-id="4fce7-126">È possibile implementare il marshalling personalizzato per consentire a un oggetto di eseguire azioni diverse in caso di utilizzo in una rete rispetto a quanto richiesto dall'accesso locale ed è completamente trasparente per il client.</span><span class="sxs-lookup"><span data-stu-id="4fce7-126">You can implement custom marshaling to allow an object to take different actions when used from across a network than it takes under local access and it is completely transparent to the client.</span></span> <span data-ttu-id="4fce7-127">Questa architettura consente di progettare interfacce client/oggetto senza considerare problemi di prestazioni di rete e successivamente di risolvere i problemi relativi alle prestazioni di rete senza compromettere la progettazione stabilita.</span><span class="sxs-lookup"><span data-stu-id="4fce7-127">This architecture makes it possible to design client/object interfaces without regard to network performance issues and then later to address network performance issues without disrupting the established design.</span></span>

<span data-ttu-id="4fce7-128">COM non specifica come sono strutturati i componenti. Specifica la modalità di interazione.</span><span class="sxs-lookup"><span data-stu-id="4fce7-128">COM does not specify how components are structured; it specifies how they interact.</span></span> <span data-ttu-id="4fce7-129">COM lascia la preoccupazione sulla struttura interna di un componente per i linguaggi di programmazione e gli ambienti di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="4fce7-129">COM leaves the concern about the internal structure of a component to programming languages and development environments.</span></span> <span data-ttu-id="4fce7-130">Viceversa, gli ambienti di programmazione non hanno standard impostati per l'utilizzo di oggetti all'esterno dell'applicazione immediata.</span><span class="sxs-lookup"><span data-stu-id="4fce7-130">Conversely, programming environments have no set standards for working with objects outside of the immediate application.</span></span> <span data-ttu-id="4fce7-131">Microsoft Visual C++, ad esempio, funziona molto bene per la manipolazione di oggetti all'interno di un'applicazione, ma non supporta l'utilizzo di oggetti all'esterno dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="4fce7-131">Microsoft Visual C++, for example, works extremely well for manipulating objects inside an application but has no support for working with objects outside the application.</span></span> <span data-ttu-id="4fce7-132">In genere, tutti gli altri linguaggi di programmazione sono gli stessi in questo senso.</span><span class="sxs-lookup"><span data-stu-id="4fce7-132">Generally, all other programming languages are the same in this regard.</span></span> <span data-ttu-id="4fce7-133">Pertanto, per garantire l'interoperabilità networkwide, COM, tramite interfacce indipendenti dal linguaggio, preleva i linguaggi di programmazione.</span><span class="sxs-lookup"><span data-stu-id="4fce7-133">Therefore, to provide networkwide interoperability, COM, through language-independent interfaces, picks up where programming languages leave off.</span></span>

<span data-ttu-id="4fce7-134">Il doppio riferimento indiretto della struttura VTBL significa che i puntatori della tabella dei puntatori a funzione non devono puntare direttamente all'implementazione reale nell'oggetto reale.</span><span class="sxs-lookup"><span data-stu-id="4fce7-134">The double indirection of the vtbl structure means that the pointers in the table of function pointers do not need to point directly to the real implementation in the real object.</span></span> <span data-ttu-id="4fce7-135">Questo è il fulcro della trasparenza dei processi.</span><span class="sxs-lookup"><span data-stu-id="4fce7-135">This is the heart of process transparency.</span></span>

<span data-ttu-id="4fce7-136">Per i server in-process, in cui l'oggetto viene caricato direttamente nel processo client, i puntatori a funzione nella tabella puntano direttamente all'implementazione effettiva.</span><span class="sxs-lookup"><span data-stu-id="4fce7-136">For in-process servers, where the object is loaded directly into the client process, the function pointers in the table point directly to the actual implementation.</span></span> <span data-ttu-id="4fce7-137">In questo caso, una chiamata di funzione dal client a un metodo di interfaccia trasferisce direttamente il controllo di esecuzione al metodo.</span><span class="sxs-lookup"><span data-stu-id="4fce7-137">In this case, a function call from the client to an interface method directly transfers execution control to the method.</span></span> <span data-ttu-id="4fce7-138">Tuttavia, questa operazione non può essere eseguita per gli oggetti remoti locali, lasciati da soli, perché i puntatori alla memoria non possono essere condivisi tra i processi.</span><span class="sxs-lookup"><span data-stu-id="4fce7-138">However, this cannot work for local, let alone remote, objects because pointers to memory cannot be shared between processes.</span></span> <span data-ttu-id="4fce7-139">Tuttavia, il client deve essere in grado di chiamare i metodi di interfaccia come se stesse chiamando l'implementazione effettiva.</span><span class="sxs-lookup"><span data-stu-id="4fce7-139">Nevertheless, the client must be able to call interface methods as if it were calling the actual implementation.</span></span> <span data-ttu-id="4fce7-140">Il client trasferisce in modo uniforme il controllo a un metodo in un oggetto eseguendo la chiamata.</span><span class="sxs-lookup"><span data-stu-id="4fce7-140">Thus, the client uniformly transfers control to a method in some object by making the call.</span></span>

<span data-ttu-id="4fce7-141">Un client chiama sempre i metodi dell'interfaccia in un oggetto in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-141">A client always calls interface methods in some in-process object.</span></span> <span data-ttu-id="4fce7-142">Se l'oggetto effettivo è locale o remoto, la chiamata viene effettuata a un oggetto proxy, che esegue quindi una chiamata di procedura remota all'oggetto effettivo.</span><span class="sxs-lookup"><span data-stu-id="4fce7-142">If the actual object is local or remote, the call is made to a proxy object, which then makes a remote procedure call to the actual object.</span></span>

<span data-ttu-id="4fce7-143">Quale metodo viene effettivamente eseguito?</span><span class="sxs-lookup"><span data-stu-id="4fce7-143">So what method is actually executed?</span></span> <span data-ttu-id="4fce7-144">La risposta è che ogni volta che viene eseguita una chiamata a un'interfaccia out-of-process, ogni metodo di interfaccia viene implementato da un oggetto proxy.</span><span class="sxs-lookup"><span data-stu-id="4fce7-144">The answer is that whenever there is a call to an out-of-process interface, each interface method is implemented by a proxy object.</span></span> <span data-ttu-id="4fce7-145">L'oggetto proxy è sempre un oggetto in-process che agisce per conto dell'oggetto chiamato.</span><span class="sxs-lookup"><span data-stu-id="4fce7-145">The proxy object is always an in-process object that acts on behalf of the object being called.</span></span> <span data-ttu-id="4fce7-146">Questo oggetto proxy sa che l'oggetto effettivo è in esecuzione in un server locale o remoto.</span><span class="sxs-lookup"><span data-stu-id="4fce7-146">This proxy object knows that the actual object is running in a local or remote server.</span></span>

<span data-ttu-id="4fce7-147">L'oggetto proxy impacchetta i parametri della funzione in alcuni pacchetti di dati e genera una chiamata RPC all'oggetto locale o remoto.</span><span class="sxs-lookup"><span data-stu-id="4fce7-147">The proxy object packages up the function parameters in some data packets and generates an RPC call to the local or remote object.</span></span> <span data-ttu-id="4fce7-148">Tale pacchetto viene prelevato da un oggetto stub nel processo del server nel computer locale o in un computer remoto, che decomprime i parametri ed effettua la chiamata all'implementazione reale del metodo.</span><span class="sxs-lookup"><span data-stu-id="4fce7-148">That packet is picked up by a stub object in the server's process on the local or a remote computer, which unpacks the parameters and makes the call to the real implementation of the method.</span></span> <span data-ttu-id="4fce7-149">Quando la funzione restituisce, lo stub crea il pacchetto di tutti i parametri out e il valore restituito e li invia al proxy, che li decomprime e li restituisce al client originale.</span><span class="sxs-lookup"><span data-stu-id="4fce7-149">When that function returns, the stub packages up any out-parameters and the return value and sends it back to the proxy, which unpacks them and returns them to the original client.</span></span>

<span data-ttu-id="4fce7-150">Il client e il server, quindi, comunicano sempre tra loro come se fossero tutti in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-150">Thus, client and server always talk to each other as if everything was in-process.</span></span> <span data-ttu-id="4fce7-151">Tutte le chiamate dal client e tutte le chiamate al server sono, a un certo punto, in-process.</span><span class="sxs-lookup"><span data-stu-id="4fce7-151">All calls from the client and all calls to the server are, at some point, in-process.</span></span> <span data-ttu-id="4fce7-152">Tuttavia, poiché la struttura VTBL consente ad alcuni agenti, come COM, di intercettare tutte le chiamate di funzione e tutti i ritorni dalle funzioni, l'agente può reindirizzare tali chiamate a una chiamata RPC, se necessario.</span><span class="sxs-lookup"><span data-stu-id="4fce7-152">But because the vtbl structure allows some agent, like COM, to intercept all function calls and all returns from functions, that agent can redirect those calls to an RPC call as necessary.</span></span> <span data-ttu-id="4fce7-153">Sebbene le chiamate in-process siano più veloci rispetto alle chiamate out-of-process, le differenze del processo sono completamente trasparenti per il client e il server.</span><span class="sxs-lookup"><span data-stu-id="4fce7-153">Although in-process calls are faster than out-of-process calls, the process differences are completely transparent to the client and server.</span></span>

<span data-ttu-id="4fce7-154">Per altre informazioni, vedere i seguenti argomenti:</span><span class="sxs-lookup"><span data-stu-id="4fce7-154">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="4fce7-155">Dettagli del marshalling</span><span class="sxs-lookup"><span data-stu-id="4fce7-155">Marshaling Details</span></span>](marshaling-details.md)
-   [<span data-ttu-id="4fce7-156">Proxy</span><span class="sxs-lookup"><span data-stu-id="4fce7-156">Proxy</span></span>](proxy.md)
-   [<span data-ttu-id="4fce7-157">Stub</span><span class="sxs-lookup"><span data-stu-id="4fce7-157">Stub</span></span>](stub.md)
-   [<span data-ttu-id="4fce7-158">Channel</span><span class="sxs-lookup"><span data-stu-id="4fce7-158">Channel</span></span>](channel.md)
-   [<span data-ttu-id="4fce7-159">RPC Microsoft</span><span class="sxs-lookup"><span data-stu-id="4fce7-159">Microsoft RPC</span></span>](microsoft-rpc.md)

## <a name="related-topics"></a><span data-ttu-id="4fce7-160">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="4fce7-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4fce7-161">Client e server COM</span><span class="sxs-lookup"><span data-stu-id="4fce7-161">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="4fce7-162">Marshalling dell'interfaccia</span><span class="sxs-lookup"><span data-stu-id="4fce7-162">Interface Marshaling</span></span>](interface-marshaling.md)
</dt> </dl>

 

 