---
title: Single-Threaded Apartment
description: Single-Threaded Apartment
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2020
ms.locfileid: "104399761"
---
# <a name="single-threaded-apartments"></a><span data-ttu-id="08aaa-103">Single-Threaded Apartment</span><span class="sxs-lookup"><span data-stu-id="08aaa-103">Single-Threaded Apartments</span></span>

<span data-ttu-id="08aaa-104">L'uso di Apartment a thread singolo (il processo del modello di Apartment) offre un paradigma basato su messaggi per la gestione simultanea di più oggetti.</span><span class="sxs-lookup"><span data-stu-id="08aaa-104">Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently.</span></span> <span data-ttu-id="08aaa-105">Consente di scrivere codice più efficiente consentendo a un thread di attendere il completamento di un'operazione che richiede molto tempo, per consentire l'esecuzione di un altro thread.</span><span class="sxs-lookup"><span data-stu-id="08aaa-105">It enables you to write more efficient code by allowing a thread, while it waits for some time-consuming operation to complete, to allow another thread to be executed.</span></span>

<span data-ttu-id="08aaa-106">Ogni thread in un processo inizializzato come processo del modello di Apartment e che recupera e invia messaggi della finestra è un thread apartment a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="08aaa-106">Each thread in a process that is initialized as an apartment model process, and that retrieves and dispatches window messages, is a single-threaded apartment thread.</span></span> <span data-ttu-id="08aaa-107">Ogni thread risiede all'interno del proprio Apartment.</span><span class="sxs-lookup"><span data-stu-id="08aaa-107">Each thread lives within its own apartment.</span></span> <span data-ttu-id="08aaa-108">All'interno di un Apartment, i puntatori all'interfaccia possono essere passati senza marshalling e, di conseguenza, tutti gli oggetti in un thread apartment a thread singolo comunicano direttamente.</span><span class="sxs-lookup"><span data-stu-id="08aaa-108">Within an apartment, interface pointers can be passed without marshaling, and therefore, all objects in one single-threaded apartment thread communicate directly.</span></span>

<span data-ttu-id="08aaa-109">Un raggruppamento logico di oggetti correlati che tutti vengono eseguiti sullo stesso thread e pertanto deve avere un'esecuzione sincrona può risiedere nello stesso thread apartment a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="08aaa-109">A logical grouping of related objects that all execute on the same thread, and therefore must have synchronous execution, could live on the same single-threaded apartment thread.</span></span> <span data-ttu-id="08aaa-110">Tuttavia, un oggetto modello di Apartment non può trovarsi in più di un thread.</span><span class="sxs-lookup"><span data-stu-id="08aaa-110">However, an apartment model object cannot reside on more than one thread.</span></span> <span data-ttu-id="08aaa-111">Le chiamate a oggetti in altri thread devono essere effettuate all'interno del contesto del thread proprietario, in modo che i commutatori COM distribuiti automaticamente i thread quando si chiama su un proxy.</span><span class="sxs-lookup"><span data-stu-id="08aaa-111">Calls to objects in other threads must be made within the context of the owning thread, so distributed COM switches threads for you automatically when you call on a proxy.</span></span>

<span data-ttu-id="08aaa-112">I modelli interprocesso e interthreading sono simili.</span><span class="sxs-lookup"><span data-stu-id="08aaa-112">The interprocess and interthread models are similar.</span></span> <span data-ttu-id="08aaa-113">Quando è necessario passare un puntatore di interfaccia a un oggetto in un altro Apartment (in un altro thread) nello stesso processo, si usa lo stesso modello di marshalling utilizzato dagli oggetti in processi diversi per passare i puntatori attraverso i limiti del processo.</span><span class="sxs-lookup"><span data-stu-id="08aaa-113">When it is necessary to pass an interface pointer to an object in another apartment (on another thread) within the same process, you use the same marshaling model that objects in different processes use to pass pointers across process boundaries.</span></span> <span data-ttu-id="08aaa-114">Ottenendo un puntatore all'oggetto di marshalling standard, è possibile effettuare il marshalling di puntatori di interfaccia tra i limiti dei thread (tra Apartment) nello stesso modo in cui si esegue tra i processi.</span><span class="sxs-lookup"><span data-stu-id="08aaa-114">By getting a pointer to the standard marshaling object, you can marshal interface pointers across thread boundaries (between apartments) in the same way you do between processes.</span></span> <span data-ttu-id="08aaa-115">(È necessario effettuare il marshalling di puntatori a interfaccia se passati tra Apartment).</span><span class="sxs-lookup"><span data-stu-id="08aaa-115">(Interface pointers must be marshaled when passed between apartments.)</span></span>

<span data-ttu-id="08aaa-116">Le regole per gli Apartment a thread singolo sono semplici, ma è importante seguirle attentamente:</span><span class="sxs-lookup"><span data-stu-id="08aaa-116">Rules for single-threaded apartments are simple, but it is important to follow them carefully:</span></span>

-   <span data-ttu-id="08aaa-117">Ogni oggetto deve risiedere su un solo thread (all'interno di un Apartment a thread singolo).</span><span class="sxs-lookup"><span data-stu-id="08aaa-117">Every object should live on only one thread (within a single-threaded apartment).</span></span>
-   <span data-ttu-id="08aaa-118">Inizializzare la libreria COM per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="08aaa-118">Initialize the COM library for each thread.</span></span>
-   <span data-ttu-id="08aaa-119">Eseguire il marshalling di tutti i puntatori a oggetti quando vengono passati tra Apartment.</span><span class="sxs-lookup"><span data-stu-id="08aaa-119">Marshal all pointers to objects when passing them between apartments.</span></span>
-   <span data-ttu-id="08aaa-120">Ogni Apartment a thread singolo deve disporre di un ciclo di messaggi per gestire le chiamate da altri processi e Apartment nello stesso processo.</span><span class="sxs-lookup"><span data-stu-id="08aaa-120">Each single-threaded apartment must have a message loop to handle calls from other processes and apartments within the same process.</span></span> <span data-ttu-id="08aaa-121">Gli Apartment a thread singolo senza oggetti (solo client) necessitano anche di un ciclo di messaggi per inviare i messaggi di trasmissione utilizzati da alcune applicazioni.</span><span class="sxs-lookup"><span data-stu-id="08aaa-121">Single-threaded apartments without objects (client only) also need a message loop to dispatch the broadcast messages that some applications use.</span></span>
-   <span data-ttu-id="08aaa-122">Gli oggetti basati su DLL o in-process non chiamano le funzioni di inizializzazione COM. al contrario, registrano il modello di threading con il valore denominato **ThreadingModel** sotto la chiave [InprocServer32](inprocserver32.md) nel registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="08aaa-122">DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the **ThreadingModel** named-value under the [InprocServer32](inprocserver32.md) key in the registry.</span></span> <span data-ttu-id="08aaa-123">Gli oggetti compatibili con l'Apartment devono anche scrivere attentamente i punti di ingresso della DLL.</span><span class="sxs-lookup"><span data-stu-id="08aaa-123">Apartment-aware objects must also write DLL entry points carefully.</span></span> <span data-ttu-id="08aaa-124">Esistono considerazioni speciali che si applicano al threading nei server in-process.</span><span class="sxs-lookup"><span data-stu-id="08aaa-124">There are special considerations that apply to threading in-process servers.</span></span> <span data-ttu-id="08aaa-125">Per ulteriori informazioni, vedere [problemi di threading del server in-process](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="08aaa-125">For more information, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="08aaa-126">Mentre più oggetti possono risiedere in un singolo thread, nessun oggetto modello di Apartment può risiedere in più di un thread.</span><span class="sxs-lookup"><span data-stu-id="08aaa-126">While multiple objects can live on a single thread, no apartment model object can live on more than one thread.</span></span>

<span data-ttu-id="08aaa-127">Ogni thread di un processo client o di un server out-of-process deve chiamare [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize)oppure chiamare [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) e specificare CoInit \_ ApartmentThreaded per il parametro *dwCoInit* .</span><span class="sxs-lookup"><span data-stu-id="08aaa-127">Each thread of a client process or out-of-process server must call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), or call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) and specify COINIT\_APARTMENTTHREADED for the *dwCoInit* parameter.</span></span> <span data-ttu-id="08aaa-128">L'Apartment principale è il thread che chiama prima **CoInitializeEx** .</span><span class="sxs-lookup"><span data-stu-id="08aaa-128">The main apartment is the thread that calls **CoInitializeEx** first.</span></span> <span data-ttu-id="08aaa-129">Per informazioni sui server in-process, vedere [problemi di threading del server in-process](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="08aaa-129">For information on in-process servers, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="08aaa-130">Tutte le chiamate a un oggetto devono essere effettuate sul relativo thread (all'interno dell'Apartment).</span><span class="sxs-lookup"><span data-stu-id="08aaa-130">All calls to an object must be made on its thread (within its apartment).</span></span> <span data-ttu-id="08aaa-131">Non è consentito chiamare un oggetto direttamente da un altro thread. l'uso di oggetti in questo modo a thread libero può causare problemi per le applicazioni.</span><span class="sxs-lookup"><span data-stu-id="08aaa-131">It is forbidden to call an object directly from another thread; using objects in this free-threaded manner could cause problems for applications.</span></span> <span data-ttu-id="08aaa-132">L'implicazione di questa regola è che tutti i puntatori agli oggetti devono essere sottoposti a marshalling quando passati tra Apartment.</span><span class="sxs-lookup"><span data-stu-id="08aaa-132">The implication of this rule is that all pointers to objects must be marshaled when passed between apartments.</span></span> <span data-ttu-id="08aaa-133">COM fornisce le due funzioni seguenti a questo scopo:</span><span class="sxs-lookup"><span data-stu-id="08aaa-133">COM provides the following two functions for this purpose:</span></span>

-   <span data-ttu-id="08aaa-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) esegue il marshalling di un'interfaccia in un oggetto flusso restituito al chiamante.</span><span class="sxs-lookup"><span data-stu-id="08aaa-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshals an interface into a stream object that is returned to the caller.</span></span>
-   <span data-ttu-id="08aaa-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) esegue l'unmarshalling di un puntatore a interfaccia da un oggetto flusso e lo rilascia.</span><span class="sxs-lookup"><span data-stu-id="08aaa-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) unmarshals an interface pointer from a stream object and releases it.</span></span>

<span data-ttu-id="08aaa-136">Queste funzioni incapsulano le chiamate alle funzioni [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) e [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) , che richiedono l'uso del \_ flag InProc di MSHCTX.</span><span class="sxs-lookup"><span data-stu-id="08aaa-136">These functions wrap calls to [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) and [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) functions, which require the use of the MSHCTX\_INPROC flag.</span></span>

<span data-ttu-id="08aaa-137">In generale, il marshalling viene eseguito automaticamente da COM.</span><span class="sxs-lookup"><span data-stu-id="08aaa-137">In general, the marshaling is accomplished automatically by COM.</span></span> <span data-ttu-id="08aaa-138">Ad esempio, quando si passa un puntatore di interfaccia come parametro in una chiamata al metodo su un proxy a un oggetto in un altro Apartment o quando si chiama [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), com esegue automaticamente il marshalling.</span><span class="sxs-lookup"><span data-stu-id="08aaa-138">For example, when passing an interface pointer as a parameter in a method call on a proxy to an object in another apartment, or when calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), COM does the marshaling automatically.</span></span> <span data-ttu-id="08aaa-139">Tuttavia, in alcuni casi particolari, in cui il writer dell'applicazione passa i puntatori di interfaccia tra gli Apartment senza usare i normali meccanismi COM, il writer deve gestire manualmente il marshalling.</span><span class="sxs-lookup"><span data-stu-id="08aaa-139">However, in some special cases, where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually.</span></span>

<span data-ttu-id="08aaa-140">Se un Apartment (Apartment 1) in un processo dispone di un puntatore a interfaccia e un altro Apartment (Apartment 2) ne richiede l'uso, l'Apartment 1 deve chiamare [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) per effettuare il marshalling dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="08aaa-140">If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) to marshal the interface.</span></span> <span data-ttu-id="08aaa-141">Il flusso creato da questa funzione è thread-safe e deve essere archiviato in una variabile accessibile dall'Apartment 2.</span><span class="sxs-lookup"><span data-stu-id="08aaa-141">The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2.</span></span> <span data-ttu-id="08aaa-142">L'Apartment 2 deve passare questo flusso a [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) per annullare il marshalling dell'interfaccia e ottenere un puntatore a un proxy tramite il quale può accedere all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="08aaa-142">Apartment 2 must pass this stream to [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) to unmarshal the interface and will get back a pointer to a proxy through which it can access the interface.</span></span> <span data-ttu-id="08aaa-143">L'Apartment principale deve rimanere attivo fino a quando il client non ha completato tutte le operazioni COM (poiché alcuni oggetti in-process vengono caricati nell'Apartment principale, come descritto in [problemi di threading del server in-process](in-process-server-threading-issues.md)).</span><span class="sxs-lookup"><span data-stu-id="08aaa-143">The main apartment must remain alive until the client has completed all COM work (because some in-process objects are loaded in the main apartment, as described in [In-Process Server Threading Issues](in-process-server-threading-issues.md)).</span></span> <span data-ttu-id="08aaa-144">Dopo che un oggetto è stato passato tra i thread in questo modo, è molto facile passare i puntatori all'interfaccia come parametri.</span><span class="sxs-lookup"><span data-stu-id="08aaa-144">After one object has been passed between threads in this manner, it is very easy to pass interface pointers as parameters.</span></span> <span data-ttu-id="08aaa-145">In questo modo, Distributed COM esegue il marshalling e il cambio di thread per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="08aaa-145">That way, distributed COM does the marshaling and thread switching for the application.</span></span>

<span data-ttu-id="08aaa-146">Per gestire le chiamate da altri processi e appartamenti nello stesso processo, ogni Apartment a thread singolo deve avere un ciclo di messaggi.</span><span class="sxs-lookup"><span data-stu-id="08aaa-146">To handle calls from other processes and apartments within the same process, each single-threaded apartment must have a message loop.</span></span> <span data-ttu-id="08aaa-147">Ciò significa che la funzione lavoro del thread deve avere un ciclo GetMessage/DispatchMessage.</span><span class="sxs-lookup"><span data-stu-id="08aaa-147">This means that the thread's work function must have a GetMessage/DispatchMessage loop.</span></span> <span data-ttu-id="08aaa-148">Se vengono utilizzate altre primitive di sincronizzazione per la comunicazione tra thread, è possibile usare la funzione [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) per attendere sia per i messaggi sia per gli eventi di sincronizzazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="08aaa-148">If other synchronization primitives are being used to communicate between threads, the [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) function can be used to wait both for messages and for thread synchronization events.</span></span> <span data-ttu-id="08aaa-149">La documentazione relativa a questa funzione presenta un esempio di questo tipo di ciclo combinato.</span><span class="sxs-lookup"><span data-stu-id="08aaa-149">The documentation for this function has an example of this sort of combination loop.</span></span>

<span data-ttu-id="08aaa-150">COM crea una finestra nascosta usando la classe Windows "OleMainThreadWndClass" in ogni Apartment a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="08aaa-150">COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment.</span></span> <span data-ttu-id="08aaa-151">Una chiamata a un oggetto viene ricevuta come messaggio di finestra in questa finestra nascosta.</span><span class="sxs-lookup"><span data-stu-id="08aaa-151">A call to an object is received as a window message to this hidden window.</span></span> <span data-ttu-id="08aaa-152">Quando l'Apartment dell'oggetto recupera e invia il messaggio, la finestra nascosta lo riceverà.</span><span class="sxs-lookup"><span data-stu-id="08aaa-152">When the object's apartment retrieves and dispatches the message, the hidden window will receive it.</span></span> <span data-ttu-id="08aaa-153">La routine della finestra chiamerà quindi il metodo di interfaccia corrispondente dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="08aaa-153">The window procedure will then call the corresponding interface method of the object.</span></span>

<span data-ttu-id="08aaa-154">Quando più client chiamano un oggetto, le chiamate vengono accodate nella coda di messaggi e l'oggetto riceve una chiamata ogni volta che l'Apartment recupera e invia i messaggi.</span><span class="sxs-lookup"><span data-stu-id="08aaa-154">When multiple clients call an object, the calls are queued in the message queue and the object will receive a call each time its apartment retrieves and dispatches messages.</span></span> <span data-ttu-id="08aaa-155">Poiché le chiamate sono sincronizzate da COM e le chiamate vengono sempre recapitate dal thread che appartiene all'Apartment dell'oggetto, le implementazioni dell'interfaccia dell'oggetto non devono fornire la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="08aaa-155">Because the calls are synchronized by COM and the calls are always delivered by the thread that belongs to the object's apartment, the object's interface implementations need not provide synchronization.</span></span> <span data-ttu-id="08aaa-156">Gli Apartment a thread singolo possono implementare [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) per consentire loro di annullare chiamate o ricevere messaggi della finestra quando necessario.</span><span class="sxs-lookup"><span data-stu-id="08aaa-156">Single-threaded apartments can implement [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) to permit them to cancel calls or receive window messages when necessary.</span></span>

<span data-ttu-id="08aaa-157">L'oggetto può essere riavviato se una delle implementazioni del metodo di interfaccia recupera e invia messaggi o esegue una chiamata ORPC a un altro thread, causando così l'invio di un'altra chiamata all'oggetto (dallo stesso Apartment).</span><span class="sxs-lookup"><span data-stu-id="08aaa-157">The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread, thereby causing another call to be delivered to the object (by the same apartment).</span></span> <span data-ttu-id="08aaa-158">OLE non impedisce la rientranza sullo stesso thread, ma può aiutare a fornire thread safety.</span><span class="sxs-lookup"><span data-stu-id="08aaa-158">OLE does not prevent reentrancy on the same thread, but it can help provide thread safety.</span></span> <span data-ttu-id="08aaa-159">Si tratta di un metodo identico al modo in cui è possibile immettere nuovamente una routine della finestra se recupera e invia messaggi durante l'elaborazione di un messaggio.</span><span class="sxs-lookup"><span data-stu-id="08aaa-159">This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.</span></span> <span data-ttu-id="08aaa-160">Tuttavia, la chiamata a un server Apartment a thread singolo out-of-process che chiama un altro Apartment server a thread singolo consentirà di reimmettere il primo server.</span><span class="sxs-lookup"><span data-stu-id="08aaa-160">However, calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered.</span></span>

## <a name="related-topics"></a><span data-ttu-id="08aaa-161">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="08aaa-161">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="08aaa-162">Accesso alle interfacce tra gli Apartment</span><span class="sxs-lookup"><span data-stu-id="08aaa-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="08aaa-163">Scelta del modello di threading</span><span class="sxs-lookup"><span data-stu-id="08aaa-163">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="08aaa-164">Apartment con multithreading</span><span class="sxs-lookup"><span data-stu-id="08aaa-164">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="08aaa-165">Problemi di threading del server in-process</span><span class="sxs-lookup"><span data-stu-id="08aaa-165">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="08aaa-166">Processi, thread e Apartment</span><span class="sxs-lookup"><span data-stu-id="08aaa-166">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="08aaa-167">Comunicazione a thread singolo e multithreading</span><span class="sxs-lookup"><span data-stu-id="08aaa-167">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 