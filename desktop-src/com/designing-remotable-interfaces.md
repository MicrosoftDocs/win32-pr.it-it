---
title: Progettazione di interfacce utilizzabili in remoto
description: Con l'avvento del modello a oggetti del componente distribuito, è importante che l'interfaccia personalizzata sia utilizzabile in modalità remota, anche se si prevede di usarla solo in-process.
ms.assetid: 2ee4d950-dfd5-4965-bd77-a600e878be59
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3502604d62e6a5129ca3e3538761722909c0198f
ms.sourcegitcommit: 85688bbfbe5b121bc05ddf112d54c23a469dfbc0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/29/2020
ms.locfileid: "103857953"
---
# <a name="designing-remotable-interfaces"></a><span data-ttu-id="25a6c-103">Progettazione di interfacce utilizzabili in remoto</span><span class="sxs-lookup"><span data-stu-id="25a6c-103">Designing Remotable Interfaces</span></span>

<span data-ttu-id="25a6c-104">Con l'avvento del modello a oggetti del componente distribuito, è importante che l'interfaccia personalizzata sia utilizzabile in modalità remota, anche se si prevede di usarla solo in-process.</span><span class="sxs-lookup"><span data-stu-id="25a6c-104">With the advent of the distributed component object model, it is important that your custom interface be remotable, even if you intend to use it in-process only.</span></span>

<span data-ttu-id="25a6c-105">MIDL non è solo un modo per generare file di intestazione per le interfacce.</span><span class="sxs-lookup"><span data-stu-id="25a6c-105">MIDL is more than just a way to generate header files for your interfaces.</span></span> <span data-ttu-id="25a6c-106">Si tratta di un linguaggio di programmazione per la comunicazione remota che consente di usare le interfacce tra computer, processi e limiti di thread.</span><span class="sxs-lookup"><span data-stu-id="25a6c-106">It is a programming language for remoting that allows you to use your interfaces across machine, process, and thread boundaries.</span></span> <span data-ttu-id="25a6c-107">Ciò significa che è necessario verificare il comportamento delle interfacce definite da MIDL in tali condizioni prima di rilasciare il programma ai clienti.</span><span class="sxs-lookup"><span data-stu-id="25a6c-107">This means that you need to verify the behavior of your MIDL-defined interfaces under those conditions before you release your program to customers.</span></span> <span data-ttu-id="25a6c-108">Se è stato commesso un errore in IDL e l'interfaccia non è stata eseguita correttamente, potrebbe essere difficile risolvere l'errore.</span><span class="sxs-lookup"><span data-stu-id="25a6c-108">If you made a mistake in your IDL and the interface is not remoted correctly, it can be difficult to remedy that mistake.</span></span> <span data-ttu-id="25a6c-109">È necessario modificare l'interfaccia con un nuovo IID e lasciare il vecchio in per la compatibilità con le versioni precedenti oppure convertire tutti i client e tutti i computer server contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="25a6c-109">Either you have to revise your interface with a new IID and leave the old one in for backward compatibility or you have to convert every client and every server machine everywhere at the same time.</span></span>

<span data-ttu-id="25a6c-110">Anche se l'interfaccia non viene mai usata out-of-process, può essere usata tra thread.</span><span class="sxs-lookup"><span data-stu-id="25a6c-110">Even if your interface will never be used out-of-process, it may be used cross-thread.</span></span> <span data-ttu-id="25a6c-111">Il problema peggiore per un file IDL non verificato può verificarsi per i server in-process che non supportano più [Apartment a thread singolo](single-threaded-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="25a6c-111">The worst problem for an unchecked IDL file can arise for in-process servers that do not support multiple [single-threaded apartments](single-threaded-apartments.md)).</span></span> <span data-ttu-id="25a6c-112">Un server che non specifica un modello di threading è implicitamente a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="25a6c-112">A server that does not specify a threading model is implicitly single-threaded.</span></span> <span data-ttu-id="25a6c-113">Tutte le operazioni contrassegnate come a thread singolo vengono forzate al thread chiamato prima [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) o [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="25a6c-113">Everything marked single-threaded is forced over to the thread that first called [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize) or [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="25a6c-114">Se un altro thread era quello che ha attivato l'oggetto, tutte le interfacce sul server a thread singolo devono essere restituite al thread di attivazione, il che può comportare la restituzione di REGDB \_ E \_ IIDNOTREG in risposta a una chiamata a [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)).</span><span class="sxs-lookup"><span data-stu-id="25a6c-114">If some other thread was the one that activated the object, all the interfaces on that single-threaded server must be remoted back to the activating thread, which can result in a return of REGDB\_E\_IIDNOTREG in response to a call to [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))).</span></span> <span data-ttu-id="25a6c-115">A meno che non sia possibile affermare che l'interfaccia è sia in-process che sempre chiamata sullo stesso thread, si otterrà una modalità remota in un determinato momento.</span><span class="sxs-lookup"><span data-stu-id="25a6c-115">Unless you can absolutely assert that your interface is both in-process and always going to be called on the same thread, you will get remoted at some time.</span></span>

<span data-ttu-id="25a6c-116">Infine, come Interface Designer, è necessario considerare come le applicazioni client utilizzeranno l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="25a6c-116">Finally, as an interface designer, you need to consider how client applications will use your interface.</span></span> <span data-ttu-id="25a6c-117">Due elementi, insieme, determinano se un'interfaccia sarà efficiente tra i limiti del processo e del computer: la frequenza delle chiamate al metodo oltre il limite dell'interfaccia e la quantità di dati da trasferire in una determinata chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="25a6c-117">Two things, together, determine whether an interface will be efficient across process and machine boundaries: the frequency of method calls across the interface boundary, and the amount of data to be transferred in a given method call.</span></span> <span data-ttu-id="25a6c-118">Sebbene COM renda le chiamate tra processi e tra reti trasparenti ai programmi, non è in grado di effettuare chiamate a frequenza elevata e larghezza di banda elevata in spazi di indirizzi.</span><span class="sxs-lookup"><span data-stu-id="25a6c-118">Although COM makes cross-process and cross-network calls transparent to programs, it cannot make high-frequency and high-bandwidth calls efficient across address spaces.</span></span> <span data-ttu-id="25a6c-119">In alcuni casi, è più appropriato progettare interfacce che in genere verranno implementate solo come server in-process, mentre altre interfacce sono più appropriate per l'uso remoto.</span><span class="sxs-lookup"><span data-stu-id="25a6c-119">In some cases, it is more appropriate to design interfaces that will normally be implemented only as in-process servers while other interfaces are more appropriate for remote use.</span></span>

 

 




