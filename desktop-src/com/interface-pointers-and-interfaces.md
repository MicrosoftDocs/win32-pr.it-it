---
title: Puntatori a interfaccia e interfacce
description: Puntatori a interfaccia e interfacce
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/24/2019
ms.locfileid: "106297593"
---
# <a name="interface-pointers-and-interfaces"></a><span data-ttu-id="73121-103">Puntatori a interfaccia e interfacce</span><span class="sxs-lookup"><span data-stu-id="73121-103">Interface Pointers and Interfaces</span></span>

<span data-ttu-id="73121-104">Un'istanza di un'implementazione di interfaccia è in realtà un puntatore a una matrice di puntatori ai metodi, ovvero una tabella di funzioni che fa riferimento a un'implementazione di tutti i metodi specificati nell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="73121-104">An instance of an interface implementation is actually a pointer to an array of pointers to methods - that is, a function table that refers to an implementation of all of the methods specified in the interface.</span></span> <span data-ttu-id="73121-105">Gli oggetti con più interfacce possono fornire puntatori a più di una tabella di funzioni.</span><span class="sxs-lookup"><span data-stu-id="73121-105">Objects with multiple interfaces can provide pointers to more than one function table.</span></span> <span data-ttu-id="73121-106">Il codice con un puntatore tramite il quale può accedere alla matrice può chiamare i metodi di tale interfaccia.</span><span class="sxs-lookup"><span data-stu-id="73121-106">Any code that has a pointer through which it can access the array can call the methods in that interface.</span></span>

<span data-ttu-id="73121-107">La precisazione di questo riferimento indiretto multiplo è scomoda, quindi il puntatore alla tabella di funzioni di interfaccia che un altro oggetto deve chiamare i relativi metodi viene chiamato semplicemente un *puntatore di interfaccia*.</span><span class="sxs-lookup"><span data-stu-id="73121-107">Speaking precisely about this multiple indirection is inconvenient, so instead, the pointer to the interface function table that another object must have to call its methods is called simply an *interface pointer*.</span></span> <span data-ttu-id="73121-108">È possibile creare manualmente tabelle di funzioni in un'applicazione C o quasi automaticamente utilizzando Visual C++ (o altri linguaggi orientati a oggetti che supportano COM).</span><span class="sxs-lookup"><span data-stu-id="73121-108">You can manually create function tables in a C application or almost automatically by using Visual C++ (or other object-oriented languages that support COM).</span></span>

<span data-ttu-id="73121-109">Con il supporto del compilatore appropriato, che è intrinseco in C e C++, un client può chiamare un metodo di interfaccia tramite il nome, non la posizione nella matrice.</span><span class="sxs-lookup"><span data-stu-id="73121-109">With appropriate compiler support (which is inherent in C and C++), a client can call an interface method through its name, not its position in the array.</span></span> <span data-ttu-id="73121-110">Poiché un'interfaccia è un tipo, il compilatore, dato i nomi dei metodi, può controllare i tipi di parametri e i valori restituiti di ogni chiamata al metodo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="73121-110">Because an interface is a type, the compiler, given the names of methods, can check the types of parameters and return values of each interface method call.</span></span> <span data-ttu-id="73121-111">Al contrario, se un client usa uno schema di chiamata basato sulla posizione, questo controllo dei tipi non è disponibile, anche in C o C++.</span><span class="sxs-lookup"><span data-stu-id="73121-111">In contrast, if a client uses a position-based calling scheme, such type-checking is not available, even in C or C++.</span></span>

<span data-ttu-id="73121-112">Ogni interfaccia è un contratto non modificabile di un gruppo funzionale di metodi.</span><span class="sxs-lookup"><span data-stu-id="73121-112">Each interface is an immutable contract of a functional group of methods.</span></span> <span data-ttu-id="73121-113">Si fa riferimento a un'interfaccia in fase di esecuzione con un identificatore di interfaccia univoco globale (IID).</span><span class="sxs-lookup"><span data-stu-id="73121-113">You reference an interface at run time with a globally unique interface identifier (IID).</span></span> <span data-ttu-id="73121-114">Questo IID, che è un'istanza specifica di un identificatore univoco globale (GUID) supportato da COM, consente a un client di richiedere un oggetto con precisione se supporta la semantica dell'interfaccia, senza un sovraccarico superfluo e senza confusione che potrebbe verificarsi in un sistema di avere più versioni della stessa interfaccia con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="73121-114">This IID, which is a specific instance of a globally unique identifier (GUID) supported by COM, allows a client to ask an object precisely whether it supports the semantics of the interface, without unnecessary overhead and without the confusion that could arise in a system from having multiple versions of the same interface with the same name.</span></span>

<span data-ttu-id="73121-115">Per riepilogare, è importante comprendere che cos'è un'interfaccia COM e non è:</span><span class="sxs-lookup"><span data-stu-id="73121-115">To summarize, it is important to understand what a COM interface is, and is not:</span></span>

-   <span data-ttu-id="73121-116">Un'interfaccia COM non corrisponde a una classe C++.</span><span class="sxs-lookup"><span data-stu-id="73121-116">A COM interface is not the same as a C++ class.</span></span> <span data-ttu-id="73121-117">La definizione virtuale pura non contiene alcuna implementazione.</span><span class="sxs-lookup"><span data-stu-id="73121-117">The pure virtual definition carries no implementation.</span></span> <span data-ttu-id="73121-118">Se si è un programmatore C++, è possibile definire l'implementazione di un'interfaccia come una classe, ma ciò rientra nell'intestazione dei dettagli di implementazione, che non è specificato da COM.</span><span class="sxs-lookup"><span data-stu-id="73121-118">If you are a C++ programmer, you can define your implementation of an interface as a class, but this falls under the heading of implementation details, which COM does not specify.</span></span> <span data-ttu-id="73121-119">È necessario creare un'istanza di un oggetto che implementa un'interfaccia per l'interfaccia effettivamente esistente.</span><span class="sxs-lookup"><span data-stu-id="73121-119">An instance of an object that implements an interface must be created for the interface actually to exist.</span></span> <span data-ttu-id="73121-120">Inoltre, le classi di oggetti diverse possono implementare un'interfaccia in modo diverso, ma devono essere usate in modo intercambiabile in forma binaria, purché il comportamento sia conforme alla definizione dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="73121-120">Furthermore, different object classes may implement an interface differently yet be used interchangeably in binary form, as long as the behavior conforms to the interface definition.</span></span>
-   <span data-ttu-id="73121-121">Un'interfaccia COM non è un oggetto.</span><span class="sxs-lookup"><span data-stu-id="73121-121">A COM interface is not an object.</span></span> <span data-ttu-id="73121-122">Si tratta semplicemente di un gruppo correlato di funzioni ed è lo standard binario attraverso cui comunicano client e oggetti.</span><span class="sxs-lookup"><span data-stu-id="73121-122">It is simply a related group of functions and is the binary standard through which clients and objects communicate.</span></span> <span data-ttu-id="73121-123">Fino a quando può fornire puntatori ai metodi di interfaccia, l'oggetto può essere implementato in qualsiasi linguaggio con qualsiasi rappresentazione di stato interna.</span><span class="sxs-lookup"><span data-stu-id="73121-123">As long as it can provide pointers to interface methods, the object can be implemented in any language with any internal state representation.</span></span>
-   <span data-ttu-id="73121-124">Le interfacce COM sono fortemente tipizzate.</span><span class="sxs-lookup"><span data-stu-id="73121-124">COM interfaces are strongly typed.</span></span> <span data-ttu-id="73121-125">Ogni interfaccia ha un proprio identificatore di interfaccia (GUID), che elimina la possibilità di duplicazione che può verificarsi con qualsiasi altro schema di denominazione.</span><span class="sxs-lookup"><span data-stu-id="73121-125">Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication that could occur with any other naming scheme.</span></span>
-   <span data-ttu-id="73121-126">Le interfacce COM non sono modificabili.</span><span class="sxs-lookup"><span data-stu-id="73121-126">COM interfaces are immutable.</span></span> <span data-ttu-id="73121-127">Non è possibile definire una nuova versione di un'interfaccia precedente e assegnargli lo stesso identificatore.</span><span class="sxs-lookup"><span data-stu-id="73121-127">You cannot define a new version of an old interface and give it the same identifier.</span></span> <span data-ttu-id="73121-128">L'aggiunta o la rimozione di metodi di un'interfaccia o la modifica della semantica crea una nuova interfaccia, non una nuova versione di un'interfaccia obsoleta.</span><span class="sxs-lookup"><span data-stu-id="73121-128">Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.</span></span> <span data-ttu-id="73121-129">Pertanto, una nuova interfaccia non può essere in conflitto con un'interfaccia obsoleta.</span><span class="sxs-lookup"><span data-stu-id="73121-129">Therefore, a new interface cannot conflict with an old interface.</span></span> <span data-ttu-id="73121-130">Tuttavia, gli oggetti possono supportare più interfacce simultaneamente e possono esporre interfacce che sono revisioni successive di un'interfaccia, con identificatori diversi.</span><span class="sxs-lookup"><span data-stu-id="73121-130">However, objects can support multiple interfaces simultaneously and can expose interfaces that are successive revisions of an interface, with different identifiers.</span></span> <span data-ttu-id="73121-131">Pertanto, ogni interfaccia è un contratto separato e gli oggetti a livello non devono preoccuparsi se la versione dell'interfaccia che sta chiamando è quella che si aspettano.</span><span class="sxs-lookup"><span data-stu-id="73121-131">Thus, each interface is a separate contract, and systemwide objects need not be concerned about whether the version of the interface they are calling is the one they expect.</span></span> <span data-ttu-id="73121-132">L'ID di interfaccia (IID) definisce il contratto di interfaccia in modo esplicito e univoco.</span><span class="sxs-lookup"><span data-stu-id="73121-132">The interface ID (IID) defines the interface contract explicitly and uniquely.</span></span>

## <a name="related-topics"></a><span data-ttu-id="73121-133">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="73121-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="73121-134">Oggetti e interfacce COM</span><span class="sxs-lookup"><span data-stu-id="73121-134">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




