---
title: Regole di gestione della memoria
description: Regole di gestione della memoria
ms.assetid: 769127a1-1a14-4ed4-9d38-7cf3e571b661
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56e7ad2483b794ec5c2e9c325bca8e469ff4ae0b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2020
ms.locfileid: "104118550"
---
# <a name="memory-management-rules"></a><span data-ttu-id="f517d-103">Regole di gestione della memoria</span><span class="sxs-lookup"><span data-stu-id="f517d-103">Memory Management Rules</span></span>

<span data-ttu-id="f517d-104">La durata dei puntatori alle interfacce viene sempre gestita tramite i metodi [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) e [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) su ogni interfaccia com.</span><span class="sxs-lookup"><span data-stu-id="f517d-104">The lifetime of pointers to interfaces is always managed through the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods on every COM interface.</span></span> <span data-ttu-id="f517d-105">Per ulteriori informazioni, vedere [regole per la gestione dei conteggi dei riferimenti](rules-for-managing-reference-counts.md).</span><span class="sxs-lookup"><span data-stu-id="f517d-105">For more information, see [Rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span></span>

<span data-ttu-id="f517d-106">Per tutti gli altri parametri, è importante rispettare determinate regole per la gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="f517d-106">For all other parameters, it is important to adhere to certain rules for managing memory.</span></span> <span data-ttu-id="f517d-107">Le regole seguenti si applicano a tutti i parametri di Interface methodsâ ", incluso il valore restituito valueâ €", che non vengono passati per valore:</span><span class="sxs-lookup"><span data-stu-id="f517d-107">The following rules apply to all parameters of interface methodsâ€”including the return valueâ€”that are not passed by value:</span></span>

-   <span data-ttu-id="f517d-108">I parametri in devono essere allocati e liberati dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="f517d-108">In-parameters must be allocated and freed by the caller.</span></span>
-   <span data-ttu-id="f517d-109">I parametri out devono essere allocati da uno chiamato; vengono liberati dal chiamante utilizzando l'allocatore di memoria delle attività COM standard.</span><span class="sxs-lookup"><span data-stu-id="f517d-109">Out-parameters must be allocated by the one called; they are freed by the caller using the standard COM task memory allocator.</span></span> <span data-ttu-id="f517d-110">Per ulteriori informazioni, vedere [l'allocatore di memoria OLE](the-ole-memory-allocator.md) .</span><span class="sxs-lookup"><span data-stu-id="f517d-110">See [The OLE Memory Allocator](the-ole-memory-allocator.md) for more information.</span></span>
-   <span data-ttu-id="f517d-111">I parametri in/out vengono inizialmente allocati dal chiamante e quindi liberati e riallocati da quello denominato, se necessario.</span><span class="sxs-lookup"><span data-stu-id="f517d-111">In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called, if necessary.</span></span> <span data-ttu-id="f517d-112">Come è vero per i parametri out, il chiamante è responsabile della liberazione del valore finale restituito.</span><span class="sxs-lookup"><span data-stu-id="f517d-112">As is true for out parameters, the caller is responsible for freeing the final returned value.</span></span> <span data-ttu-id="f517d-113">È necessario usare l'allocatore di memoria COM standard.</span><span class="sxs-lookup"><span data-stu-id="f517d-113">The standard COM memory allocator must be used.</span></span>

<span data-ttu-id="f517d-114">Negli ultimi due casi, in cui un frammento di codice consente di allocare la memoria e una parte diversa del codice la libera, l'uso dell'allocatore COM garantisce che le due parti di codice utilizzino gli stessi metodi di allocazione.</span><span class="sxs-lookup"><span data-stu-id="f517d-114">In the latter two cases, where one piece of code allocates the memory and a different piece of code frees it, using the COM allocator ensures that the two pieces of code are using the same allocation methods.</span></span>

<span data-ttu-id="f517d-115">Un'altra area che richiede particolare attenzione è il trattamento di parametri out e out in condizioni di errore.</span><span class="sxs-lookup"><span data-stu-id="f517d-115">Another area that needs special attention is the treatment of out and in-out parameters in failure conditions.</span></span> <span data-ttu-id="f517d-116">Se una funzione restituisce un codice di errore, il chiamante non ha in genere alcun modo per pulire i parametri out o out.</span><span class="sxs-lookup"><span data-stu-id="f517d-116">If a function returns a failure code, the caller typically has no way to clean up the out or in-out parameters.</span></span> <span data-ttu-id="f517d-117">Ciò comporta le regole aggiuntive seguenti:</span><span class="sxs-lookup"><span data-stu-id="f517d-117">This leads to the following additional rules:</span></span>

-   <span data-ttu-id="f517d-118">In caso di condizione di errore, i parametri devono essere sempre impostati in modo affidabile su un valore che verrà pulito senza alcuna azione da parte del chiamante.</span><span class="sxs-lookup"><span data-stu-id="f517d-118">In case of an error condition, parameters must always be reliably set to a value that will be cleaned up without any action by the caller.</span></span>
-   <span data-ttu-id="f517d-119">Tutti i parametri del puntatore out devono essere impostati in modo esplicito su **null**.</span><span class="sxs-lookup"><span data-stu-id="f517d-119">All out pointer parameters must explicitly be set to **NULL**.</span></span> <span data-ttu-id="f517d-120">Questi vengono in genere passati in un parametro puntatore a puntatore, ma possono anche essere passati come membri di una struttura allocata dal chiamante e il codice chiamato riempie.</span><span class="sxs-lookup"><span data-stu-id="f517d-120">These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.</span></span> <span data-ttu-id="f517d-121">Il modo più semplice per assicurarsi che sia (in parte) impostare questi valori su **null** nella voce di funzione.</span><span class="sxs-lookup"><span data-stu-id="f517d-121">The most straightforward way to ensure this is (in part) to set these values to **NULL** on function entry.</span></span> <span data-ttu-id="f517d-122">Questa regola è importante perché promuove l'interoperabilità di applicazioni più affidabili.</span><span class="sxs-lookup"><span data-stu-id="f517d-122">This rule is important because it promotes more robust application interoperability.</span></span>
-   <span data-ttu-id="f517d-123">In condizioni di errore, tutti i parametri in uscita devono essere lasciati da solo dal codice chiamato (rimanendo così in corrispondenza del valore a cui sono stati inizializzati dal chiamante) o essere impostati in modo esplicito, come nel caso di errore del parametro out.</span><span class="sxs-lookup"><span data-stu-id="f517d-123">Under error conditions, all in-out parameters must either be left alone by the code called (thus remaining at the value to which they were initialized by the caller) or be explicitly set, as in the out parameter error return case.</span></span>

<span data-ttu-id="f517d-124">Tenere presente che le convenzioni di gestione della memoria per le applicazioni COM si applicano solo tra le interfacce pubbliche e APIsâ "non è necessario che l'allocazione di memoria strettamente interna a un'applicazione COM venga eseguita usando questi meccanismi.</span><span class="sxs-lookup"><span data-stu-id="f517d-124">Remember that these memory management conventions for COM applications apply only across public interfaces and APIsâ€”there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</span></span>

<span data-ttu-id="f517d-125">COM utilizza internamente RPC (Remote Procedure Call) per la comunicazione tra client e server.</span><span class="sxs-lookup"><span data-stu-id="f517d-125">COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers.</span></span> <span data-ttu-id="f517d-126">Per ulteriori informazioni sulla gestione della memoria negli stub del server RPC, vedere l'argomento relativo alla [gestione della memoria dei stub server](../rpc/server-stub-memory-management.md) .</span><span class="sxs-lookup"><span data-stu-id="f517d-126">For more information about managing memory in RPC server stubs, see the [Server-stub Memory Management](../rpc/server-stub-memory-management.md) topic.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f517d-127">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="f517d-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f517d-128">Gestione dell'allocazione di memoria</span><span class="sxs-lookup"><span data-stu-id="f517d-128">Managing Memory Allocation</span></span>](managing-memory-allocation.md)
</dt> </dl>

 

 