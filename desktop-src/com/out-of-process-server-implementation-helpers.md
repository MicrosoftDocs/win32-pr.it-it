---
title: Helper di implementazione del server out-of-process
description: Helper di implementazione del server out-of-process
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2020
ms.locfileid: "104399780"
---
# <a name="out-of-process-server-implementation-helpers"></a><span data-ttu-id="ec1cd-103">Helper di implementazione del server out-of-process</span><span class="sxs-lookup"><span data-stu-id="ec1cd-103">Out-of-Process Server Implementation Helpers</span></span>

<span data-ttu-id="ec1cd-104">Sono disponibili quattro funzioni helper che possono essere chiamate da server out-of-process per semplificare il processo di scrittura del codice server.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-104">Four helper functions that can be called by out-of-process servers are available to simplify the job of writing server code.</span></span> <span data-ttu-id="ec1cd-105">I client COM e i server COM in-process non li chiamano in genere.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-105">COM clients and COM in-process servers typically would not call them.</span></span> <span data-ttu-id="ec1cd-106">Queste funzioni sono progettate per evitare race condition nell'attivazione del server quando i server hanno più Apartment o più oggetti classe.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-106">These functions are designed to help prevent race conditions in server activation when the servers have multiple apartments or multiple class objects.</span></span> <span data-ttu-id="ec1cd-107">Tuttavia, possono essere usati anche per i server a thread singolo e per gli oggetti a singolo livello.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-107">They can also, however, as easily be used for single-threaded and single class object servers.</span></span> <span data-ttu-id="ec1cd-108">Le funzioni sono le seguenti:</span><span class="sxs-lookup"><span data-stu-id="ec1cd-108">The functions are as follows:</span></span>

-   [<span data-ttu-id="ec1cd-109">**CoAddRefServerProcess**</span><span class="sxs-lookup"><span data-stu-id="ec1cd-109">**CoAddRefServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [<span data-ttu-id="ec1cd-110">**CoReleaseServerProcess**</span><span class="sxs-lookup"><span data-stu-id="ec1cd-110">**CoReleaseServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [<span data-ttu-id="ec1cd-111">**CoSuspendClassObjects**</span><span class="sxs-lookup"><span data-stu-id="ec1cd-111">**CoSuspendClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [<span data-ttu-id="ec1cd-112">**CoResumeClassObjects**</span><span class="sxs-lookup"><span data-stu-id="ec1cd-112">**CoResumeClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

<span data-ttu-id="ec1cd-113">Per arrestare correttamente, un server COM deve tenere traccia del numero di istanze dell'oggetto di cui è stata creata un'istanza e il numero di volte in cui è stato chiamato il metodo [**IClassFactory:: LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) .</span><span class="sxs-lookup"><span data-stu-id="ec1cd-113">To shut down properly, a COM server must keep track of how many object instances it has instantiated and how many times its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method has been called.</span></span> <span data-ttu-id="ec1cd-114">Solo quando entrambi i conteggi raggiungono zero può arrestare un server.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-114">Only when both of these counts reach zero can a server shut down.</span></span> <span data-ttu-id="ec1cd-115">Nei server COM a thread singolo la decisione di arrestare è stata coordinata con le richieste di attivazione in ingresso, che sono state serializzate dalla coda di messaggi.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-115">In single-threaded COM servers, the decision to shut down was coordinated with incoming activation requests, which were serialized by the message queue.</span></span> <span data-ttu-id="ec1cd-116">Il server, alla ricezione di un rilascio sull'istanza dell'oggetto finale e la decisione di arrestarsi, potrebbe revocare gli oggetti classe prima che venissero inviate altre richieste di attivazione.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-116">The server, upon receiving a release on its final object instance and deciding to shut down, would revoke its class objects before any more activation requests were dispatched.</span></span> <span data-ttu-id="ec1cd-117">Se dopo questo punto è stata rilevata una richiesta di attivazione, COM riconoscerebbe che gli oggetti classe sono stati revocati e restituirebbe un errore a gestione controllo servizi (SCM), che provocherebbe quindi una nuova istanza del processo server locale da eseguire.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-117">If an activation request did come in after this point, COM would recognize that the class objects were revoked and would return an error to the Service Control Manager (SCM), which would then cause a new instance of the local server process to be run.</span></span>

<span data-ttu-id="ec1cd-118">Tuttavia, in un server modello di Apartment, in cui gli oggetti classe diversi sono registrati in diversi Apartment e in tutti i server a thread libero, questa decisione di arrestare deve essere coordinata con richieste di attivazione su più thread, in modo che un thread del server non decida di arrestarsi mentre un altro thread del server è occupato a distribuire oggetti classe o istanze di oggetti.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-118">However, in an apartment model server, in which different class objects are registered on different apartments, and in all free-threaded servers, this decision to shut down must be coordinated with activation requests across multiple threads so that one thread of the server does not decide to shut down while another thread of the server is busy handing out class objects or object instances.</span></span> <span data-ttu-id="ec1cd-119">Un approccio classico ma complesso per risolvere questo problema consiste nel fare in modo che il server, dopo aver revocato gli oggetti classe, ricontrollare il numero di istanze e rimanere attivo fino a quando tutte le istanze non sono state rilasciate.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-119">One classical but cumbersome approach to solving this is to have the server, after it has revoked its class objects, recheck its instance count and stay alive until all instances have been released.</span></span>

<span data-ttu-id="ec1cd-120">Per semplificare la gestione di questi tipi di race condition da parte dei writer di server, COM fornisce due funzioni di conteggio dei riferimenti:</span><span class="sxs-lookup"><span data-stu-id="ec1cd-120">To make it easier for server writers to handle these types of race conditions, COM provides two reference counting functions:</span></span>

-   <span data-ttu-id="ec1cd-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) incrementa un conteggio di riferimenti globali per processo.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) increments a global per-process reference count.</span></span>
-   <span data-ttu-id="ec1cd-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrementa il conteggio dei riferimenti globali per processo.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrements the global per-process reference count.</span></span>

<span data-ttu-id="ec1cd-123">Quando il conteggio dei riferimenti globali per processo raggiunge zero, COM chiama automaticamente [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), che impedisce l'arrivo di nuove richieste di attivazione.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-123">When the global per-process reference count reaches zero, COM automatically calls [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), which prevents any new activation requests from coming in.</span></span> <span data-ttu-id="ec1cd-124">Il server può quindi annullare la registrazione dei vari oggetti classe dai diversi thread a piacimento senza preoccuparsi di poter entrare in un'altra richiesta di attivazione.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-124">The server can then deregister its various class objects from its various threads at leisure without worry that another activation request may come in.</span></span> <span data-ttu-id="ec1cd-125">Tutte le nuove richieste di attivazione verranno gestite dal gestore SCM per avviare una nuova istanza del processo del server locale.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-125">All new activation requests are henceforth handled by the SCM launching a new instance of the local server process.</span></span>

<span data-ttu-id="ec1cd-126">Il modo più semplice per usare queste funzioni in un'applicazione server locale è chiamare [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) nel costruttore per ognuno dei relativi oggetti istanza e in ognuno dei relativi metodi [**IClassFactory:: LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) quando il parametro *Flock* è **true**.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-126">The simplest way for a local server application to make use of these functions is to call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) in the constructor for each of its instance objects and in each of its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) methods when the *fLock* parameter is **TRUE**.</span></span> <span data-ttu-id="ec1cd-127">L'applicazione server deve chiamare anche [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) nel distruttore di ognuno dei relativi oggetti istanza e in ognuno dei relativi metodi IClassFactory::**LockServer** quando il parametro *Flock* è **false**.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-127">The server application should also call [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) in the destructor of each of its instance objects and in each of its IClassFactory::**LockServer** methods when the *fLock* parameter is **FALSE**.</span></span>

<span data-ttu-id="ec1cd-128">Infine, l'applicazione server deve prestare attenzione al codice restituito da [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)e se restituisce 0, l'applicazione server deve avviare la pulitura, che, per un server con più thread, significa in genere che deve segnalare i vari thread per uscire dai cicli di messaggi e chiamare [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) e [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span><span class="sxs-lookup"><span data-stu-id="ec1cd-128">Finally, the server application should pay attention to the return code from [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) and [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span></span> <span data-ttu-id="ec1cd-129">Se vengono utilizzate le funzioni di gestione della durata del processo server, devono essere utilizzate sia nelle istanze dell'oggetto che nel metodo [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) . in caso contrario, l'applicazione server potrebbe essere arrestata in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-129">If the server process lifetime management functions are used, they must be used in both the object instances and the [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method; otherwise, the server application may be shut down prematurely.</span></span>

<span data-ttu-id="ec1cd-130">Quando viene effettuata una richiesta [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) , com Contatta il server, esegue il marshalling dell'interfaccia [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) dell'oggetto classe, torna al processo client, esegue l'unmarshalling dell'interfaccia **IClassFactory** e la restituisce al client.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-130">When a [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) request is made, COM contacts the server, marshals the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface of the class object, returns to the client process, unmarshals the **IClassFactory** interface, and returns this to the client.</span></span> <span data-ttu-id="ec1cd-131">A questo punto, i client in genere chiamano [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) con **true** per impedire l'arresto del processo server.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-131">At this point, clients typically call [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) with **TRUE** to prevent the server process from shutting down.</span></span> <span data-ttu-id="ec1cd-132">Tuttavia, esiste una finestra di tempo tra il marshalling dell'oggetto classe e il momento in cui il client chiama **LockServer** in cui un altro client può connettersi allo stesso server, ottenere un'istanza e rilasciare tale istanza, causando l'arresto del server e l'interruzione del primo client con un puntatore **IClassFactory** disconnesso.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-132">However, there is a window of time between when the class object is marshaled and when the client calls **LockServer** in which another client could connect to the same server, get an instance, and release that instance, thus causing the server to shut down and leaving the first client high and dry with a disconnected **IClassFactory** pointer.</span></span> <span data-ttu-id="ec1cd-133">Per evitare questo race condition, COM aggiunge una chiamata implicita a **LockServer** con **true** all'oggetto classe quando esegue il marshalling dell'interfaccia **IClassFactory** e una chiamata implicita a **LockServer** con **false** quando il client rilascia l'interfaccia **IClassFactory** .</span><span class="sxs-lookup"><span data-stu-id="ec1cd-133">To prevent this race condition, COM adds an implicit call to **LockServer** with **TRUE** to the class object when it marshals the **IClassFactory** interface and an implicit call to **LockServer** with **FALSE** when the client releases the **IClassFactory** interface.</span></span> <span data-ttu-id="ec1cd-134">Di conseguenza, non è necessario eseguire chiamate **LockServer** remote al server e il proxy per **LockServer** restituisce semplicemente S \_ OK senza eseguire effettivamente la comunicazione remota della chiamata.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-134">Therefore, it is not necessary to remote **LockServer** calls back to the server, and the proxy for **LockServer** simply returns S\_OK without actually remoting the call.</span></span>

<span data-ttu-id="ec1cd-135">Durante l'inizializzazione di un processo server out-of-process è presente un'altra race condition correlata all'attivazione.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-135">There is another activation-related race condition during initialization of an out-of-process server process.</span></span> <span data-ttu-id="ec1cd-136">Un server COM che registra più classi chiama in genere [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) con il \_ server locale REGCLS \_ per ogni CLSID supportato.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-136">A COM server that registers multiple classes typically calls [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER for each CLSID it supports.</span></span> <span data-ttu-id="ec1cd-137">Una volta eseguita questa operazione per tutte le classi, il server immette il relativo ciclo di messaggi.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-137">After it has done this for all classes, the server enters its message loop.</span></span> <span data-ttu-id="ec1cd-138">Per un server COM a thread singolo, tutte le richieste di attivazione vengono bloccate fino a quando il server non entra nel ciclo di messaggi.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-138">For a single-threaded COM server, all activation requests are blocked until the server enters the message loop.</span></span> <span data-ttu-id="ec1cd-139">Tuttavia, per un server del modello di Apartment che registra oggetti classe diversi in Apartment diversi e per tutti i server a thread libero, le richieste di attivazione possono arrivare prima di questo.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-139">However, for an apartment model server that registers different class objects in different apartments and for all free-threaded servers, activation requests can arrive earlier than this.</span></span> <span data-ttu-id="ec1cd-140">Nel caso dei server del modello di Apartment, le richieste di attivazione potrebbero arrivare non appena un thread entra in un ciclo di messaggi.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-140">In the case of apartment model servers, activation requests could arrive as soon as any one thread has entered its message loop.</span></span> <span data-ttu-id="ec1cd-141">Nel caso di server a thread libero, una richiesta di attivazione potrebbe arrivare non appena viene registrato il primo oggetto classe.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-141">In the case of free-threaded servers, an activation request could arrive as soon as the first class object is registered.</span></span> <span data-ttu-id="ec1cd-142">Poiché un'attivazione può avvenire in anticipo, è anche possibile che si verifichi la versione finale (e di conseguenza causare l'arresto del server) prima che il resto del server abbia avuto la possibilità di completare l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-142">Since an activation can happen this early, it is also possible for the final release to occur (and therefore cause the server to begin shutting down) before the rest of the server has had a chance to finish initializing.</span></span>

<span data-ttu-id="ec1cd-143">Per eliminare queste race condition e semplificare il processo del writer del server, tutti i server che vogliono registrare più oggetti classe con COM devono chiamare [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) con REGCLS \_ \_ server locale \| REGCLS \_ sospeso per ogni CLSID diverso supportato dal server.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-143">To eliminate these race conditions and simplify the job of the server writer, any server that wants to register multiple class objects with COM should call [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER \| REGCLS\_SUSPENDED for each different CLSID the server supports.</span></span> <span data-ttu-id="ec1cd-144">Dopo che tutte le classi sono state registrate e il processo server è pronto per accettare le richieste di attivazione in ingresso, il server deve effettuare una chiamata a [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span><span class="sxs-lookup"><span data-stu-id="ec1cd-144">After all classes have been registered and the server process is ready to accept incoming activation requests, the server should make one call to [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span></span> <span data-ttu-id="ec1cd-145">Questa funzione indica a COM di informare il SCM su tutte le classi registrate e inizia a consentire le richieste di attivazione al processo server.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-145">This function tells COM to inform the SCM about all the registered classes, and it begins letting activation requests into the server process.</span></span> <span data-ttu-id="ec1cd-146">L'utilizzo di queste funzioni offre i vantaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="ec1cd-146">Using these functions provides the following advantages:</span></span>

-   <span data-ttu-id="ec1cd-147">Viene eseguita una sola chiamata a SCM, indipendentemente dal numero di CLSID registrati, riducendo così l'ora di registrazione complessiva (e quindi il tempo di avvio dell'applicazione server).</span><span class="sxs-lookup"><span data-stu-id="ec1cd-147">Only one call is made to the SCM, regardless of how many CLSIDs are registered, thus reducing the overall registration time (and hence startup time of the server application).</span></span>
-   <span data-ttu-id="ec1cd-148">Se il server dispone di più Apartment e CLSID diversi sono registrati in Apartment diversi o se il server è un server a thread libero, nessuna richiesta di attivazione sarà disponibile fino a quando il server non chiamerà [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), offrendo al server la possibilità di registrare tutti i relativi CLSID e di essere impostati correttamente prima di gestire le richieste di attivazione e di arrestare le richieste.</span><span class="sxs-lookup"><span data-stu-id="ec1cd-148">If the server has multiple apartments and different CLSIDs are registered in different apartments, or if the server is a free-threaded server, no activation requests will come in until the server calls [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), giving the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests and possible shut down requests.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ec1cd-149">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="ec1cd-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ec1cd-150">Responsabilità server COM</span><span class="sxs-lookup"><span data-stu-id="ec1cd-150">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 