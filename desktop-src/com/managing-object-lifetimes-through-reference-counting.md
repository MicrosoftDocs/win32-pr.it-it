---
title: Gestione della durata degli oggetti tramite il conteggio dei riferimenti
description: Gestione della durata degli oggetti tramite il conteggio dei riferimenti
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/17/2020
ms.locfileid: "106299540"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a><span data-ttu-id="b96f6-103">Gestione della durata degli oggetti tramite il conteggio dei riferimenti</span><span class="sxs-lookup"><span data-stu-id="b96f6-103">Managing Object Lifetimes Through Reference Counting</span></span>

<span data-ttu-id="b96f6-104">Nei sistemi a oggetti tradizionali, il ciclo di vita degli oggetti, ovvero i problemi relativi alla creazione e all'eliminazione di oggetti, viene gestito in modo implicito dalla lingua (o dal tempo di esecuzione del linguaggio) o in modo esplicito dai programmatori di applicazioni.</span><span class="sxs-lookup"><span data-stu-id="b96f6-104">In traditional object systems, the life cycle of objects—that is, the issues surrounding the creation and deletion of objects—is handled implicitly by the language (or the language run time) or explicitly by application programmers.</span></span>

<span data-ttu-id="b96f6-105">In un sistema in continua evoluzione, costruito in modo decentrato, costituito da componenti riutilizzati, non è più vero che qualsiasi client, o anche un programmatore, sempre "sa" come gestire la durata di un componente.</span><span class="sxs-lookup"><span data-stu-id="b96f6-105">In an evolving, decentrally constructed system made up of reused components, it is no longer true that any client, or even any programmer, always "knows" how to deal with a component's lifetime.</span></span> <span data-ttu-id="b96f6-106">Per un client con i privilegi di sicurezza corretti, è ancora relativamente semplice creare oggetti tramite una semplice richiesta, ma l'eliminazione degli oggetti è interamente un altro aspetto.</span><span class="sxs-lookup"><span data-stu-id="b96f6-106">For a client with the right security privileges, it is still relatively easy to create objects through a simple request, but object deletion is another matter entirely.</span></span> <span data-ttu-id="b96f6-107">Non è necessariamente chiaro quando un oggetto non è più necessario e deve essere eliminato.</span><span class="sxs-lookup"><span data-stu-id="b96f6-107">It is not necessarily clear when an object is no longer needed and should be deleted.</span></span> <span data-ttu-id="b96f6-108">I lettori che hanno familiarità con gli ambienti di programmazione sottoposti a Garbage Collection, ad esempio Java, potrebbero non essere d'accordo. gli oggetti Java, tuttavia, non si estendono sul computer o persino i limiti del processo e pertanto la Garbage Collection è limitata agli oggetti che risiedono in uno spazio a processo</span><span class="sxs-lookup"><span data-stu-id="b96f6-108">(Readers familiar with garbage-collected programming environments, such as Java, may disagree; however, Java objects do not span machine or even process boundaries, and therefore the garbage collection is restricted to objects living within a single-process space.</span></span> <span data-ttu-id="b96f6-109">Inoltre, Java impone l'uso di un singolo linguaggio di programmazione. Anche quando il client originale viene eseguito con l'oggetto, non può semplicemente arrestare l'oggetto, perché è possibile che altri client o client abbiano ancora un riferimento a tale oggetto.</span><span class="sxs-lookup"><span data-stu-id="b96f6-109">In addition, Java forces the use of a single programming language.) Even when the original client is done with the object, it cannot simply shut the object down, because some other client or clients might still have a reference to it.</span></span>

<span data-ttu-id="b96f6-110">Un modo per garantire che un oggetto non è più necessario dipende interamente da un canale di comunicazione sottostante per informare il sistema quando tutte le connessioni a un oggetto tra processi o tra canali sono scomparse.</span><span class="sxs-lookup"><span data-stu-id="b96f6-110">One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared.</span></span> <span data-ttu-id="b96f6-111">Tuttavia, gli schemi che utilizzano questo metodo sono inaccettabili per diversi motivi.</span><span class="sxs-lookup"><span data-stu-id="b96f6-111">However, schemes that use this method are unacceptable for several reasons.</span></span> <span data-ttu-id="b96f6-112">Un problema consiste nel fatto che potrebbe essere necessaria una differenza sostanziale tra il modello di programmazione tra processi e tra più reti e il modello di programmazione a processo singolo.</span><span class="sxs-lookup"><span data-stu-id="b96f6-112">One problem is that it could require a major difference between the cross-process/cross-network programming model and the single-process programming model.</span></span> <span data-ttu-id="b96f6-113">Nel modello di programmazione tra più processi e tra più reti, il sistema di comunicazione fornirebbe gli hook necessari per la gestione della durata degli oggetti, mentre nel modello di programmazione a processo singolo gli oggetti vengono connessi direttamente senza alcun canale di comunicazione corrispondente.</span><span class="sxs-lookup"><span data-stu-id="b96f6-113">In the cross-process/cross-network programming model, the communication system would provide the hooks necessary for object lifetime management, while in the single-process programming model, objects are directly connected without any intervening communications channel.</span></span> <span data-ttu-id="b96f6-114">Un altro problema è che questo schema può comportare anche un livello di software fornito dal sistema che interferisce con le prestazioni dei componenti nel caso in-process.</span><span class="sxs-lookup"><span data-stu-id="b96f6-114">Another problem is that this scheme could also result in a layer of system-provided software that would interfere with component performance in the in-process case.</span></span> <span data-ttu-id="b96f6-115">Inoltre, un meccanismo basato sul monitoraggio esplicito non tenderebbe a ridimensionarsi verso molte migliaia o milioni di oggetti.</span><span class="sxs-lookup"><span data-stu-id="b96f6-115">Furthermore, a mechanism based on explicit monitoring would not tend to scale toward many thousands or millions of objects.</span></span>

<span data-ttu-id="b96f6-116">COM offre un approccio scalabile e distribuito a questo set di problemi.</span><span class="sxs-lookup"><span data-stu-id="b96f6-116">COM offers a scalable and distributed approach to this set of problems.</span></span> <span data-ttu-id="b96f6-117">I client indicano un oggetto quando lo usano e quando vengono eseguiti e gli oggetti vengono eliminati quando non sono più necessari.</span><span class="sxs-lookup"><span data-stu-id="b96f6-117">Clients tell an object when they are using it and when they are done, and objects delete themselves when they are no longer needed.</span></span> <span data-ttu-id="b96f6-118">Questo approccio impone che tutti gli oggetti conteggino i riferimenti a se stessi.</span><span class="sxs-lookup"><span data-stu-id="b96f6-118">This approach mandates that all objects count references to themselves.</span></span> <span data-ttu-id="b96f6-119">I linguaggi di programmazione, ad esempio Java, che hanno intrinsecamente i propri schemi di gestione della durata, ad esempio Garbage Collection, possono utilizzare il conteggio dei riferimenti di COM per implementare e utilizzare internamente gli oggetti COM, consentendo al programmatore di evitare di gestirlo.</span><span class="sxs-lookup"><span data-stu-id="b96f6-119">Programming languages such as Java, which inherently have their own lifetime management schemes, such as garbage collection, can use COM's reference counting to implement and use COM objects internally, allowing the programmer to avoid dealing with it.</span></span>

<span data-ttu-id="b96f6-120">Proprio come un'applicazione deve liberare memoria, quando l'oggetto non è più in uso, un client di un oggetto è responsabile di liberare i relativi riferimenti all'oggetto quando tale oggetto non è più necessario.</span><span class="sxs-lookup"><span data-stu-id="b96f6-120">Just as an application must free memory it has allocated once that memory is no longer in use, a client of an object is responsible for freeing its references to the object when that object is no longer needed.</span></span> <span data-ttu-id="b96f6-121">In un sistema orientato a oggetti, il client può eseguire questa operazione solo assegnando all'oggetto un'istruzione per liberarsi.</span><span class="sxs-lookup"><span data-stu-id="b96f6-121">In an object-oriented system, the client can do this only by giving the object an instruction to free itself.</span></span>

<span data-ttu-id="b96f6-122">È importante deallocare un oggetto quando non è più usato.</span><span class="sxs-lookup"><span data-stu-id="b96f6-122">It is important that an object be deallocated when it is no longer being used.</span></span> <span data-ttu-id="b96f6-123">La difficoltà consiste nel determinare quando è appropriato deallocare un oggetto.</span><span class="sxs-lookup"><span data-stu-id="b96f6-123">The difficulty lies in determining when it is appropriate to deallocate an object.</span></span> <span data-ttu-id="b96f6-124">Questa operazione è facile con le variabili automatiche (quelle allocate nello stack), che non possono essere usate all'esterno del blocco in cui sono dichiarate, quindi il compilatore le dealloca quando viene raggiunta la fine del blocco.</span><span class="sxs-lookup"><span data-stu-id="b96f6-124">This is easy with automatic variables (those allocated on the stack)—they cannot be used outside the block in which they're declared, so the compiler deallocates them when the end of the block is reached.</span></span> <span data-ttu-id="b96f6-125">Per gli oggetti COM, che vengono allocati dinamicamente, spetta ai client di un oggetto decidere quando non è più necessario utilizzare l'oggetto, in particolare oggetti locali o remoti che potrebbero essere utilizzati da più client nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="b96f6-125">For COM objects, which are dynamically allocated, it is up to the clients of an object to decide when they no longer need to use the object—especially local or remote objects that might be in use by multiple clients at the same time.</span></span> <span data-ttu-id="b96f6-126">L'oggetto deve attendere il completamento di tutti i client prima che venga liberato.</span><span class="sxs-lookup"><span data-stu-id="b96f6-126">The object must wait until all clients are finished with it before freeing itself.</span></span> <span data-ttu-id="b96f6-127">Poiché gli oggetti COM vengono modificati tramite puntatori di interfaccia e possono essere usati da oggetti in processi diversi o in altri computer, il sistema non può tenere traccia dei client di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="b96f6-127">Because COM objects are manipulated through interface pointers and can be used by objects in different processes or on other machines, the system cannot keep track of an object's clients.</span></span>

<span data-ttu-id="b96f6-128">Il metodo COM per determinare quando è appropriato deallocare un oggetto è il conteggio manuale dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="b96f6-128">COM's method of determining when it is appropriate to deallocate an object is manual reference counting.</span></span> <span data-ttu-id="b96f6-129">Ogni oggetto mantiene un conteggio dei riferimenti che tiene traccia del numero di client connessi, ovvero il numero di puntatori a una qualsiasi delle sue interfacce in qualsiasi client.</span><span class="sxs-lookup"><span data-stu-id="b96f6-129">Each object maintains a reference count that tracks how many clients are connected to it - that is, how many pointers exist to any of its interfaces in any client.</span></span>

<span data-ttu-id="b96f6-130">Per altre informazioni, vedere i seguenti argomenti:</span><span class="sxs-lookup"><span data-stu-id="b96f6-130">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="b96f6-131">Implementazione del conteggio dei riferimenti</span><span class="sxs-lookup"><span data-stu-id="b96f6-131">Implementing Reference Counting</span></span>](implementing-reference-counting.md)
-   [<span data-ttu-id="b96f6-132">Regole per la gestione dei conteggi dei riferimenti</span><span class="sxs-lookup"><span data-stu-id="b96f6-132">Rules for Managing Reference Counts</span></span>](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a><span data-ttu-id="b96f6-133">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="b96f6-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b96f6-134">Uso e implementazione di IUnknown</span><span class="sxs-lookup"><span data-stu-id="b96f6-134">Using and Implementing IUnknown</span></span>](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




